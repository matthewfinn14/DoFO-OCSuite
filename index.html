<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <script>
        window.onerror = function (msg, url, line, col, error) {
            alert("CRITICAL ERROR:\n" + msg + "\nLine: " + line + ":" + col + "\n" + (error ? error.stack : ""));
            return false;
        };
        window.addEventListener('unhandledrejection', function (event) {
            alert("UNHANDLED PROMISE:\n" + event.reason);
        });
    </script>
    <title>DoFO</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="stylesheet" href="style.css">
    <!-- React & ReactDOM (Development Version for better errors, switch to Production for speed) -->
    <script crossorigin="anonymous" src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script crossorigin="anonymous" src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>

    <!-- Babel Standalone -->
    <script crossorigin="anonymous" src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Tailwind CSS -->
    <script crossorigin="anonymous" src="https://cdn.tailwindcss.com"></script>

    <!-- Firebase SDK (v8.10.1 compat) -->
    <script crossorigin="anonymous" src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script crossorigin="anonymous" src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script crossorigin="anonymous" src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script crossorigin="anonymous" src="https://www.gstatic.com/firebasejs/8.10.1/firebase-storage.js"></script>

    <!-- Lucide Icons -->
    <script crossorigin="anonymous" src="https://unpkg.com/lucide@0.303.0"></script>

    <!-- PropTypes (Required for Recharts UMD) -->
    <script crossorigin="anonymous" src="https://unpkg.com/prop-types@15.8.1/prop-types.min.js"></script>

    <!-- Recharts -->
    <script crossorigin="anonymous" src="https://unpkg.com/recharts@2.12.3/umd/Recharts.js"></script>

    <!-- Framer Motion (via Unpkg) -->
    <script crossorigin="anonymous" src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>

    <!-- SortableJS -->
    <script crossorigin="anonymous"
        src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <!-- Classnames (Dependency for React-SortableJS) -->
    <script crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/classnames/2.3.2/index.min.js"></script>

    <!-- React SortableJS Shim (Fix for "require is not defined") -->
    <script>
        window.require = function (name) {
            if (name === 'react') return window.React;
            if (name === 'prop-types') return window.PropTypes;
            if (name === 'sortablejs') return window.Sortable;
            if (name === 'classnames') return window.classNames;
            if (name === 'tiny-invariant') return function (condition, message) { if (!condition) console.error("Invariant failed:", message); };
            return {};
        };
        window.module = { exports: {} };
        window.exports = window.module.exports;
    </script>
    <script crossorigin="anonymous"
        src="https://cdn.jsdelivr.net/npm/react-sortablejs@6.1.4/dist/index.min.js"></script>
    <script>
        if (window.module && window.module.exports && window.module.exports.ReactSortable) {
            window.ReactSortable = window.module.exports.ReactSortable;
            console.log("ReactSortable loaded successfully via Shim");
        } else {
            console.error("Failed to load ReactSortable via Shim");
        }
        // Cleanup global pollution
        delete window.require;
        delete window.module;
        delete window.exports;
    </script>

    <!-- Firebase Initialization -->
    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyChvjfVMQ_jrAt7C08pLTreckUIizKFKis",
            authDomain: "dofo-c3fbe.firebaseapp.com",
            projectId: "dofo-c3fbe",
            storageBucket: "dofo-c3fbe.firebasestorage.app",
            messagingSenderId: "953198874702",
            appId: "1:953198874702:web:025100b11c243f73f9731f",
            measurementId: "G-LCFEPZ57EJ"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);

        // Expose services globally
        window.auth = firebase.auth();
        window.db = firebase.firestore();
        window.storage = firebase.storage();

        console.log("Firebase Initialized:", firebase.app().name);

        // Check for file:// protocol
        if (window.location.protocol === 'file:') {
            alert("⚠️ CRITICAL ERROR: Google Sign-In does NOT work when opening the file directly (file://). You MUST serve this file using a local web server (e.g., 'npx serve' or VS Code Live Server).");
        }
    </script>

    <style>
        .wristband-print-container {
            display: none;
        }

        .print-only-text {
            display: none !important;
        }

        @media print {
            .print-only-text {
                display: block !important;
            }

            @page {
                size: landscape !important;
                margin: 0.25in !important;
            }

            body {
                background: white !important;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
                margin: 0;
                padding: 0;
            }

            /* Print Styles */
            /* Hide UI Chrome */
            .sidebar,
            .app-toolbar,
            .print-preview-header,
            .hide-on-print,
            button,
            .btn,
            input,
            select {
                display: none !important;
            }

            /* Compact FZDnD Rows for Print */
            .fzdnd-row-container {
                min-height: 22px !important;
                border: 1px solid black !important;
                border-top: none !important;
                /* Avoid double top borders */
                border-left: 1px solid black !important;
                /* Ensure left border */
                border-right: 1px solid black !important;
                /* Ensure right border */
            }

            .fzdnd-cell {
                min-height: 22px !important;
                padding: 1px 2px !important;
                border-bottom: 1px solid black !important;
                border-right: 1px solid black !important;
            }

            .fzdnd-cell:last-child {
                border-right: none !important;
                /* Container handles the right edge, or keep it if container lacks it? Container has right border now. */
            }

            .fzdnd-cell input {
                height: 18px !important;
                font-size: 0.65rem !important;
                padding: 0 !important;
                margin: 0 !important;
            }

            /* Toggle Cell in Print */
            .fzdnd-toggle-cell {
                border-right: 1px solid black !important;
                border-bottom: 1px solid black !important;
                background: transparent !important;
            }

            /* Header Row for Print */
            .fzdnd-header-row {
                border-left: 1px solid black !important;
                border-right: 1px solid black !important;
            }

            .print-only-scripts {
                display: block !important;
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                padding: 1rem;
                box-sizing: border-box;
                z-index: 99998;
            }

            /* Ensure Print Preview Modal behaves nicely */
            .print-preview-modal-wrapper {
                position: absolute !important;
                background: white !important;
                width: 100% !important;
                height: auto !important;
                overflow: visible !important;
                top: 0 !important;
                left: 0 !important;
                z-index: 99999 !important;
            }

            .print-preview-content {
                padding: 0 !important;
                overflow: visible !important;
            }

            /* Reset Game Plan Containers for Print */
            .app-container,
            .main-content,
            .game-plan-container,
            .game-plan-content,
            .depth-view-container,
            .depth-content-wrapper,
            .depth-chart-print-section,
            .depth-chart-print-view {
                height: auto !important;
                overflow: visible !important;
                display: block !important;
                flex: none !important;
                margin: 0 !important;
                padding: 0 !important;
            }

            /* Hide controls and checkboxes during print */
            @media print {

                .btn,
                button,
                input[type="checkbox"],
                label {
                    display: none !important;
                }

                h2 {
                    display: block !important;
                    margin-bottom: 1rem !important;
                }
            }

            /* Ensure content utilizes full width and avoids breaks */
            .print-preview-content>div {
                width: 100%;
            }

            table,
            tr,
            td,
            .box,
            .call-sheet-grid {
                page-break-inside: avoid;
                break-inside: avoid;
            }

            /* Hide empty rows in print */
            .hidden-row {
                display: none !important;
            }

            /* FZ DND Print Layout - Full Width */
            .fzdnd-zone-container {
                page-break-inside: avoid;
                break-inside: avoid;
                margin-bottom: 0 !important;
            }

            .fzdnd-zone-grid {
                display: block !important;
                grid-template-columns: none !important;
            }

            .fzdnd-philosophy-column {
                display: none !important;
            }

            .fzdnd-content-wrapper {
                display: block !important;
                width: 100% !important;
            }

            /* Call sheet sections - allow natural flow, no forced page breaks */
            .call-sheet-section {
                page-break-before: auto !important;
                break-before: auto !important;
                page-break-after: auto !important;
                break-after: auto !important;
                /* Keep header with content */
                break-inside: avoid !important;
                -webkit-column-break-inside: avoid !important;
                margin-bottom: 0.5rem !important;
            }

            /* Multi-column layout for sheet view content */
            .print-preview-content>div {
                column-count: 2 !important;
                column-gap: 1rem !important;
                column-fill: auto !important;
            }

            /* Reduce font sizes and padding for density */
            .print-preview-content table,
            .print-preview-content div {
                font-size: 0.8rem !important;
            }

            .print-preview-content td,
            .print-preview-content th,
            .call-sheet-section>div>div>div {
                padding: 2px !important;
            }

            /* Smaller section headings */
            .call-sheet-section>div:first-child {
                font-size: 0.75rem !important;
                padding: 4px !important;
            }

            /* Tighter grid cells */
            .call-sheet-section div[style*="grid"]>div {
                padding: 1px !important;
                font-size: 0.65rem !important;
                min-height: 14px !important;
            }

            /* BUT show the print portal */
            .print-only-portal {
                display: block !important;
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: auto !important;
                background: white;
                z-index: 99999;
            }

            .print-only-portal * {
                visibility: visible !important;
            }

            /* Ensure body allows printing */
            body,
            html {
                visibility: visible !important;
                height: auto !important;
                overflow: visible !important;
                background: white !important;
            }
        }

        /* Screen Styles for Portal */
        .print-only-portal {
            display: none;
        }

        .print-only-scripts {
            display: none;
        }

        /* Travel Packet Printing Exception */
        .travel-print-container,
        .travel-print-container * {
            visibility: visible;
        }

        .travel-print-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: white;
            color: black;
            padding: 2rem;
            z-index: 99998;
            display: block !important;
        }









        .wristband-print-container>* {
            display: flex !important;
        }

        .wristband-card {
            width: 4.75in;
            height: 2.75in;
            border: 2px solid black !important;
            display: flex;
            flex-direction: column;
            background: white;
            overflow: hidden;
            /* Ensure content stays within 5x3 */
        }

        .wristband-card-header {
            font-size: 9.5pt;
            font-weight: bold;
            background: black !important;
            color: white !important;
            text-align: center;
            padding: 2px 0;
            border-bottom: 2px solid black;
            text-transform: uppercase;
        }

        .wristband-content {
            flex: 1;
            display: flex;
            border-top: 1px solid black;
        }

        .wristband-col {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .wristband-col:first-child {
            border-right: 2px solid black;
            /* Split columns clearly */
        }

        .wristband-row {
            flex: 1;
            /* Distribute height evenly */
            display: flex;
            border-bottom: 1px solid black;
            align-items: center;
            overflow: hidden;
        }

        .wristband-row:last-child {
            border-bottom: none;
        }

        .wristband-num {
            width: 27px;
            /* Fixed width */
            font-size: 7.5pt;
            font-weight: bold;
            background: #f0f0f0 !important;
            /* Light grey for numbers */
            display: flex;
            align-items: center;
            justify-content: center;
            border-right: 1px solid black;
            height: 100%;
            color: black;
        }

        .wristband-play {
            flex: 1;
            font-size: 7.5pt;
            /* Smaller font to fit */
            font-weight: bold;
            padding: 0 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
            height: 100%;
        }

        /* Alternating row colors for readability if desired, but user image showed white/tan strips */
        /* Let's try to match user sample roughly or keep clean white */
        .wristband-row:nth-child(odd) .wristband-play {
            background: white;
        }

        .wristband-row:nth-child(even) .wristband-play {
            background: #ffedd5 !important;
            /* Orange-ish tint like screenshot */
        }

        /* Specific overrides for color classes if we pass them */
        .wristband-card.green .wristband-row:nth-child(even) .wristband-play {
            background: #dcfce7 !important;
        }

        /* --- NEW WRISTBAND STYLES --- */

        /* Grid Card (Diagrams) */
        .wristband-grid-card {
            width: 4.75in;
            height: 2.75in;
            border: 2px solid black !important;
            background: white;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(5, 1fr);
            width: 100%;
            height: 100%;
            box-sizing: border-box;
        }

        .wristband-grid-cell {
            border-right: 1px solid black;
            border-bottom: 1px solid black;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        /* Remove right border for last column */
        .wristband-grid-cell:nth-child(4n) {
            border-right: none;
        }

        /* Remove bottom border for last row */
        .wristband-grid-cell:nth-nth-child(n+17) {
            /* 17-20 are last row */
            border-bottom: none;
        }

        /* Actually simpler: just let container border handle edges? 
                Grid borders are tricky. Let's strictly border right/bottom and overlap or use gap.
                Gap is bad for print alignment. 
                Let's use outline/negative margin or standard table-like borders.
             */

        .wristband-grid-cell-header {
            font-size: 5.5pt;
            font-weight: bold;
            background: #eee;
            border-bottom: 1px solid #ccc;
            padding: 1px 2px;
            display: flex;
            justify-content: space-between;
            white-space: nowrap;
        }

        .wristband-grid-cell-body {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .wristband-grid-cell-body img,
        .wristband-grid-cell-body svg {
            object-fit: cover;
            width: 100%;
            height: 100%;
        }

        .wristband-grid-cell-footer {
            font-size: 6.5pt;
            font-weight: 800;
            text-align: center;
            background: black;
            color: white;
            padding: 1px 0;
            white-space: nowrap;
            overflow: hidden;
        }

        /* --- DEPTH CHART PRINT STYLES --- */
        .depth-chart-container {
            display: block !important;
            height: auto !important;
            overflow: visible !important;
        }

        .depth-chart-viewport {
            display: block !important;
            height: auto !important;
            min-height: 0 !important;
            overflow: visible !important;
            border: none !important;
        }

        /* Hide controls when printing */
        .depth-chart-controls {
            display: none !important;
        }

        /* Updated Text List Styles (High Contrast) */
        .wristband-card.text-list .wristband-card-header {
            background: black !important;
            color: white !important;
            font-size: 10.5pt;
            text-transform: uppercase;
            padding: 4px 0;
        }

        .wristband-card.text-list .wristband-row {
            border-bottom: 1px solid black;
            height: 12.5%;
            /* 8 rows per column for 16 items? Or stick to 20-25? User wants specific count. */
            /* User sample 1 had 301-316 per col? No, sample 2 has 25 rows (101-125). */
        }

        .wristband-card.text-list .wristband-num {
            background: black !important;
            color: white !important;
            font-weight: bold;
            font-size: 8.5pt;
            width: 30px;
        }

        .wristband-card.text-list .wristband-play {
            font-size: 8.5pt;
            font-weight: bold;
            color: black;
        }

        .wristband-card.text-list .wristband-row:nth-child(even) .wristband-play {
            background: #e5e5e5 !important;
            /* Light Grey striping instead of orange */
        }

        .wristband-card.text-list.green .wristband-row:nth-child(even) .wristband-play {
            background: #dcfce7 !important;
        }

        /* --- WRISTBAND BUILDER SCREEN STYLES --- */
        .wristband-spreadsheet-container {
            display: flex;
            gap: 2rem;
            height: 100%;
            overflow: auto;
        }

        .wristband-spreadsheet-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.7rem;
            background: white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            color: #000;
        }

        .wristband-spreadsheet-table thead {
            position: sticky;
            top: 0;
            z-index: 10;
            background: #f3f4f6;
            border-bottom: 2px solid #000;
        }

        .wristband-spreadsheet-table th {
            padding: 8px 12px;
            text-align: left;
            font-weight: 600;
            border: 1px solid #333;
            background: #f3f4f6;
            color: #000;
        }

        .wristband-spreadsheet-table td {
            padding: 1px 6px;
            border: 1px solid #333;
            height: 11px;
            vertical-align: middle;
            color: #000;
        }

        .wristband-spreadsheet-table td:first-child {
            font-weight: 600;
            text-align: center;
            width: 60px;
        }

        .wristband-spreadsheet-table td:nth-child(2) {
            font-weight: 500;
        }

        /* Alternating row colors for 100s (green) */
        .wristband-spreadsheet-table tbody tr.wb-100s:nth-child(odd) {
            background-color: #d1fae5;
        }

        .wristband-spreadsheet-table tbody tr.wb-100s:nth-child(even) {
            background-color: #a7f3d0;
        }

        /* Alternating row colors for 200s (orange) */
        .wristband-spreadsheet-table tbody tr.wb-200s:nth-child(odd) {
            background-color: #fed7aa;
        }

        .wristband-spreadsheet-table tbody tr.wb-200s:nth-child(even) {
            background-color: #fdba74;
        }

        /* Alternating row colors for 400s (purple) */
        .wristband-spreadsheet-table tbody tr.wb-400s:nth-child(odd) {
            background-color: #e9d5ff;
        }

        .wristband-spreadsheet-table tbody tr.wb-400s:nth-child(even) {
            background-color: #d8b4fe;
        }

        /* Alternating row colors for 500s (teal) */
        .wristband-spreadsheet-table tbody tr.wb-500s:nth-child(odd) {
            background-color: #99f6e4;
        }

        .wristband-spreadsheet-table tbody tr.wb-500s:nth-child(even) {
            background-color: #5eead4;
        }

        /* Alternating row colors for 600s (pink) */
        .wristband-spreadsheet-table tbody tr.wb-600s:nth-child(odd) {
            background-color: #fbcfe8;
        }

        .wristband-spreadsheet-table tbody tr.wb-600s:nth-child(even) {
            background-color: #f9a8d4;
        }

        .wristband-spreadsheet-table tbody tr:hover {
            outline: 2px solid var(--accent);
            outline-offset: -1px;
        }

        .wristband-spreadsheet-table tbody tr.selected {
            background-color: rgba(56, 189, 248, 0.3) !important;
        }

        .wristband-spreadsheet-table tbody tr.empty {
            opacity: 0.5;
        }

        .wristband-clear-btn {
            background: none;
            border: none;
            color: #ef4444;
            cursor: pointer;
            padding: 2px 6px;
            font-size: 0.75rem;
            opacity: 0.7;
        }

        .wristband-clear-btn:hover {
            opacity: 1;
        }

        /* Print styles for spreadsheet view */
        @media print {
            @page {
                size: letter landscape;
                margin: 0;
            }

            body {
                margin: 0;
                padding: 0;
            }

            /* Hide all non-print elements */
            .wristband-spreadsheet-container,
            .sidebar,
            button,
            .nav-item,
            .top-nav,
            .main-content>*:not(.wristband-print-container) {
                display: none !important;
            }

            /* Print Preview specific styles */
            .print-preview-header {
                display: none !important;
            }

            .print-preview-content {
                padding: 0 !important;
                overflow: visible !important;
            }
        }

        /* Show print container */


        /* 2x2 Grid Layout - Centered on page */
        .wristband-print-grid {
            display: grid;
            grid-template-columns: 2.75in 2.75in;
            grid-template-rows: 4.75in 4.75in;
            gap: 0.5in 0.5in;
            width: 6in;
            /* 2 cards × 2.75in + 1 gap × 0.5in */
            height: 10in;
            /* 2 cards × 4.75in + 1 gap × 0.5in */
            /* Center on page: (11 - 6) / 2 = 2.5in horizontal */
            margin: -0.75in auto 0;
            margin-left: 2.5in;
            margin-right: 2.5in;
            page-break-inside: avoid;
        }

        /* Individual Wristband Card - 4.75in × 2.75in landscape */
        .wristband-print-card {
            width: 4.75in;
            height: 2.75in;
            border: 2px solid black;
            background: white;
            overflow: hidden;
            page-break-inside: avoid;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        /* Card header styling */
        .wristband-print-card .print-card-header {
            background: black;
            color: white;
            padding: 4px 8px;
            font-weight: bold;
            font-size: 9pt;
            text-align: center;
            display: flex;
            justify-content: space-between;
            border-bottom: 2px solid black;
            flex-shrink: 0;
        }

        /* Colored wristband backgrounds */
        /* Green shades - alternating */
        .wristband-color-green-light {
            background: #d1fae5 !important;
        }

        .wristband-color-green-medium {
            background: #a7f3d0 !important;
        }

        /* Orange shades - alternating */
        .wristband-color-orange-light {
            background: #fed7aa !important;
        }

        .wristband-color-orange-medium {
            background: #fdba74 !important;
        }

        /* Red shades - alternating */
        .wristband-color-red-light {
            background: #fecaca !important;
        }

        .wristband-color-red-medium {
            background: #fca5a5 !important;
        }

        /* Blue shades - alternating */
        .wristband-color-blue-light {
            background: #bfdbfe !important;
        }

        .wristband-color-blue-medium {
            background: #93c5fd !important;
        }

        /* Yellow shades - alternating */
        .wristband-color-yellow-light {
            background: #fef08a !important;
        }

        .wristband-color-yellow-medium {
            background: #fde047 !important;
        }

        /* Purple shades - alternating */
        .wristband-color-purple-light {
            background: #e9d5ff !important;
        }

        .wristband-color-purple-medium {
            background: #d8b4fe !important;
        }

        /* Teal shades - alternating */
        .wristband-color-teal-light {
            background: #99f6e4 !important;
        }

        .wristband-color-teal-medium {
            background: #5eead4 !important;
        }

        /* Pink shades - alternating */
        .wristband-color-pink-light {
            background: #fbcfe8 !important;
        }

        .wristband-color-pink-medium {
            background: #f9a8d4 !important;
        }

        /* Card content area */
        .wristband-print-card .print-card-content {
            flex: 1;
            overflow: hidden;
        }

        /* Table styling for print */
        .wristband-print-card table {
            width: 100%;
            border-collapse: collapse;
            font-size: 6pt;
            height: 100%;
        }

        .wristband-print-card td {
            border: 1px solid #666;
            padding: 1px 2px;
            vertical-align: middle;
        }

        .wristband-print-card td:first-child {
            font-weight: bold;
            text-align: center;
            width: 25px;
        }

        .wristband-print-card-spreadsheet.orange tbody tr:nth-child(odd) {
            background-color: #fed7aa;
        }

        .wristband-print-card-spreadsheet.orange tbody tr:nth-child(even) {
            background-color: #fdba74;
        }
    </style>
</head>

<body>
    <!-- Error Handler (Standard JS) -->
    <script>
        window.onerror = function (message, source, lineno, colno, error) {
            console.error("Global Error Caught:", message, source, lineno, error);
            // If it's a generic "Script error." (cross-origin), we can't do much, but let's not nuke the app if it's running.
            // Only show the red screen if the root element is empty or if it's a critical error we want to surface.
            const root = document.getElementById('root');
            const hasContent = root && root.childElementCount > 0;

            // Don't nuke if it's just a resize observer loop limit exceeded or similar benign error
            if (message && message.includes('ResizeObserver')) return false;

            // For critical errors where the app probably crashed:
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); color:red; padding:20px; font-family:monospace; z-index:99999; overflow:auto;';
            errorDiv.innerHTML = '<h1>Application Error</h1><p><strong>Message:</strong> ' + message + '</p><p><strong>Source:</strong> ' + source + '</p><p><strong>Line:</strong> ' + lineno + '</p><pre>' + (error ? error.stack : 'No stack trace') + '</pre><button onclick="this.parentElement.remove()">Dismiss</button>';

            document.body.appendChild(errorDiv);
            return false;
        };
    </script>

    <div id="root"></div>
    <script type="text/babel">
        // CACHE BUST: 2025-12-21-20:14:00 - REM
        const { useState, useEffect, useRef, useContext, createContext, useMemo, useCallback } = React;

        // --- FIRESTORE SYNC UTILITIES ---
        // HELPER: Clear all local app data
        // HELPER: Clear all local app data
        const clearAllLocalData = () => {
            // NUCLEAR OPTION: Wipe everything to guarantee a clean slate for new users/trials
            // FIX: Preserve the reload flag to prevent infinite loops in AuthProvider
            const reloadFlag = sessionStorage.getItem('just_reloaded_for_sync');

            localStorage.clear();
            sessionStorage.clear();

            if (reloadFlag) {
                sessionStorage.setItem('just_reloaded_for_sync', reloadFlag);
            }
            console.log("Local data COMPLETELY cleared (persisted sync flag).");
        };

        const loadUserDataFromFirestore = async (userId) => {
            try {
                console.log("Loading user data from Firestore for user (Force Server):", userId);
                const userDocRef = window.db.collection('users').doc(userId);
                const userDoc = await userDocRef.get({ source: 'server' });

                let appData = {};
                let isSchoolData = false;

                if (userDoc.exists) {
                    const userData = userDoc.data();
                    appData = userData; // Default to user data

                    // CHECK FOR MEMBERSHIPS (New Logic)
                    const membershipsSnapshot = await userDocRef.collection('memberships').get();
                    let activeSchoolId = null;

                    if (!membershipsSnapshot.empty) {
                        // Use first membership for now (TODO: Add "lastActiveSchool" to user profile)
                        activeSchoolId = membershipsSnapshot.docs[0].id;
                        console.log("Found membership for school:", activeSchoolId);
                    } else if (userData.schoolId) {
                        // MIGRATION: Auto-create membership
                        console.log("Migrating legacy schoolId to membership...");
                        activeSchoolId = userData.schoolId;
                        try {
                            await userDocRef.collection('memberships').doc(activeSchoolId).set({
                                role: 'admin', // Default to admin for legacy upgrades
                                joinedAt: new Date().toISOString(),
                                status: 'active'
                            });
                        } catch (err) {
                            console.error("Migration failed:", err);
                        }
                    }

                    // LOAD DATA
                    if (activeSchoolId) {
                        console.log("Loading SCHOOL data for:", activeSchoolId);
                        localStorage.setItem('hc_school_id', activeSchoolId);

                        const schoolDoc = await window.db.collection('schools').doc(activeSchoolId).get();
                        if (schoolDoc.exists) {
                            console.log("Loaded SCHOOL data");
                            appData = schoolDoc.data();
                            isSchoolData = true;

                            // SYNC MEMBER LIST (Ensure user is listed in school doc)
                            try {
                                const currentMembers = appData.memberList || [];
                                const myEmail = window.auth.currentUser.email;
                                const isListed = currentMembers.find(m => m.uid === userId);

                                if (!isListed) {
                                    console.log("Adding self to school memberList...");
                                    const newMember = {
                                        uid: userId,
                                        email: myEmail,
                                        role: 'admin', // Default for now, later derived from membership
                                        joinedAt: new Date().toISOString()
                                    };
                                    await window.db.collection('schools').doc(activeSchoolId).update({
                                        memberList: firebase.firestore.FieldValue.arrayUnion(newMember)
                                    });
                                }
                            } catch (err) {
                                console.warn("Failed to sync member list:", err);
                            }
                        } else {
                            console.warn("School ID found but document missing.");
                        }
                    } else {
                        // Check for Pending Invites (Auto-Join)
                        console.log("No membership found. Checking for invites...");
                        const myEmail = window.auth.currentUser.email.toLowerCase();
                        let inviteSchoolId = null;

                        try {
                            const inviteDoc = await window.db.collection('invites').doc(myEmail).get();
                            if (inviteDoc.exists) {
                                const inviteData = inviteDoc.data();
                                console.log("Found invite for school:", inviteData.schoolId);
                                inviteSchoolId = inviteData.schoolId;

                                // Auto-create membership
                                await userDocRef.collection('memberships').doc(inviteSchoolId).set({
                                    role: inviteData.role || 'assistant',
                                    joinedAt: new Date().toISOString(),
                                    status: 'active'
                                });
                                activeSchoolId = inviteSchoolId;
                            }
                        } catch (err) {
                            console.error("Error checking invites:", err);
                        }

                        if (activeSchoolId) {
                            // Recursively load data now that we have a school
                            // Or just fall through to the logic below?
                            // Logic below checks `if (activeSchoolId)` so we just need to set it!
                            console.log("Auto-joined school. Loading data...");
                        } else {
                            // Ensure we clear any stale school ID if they are not in a school
                            console.log("No school data found for user.");
                            localStorage.removeItem('hc_school_id');
                        }

                        localStorage.removeItem('hc_school_id');
                    }
                } else {
                    // NEW: User Doc does not exist (New User or Deleted Doc).
                    // WIPE LOCAL STORAGE to prevent "ghost" sessions from previous users on this device.
                    clearAllLocalData();
                    // Don't return, let execution continue so appData (empty) flows through to clear state
                }

                console.log("Applying data to localStorage...", appData);
                const data = appData;

                // Apply data to localStorage
                // CRITICAL FIX: Ensure keys match what the App component uses for initialization
                if (data.roster) {
                    localStorage.setItem('oc-dashboard-roster', JSON.stringify(data.roster)); // WAS: roster_data
                }
                if (data.plays) {
                    localStorage.setItem('oc-dashboard-plays', JSON.stringify(data.plays)); // WAS: play_library
                }
                if (data.staff) {
                    localStorage.setItem('oc-dashboard-staff', JSON.stringify(data.staff)); // NEW
                }
                if (data.depthChart) {
                    localStorage.setItem('oc-dashboard-depthchart', JSON.stringify(data.depthChart)); // NEW
                }

                if (data.settings) {
                    if (data.settings.teamLogo) localStorage.setItem('oc-dashboard-logo', data.settings.teamLogo);
                    // Fix: Check root name first (standard), then settings (legacy/alt)
                    if (data.name) localStorage.setItem('hc_school_name', data.name);
                    else if (data.settings.schoolName) localStorage.setItem('hc_school_name', data.settings.schoolName);
                    // Fix Accent Color Key
                    if (data.settings.accentColor) {
                        localStorage.setItem('oc-dashboard-accent', data.settings.accentColor); // Match App Init
                        localStorage.setItem('user_accent_color', data.settings.accentColor); // Legacy/Backup
                    }
                    // Fix Theme Key
                    if (data.settings.theme) {
                        localStorage.setItem('oc-dashboard-theme', data.settings.theme); // Match App Init
                        localStorage.setItem('user_theme', data.settings.theme); // Legacy/Backup
                    }
                    if (data.settings.activeYear) localStorage.setItem('hc-active-year', data.settings.activeYear);
                    if (data.settings.visibleFeatures) localStorage.setItem('hc-visible-features', JSON.stringify(data.settings.visibleFeatures));
                    // Fix: Load Position Names
                    if (data.settings.positionNames) localStorage.setItem('oc-dashboard-position-names', JSON.stringify(data.settings.positionNames));
                }

                // --- NEW SYNC ITEMS (Complete Coverage) ---
                if (data.weeks) {
                    localStorage.setItem('oc-dashboard-weeks', JSON.stringify(data.weeks));
                }
                if (data.billing) {
                    localStorage.setItem('hc_school_billing', JSON.stringify(data.billing));
                }
                if (data.attendance) {
                    localStorage.setItem('attendance_log', JSON.stringify(data.attendance));
                }

                if (data.inventory) {
                    localStorage.setItem('oc-dashboard-equipment-inventory', JSON.stringify(data.inventory));
                }
                if (data.checkouts) {
                    localStorage.setItem('oc-dashboard-equipment-checkouts', JSON.stringify(data.checkouts));
                }
                if (data.formationLayouts) {
                    localStorage.setItem('formationLayouts', JSON.stringify(data.formationLayouts));
                }
                if (data.ratings) {
                    localStorage.setItem('oc-dashboard-ratings', JSON.stringify(data.ratings));
                }

                if (data.summerComp) {
                    localStorage.setItem('oc-dashboard-summer-comp', JSON.stringify(data.summerComp));
                }

                if (data.issuance) {
                    localStorage.setItem('oc-dashboard-equipment-issuance', JSON.stringify(data.issuance));
                }
                if (data.wishlist) {
                    localStorage.setItem('oc-dashboard-equipment-wishlist', JSON.stringify(data.wishlist));
                }
                if (data.athleteAssessments) {
                    localStorage.setItem('athlete_assessments', JSON.stringify(data.athleteAssessments));
                }
                if (data.staff) {
                    localStorage.setItem('oc-dashboard-staff', JSON.stringify(data.staff));
                }

                // --- ADDITIONAL MISSING ITEMS ---
                if (data.formations) {
                    localStorage.setItem('oc-dashboard-formations', JSON.stringify(data.formations));
                }
                if (data.zonePhilosophies) {
                    localStorage.setItem('oc-dashboard-zone-philosophies', JSON.stringify(data.zonePhilosophies));
                }
                if (data.customFocus) {
                    localStorage.setItem('oc-dashboard-custom-focus', JSON.stringify(data.customFocus));
                }
                if (data.duties) {
                    localStorage.setItem('oc-dashboard-duties', JSON.stringify(data.duties));
                }
                if (data.metrics) {
                    localStorage.setItem('oc-dashboard-metrics', JSON.stringify(data.metrics));
                }
                if (data.fatigueThresholds) {
                    localStorage.setItem('fatigue-thresholds', JSON.stringify(data.fatigueThresholds));
                }
                if (data.positionFatigue) {
                    localStorage.setItem('position-fatigue-values', JSON.stringify(data.positionFatigue));
                }

                // --- FINAL AUDIT ITEMS (Budget, Onboarding, Wristband, Apps) ---
                if (data.budget) {
                    localStorage.setItem('program_budget_data', JSON.stringify(data.budget));
                }
                if (data.onboarding) {
                    localStorage.setItem('program_onboarding_data', JSON.stringify(data.onboarding));
                }
                if (data.positionNames) {
                    localStorage.setItem('oc-dashboard-position-names', JSON.stringify(data.positionNames));
                }
                if (data.dailyConnections) {
                    localStorage.setItem('player_daily_connections', JSON.stringify(data.dailyConnections));
                }
                if (data.weightLogs) {
                    localStorage.setItem('player_weight_logs', JSON.stringify(data.weightLogs));
                }
                if (data.roleTasks) {
                    localStorage.setItem('staff_role_tasks', JSON.stringify(data.roleTasks));
                }
                if (data.wizLib) {
                    localStorage.setItem('wiz_ol_library', JSON.stringify(data.wizLib));
                } else if (data.wizLib) {
                    localStorage.setItem('wiz_ol_library', JSON.stringify(data.wizLib));
                }
                // Wristband Settings
                if (data.wbSettings) {
                    if (data.wbSettings.wb1Opp) localStorage.setItem('hc_wb1_opponent', data.wbSettings.wb1Opp);
                    if (data.wbSettings.wb1Iter) localStorage.setItem('hc_wb1_iteration', data.wbSettings.wb1Iter);
                    if (data.wbSettings.wb2Opp) localStorage.setItem('hc_wb2_opponent', data.wbSettings.wb2Opp);
                    if (data.wbSettings.wb2Iter) localStorage.setItem('hc_wb2_iteration', data.wbSettings.wb2Iter);
                    if (data.wbSettings.sheetUrl) localStorage.setItem('hc_wristband_sheet_url', data.wbSettings.sheetUrl);
                }

            } catch (error) {
                console.error("Error loading data from Firestore:", error);
                return { success: false, error };
            }
        };

        const syncToFirestore = async (userId, dataType, data) => {
            try {
                // DETERMINE DESTINATION (School or User)
                const schoolId = localStorage.getItem('hc_school_id');
                let docRef;
                let contextLog = "Personal";

                if (schoolId) {
                    docRef = window.db.collection('schools').doc(schoolId);
                    contextLog = `School (${schoolId})`;
                } else {
                    docRef = window.db.collection('users').doc(userId);
                }

                console.log(`Syncing ${dataType} to ${contextLog}...`);

                const updateData = {
                    [dataType]: data,
                    [`${dataType}LastModified`]: new Date().toISOString()
                };

                await docRef.set(updateData, { merge: true });
                console.log(`${dataType} synced successfully`);
                return { success: true };
            } catch (error) {
                console.error(`Error syncing ${dataType}:`, error);
                return { success: false, error };
            }
        };

        // --- AUTHENTICATION ---
        const AuthContext = createContext();

        const AuthProvider = ({ children }) => {
            const [currentUser, setCurrentUser] = useState(null);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                const unsubscribe = window.auth.onAuthStateChanged(async (user) => {
                    if (user) {
                        try {
                            // SUPER ADMIN BYPASS
                            // Always allow the owner to log in, ignoring access control rules
                            if (user.email.toLowerCase() === 'matthewfinn14@gmail.com') {
                                console.log("Super Admin Login detected. Bypassing access control.");
                                setCurrentUser(user);
                                setLoading(false);
                                return;
                            }

                            // CHECK ACCESS CONTROL
                            const accessDoc = await window.db.collection('config').doc('access').get();
                            if (accessDoc.exists) {
                                const accessData = accessDoc.data();
                                if (accessData.inviteRequired) {
                                    const allowed = accessData.allowedEmails || [];
                                    const userEmail = user.email.toLowerCase();

                                    // 1. Check explicit allowance
                                    let isAllowed = allowed.some(email => email.toLowerCase() === userEmail);

                                    // 2. If not allowed, check for pending invites
                                    if (!isAllowed) {
                                        const inviteCheck = await window.db.collection('invites')
                                            .where('email', '==', userEmail)
                                            .where('status', '==', 'pending')
                                            .limit(1)
                                            .get();
                                        if (!inviteCheck.empty) isAllowed = true;
                                    }

                                    // 3. If not allowed, check for existing memberships
                                    if (!isAllowed) {
                                        const memCheck = await window.db.collection('users').doc(user.uid)
                                            .collection('memberships')
                                            .where('status', '==', 'active')
                                            .limit(1)
                                            .get();
                                        if (!memCheck.empty) isAllowed = true;
                                    }

                                    if (!isAllowed) {
                                        console.warn("Access Denied: Email not in allowlist and no valid invites/memberships found.");
                                        alert("Access Denied: This application is currently invite-only. Please contact the administrator.");
                                        await window.auth.signOut();
                                        setCurrentUser(null);
                                        setLoading(false);
                                        return;
                                    }
                                }
                            }
                        } catch (err) {
                            console.error("Error checking access control:", err);
                            // Fallback: Allow login if check fails? Or Block?
                            // Default to ALLOW to avoid lockout during outages, but log heavily.
                        }
                    }
                    if (user) {
                        try {
                            // ... access control logic already handled above ...

                            // LOAD DATA BEFORE SETTING LOADING TO FALSE
                            // This ensures the App component sees fresh cloud data on its first render
                            // and removes the need for a flickering window.location.reload()
                            console.log("Fetching cloud data for user:", user.uid);
                            await loadUserDataFromFirestore(user.uid);
                        } catch (err) {
                            console.error("Error in startup sync:", err);
                        }
                    }
                    setCurrentUser(user);
                    setLoading(false);
                });
                return unsubscribe;
            }, []);


            const login = (email, password, loginMode = 'coach') => {
                // Store user type for routing
                localStorage.setItem('user_type', loginMode);
                return window.auth.signInWithEmailAndPassword(email, password);
            };

            const loginWithGoogle = async (loginMode = 'coach') => {
                localStorage.setItem('user_type', loginMode);
                const provider = new firebase.auth.GoogleAuthProvider();
                try {
                    const result = await window.auth.signInWithPopup(provider);
                    return result.user;
                } catch (error) {
                    console.error("Google Sign-In Error:", error);
                    throw error;
                }
            };

            const register = (email, password) => window.auth.createUserWithEmailAndPassword(email, password);
            const logout = async () => {
                const isDemo = localStorage.getItem('is_demo_session') === 'true';
                const currentSchoolId = localStorage.getItem('hc_school_id');
                const userId = window.auth.currentUser ? window.auth.currentUser.uid : null;

                if (isDemo && userId) {
                    if (confirm("End Demo Session? All demo data (School & User) will be PERMANENTLY DELETED.")) {
                        try {
                            console.log("Cleaning up demo session...");

                            // 1. Delete School (if exists)
                            if (currentSchoolId) {
                                await window.db.collection('schools').doc(currentSchoolId).delete();
                            }

                            // 2. Delete User Doc
                            // (We skip deep subcollection deletion for speed, but main doc is key)
                            await window.db.collection('users').doc(userId).delete();

                            // 3. Delete Auth Account
                            const user = window.auth.currentUser;
                            if (user) {
                                await user.delete().catch(err => console.warn("Could not delete auth user:", err));
                            }

                            console.log("Demo cleanup complete.");
                        } catch (e) {
                            console.error("Demo cleanup failed:", e);
                        }
                    } else {
                        return; // Cancel logout
                    }
                }

                clearAllLocalData();
                return window.auth.signOut();
            };

            if (loading) {
                return (
                    <div style={{ height: '100vh', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', background: '#0f172a', color: 'white', gap: '1rem' }}>
                        <div style={{ fontSize: '1.2rem' }}>
                            Loading Dashboard...
                        </div>
                        <div style={{ fontSize: '0.9rem', color: '#94a3b8' }}>
                            Syncing roster, plays, and settings from cloud...
                        </div>
                    </div>
                );
            }

            return (
                <AuthContext.Provider value={{ currentUser, login, loginWithGoogle, register, logout }}>
                    {children}
                </AuthContext.Provider>
            );
        };

        const useAuth = () => useContext(AuthContext);

        const useSchoolPlan = () => {
            const { currentUser } = useAuth();
            const [billingInfo, setBillingInfo] = useState(() => {
                try {
                    return JSON.parse(localStorage.getItem('hc_school_billing') || '{}');
                } catch (e) { return {}; }
            });

            const planStatus = useMemo(() => {
                const SITE_ADMINS = ['matthewfinn14@gmail.com'];
                if (currentUser && SITE_ADMINS.includes(currentUser.email.toLowerCase())) return 'ALL_ACCESS';

                const plan = billingInfo.plan || 'free';
                const now = new Date();

                if (plan === 'trial') {
                    if (billingInfo.trialEndsAt && new Date(billingInfo.trialEndsAt) > now) return 'PREMIUM_TRIAL';
                    return 'FREE';
                }
                if (plan === 'premium') {
                    if (billingInfo.subscriptionEndsAt && new Date(billingInfo.subscriptionEndsAt) <= now) return 'FREE';
                    return 'PREMIUM';
                }
                if (plan === 'all_access') return 'ALL_ACCESS';
                return 'FREE';
            }, [billingInfo, currentUser]);

            const updateBilling = (newData) => {
                setBillingInfo(newData);
                localStorage.setItem('hc_school_billing', JSON.stringify(newData));
            };

            return {
                planStatus,
                isPremium: ['PREMIUM', 'PREMIUM_TRIAL', 'ALL_ACCESS'].includes(planStatus),
                isFree: planStatus === 'FREE',
                billingInfo,
                updateBilling
            };
        };

        const FZDND_ZONES = [
            { id: 'red', title: 'Red Zone (20-Goalline)', color: '#fee2e2' },
            { id: 'orange', title: 'Orange Zone (40-20)', color: '#ffedd5' },
            { id: 'yellow', title: 'Yellow Zone (-40 to +40)', color: '#fef9c3' },
            { id: 'green', title: 'Green Zone (-20 to -40)', color: '#dcfce7' },
            { id: 'backedup', title: 'Backed Up (Goalline-10)', color: '#f1f5f9' }
        ];

        const PRIORITY_CATEGORIES = [
            { id: 'must_use', label: 'Must Use', color: 'bg-red-100 text-red-800' },
            { id: 'alert', label: 'Alert/Kill', color: 'bg-amber-100 text-amber-800' },
            { id: 'check_with_me', label: 'Check w/ Me', color: 'bg-blue-100 text-blue-800' },
            { id: 'waste', label: 'Waste', color: 'bg-gray-100 text-gray-800' }
        ];

        const signup = (email, password, loginMode = 'coach') => {
            localStorage.setItem('user_type', loginMode);
            return window.auth.createUserWithEmailAndPassword(email, password);
        };

        const LoginScreen = () => {
            const { login, loginWithGoogle } = useAuth(); // We need to expose signup from context or define it here if context is limited
            // NOTE: useAuth returns { login, loginWithGoogle, ... }. We need to extend it or just use window.auth directly in component for now.

            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [error, setError] = useState('');
            const [loading, setLoading] = useState(false);
            const [loginMode, setLoginMode] = useState('coach'); // 'coach' or 'player'
            const [isSignUp, setIsSignUp] = useState(false); // NEW: Toggle between Login and Signup

            const handleSubmit = async (e) => {
                e.preventDefault();
                setError('');
                setLoading(true);
                try {
                    if (isSignUp) {
                        // CREATE NEW ACCOUNT
                        localStorage.setItem('user_type', loginMode);
                        await window.auth.createUserWithEmailAndPassword(email, password);
                    } else {
                        // LOG IN EXISTING ACCOUNT
                        await login(email, password, loginMode);
                    }
                } catch (err) {
                    setError('Failed to ' + (isSignUp ? 'sign up: ' : 'log in: ') + err.message);
                    setLoading(false);
                }
            };

            const handleGoogleLogin = async () => {
                setError('');
                setLoading(true);
                try {
                    await loginWithGoogle(loginMode);
                } catch (err) {
                    console.error("Login Error:", err);
                    alert("Login Error: " + err.message);
                    setError('Failed to log in with Google: ' + err.message);
                    setLoading(false);
                }
            };

            return (
                <div style={{
                    height: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center',
                    background: 'linear-gradient(135deg, #0f172a 0%, #1e293b 100%)', color: 'white'
                }}>
                    <div style={{ background: '#1e293b', padding: '2rem', borderRadius: '12px', width: '100%', maxWidth: '400px', boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.25)' }}>
                        {/* Login Mode Toggle */}
                        <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '1.5rem', background: '#0f172a', padding: '0.25rem', borderRadius: '8px' }}>
                            <button
                                onClick={() => setLoginMode('coach')}
                                style={{
                                    flex: 1,
                                    padding: '0.75rem',
                                    borderRadius: '6px',
                                    border: 'none',
                                    background: loginMode === 'coach' ? '#0ea5e9' : 'transparent',
                                    color: 'white',
                                    fontWeight: loginMode === 'coach' ? 'bold' : 'normal',
                                    cursor: 'pointer',
                                    transition: 'all 0.2s'
                                }}
                            >
                                Coach
                            </button>
                            <button
                                onClick={() => setLoginMode('player')}
                                style={{
                                    flex: 1,
                                    padding: '0.75rem',
                                    borderRadius: '6px',
                                    border: 'none',
                                    background: loginMode === 'player' ? '#10b981' : 'transparent',
                                    color: 'white',
                                    fontWeight: loginMode === 'player' ? 'bold' : 'normal',
                                    cursor: 'pointer',
                                    transition: 'all 0.2s'
                                }}
                            >
                                Player
                            </button>
                        </div>

                        <h1 style={{ fontSize: '1.5rem', fontWeight: 'bold', marginBottom: '1.5rem', textAlign: 'center', color: loginMode === 'coach' ? '#38bdf8' : '#34d399' }}>
                            {loginMode === 'coach' ? 'Coach Login' : 'Player Login'}
                        </h1>
                        {error && <div style={{ background: '#7f1d1d', color: '#fca5a5', padding: '0.75rem', borderRadius: '6px', marginBottom: '1rem', fontSize: '0.9rem' }}>{error}</div>}
                        <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                            <div>
                                <label style={{ display: 'block', fontSize: '0.9rem', marginBottom: '0.5rem', color: '#cbd5e1' }}>
                                    {loginMode === 'coach' ? 'Email' : 'Player Email'}
                                </label>
                                <input
                                    type="email"
                                    required
                                    value={email}
                                    onChange={(e) => setEmail(e.target.value)}
                                    style={{ width: '100%', padding: '0.75rem', borderRadius: '6px', border: '1px solid #475569', background: '#0f172a', color: 'white' }}
                                    placeholder={loginMode === 'coach' ? 'coach@team.com' : 'player@team.com'}
                                />
                            </div>
                            <div>
                                <label style={{ display: 'block', fontSize: '0.9rem', marginBottom: '0.5rem', color: '#cbd5e1' }}>Password</label>
                                <input
                                    type="password"
                                    required
                                    value={password}
                                    onChange={(e) => setPassword(e.target.value)}
                                    style={{ width: '100%', padding: '0.75rem', borderRadius: '6px', border: '1px solid #475569', background: '#0f172a', color: 'white' }}
                                    placeholder="••••••••"
                                />
                            </div>
                            <button
                                type="submit"
                                disabled={loading}
                                style={{
                                    marginTop: '1rem', padding: '0.75rem', borderRadius: '6px', border: 'none',
                                    background: loading ? '#475569' : (loginMode === 'coach' ? '#0ea5e9' : '#10b981'),
                                    color: 'white', fontWeight: 'bold', cursor: loading ? 'not-allowed' : 'pointer'
                                }}
                            >
                                {loading ? 'Processing...' : (isSignUp ? 'Create Account' : 'Sign In')}
                            </button>
                        </form>


                        <div style={{ marginTop: '1rem', textAlign: 'center' }}>
                            <button
                                onClick={() => setIsSignUp(!isSignUp)}
                                style={{ background: 'none', border: 'none', color: '#94a3b8', fontSize: '0.9rem', cursor: 'pointer', textDecoration: 'underline' }}
                            >
                                {isSignUp ? 'Already have an account? Sign In' : 'Need an account? Sign Up'}
                            </button>
                        </div>

                        <div style={{ display: 'flex', alignItems: 'center', margin: '1.5rem 0' }}>
                            <div style={{ flex: 1, height: '1px', background: '#475569' }}></div>
                            <span style={{ padding: '0 0.5rem', color: '#94a3b8', fontSize: '0.85rem' }}>OR</span>
                            <div style={{ flex: 1, height: '1px', background: '#475569' }}></div>
                        </div>

                        <button
                            onClick={handleGoogleLogin}
                            disabled={loading}
                            style={{
                                width: '100%',
                                padding: '0.75rem',
                                borderRadius: '6px',
                                border: '1px solid #475569',
                                background: 'white',
                                color: '#0f172a',
                                fontWeight: 'bold',
                                cursor: loading ? 'not-allowed' : 'pointer',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                gap: '0.5rem'
                            }}
                        >
                            {isSignUp ? 'Sign up with Google' : 'Sign in with Google'}
                        </button>

                        <div style={{ marginTop: '1rem', paddingTop: '1rem', borderTop: '1px solid #334155' }}>
                            <button
                                onClick={async () => {
                                    setError('');
                                    setLoading(true);
                                    try {
                                        const timestamp = Date.now();
                                        const demoEmail = `demo_${timestamp}@test.com`;
                                        const demoPassword = `demo${timestamp}`;
                                        await window.auth.createUserWithEmailAndPassword(demoEmail, demoPassword);
                                        localStorage.setItem('is_demo_session', 'true');
                                    } catch (err) {
                                        console.error("Demo Error:", err);
                                        setError('Demo failed: ' + err.message);
                                        setLoading(false);
                                    }
                                }}
                                disabled={loading}
                                style={{
                                    width: '100%',
                                    padding: '0.75rem',
                                    borderRadius: '6px',
                                    border: '1px dashed #6366f1',
                                    background: 'rgba(99, 102, 241, 0.1)',
                                    color: '#818cf8',
                                    fontWeight: 'bold',
                                    cursor: loading ? 'not-allowed' : 'pointer',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    gap: '0.5rem'
                                }}
                            >
                                <Icon name="Zap" size={16} />
                                Test Drive (Demo Mode)
                            </button>
                            <div style={{ fontSize: '0.75rem', color: '#64748b', textAlign: 'center', marginTop: '0.5rem' }}>
                                Creates a temporary school that self-destructs on logout.
                            </div>
                        </div>

                        {loginMode === 'player' && (
                            <div style={{ marginTop: '1rem', padding: '0.75rem', background: 'rgba(16, 185, 129, 0.1)', borderRadius: '6px', fontSize: '0.85rem', color: '#6ee7b7', textAlign: 'center' }}>
                                <Icon name="Info" size={14} style={{ display: 'inline', marginRight: '0.5rem' }} />
                                Contact your coach if you need login credentials
                            </div>
                        )}
                        <div style={{ textAlign: 'center', marginTop: '1rem' }}>
                            <button
                                type="button"
                                onClick={() => {
                                    localStorage.clear();
                                    sessionStorage.clear();
                                    alert("Local data cleared. Please refresh the page.");
                                    window.location.reload();
                                }}
                                style={{ background: 'transparent', border: 'none', color: '#64748b', fontSize: '0.8rem', textDecoration: 'underline', cursor: 'pointer' }}
                            >
                                Reset Application Data (Fix Stuck State)
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const SchoolOnboardingWizard = ({ user, onComplete }) => {
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState('');

            // Data State
            const [schoolName, setSchoolName] = useState('');
            const [mascot, setMascot] = useState('');
            const [zipCode, setZipCode] = useState('');
            const [primaryColor, setPrimaryColor] = useState('#000000');
            const [secondaryColor, setSecondaryColor] = useState('#ffffff');

            // Default Levels (Hidden from wizard, used as defaults)
            const [levels] = useState(['Varsity', 'JV', 'Freshman']);

            // Default Positions (Hidden from wizard, used as defaults)
            const [offensePositions] = useState([
                { name: 'QB', type: 'QB' },
                { name: 'RB', type: 'RB' },
                { name: 'WR', type: 'WR' },
                { name: 'TE', type: 'TE' },
                { name: 'LT', type: 'OL' },
                { name: 'LG', type: 'OL' },
                { name: 'C', type: 'OL' },
                { name: 'RG', type: 'OL' },
                { name: 'RT', type: 'OL' }
            ]);

            const [defensePositions] = useState([
                { name: 'DL', type: 'DL' },
                { name: 'LB', type: 'LB' },
                { name: 'DB', type: 'DB' },
                { name: 'S', type: 'DB' }
            ]);

            const handleSave = async () => {
                if (!schoolName || !mascot || !zipCode) {
                    setError('Please fill in all fields (School Name, Mascot, Zip Code).');
                    return;
                }

                setLoading(true);
                setError('');
                try {
                    // 1. Create School Document
                    const schoolData = {
                        name: schoolName,
                        mascot: mascot,
                        zipCode: zipCode,
                        colors: { primary: primaryColor, secondary: secondaryColor },
                        settings: {
                            schoolName: schoolName,
                            mascot: mascot,
                            zipCode: zipCode,
                            accentColor: primaryColor, // Use primary as accent
                            levels: levels,
                            offensePositions: offensePositions,
                            defensePositions: defensePositions,
                            activeYear: new Date().getFullYear().toString(),
                            theme: 'dark', // Default
                            initialized: true,
                            createdAt: new Date().toISOString(),
                            createdBy: user.uid
                        },
                        // Initialize empty collections/structures if needed
                        roster: [],
                        plays: {}, // Empty library
                        staff: [{
                            email: user.email,
                            role: 'Head Coach',
                            name: user.displayName || 'Coach',
                            uid: user.uid,
                            permissions: ['ADMIN']
                        }]
                    };

                    const schoolRef = await window.db.collection('schools').add(schoolData);
                    const schoolId = schoolRef.id;

                    // 2. Update User Profile with School ID
                    const userRef = window.db.collection('users').doc(user.uid);
                    await userRef.set({
                        schoolId: schoolId,
                        role: 'Head Coach',
                        email: user.email
                    }, { merge: true });

                    // 3. VERIFY WRITE (Retry logic to prevent race conditions on reload)
                    let confirmed = false;
                    let attempts = 0;
                    while (!confirmed && attempts < 5) {
                        try {
                            const checkDoc = await userRef.get({ source: 'server' }); // Force server check
                            if (checkDoc.exists && checkDoc.data().schoolId === schoolId) {
                                confirmed = true;
                            } else {
                                await new Promise(r => setTimeout(r, 1000));
                            }
                        } catch (e) {
                            console.warn("Verification check failed, retrying...");
                            await new Promise(r => setTimeout(r, 1000));
                        }
                        attempts++;
                    }

                    console.log("School Created & Verified:", schoolId);

                    // Force local storage update nicely
                    localStorage.setItem('hc_school_id', schoolId);

                    onComplete(schoolId);

                } catch (err) {
                    console.error("Error creating school:", err);
                    setError("Failed to create school: " + err.message);
                    setLoading(false);
                }
            };

            return (
                <div style={{
                    height: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center',
                    background: 'linear-gradient(135deg, #0f172a 0%, #1e293b 100%)', color: 'white'
                }}>
                    <div style={{ background: '#1e293b', padding: '2rem', borderRadius: '12px', width: '100%', maxWidth: '500px', boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.25)' }}>
                        <h1 style={{ fontSize: '1.5rem', fontWeight: 'bold', marginBottom: '1rem', textAlign: 'center', color: '#38bdf8' }}>
                            Welcome to DoFO!
                        </h1>
                        <p style={{ textAlign: 'center', color: '#94a3b8', marginBottom: '2rem' }}>
                            Let&apos;s get your team set up in seconds.
                        </p>

                        {error && <div style={{ background: '#7f1d1d', color: '#fca5a5', padding: '1rem', borderRadius: '8px', marginBottom: '1rem' }}>{error}</div>}

                        {/* Single Step Form */}
                        <div>
                            <div style={{ marginBottom: '1rem' }}>
                                <label style={{ display: 'block', marginBottom: '0.5rem', color: '#cbd5e1' }}>School Name</label>
                                <input
                                    value={schoolName} onChange={e => setSchoolName(e.target.value)}
                                    style={{ width: '100%', padding: '0.75rem', borderRadius: '6px', background: '#0f172a', border: '1px solid #475569', color: 'white' }}
                                    placeholder="e.g. East Dillon Lions"
                                />
                            </div>

                            <div style={{ display: 'flex', gap: '1rem', marginBottom: '1rem' }}>
                                <div style={{ flex: 1 }}>
                                    <label style={{ display: 'block', marginBottom: '0.5rem', color: '#cbd5e1' }}>Mascot</label>
                                    <input
                                        value={mascot} onChange={e => setMascot(e.target.value)}
                                        style={{ width: '100%', padding: '0.75rem', borderRadius: '6px', background: '#0f172a', border: '1px solid #475569', color: 'white' }}
                                        placeholder="e.g. Lions"
                                    />
                                </div>
                                <div style={{ flex: 1 }}>
                                    <label style={{ display: 'block', marginBottom: '0.5rem', color: '#cbd5e1' }}>Zip Code</label>
                                    <input
                                        value={zipCode} onChange={e => setZipCode(e.target.value)}
                                        style={{ width: '100%', padding: '0.75rem', borderRadius: '6px', background: '#0f172a', border: '1px solid #475569', color: 'white' }}
                                        placeholder="e.g. 90210"
                                    />
                                </div>
                            </div>

                            <div style={{ display: 'flex', gap: '1rem', marginBottom: '2rem' }}>
                                <div style={{ flex: 1 }}>
                                    <label style={{ display: 'block', marginBottom: '0.5rem', color: '#cbd5e1' }}>School Colors</label>
                                    <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center', background: '#0f172a', padding: '0.5rem', borderRadius: '6px', border: '1px solid #475569' }}>
                                        <input type="color" value={primaryColor} onChange={e => setPrimaryColor(e.target.value)} style={{ border: 'none', width: '32px', height: '32px', cursor: 'pointer', background: 'none' }} />
                                        <span style={{ fontSize: '0.85rem', color: '#94a3b8' }}>Primary</span>
                                    </div>
                                </div>
                                <div style={{ flex: 1 }}>
                                    <label style={{ display: 'block', marginBottom: '0.5rem', color: '#cbd5e1' }}>&nbsp;</label>
                                    <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center', background: '#0f172a', padding: '0.5rem', borderRadius: '6px', border: '1px solid #475569' }}>
                                        <input type="color" value={secondaryColor} onChange={e => setSecondaryColor(e.target.value)} style={{ border: 'none', width: '32px', height: '32px', cursor: 'pointer', background: 'none' }} />
                                        <span style={{ fontSize: '0.85rem', color: '#94a3b8' }}>Secondary</span>
                                    </div>
                                </div>
                            </div>

                            <button
                                onClick={handleSave}
                                disabled={loading}
                                style={{
                                    width: '100%',
                                    padding: '0.75rem 2rem', background: '#0ea5e9',
                                    border: 'none', color: 'white', borderRadius: '6px', fontWeight: 'bold', cursor: loading ? 'wait' : 'pointer',
                                    fontSize: '1rem'
                                }}
                            >
                                {loading ? 'Creating School...' : 'Complete Setup'}
                            </button>
                        </div>
                    </div>
                </div>
            )
        };

        // --- Data & Constants ---
        // ... (rest of the file)


        // --- Data & Constants ---

        const GAME_PLAN_LAYOUTS = {
            CALL_SHEET: [],
            MATRIX: {
                id: 'MATRIX',
                name: "Strike 'Em Out",
                cols: [
                    { id: 'FB_L', label: 'FB L', fullLabel: 'Base/Initial Left' },
                    { id: 'FB_R', label: 'FB R', fullLabel: 'Base/Initial Right' },
                    { id: 'CB_L', label: 'CB L', fullLabel: 'Base w/ Dressing Left' },
                    { id: 'CB_R', label: 'CB R', fullLabel: 'Base w/ Dressing Right' },
                    { id: 'CU_L', label: 'CU L', fullLabel: 'Convert Left' },
                    { id: 'CU_R', label: 'CU R', fullLabel: 'Convert Right' },
                    { id: 'SO_L', label: 'SO L', fullLabel: 'Explosive Left' },
                    { id: 'SO_R', label: 'SO R', fullLabel: 'Explosive Right' }
                ],
                formations: [
                    { id: '887', label: '887', color: '#ef4444' },
                    { id: '888', label: '888', color: '#ef4444' },
                    { id: '687', label: '687', color: '#fbbf24' },
                    { id: '688', label: '688', color: '#fbbf24' },
                    { id: '881', label: '881', color: '#facc15' },
                    { id: '984', label: '984', color: '#4ade80' },
                    { id: '983', label: '983', color: '#4ade80' },
                    { id: '488', label: '488', color: '#60a5fa' },
                    { id: '487', label: '487', color: '#60a5fa' },
                    { id: 'jets', label: 'Jets/Specials', color: '#a8a29e' }
                ],
                playTypes: [
                    { id: 'strong_run', label: 'STRONG RUN' },
                    { id: 'weak_run', label: 'WEAK RUN' },
                    { id: 'quick_game', label: 'QUICK GAME' },
                    { id: 'drop_back', label: 'DROPBACK' },
                    { id: 'gadget', label: 'GADGET' }
                ]
            }
        };

        const TAG_CATEGORIES = {
            "Field Position": ["Backed Up", "Coming Out", "Open Field", "Fringe", "Red Zone", "Gold Zone", "Goal Line", "2-PT"],
            "Down & Distance": [
                "1st & 10", "Normal Down",
                "2nd & XL", "2nd & Long", "2nd & Med", "2nd & Short",
                "3rd & XL", "3rd & Long", "3rd & Med", "3rd & Short",
                "4th & XL", "4th & Long", "4th & Med", "4th & Short"
            ],
            "Situation": ["2 Min", "4 Min", "End of Game", "Possession", "Opening Script", "Tank Play", "Test Play", "Setup Play"],
            "Coverage Beaters": ["MOFO (Middle Open)", "MOFC (Middle Closed)", "Man Beater", "Zone Beater"],
            "Front Beaters": ["Odd Beater", "Even Beater", "Pressure Beater"],
            "Motion": [
                "Down motion",
                "THRU MO from 1x3 to 2x2",
                "THRU mo from 2x2 to 3x1",
                "Orbit MO from 1x3 to 2x2",
                "Orbit MO from 2x2 to 3x1",
                "RB push motion",
                "Zipper",
                "YAC",
                "YO-YO"
            ],
            "Primary Target": ["X", "A", "Z", "Y", "B", "Q", "F"],

            // Merged Call Sheet Tags
            "Play Type": [
                "Tank Runs",
                "Perimeter Runs",
                "FLOW RPOS",
                "FIT RPOS",
                "Quick",
                "Intermediate",
                "PAP",
                "MOVEMENT",
                "Deep",
                "GADGET"
            ],

            "Action Types": ["Strong Run", "Weak Run", "Quick Game", "Drop Back", "Screen", "Gadget"],
            "Base Type": ["Run", "Pass", "RPO", "Gadget"]
        };

        const HASH_PREFERENCES = ["Left", "Right", "Middle", "Any"];

        const INITIAL_MASTER_TASKS = [
            // DAILY
            { id: 'dt_1', category: 'Year-Round', task: 'Check Warrior Dials & Outreach (Trends)', recurrence: 'Daily', assignTo: ['All Position Coaches', 'Head Coach'] },
            { id: 'dt_2', category: 'Year-Round', task: 'Study Player Profiles (Favorites/Preferences)', recurrence: 'Daily', assignTo: ['All Position Coaches'] },
            { id: 'dt_hc_1', category: 'Year-Round', task: 'Staff Communication / Pulse Check', recurrence: 'Daily', assignTo: ['Head Coach'] },
            { id: 'dt_hc_2', category: 'Year-Round', task: 'Review Practice Plan & Scripts (Global View)', recurrence: 'Daily', assignTo: ['Head Coach'] },
            { id: 'dt_hc_3', category: 'Year-Round', task: 'Admin / Parent Communication Check', recurrence: 'Daily', assignTo: ['Head Coach'] },

            // WEEKLY / SATURDAY
            { id: 'wt_1', category: 'Saturday', task: 'Grade Position Groups', recurrence: 'Weekly: Saturday', assignTo: ['All Position Coaches'] },
            { id: 'wt_dc', category: 'Saturday', task: 'Finalize Defensive Game Plan / Blitz Packages', recurrence: 'Weekly', assignTo: ['DC'] },
            { id: 'wt_oc', category: 'Saturday', task: 'Finalize Offensive Script / Opening Drive', recurrence: 'Weekly', assignTo: ['OC'] },
            { id: 'wt_st', category: 'Saturday', task: 'Scout Opponent Special Teams / Personnel', recurrence: 'Weekly', assignTo: ['STC'] },

            // GAME WEEK
            { id: 'gw_1', category: 'Game Week', task: 'Opponent Scouting (Assigned Area)', recurrence: 'Weekly: Monday', assignTo: ['All Position Coaches'] },
            { id: 'gw_2', category: 'Game Week', task: 'Prepare Drills & Link to Practice Plan', recurrence: 'Weekly: Monday', assignTo: ['All Position Coaches'] },
            { id: 'gw_3', category: 'Game Week', task: 'Populate Practice Equipment Needs', recurrence: 'Daily', assignTo: ['All Position Coaches'] },
            { id: 'gw_4', category: 'Game Week', task: 'Review Practice Scripts', recurrence: 'Daily', assignTo: ['All Position Coaches'] },
            { id: 'gw_qb', category: 'Game Week', task: 'Review QB Mechanics / Footwork Drills', recurrence: 'Weekly', assignTo: ['QB Coach'] },
            { id: 'gw_mgr', category: 'Game Week', task: 'Practice Field Setup (Cones/Bags)', recurrence: 'Daily', assignTo: ['Managers'] },

            // DAY BEFORE GAME
            { id: 'dbg_1', category: 'Day Before Game', task: 'Pack Footballs & Extra Equipment', recurrence: 'Weekly: Thursday', assignTo: ['Managers', 'Equipment Mgr'] },
            { id: 'dbg_2', category: 'Day Before Game', task: 'Charge Tablets, Cameras, Headsets', recurrence: 'Weekly: Thursday', assignTo: ['Tech Coodinator'] },
            { id: 'dbg_3', category: 'Day Before Game', task: 'Clear iPad Storage', recurrence: 'Weekly: Thursday', assignTo: ['Tech Coodinator'] },

            // TRAVEL
            { id: 'tr_1', category: 'Travel', task: 'Trailer / Suburban Driver', recurrence: 'Weekly: Friday', assignTo: [] },
            { id: 'tr_2', category: 'Travel', task: 'Bus Supervision', recurrence: 'Weekly: Friday', assignTo: ['All Staff'] },
            { id: 'tr_3', category: 'Travel', task: 'Load Trailer', recurrence: 'Weekly: Friday', assignTo: ['Managers'] },

            // ARRIVAL / SETUP
            { id: 'arr_1', category: 'Arrival', task: 'Unload Trailer', recurrence: 'Weekly: Friday', assignTo: ['Managers'] },
            { id: 'arr_2', category: 'Arrival', task: 'Setup Replay & Cameras', recurrence: 'Weekly: Friday', assignTo: ['Video Coordinator'] },
            { id: 'arr_3', category: 'Arrival', task: 'Setup Pressbox & Headsets', recurrence: 'Weekly: Friday', assignTo: ['Tech Coodinator'] },
            { id: 'arr_4', category: 'Arrival', task: 'Locker Room Supervision', recurrence: 'Weekly: Friday', assignTo: ['assigned'] },
            { id: 'arr_5', category: 'Arrival', task: 'Keep Team on Schedule', recurrence: 'Weekly: Friday', assignTo: ['Get Back Coach'] },

            // PRE-GAME
            { id: 'pre_1', category: 'Pre-Game', task: 'Run Walkthroughs / Meetings', recurrence: 'Weekly: Friday', assignTo: ['Coordinators'] },
            { id: 'pre_2', category: 'Pre-Game', task: 'Run Pre-game Stretches / Fundamentals', recurrence: 'Weekly: Friday', assignTo: ['Position Coaches'] },

            // IN-GAME
            { id: 'ig_1', category: 'In-Game', task: 'Equipment Help / Water', recurrence: 'Weekly: Friday', assignTo: ['Managers'] },
            { id: 'ig_2', category: 'In-Game', task: 'Injury Communication', recurrence: 'Weekly: Friday', assignTo: ['Trainer'] },
            { id: 'ig_3', category: 'In-Game', task: 'Pressbox Ops', recurrence: 'Weekly: Friday', assignTo: ['AC'] },
            { id: 'ig_4', category: 'In-Game', task: 'Stats Logging', recurrence: 'Weekly: Friday', assignTo: ['Stats Crew'] },
            { id: 'ig_5', category: 'In-Game', task: 'Substitutions', recurrence: 'Weekly: Friday', assignTo: ['Position Coaches'] },

            // POST-GAME
            { id: 'pg_1', category: 'Post-Game', task: 'Clean Up / Locker Room Check', recurrence: 'Weekly: Friday', assignTo: ['All Staff'] },
            { id: 'pg_2', category: 'Post-Game', task: 'Upload Film', recurrence: 'Weekly: Friday', assignTo: ['Video Coordinator'] },
            { id: 'pg_3', category: 'Post-Game', task: 'Upload / Check Stats', recurrence: 'Weekly: Friday', assignTo: ['Stats Crew'] },
            { id: 'pg_4', category: 'Post-Game', task: 'Injury Forms', recurrence: 'Weekly: Friday', assignTo: ['Trainer'] },

            // SUMMER
            { id: 'sum_1', category: 'Summer', task: 'Lay out Football Field', recurrence: 'Seasonal', assignTo: ['Staff'] },
            { id: 'sum_2', category: 'Summer', task: 'Prep for Installs', recurrence: 'Seasonal', assignTo: ['Coordinators'] },
            { id: 'sum_3', category: 'Summer', task: 'Weight Room Supervision', recurrence: 'Seasonal', assignTo: ['Strength Coach'] },
            { id: 'sum_4', category: 'Summer', task: 'Thud Camps Support', recurrence: 'Seasonal', assignTo: ['All Staff'] },
            { id: 'sum_5', category: 'Summer', task: 'Youth Camp Support', recurrence: 'Seasonal', assignTo: ['All Staff'] },
            { id: 'sum_6', category: 'Summer', task: 'Fundraisers', recurrence: 'Seasonal', assignTo: ['All Staff'] },

            // OFFSEASON
            { id: 'off_1', category: 'Offseason', task: 'Equipment Turn-in', recurrence: 'Annual', assignTo: ['Equipment Mgr'] },
            { id: 'off_2', category: 'Offseason', task: 'Banquet Prep (Slides, Video, Speech, Awards)', recurrence: 'Annual', assignTo: ['Head Coach'] },
            { id: 'off_2b', category: 'Offseason', task: 'Reserve Auditorium for Banquet', recurrence: 'Annual', assignTo: ['Head Coach'] },
            { id: 'off_3', category: 'Offseason', task: 'Inventory & Order Equipment', recurrence: 'Annual', assignTo: ['Equipment Mgr'] },
            { id: 'off_4', category: 'Offseason', task: 'Player Evaluations', recurrence: 'Annual', assignTo: ['All Staff'] },
            { id: 'off_5', category: 'Offseason', task: 'Update Position Manuals / Drills', recurrence: 'Annual', assignTo: ['Position Coaches'] },
            { id: 'off_6', category: 'Offseason', task: 'College Recruiting Visits (Spring)', recurrence: 'Seasonal', assignTo: ['Recruiting Coord'] },
            { id: 'off_7', category: 'Offseason', task: 'Submit All-District / All-State Nominations', recurrence: 'Annual', assignTo: ['Head Coach'] },
            { id: 'off_8', category: 'Offseason', task: 'Schedule Summer Gauntlet Draft & Notify Captains', recurrence: 'Annual', assignTo: ['Head Coach'] },
            { id: 'off_9', category: 'Offseason', task: 'Send out Youth Camp Forms (Before May)', recurrence: 'Annual', assignTo: ['Head Coach'] },
            { id: 'off_10', category: 'Offseason', task: 'Set up Team Clothing Store (Late April)', recurrence: 'Annual', assignTo: ['Head Coach', 'Equipment Mgr'] },
            { id: 'off_11', category: 'Offseason', task: 'Book Hotels & Transport for Winter Clinics', recurrence: 'Annual', assignTo: ['Head Coach'] },
            { id: 'sum_7', category: 'Summer', task: 'Reserve Auditorium for First Week Meetings', recurrence: 'Annual', assignTo: ['Head Coach'] },

            // ADMIN / ONGOING

            { id: 'adm_2', category: 'Daily', task: 'Player Academic / Recruiting Check-ins', recurrence: 'Weekly', assignTo: ['Head Coach', 'Recruiting Coord'] },
            { id: 'adm_3', category: 'Administrative', task: 'Reserve Facilities (Pool, Fields)', recurrence: 'Seasonal', assignTo: ['Head Coach'] },
            { id: 'adm_4', category: 'Administrative', task: 'Order Rentals (Port-a-potty, etc.)', recurrence: 'Seasonal', assignTo: ['Head Coach'] },
        ];

        const INITIAL_PLAYS = [
            // 100s - WB1 Left Column
            { id: '101', wristbandSlot: '101', name: 'DIAMOND RT GRN 3 GAMBLE', formation: 'Diamond Rt', tags: ['Gamble'] },
            { id: '103', wristbandSlot: '103', name: 'BUNCH RT 2 GAMBLE', formation: 'Bunch Rt', tags: ['Gamble'] },
            { id: '105', wristbandSlot: '105', name: 'BUNCH LT 3 RED 6 + GAMBLE*', formation: 'Bunch Lt', tags: ['Gamble', 'Red 6'] },
            { id: '107', wristbandSlot: '107', name: 'GRN BOOMER 1', formation: 'Green', tags: ['Boomer'] },
            { id: '109', wristbandSlot: '109', name: 'RED 39 MUSTANG', formation: 'Red', tags: ['Mustang'] },
            { id: '111', wristbandSlot: '111', name: 'BRT 56D + KNIFE', formation: 'Bright', tags: ['Knife'] },
            { id: '113', wristbandSlot: '113', name: 'GRN Fist Smoke', formation: 'Green', tags: ['Smoke'] },
            { id: '115', wristbandSlot: '115', name: '983 BLUE 1', formation: 'Blue', tags: ['983'] },
            { id: '117', wristbandSlot: '117', name: 'BRT RED "A THRU" + SALT', formation: 'Bright Red', tags: ['Salt'] },
            { id: '119', wristbandSlot: '119', name: '941 BLUE 4+ Y Willy', formation: 'Blue', tags: ['Willy'] },
            { id: '121', wristbandSlot: '121', name: '983 BLUE 2+ CAPONE', formation: 'Blue', tags: ['Capone'] },
            { id: '123', wristbandSlot: '123', name: '934 BLUE 2 SUPER', formation: 'Blue', tags: ['Super'] },
            { id: '125', wristbandSlot: '125', name: '980 BLUE 6+ Y RPO', formation: 'Blue', tags: ['RPO'] },
            { id: '127', wristbandSlot: '127', name: '984 RED 2+ Y Willy', formation: 'Red', tags: ['Willy'] },
            { id: '129', wristbandSlot: '129', name: '36A RED 4+Y Willy', formation: 'Red', tags: ['Willy'] },
            { id: '131', wristbandSlot: '131', name: 'GRN RED "B THRU" + 3T', formation: 'Green Red', tags: [] },
            { id: '133', wristbandSlot: '133', name: '463 BLUE 4A', formation: 'Blue', tags: [] },
            { id: '135', wristbandSlot: '135', name: '488 LIZ GREEN STICK + TAG', formation: 'Green', tags: ['Stick'] },
            { id: '137', wristbandSlot: '137', name: '468 RN "A JET"', formation: 'Rn', tags: ['Jet'] },
            { id: '139', wristbandSlot: '139', name: '468 LIZ GRN RICE*', formation: 'Green', tags: ['Rice'] },
            { id: '141', wristbandSlot: '141', name: '430 GRN RICE*', formation: 'Green', tags: ['Rice'] },
            { id: '143', wristbandSlot: '143', name: '488 RED "A ACROSS" 3A+ KNIFE', formation: 'Red', tags: ['Knife'] },
            { id: '145', wristbandSlot: '145', name: '987 BLUE 6G+ WILLY', formation: 'Blue', tags: ['Willy'] },
            { id: '147', wristbandSlot: '147', name: '466 ORNG BOOMER 1 + A SHALLOW', formation: 'Orange', tags: ['Boomer', 'Shallow'] },

            // 100s - WB1 Right Column
            { id: '102', wristbandSlot: '102', name: 'DIAMOND LT GRN GAMBLE', formation: 'Diamond Lt', tags: ['Gamble'] },
            { id: '104', wristbandSlot: '104', name: 'BUNCH LT 3 GAMBLE (BULLS)*', formation: 'Bunch Lt', tags: ['Gamble', 'Bulls'] },
            { id: '106', wristbandSlot: '106', name: 'BUNCH RT RT RED 6 + GAMBLE*', formation: 'Bunch Rt', tags: ['Gamble', 'Red 6'] },
            { id: '108', wristbandSlot: '108', name: 'GRN BOOMER 1 SPECIAL', formation: 'Green', tags: ['Boomer'] },
            { id: '110', wristbandSlot: '110', name: 'RED 39 MUSTANG', formation: 'Red', tags: ['Mustang'] },
            { id: '112', wristbandSlot: '112', name: '987 GRN 5G + KNIFE', formation: 'Green', tags: ['Knife'] },
            { id: '114', wristbandSlot: '114', name: '988 GRN FIST LEAK', formation: 'Green', tags: ['Leak'] },
            { id: '116', wristbandSlot: '116', name: '983 GRN 1 SMOKE*', formation: 'Green', tags: ['Smoke'] },
            { id: '118', wristbandSlot: '118', name: '974 RED 5Y + GOT7!', formation: 'Red', tags: ['Got7'] },
            { id: '120', wristbandSlot: '120', name: '974 RED 5Y+ GOT7!', formation: 'Red', tags: ['Got7'] },
            { id: '122', wristbandSlot: '122', name: '974 RED 5Y + CAPONE', formation: 'Red', tags: ['Capone'] },
            { id: '124', wristbandSlot: '124', name: '934 RED 1 (A ARC)', formation: 'Red', tags: ['Arc'] },
            { id: '126', wristbandSlot: '126', name: '970 RED 6+ Y RPO', formation: 'Red', tags: ['RPO'] },
            { id: '128', wristbandSlot: '128', name: '973 BLUE 4Y + WILLY', formation: 'Blue', tags: ['Willy'] },
            { id: '130', wristbandSlot: '130', name: '473 BLUE 4A + WILLY', formation: 'Blue', tags: ['Willy'] },
            { id: '132', wristbandSlot: '132', name: '974 RED "B THRU" + 4T', formation: 'Red', tags: [] },
            { id: '134', wristbandSlot: '134', name: '374 RED 3A', formation: 'Red', tags: [] },
            { id: '136', wristbandSlot: '136', name: '877 RIP GOLD STICK + TAG', formation: 'Gold', tags: ['Stick'] },
            { id: '138', wristbandSlot: '138', name: '866 RIP "A JET"', formation: 'Rip', tags: ['Jet'] },
            { id: '140', wristbandSlot: '140', name: '888 LIZ GRN BOOMER 1 + B SHAL*', formation: 'Green', tags: ['Boomer'] },
            { id: '142', wristbandSlot: '142', name: '830 RIP Inverted Veer', formation: 'Rip', tags: ['Veer'] },
            { id: '144', wristbandSlot: '144', name: '470 Rip Red "A ACROSS" 4A + Knife', formation: 'Red', tags: ['Knife'] },
            { id: '146', wristbandSlot: '146', name: '987 RED 5G+ WILLY', formation: 'Red', tags: ['Willy'] },
            { id: '148', wristbandSlot: '148', name: '466 ORNG STASH (X ST)', formation: 'Orange', tags: ['Stash'] },

            // 200s - WB2 Left Column
            { id: '201', wristbandSlot: '201', name: '987 BLUE 3', formation: 'Blue', tags: [] },
            { id: '203', wristbandSlot: '203', name: '473 GRN B THRU + MICKEY (SIG)', formation: 'Green', tags: ['Mickey'] },
            { id: '205', wristbandSlot: '205', name: '987 BRN CROSS*', formation: 'Brown', tags: ['Cross'] },
            { id: '207', wristbandSlot: '207', name: '288 BRN SHARK (SIG)', formation: 'Brown', tags: ['Shark'] },
            { id: '209', wristbandSlot: '209', name: '469 RED 2', formation: 'Red', tags: [] },
            { id: '211', wristbandSlot: '211', name: '877 RED 3T', formation: 'Red', tags: [] },
            { id: '213', wristbandSlot: '213', name: '479 OVER U RED 2*', formation: 'Red', tags: [] },
            { id: '215', wristbandSlot: '215', name: '430 OVER O DITCH', formation: 'Over', tags: ['Ditch'] },
            { id: '217', wristbandSlot: '217', name: '888 GRN BOOMER 1', formation: 'Green', tags: ['Boomer'] },
            { id: '219', wristbandSlot: '219', name: 'TANK 48 OVER RED 2*', formation: 'Red', tags: [] },
            { id: '221', wristbandSlot: '221', name: '830 METAL RED Z JUKE', formation: 'Red', tags: ['Juke'] },
            { id: '223', wristbandSlot: '223', name: '677 RED 1 OPTION', formation: 'Red', tags: ['Option'] },
            { id: '225', wristbandSlot: '225', name: '878 GRN WHEEL BUMP*', formation: 'Green', tags: ['Wheel'] },
            { id: '227', wristbandSlot: '227', name: '889 BRN TAG+ WHEEL*', formation: 'Brown', tags: ['Wheel'] },
            { id: '229', wristbandSlot: '229', name: '469 RED 2', formation: 'Red', tags: [] },
            { id: '231', wristbandSlot: '231', name: '876 J RED 1', formation: 'Red', tags: [] },
            { id: '233', wristbandSlot: '233', name: '984 RED 1 + SMOKE (SIG)', formation: 'Red', tags: ['Smoke'] },
            { id: '235', wristbandSlot: '235', name: '697 BROWN SMASH + DEPOT', formation: 'Brown', tags: ['Smash'] },
            { id: '237', wristbandSlot: '237', name: '369 RED WHEEL BUMP + Q SPK', formation: 'Red', tags: ['Wheel'] },
            { id: '239', wristbandSlot: '239', name: '983 RED SWING NOLES', formation: 'Red', tags: ['Swing'] },
            { id: '241', wristbandSlot: '241', name: '489 RED 2 (J ROG)', formation: 'Red', tags: [] },
            { id: '243', wristbandSlot: '243', name: '676 BLUE 3Y*', formation: 'Blue', tags: [] },
            { id: '245', wristbandSlot: '245', name: '888 RED BRN', formation: 'Red', tags: [] },
            { id: '247', wristbandSlot: '247', name: '934 MAROON MOSS', formation: 'Maroon', tags: ['Moss'] },

            // 200s - WB2 Right Column
            { id: '202', wristbandSlot: '202', name: '987 BLUE 2', formation: 'Blue', tags: [] },
            { id: '204', wristbandSlot: '204', name: '473 GRN B THRU + MICKEY (SIG)', formation: 'Green', tags: ['Mickey'] },
            { id: '206', wristbandSlot: '206', name: '987 GRN CROSS*', formation: 'Green', tags: ['Cross'] },
            { id: '208', wristbandSlot: '208', name: '288 GRN SHARK (SIG)', formation: 'Green', tags: ['Shark'] },
            { id: '210', wristbandSlot: '210', name: '469 RED 1', formation: 'Red', tags: [] },
            { id: '212', wristbandSlot: '212', name: '877 RED 3T', formation: 'Red', tags: [] },
            { id: '214', wristbandSlot: '214', name: '479 OVER U RED 2*', formation: 'Red', tags: [] },
            { id: '216', wristbandSlot: '216', name: '430 OVER O DITCH', formation: 'Over', tags: ['Ditch'] },
            { id: '218', wristbandSlot: '218', name: '877 GOLD BOOMER 1', formation: 'Gold', tags: ['Boomer'] },
            { id: '220', wristbandSlot: '220', name: 'TANK 471 OVER BLUE 2', formation: 'Blue', tags: [] },
            { id: '222', wristbandSlot: '222', name: '830 METAL RED Z JUKE', formation: 'Red', tags: ['Juke'] },
            { id: '224', wristbandSlot: '224', name: '688 BLUE 1 OPTION', formation: 'Blue', tags: ['Option'] },
            { id: '226', wristbandSlot: '226', name: '878 GRN WHEEL BUMP*', formation: 'Green', tags: ['Wheel'] },
            { id: '228', wristbandSlot: '228', name: '889 BRN SMASH + BLADE', formation: 'Brown', tags: ['Smash'] },
            { id: '230', wristbandSlot: '230', name: '370 BLUE 1', formation: 'Blue', tags: [] },
            { id: '232', wristbandSlot: '232', name: '876 BLUE 1', formation: 'Blue', tags: [] },
            { id: '234', wristbandSlot: '234', name: '984 RED 1 + SMOKE (SIG)', formation: 'Red', tags: ['Smoke'] },
            { id: '236', wristbandSlot: '236', name: 'NUB RT + TUB LEFT BLUE Z THRU 4A', formation: 'Nub Rt', tags: [] },
            { id: '238', wristbandSlot: '238', name: '480 BLACK WHEEL SHARK', formation: 'Black', tags: ['Wheel', 'Shark'] },
            { id: '240', wristbandSlot: '240', name: 'SCRAMBLE 984 RED SHOW 3Y MLB*', formation: 'Red', tags: ['Scramble'] },
            { id: '242', wristbandSlot: '242', name: '370 RED 1 (J ROG)', formation: 'Red', tags: [] },
            { id: '244', wristbandSlot: '244', name: '983 RED 1*', formation: 'Red', tags: [] },
            { id: '246', wristbandSlot: '246', name: 'TANK 32A U OVER BLUE QB WEDGE RT', formation: 'Blue', tags: ['Wedge'] },
            { id: '248', wristbandSlot: '248', name: '934 MAROON (SIG)', formation: 'Maroon', tags: [] },
        ];

        // --- Director of Ops Data ---
        const WEEKLY_OPS_TASKS = [
            // Saturday
            { id: 'sat_1', day: 'Saturday', task: 'Break down our game film', roles: ['HC', 'OC', 'DC'], completed: false },
            { id: 'sat_2', day: 'Saturday', task: 'Send opponent film to Hudl Assist', roles: ['HC', 'OC', 'DC'], completed: false },

            // Sunday
            { id: 'sun_1', day: 'Sunday', task: 'Break down opponent scheme, tendencies, and personnel', roles: ['OC', 'DC', 'Position Coach'], completed: false },
            { id: 'sun_2', day: 'Sunday', task: 'Formulate game plan and prepare scheme tweaks', roles: ['HC', 'OC', 'DC'], completed: false },
            { id: 'sun_3', day: 'Sunday', task: 'Staff Meeting: Preview opponent & discuss improvements', roles: ['ALL'], completed: false },
            { id: 'sun_4', day: 'Sunday', task: 'Finalize practice plans and segment allotments', roles: ['HC', 'OC', 'DC'], completed: false },

            // Monday
            { id: 'mon_1', day: 'Monday', task: 'Check JV Game schedule (adjust practice load)', roles: ['HC', 'OC', 'DC'], completed: false },
            { id: 'mon_2', day: 'Monday', task: 'Film segment prior to walkthrough', roles: ['HC', 'OC', 'DC', 'Position Coach'], completed: false },
            { id: 'mon_3', day: 'Monday', task: 'Walkthrough', roles: ['ALL'], completed: false },
            { id: 'mon_4', day: 'Monday', task: 'Upload previous game film to Hudl (if not done)', roles: ['HC', 'Ops'], completed: false },

            // Tuesday
            { id: 'tue_1', day: 'Tuesday', task: 'Complete opponent scouting report', roles: ['OC', 'DC'], completed: false },
            { id: 'tue_2', day: 'Tuesday', task: 'Finalize practice scripts for Wed/Thu', roles: ['OC', 'DC'], completed: false },

            // Wednesday
            { id: 'wed_1', day: 'Wednesday', task: 'Confirm travel arrangements', roles: ['Ops', 'HC'], completed: false },
            { id: 'wed_2', day: 'Wednesday', task: 'Check medical/injury reports', roles: ['HC', 'Ops'], completed: false },

            // Thursday
            { id: 'thu_1', day: 'Thursday', task: 'Review game day roster', roles: ['HC', 'OC', 'DC'], completed: false },
            { id: 'thu_2', day: 'Thursday', task: 'Print wristbands and call sheets', roles: ['OC', 'DC', 'Ops'], completed: false },

            // Friday
            { id: 'fri_1', day: 'Friday', task: 'Pre-game meal check', roles: ['Ops'], completed: false },
            { id: 'fri_2', day: 'Friday', task: 'Equipment check', roles: ['Ops'], completed: false }
        ];

        // --- Components ---

        const Icon = ({ name, size = 20, color, style = {} }) => {
            const strokeColor = color || "currentColor";
            const iconStyle = { ...style, width: size, height: size, minWidth: size, minHeight: size };
            const commonProps = {
                xmlns: "http://www.w3.org/2000/svg",
                width: size,
                height: size,
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: strokeColor,
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                style: iconStyle
            };

            switch (name) {
                // -- Program Mgmt --
                case "Home": return <svg {...commonProps}><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" /><polyline points="9 22 9 12 15 12 15 22" /></svg>;
                case "Users": return <svg {...commonProps}><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" /><circle cx="9" cy="7" r="4" /><path d="M22 21v-2a4 4 0 0 0-3-3.87" /><path d="M16 3.13a4 4 0 0 1 0 7.75" /></svg>;
                case "Briefcase": return <svg {...commonProps}><rect width="20" height="14" x="2" y="6" rx="2" /><path d="M16 20V4a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16" /></svg>;
                case "ClipboardList": return <svg {...commonProps}><rect width="8" height="4" x="8" y="2" rx="1" ry="1" /><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" /><path d="M12 11h4" /><path d="M12 16h4" /><path d="M8 11h.01" /><path d="M8 16h.01" /></svg>;
                case "Calendar": return <svg {...commonProps}><rect width="18" height="18" x="3" y="4" rx="2" /><path d="M16 2v4" /><path d="M8 2v4" /><path d="M3 10h18" /></svg>;
                case "DollarSign": return <svg {...commonProps}><line x1="12" x2="12" y1="2" y2="22" /><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6" /></svg>;
                case "UserPlus": return <svg {...commonProps}><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" /><circle cx="9" cy="7" r="4" /><line x1="19" x2="19" y1="8" y2="14" /><line x1="22" x2="16" y1="11" y2="11" /></svg>;

                // -- Equipment --
                case "Package": return <svg {...commonProps}><path d="m7.5 4.27 9 5.15" /><path d="M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z" /><path d="m3.3 7 8.7 5 8.7-5" /><path d="M12 22v-9" /></svg>;
                case "ClipboardCheck": return <svg {...commonProps}><rect width="8" height="4" x="8" y="2" rx="1" ry="1" /><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" /><path d="m9 14 2 2 4-4" /></svg>;
                case "Trophy": return <svg {...commonProps}><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6" /><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18" /><path d="M4 22h16" /><path d="M10 14.66V17" /><path d="M14 14.66V17" /><path d="M12 2v8" /><path d="M12 22h0" /><path d="M12 10a4 4 0 0 0 4 4 4 4 0 0 0 4-4H4a4 4 0 0 0 4 4 4 4 0 0 0 4-4z" /></svg>;
                case "List": return <svg {...commonProps}><line x1="8" x2="21" y1="6" y2="6" /><line x1="8" x2="21" y1="12" y2="12" /><line x1="8" x2="21" y1="18" y2="18" /><line x1="3" x2="3.01" y1="6" y2="6" /><line x1="3" x2="3.01" y1="12" y2="12" /><line x1="3" x2="3.01" y1="18" y2="18" /></svg>;
                case "ShoppingCart": return <svg {...commonProps}><circle cx="8" cy="21" r="1" /><circle cx="19" cy="21" r="1" /><path d="M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12" /></svg>;

                // -- Apps --
                case "Smartphone": return <svg {...commonProps}><rect width="14" height="20" x="5" y="2" rx="2" ry="2" /><path d="M12 18h.01" /></svg>;
                case "UserCheck": return <svg {...commonProps}><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" /><circle cx="9" cy="7" r="4" /><polyline points="16 11 18 13 22 9" /></svg>;
                case "Clipboard": return <svg {...commonProps}><rect width="8" height="4" x="8" y="2" rx="1" ry="1" /><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" /></svg>;
                case "FileText": return <svg {...commonProps}><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7z" /><path d="M14 2v4a2 2 0 0 0 2 2h4" /><path d="M10 9H8" /><path d="M16 13H8" /><path d="M16 17H8" /></svg>;
                case "Gamepad2": return <svg {...commonProps}><line x1="6" x2="10" y1="12" y2="12" /><line x1="8" x2="8" y1="10" y2="14" /><line x1="15" x2="15.01" y1="13" y2="13" /><line x1="18" x2="18.01" y1="11" y2="11" /><rect width="20" height="12" x="2" y="6" rx="2" /></svg>;
                case "Monitor": return <svg {...commonProps}><rect width="20" height="14" x="2" y="3" rx="2" ry="2" /><line x1="8" x2="16" y1="21" y2="21" /><line x1="12" x2="12" y1="17" y2="21" /></svg>;
                case "Target": return <svg {...commonProps}><circle cx="12" cy="12" r="10" /><circle cx="12" cy="12" r="6" /><circle cx="12" cy="12" r="2" /></svg>;

                // -- Development --
                case "Activity": return <svg {...commonProps}><path d="M22 12h-4l-3 9L9 3l-3 9H2" /></svg>;
                case "Timer": return <svg {...commonProps}><line x1="10" x2="14" y1="2" y2="2" /><line x1="12" x2="15" y1="14" y2="11" /><circle cx="12" cy="14" r="8" /></svg>;
                case "Dumbbell": return <svg {...commonProps}><path d="m6.5 6.5 11 11" /><path d="m21 21-1-1" /><path d="m3 3 1 1" /><path d="m18 22 4-4" /><path d="m2 6 4-4" /><path d="m3 10 7-7" /><path d="m14 21 7-7" /></svg>;
                case "Swords": return <svg {...commonProps}><polyline points="14.5 17.5 3 6 3 3 6 3 17.5 14.5" /><line x1="13" x2="19" y1="19" y2="13" /><line x1="16" x2="20" y1="16" y2="20" /><line x1="19" x2="21" y1="21" y2="19" /><polyline points="14.5 6.5 18 3 21 3 21 6 17.5 9.5" /><line x1="5" x2="9" y1="14" y2="10" /><line x1="9" x2="11" y1="11" y2="13" /><line x1="12" x2="14" y1="14" y2="16" /></svg>;
                case "FileBarChart": return <svg {...commonProps}><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7z" /><path d="M14 2v4a2 2 0 0 0 2 2h4" /><path d="M8 12v-2" /><path d="M12 18v-6" /><path d="M16 14v-2" /></svg>;

                // -- Personnel --
                case "UserCog": return <svg {...commonProps}><circle cx="18" cy="15" r="3" /><circle cx="9" cy="7" r="4" /><path d="M10 15H6a4 4 0 0 0-4 4v2" /><path d="m21.7 16.4-.9-.3" /><path d="m15.2 13.9-.9-.3" /><path d="m16.6 18.7.3-.9" /><path d="m19.1 12.2.3-.9" /><path d="m19.6 18.7-.4-1" /><path d="m16.8 12.3-.4-1" /><path d="m14.3 16.6 1-.4" /><path d="m20.7 13.8 1-.4" /></svg>;
                case "User": return <svg {...commonProps}><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" /><circle cx="12" cy="7" r="4" /></svg>;

                // -- Game Week --
                case "CalendarClock": return <svg {...commonProps}><path d="M21 7.5V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h3.5" /><path d="M16 2v4" /><path d="M8 2v4" /><path d="M3 10h18" /><circle cx="18" cy="18" r="4" /><path d="M17 16l1 2 2 .5" /></svg>;
                case "Sun": return <svg {...commonProps}><circle cx="12" cy="12" r="4" /><path d="M12 2v2" /><path d="M12 20v2" /><path d="m4.93 4.93 1.41 1.41" /><path d="m17.66 17.66 1.41 1.41" /><path d="M2 12h2" /><path d="M20 12h2" /><path d="m6.34 17.66-1.41 1.41" /><path d="m19.07 4.93-1.41 1.41" /></svg>;
                case "Eye": return <svg {...commonProps}><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z" /><circle cx="12" cy="12" r="3" /></svg>;
                case "LayoutDashboard": return <svg {...commonProps}><rect width="7" height="9" x="3" y="3" rx="1" /><rect width="7" height="5" x="14" y="3" rx="1" /><rect width="7" height="9" x="14" y="12" rx="1" /><rect width="7" height="5" x="3" y="16" rx="1" /></svg>;
                case "Zap": return <svg {...commonProps}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2" /></svg>;
                case "PawPrint": return <svg {...commonProps}><circle cx="11" cy="4" r="2" /><circle cx="18" cy="8" r="2" /><circle cx="20" cy="15" r="2" /><path d="M5 20s2.05-2 5.04-2c2.99 0 5.16 2 5.16 2" /><circle cx="8" cy="13" r="3" /></svg>;
                case "Search": return <svg {...commonProps}><circle cx="11" cy="11" r="8" /><line x1="21" x2="16.65" y1="21" y2="16.65" /></svg>;
                case "PlusCircle": return <svg {...commonProps}><circle cx="12" cy="12" r="10" /><line x1="12" x2="12" y1="8" y2="16" /><line x1="8" x2="16" y1="12" y2="12" /></svg>;
                case "Watch": return <svg {...commonProps}><circle cx="12" cy="12" r="6" /><polyline points="12 10 12 12 13 13" /><path d="m16.13 7.66-.81-4.05a2 2 0 0 0-2-1.61h-2.68a2 2 0 0 0-2 1.61l-.78 4.05" /><path d="m7.88 16.36.8 4a2 2 0 0 0 2 1.61h2.72a2 2 0 0 0 2-1.61l.81-4.05" /></svg>;
                case "Megaphone": return <svg {...commonProps}><path d="m3 11 18-5v12L3 14v-3z" /><path d="M11.6 16.8a3 3 0 1 1-5.8-1.6" /></svg>;
                case "Whistle": return <svg {...commonProps}><path d="M11 3v8c-1.1 0-2 .9-2 2a3 3 0 0 0 3 3 3 3 0 0 0 3-3V3h-4z" /><path d="M15 9h3a3 3 0 0 1 3 3v2a1 1 0 0 1-1 1h-2" /><path d="M5.8 11.3L2 12l.7-3.8L5.8 11.3z" transform="rotate(-15 4 11)" /></svg>;

                // -- Scheme --
                case "Book": // Using BookOpen logic
                case "BookOpen": return <svg {...commonProps}><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z" /><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z" /></svg>;
                case "LayoutGrid": return <svg {...commonProps}><rect width="7" height="7" x="3" y="3" rx="1" /><rect width="7" height="7" x="14" y="3" rx="1" /><rect width="7" height="7" x="14" y="14" rx="1" /><rect width="7" height="7" x="3" y="14" rx="1" /></svg>; // Used for Formations
                case "Library": return <svg {...commonProps}><path d="m16 6 4 2 4-2" /><path d="M12 13V2.5A2.5 2.5 0 0 0 9.5 0S7 0 7 2.5V13" /><path d="M12 13V2.5A2.5 2.5 0 0 0 9.5 0S7 0 7 2.5V13" /><path d="M7 17v4a2.5 2.5 0 0 0 2.5 2.5C12 23.5 12 21 12 21" /><path d="M12 17v4a2.5 2.5 0 0 0 2.5 2.5C17 23.5 17 21 17 21" /></svg>;

                // -- Footer --
                case "Settings": return <svg {...commonProps}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.72l-.15.1a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.72l.15-.1a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z" /><circle cx="12" cy="12" r="3" /></svg>;
                case "Lock": return <svg {...commonProps}><rect width="18" height="11" x="3" y="11" rx="2" ry="2" /><path d="M7 11V7a5 5 0 0 1 10 0v4" /></svg>;
                case "Unlock": return <svg {...commonProps}><rect width="18" height="11" x="3" y="11" rx="2" ry="2" /><path d="M7 11V7a5 5 0 0 1 10 0v4" /></svg>; // Unlock is technically same icon in Lucide usually or open
                case "Pencil": return <svg {...commonProps}><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z" /><path d="m15 5 4 4" /></svg>;
                case "Trash2": return <svg {...commonProps}><path d="M3 6h18" /><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" /><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" /><line x1="10" x2="10" y1="11" y2="17" /><line x1="14" x2="14" y1="11" y2="17" /></svg>;
                case "HelpCircle": return <svg {...commonProps}><circle cx="12" cy="12" r="10" /><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3" /><line x1="12" x2="12.01" y1="17" y2="17" /></svg>;

                // -- Legacy / Others --
                case "X": return <svg {...commonProps}><path d="M18 6 6 18" /><path d="m6 6 12 12" /></svg>;
                case "ArrowLeft": return <svg {...commonProps}><path d="M19 12H5" /><path d="m12 19-7-7 7-7" /></svg>;
                case "ChevronDown": return <svg {...commonProps}><path d="m6 9 6 6 6-6" /></svg>;
                case "ChevronRight": return <svg {...commonProps}><path d="m9 18 6-6-6-6" /></svg>;
                case "ChevronUp": return <svg {...commonProps}><path d="m18 15-6-6-6 6" /></svg>;
                case "Chevron": // Fallback for shortened name?
                case "ChevronLeft": return <svg {...commonProps}><path d="m15 18-6-6 6-6" /></svg>;
                case "ChevronsRight": return <svg {...commonProps}><path d="m7 7 5 5-5 5" /><path d="m13 7 5 5-5 5" /></svg>;
                case "ChevronsLeft": return <svg {...commonProps}><path d="m11 17-5-5 5-5" /><path d="m18 17-5-5 5-5" /></svg>;

                case "Check": return <svg {...commonProps}><polyline points="20 6 9 17 4 12" /></svg>;
                case "Plus": return <svg {...commonProps}><path d="M5 12h14" /><path d="M12 5v14" /></svg>;
                case "Minus": return <svg {...commonProps}><path d="M5 12h14" /></svg>;

                // -- Missing Icons Added --
                case "Copy": return <svg {...commonProps}><rect x="9" y="9" width="13" height="13" rx="2" ry="2" /><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" /></svg>;
                case "MousePointer": return <svg {...commonProps}><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z" /><path d="M13 13l6 6" /></svg>;
                case "Edit3": return <svg {...commonProps}><path d="M12 20h9" /><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z" /></svg>;
                case "Trash": // Fallthrough to Trash2
                case "Trash2": return <svg {...commonProps}><path d="M3 6h18" /><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" /><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" /><line x1="10" x2="10" y1="11" y2="17" /><line x1="14" x2="14" y1="11" y2="17" /></svg>;
                case "Save": return <svg {...commonProps}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" /><polyline points="17 21 17 13 7 13 7 21" /><polyline points="7 3 7 8 15 8" /></svg>;
                case "RotateCcw": return <svg {...commonProps}><path d="M1 4v6h6" /><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10" /></svg>;
                case "RotateCw": return <svg {...commonProps}><path d="M23 4v6h-6" /><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10" /></svg>;
                case "CheckCircle": return <svg {...commonProps}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" /><polyline points="22 4 12 14.01 9 11.01" /></svg>;
                case "Database": return <svg {...commonProps}><ellipse cx="12" cy="5" rx="9" ry="3" /><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3" /><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5" /></svg>;
                case "Layers": return <svg {...commonProps}><polygon points="12 2 2 7 12 12 22 7 12 2" /><polyline points="2 17 12 22 22 17" /><polyline points="2 12 12 17 22 12" /></svg>;

                // -- Newly Added Icons --
                case "Activity": return <svg {...commonProps}><path d="M22 12h-4l-3 9L9 3l-3 9H2" /></svg>;
                case "Calendar": return <svg {...commonProps}><rect x="3" y="4" width="18" height="18" rx="2" ry="2" /><line x1="16" y1="2" x2="16" y2="6" /><line x1="8" y1="2" x2="8" y2="6" /><line x1="3" y1="10" x2="21" y2="10" /></svg>;
                case "CheckSquare": return <svg {...commonProps}><polyline points="9 11 12 14 22 4" /><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11" /></svg>;
                case "Clipboard": return <svg {...commonProps}><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" /><rect x="8" y="2" width="8" height="4" rx="1" ry="1" /></svg>;
                case "ClipboardCheck": return <svg {...commonProps}><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" /><rect x="8" y="2" width="8" height="4" rx="1" ry="1" /><path d="m9 14 2 2 4-4" /></svg>;
                case "Compass": return <svg {...commonProps}><circle cx="12" cy="12" r="10" /><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76" /></svg>;
                case "Download": return <svg {...commonProps}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="7 10 12 15 17 10" /><line x1="12" x2="12" y1="15" y2="3" /></svg>;
                case "Dumbbell": return <svg {...commonProps}><path d="m6.5 6.5 11 11" /><path d="m21 21-1-1a4.5 4.5 0 0 0-6.364 0l-1.072 1.071a4.5 4.5 0 0 0-6.364 0l-1 .99" /><path d="m3 3 1 1a4.5 4.5 0 0 0 6.364 0l1.071 1.071a4.5 4.5 0 0 0 6.364 0l1.001-.993" /><path d="m11.5 6.5-6.002 5.996" /><path d="m25.5 12.5-6.002 5.996" transform="translate(-8)" /></svg>;
                case "Edit": return <svg {...commonProps}><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" /><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" /></svg>;
                case "Image": return <svg {...commonProps}><rect x="3" y="3" width="18" height="18" rx="2" ry="2" /><circle cx="8.5" cy="8.5" r="1.5" /><polyline points="21 15 16 10 5 21" /></svg>;
                case "Info": return <svg {...commonProps}><circle cx="12" cy="12" r="10" /><line x1="12" x2="12" y1="16" y2="12" /><line x1="12" x2="12.01" y1="8" y2="8" /></svg>;
                case "Link": return <svg {...commonProps}><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" /><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" /></svg>;
                case "List": return <svg {...commonProps}><line x1="8" x2="21" y1="6" y2="6" /><line x1="8" x2="21" y1="12" y2="12" /><line x1="8" x2="21" y1="18" y2="18" /><line x1="3" x2="3.01" y1="6" y2="6" /><line x1="3" x2="3.01" y1="12" y2="12" /><line x1="3" x2="3.01" y1="18" y2="18" /></svg>;
                case "LogOut": return <svg {...commonProps}><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" /><polyline points="16 17 21 12 16 7" /><line x1="21" x2="9" y1="12" y2="12" /></svg>;
                case "Printer": return <svg {...commonProps}><polyline points="6 9 6 2 18 2 18 9" /><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2" /><rect x="6" y="14" width="12" height="8" /></svg>;
                case "Scale": return <svg {...commonProps}><path d="m16 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z" /><path d="m2 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z" /><path d="M7 21h10" /><path d="M12 3v18" /><path d="M3 7h2c2 0 5-1 7-2 2 1 5 2 7 2h2" /></svg>;
                case "Shield": return <svg {...commonProps}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z" /></svg>;
                case "Star": return <svg {...commonProps}><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2" /></svg>;
                case "Swords": return <svg {...commonProps}><polyline points="14.5 17.5 3 6 3 3 6 3 17.5 14.5" /><line x1="13" x2="19" y1="19" y2="13" /><line x1="16" x2="20" y1="16" y2="20" /><line x1="19" x2="21" y1="21" y2="19" /><polyline points="14.5 6.5 18 3 21 3 21 6 17.5 9.5" /><line x1="5" x2="9" y1="14" y2="18" /><line x1="7" x2="4" y1="17" y2="20" /><line x1="3" x2="5" y1="19" y2="21" /></svg>;
                case "Target": return <svg {...commonProps}><circle cx="12" cy="12" r="10" /><circle cx="12" cy="12" r="6" /><circle cx="12" cy="12" r="2" /></svg>;
                case "Trophy": return <svg {...commonProps}><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6" /><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18" /><path d="M4 22h16" /><path d="M9 3v8c0 .248.016.492.046.732.186 1.488 1.134 2.766 2.454 3.518.35.2.7.4 1 1" /><path d="M15 3v8c0 .248-.016.492-.046.732-.186 1.488-1.134 2.766-2.454 3.518-.35.2-.7.4-1 1" /><path d="M12 16v6" /></svg>;
                case "Users": return <svg {...commonProps}><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" /><circle cx="9" cy="7" r="4" /><path d="M22 21v-2a4 4 0 0 0-3-3.87" /><path d="M16 3.13a4 4 0 0 1 0 7.75" /></svg>;

                // -- Additional Missing Icons --
                case "Award": return <svg {...commonProps}><circle cx="12" cy="8" r="7" /><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88" /></svg>;
                case "Clock": return <svg {...commonProps}><circle cx="12" cy="12" r="10" /><polyline points="12 6 12 12 16 14" /></svg>;
                case "HardHat": return <svg {...commonProps}><path d="M2 18a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v2z" /><path d="M10 10V5a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v5" /><path d="M4 15v-3a6 6 0 0 1 6-6h0a6 6 0 0 1 6 6v3" /><path d="M14 10a2 2 0 0 0-2 2v2a2 2 0 0 0 4 0v-2a2 2 0 0 0-2-2z" /></svg>;
                case "Key": return <svg {...commonProps}><circle cx="7.5" cy="15.5" r="5.5" /><path d="m21 2-9.6 9.6" /><path d="m15.5 7.5 3 3L22 7l-3-3" /></svg>;

                // -- Settings & UI Fixes --
                case "Mail": return <svg {...commonProps}><rect width="20" height="16" x="2" y="4" rx="2" /><path d="m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7" /></svg>;
                case "Archive": return <svg {...commonProps}><rect width="20" height="5" x="2" y="3" rx="1" /><path d="M4 8v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8" /><path d="M10 12h4" /></svg>;
                case "Phone": return <svg {...commonProps}><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z" /></svg>;
                case "Edit2": return <svg {...commonProps}><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z" /><path d="m15 5 4 4" /></svg>;
                case "Pencil": return <svg {...commonProps}><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z" /><path d="m15 5 4 4" /></svg>;
                case "Trash2": return <svg {...commonProps}><path d="M3 6h18" /><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" /><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" /><line x1="10" x2="10" y1="11" y2="17" /><line x1="14" x2="14" y1="11" y2="17" /></svg>;
                case "Heart": return <svg {...commonProps}><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z" /></svg>;
                case "Code": return <svg {...commonProps}><polyline points="16 18 22 12 16 6" /><polyline points="8 6 2 12 8 18" /></svg>;
                case "Grid": return <svg {...commonProps}><rect x="3" y="3" width="7" height="7" /><rect x="14" y="3" width="7" height="7" /><rect x="14" y="14" width="7" height="7" /><rect x="3" y="14" width="7" height="7" /></svg>;
                case "Tag": return <svg {...commonProps}><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z" /><line x1="7" y1="7" x2="7.01" y2="7" /></svg>;
                case "Filter": return <svg {...commonProps}><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3" /></svg>;
                case "FilterX": return <svg {...commonProps}><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3" /><line x1="14" x2="20" y1="3" y2="9" /><line x1="20" x2="14" y1="3" y2="9" /></svg>;
                case "XCircle": return <svg {...commonProps}><circle cx="12" cy="12" r="10" /><line x1="15" x2="9" y1="9" y2="15" /><line x1="9" x2="15" y1="9" y2="15" /></svg>;

                case "BarChart2": return <svg {...commonProps}><line x1="18" y1="20" x2="18" y2="10" /><line x1="12" y1="20" x2="12" y2="4" /><line x1="6" y1="20" x2="6" y2="14" /></svg>;

                default:
                    // Fallback to text (Emoji or just text)
                    return <span style={{ fontSize: '0.8rem', marginRight: '0.2rem', display: 'inline-block', width: 'auto', textAlign: 'center', opacity: 0.8, ...style, color: 'red' }}>MISSING: {name}</span>;
            }
        };

        // -------------------------------------------------------------------------
        // GLOBAL HELPER COMPONENTS (Moved out of components to prevent re-mounting)
        // -------------------------------------------------------------------------

        // Install Sortable Column
        const InstallSortableColumn = ({
            items,
            type,
            onListChange,
            onUpdatePlay,
            handleRemoveFromInstall,
            getGamePlanStatus,
            getScriptCount,
            handleTogglePriority,
            handleToggleNewPlay,
            newInstallIds = [],
            onOpenAssignmentModal,
            onDuplicatePlay,
            playBuckets = []
        }) => {

            // Group items by bucket
            const groupItems = (rawItems) => {
                const groups = { unassigned: [], buckets: {} };
                rawItems.forEach(item => {
                    if (item.bucketId && playBuckets.some(b => b.id === item.bucketId)) {
                        if (!groups.buckets[item.bucketId]) groups.buckets[item.bucketId] = [];
                        groups.buckets[item.bucketId].push(item);
                    } else {
                        groups.unassigned.push(item);
                    }
                });
                return groups;
            };

            const [groupedItems, setGroupedItems] = React.useState(groupItems(items));

            // Flatten groups back to array
            const flattenGroups = (groups) => {
                const sortedBucketIds = Object.keys(groups.buckets).sort((a, b) => {
                    const nameA = playBuckets.find(xb => xb.id === a)?.label || '';
                    const nameB = playBuckets.find(xb => xb.id === b)?.label || '';
                    return nameA.localeCompare(nameB);
                });
                let list = [...groups.unassigned];
                sortedBucketIds.forEach(bid => {
                    list = list.concat(groups.buckets[bid]);
                });
                return list;
            };

            // Sync with external changes
            const itemsSignature = items.map(p => `${p.id}-${p.priority}-${p.wristbandSlot}-${p.bucketId || ''}`).join(',');
            React.useEffect(() => {
                const flatLocal = flattenGroups(groupedItems);
                const localSignature = flatLocal.map(p => `${p.id}-${p.priority}-${p.wristbandSlot}-${p.bucketId || ''}`).join(',');
                if (itemsSignature !== localSignature) {
                    setGroupedItems(groupItems(items));
                }
            }, [itemsSignature]);

            const handleSetList = (newList, bucketId) => {
                setGroupedItems(prev => {
                    const oldList = bucketId ? (prev.buckets[bucketId] || []) : prev.unassigned;
                    const addedItem = newList.find(p => !oldList.some(old => old.id === p.id));

                    if (addedItem) {
                        const targetBucketId = bucketId || null;
                        if (addedItem.bucketId !== targetBucketId) {
                            onUpdatePlay(addedItem.id, { bucketId: targetBucketId });
                            addedItem.bucketId = targetBucketId;
                        }
                    }

                    const newGroups = { ...prev, buckets: { ...prev.buckets } };
                    if (bucketId) {
                        newGroups.buckets[bucketId] = newList;
                    } else {
                        newGroups.unassigned = newList;
                    }

                    const flat = flattenGroups(newGroups);
                    onListChange(flat);

                    return newGroups;
                });
            };

            const sortedBucketIds = Object.keys(groupedItems.buckets).sort((a, b) => {
                const nameA = playBuckets.find(xb => xb.id === a)?.label || '';
                const nameB = playBuckets.find(xb => xb.id === b)?.label || '';
                return nameA.localeCompare(nameB);
            });

            const ReactSortable = window.ReactSortable;

            // Use ref to track click timer for distinguishing single vs double click
            const clickTimerRef = React.useRef(null);

            const handleCardClick = (play, e) => {
                e.stopPropagation();

                // Clear any existing timer
                if (clickTimerRef.current) {
                    clearTimeout(clickTimerRef.current);
                    clickTimerRef.current = null;
                    return; // This is a double-click, do nothing (double-click handler will fire)
                }

                // Set a timer for single click
                clickTimerRef.current = setTimeout(() => {
                    clickTimerRef.current = null;
                    // Toggle priority
                    onUpdatePlay(play.id, { priority: !play.priority });
                }, 250);
            };

            const renderPlayCard = (play) => (
                <div
                    key={play.id}
                    className="card"
                    style={{
                        padding: '0.4rem',
                        marginBottom: '0.35rem',
                        borderLeft: `4px solid ${type === 'Run' ? '#10b981' : '#3b82f6'}`,
                        cursor: 'pointer',
                        background: 'white',
                        color: '#0f172a',
                        userSelect: 'none',
                        position: 'relative'
                    }}
                    onClick={(e) => handleCardClick(play, e)}
                    onDoubleClick={(e) => {
                        if (onOpenAssignmentModal) {
                            e.stopPropagation();
                            onOpenAssignmentModal(play.id, e.clientX, e.clientY);
                        }
                    }}
                >
                    <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'start' }}>
                        <div style={{ flex: 1, minWidth: 0 }}>
                            <div style={{ fontWeight: '600', fontSize: '0.85rem', display: 'flex', alignItems: 'center', gap: '4px', flexWrap: 'wrap' }}>
                                {play.priority && (
                                    <Icon name="Star" size={12} style={{ fill: '#eab308', color: '#eab308', flexShrink: 0 }} />
                                )}
                                <span style={{ overflow: 'hidden', textOverflow: 'ellipsis' }}>{getPlayDisplayName(play)}</span>
                                {play.wristbandSlot && (
                                    <span style={{
                                        background: '#eff6ff',
                                        color: '#1d4ed8',
                                        padding: '1px 5px',
                                        borderRadius: '3px',
                                        fontSize: '0.7rem',
                                        fontWeight: '600',
                                        flexShrink: 0
                                    }}>
                                        #{play.wristbandSlot}
                                    </span>
                                )}
                            </div>
                        </div>
                    </div>

                    <button
                        className="btn-ghost remove-btn"
                        onClick={(e) => { e.stopPropagation(); handleRemoveFromInstall(play.id); }}
                        style={{
                            position: 'absolute',
                            top: '2px',
                            right: '2px',
                            padding: '2px',
                            color: '#ef4444',
                            opacity: 0.3,
                            transition: 'opacity 0.2s',
                            background: 'white',
                            borderRadius: '3px'
                        }}
                        onMouseEnter={(e) => e.currentTarget.style.opacity = '1'}
                        onMouseLeave={(e) => e.currentTarget.style.opacity = '0.3'}
                        title="Remove from install"
                    >
                        <Icon name="X" size={12} />
                    </button>
                </div>
            );

            return (
                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                    {/* Unassigned Section */}
                    <ReactSortable
                        list={groupedItems.unassigned}
                        setList={(l) => handleSetList(l, null)}
                        group="installColumns"
                        animation={150}
                        style={{ minHeight: '50px' }}
                    >
                        {groupedItems.unassigned.map(play => renderPlayCard(play))}
                    </ReactSortable>

                    {/* Buckets */}
                    {sortedBucketIds.map(bucketId => {
                        const bucket = playBuckets.find(b => b.id === bucketId);
                        return (
                            <div key={bucketId} style={{ marginTop: '0.5rem' }}>
                                <div style={{
                                    fontSize: '0.75rem', fontWeight: 'bold', color: '#475569',
                                    marginBottom: '0.25rem', padding: '0.25rem 0.5rem',
                                    background: '#f1f5f9', borderRadius: '4px',
                                    display: 'flex', justifyContent: 'space-between'
                                }}>
                                    <span>{bucket ? bucket.label : 'Unknown Bucket'}</span>
                                    <span style={{ opacity: 0.5 }}>{groupedItems.buckets[bucketId].length}</span>
                                </div>
                                <ReactSortable
                                    list={groupedItems.buckets[bucketId]}
                                    setList={(l) => handleSetList(l, bucketId)}
                                    group="installColumns"
                                    animation={150}
                                    style={{ minHeight: '40px' }}
                                >
                                    {groupedItems.buckets[bucketId].map(play => renderPlayCard(play))}
                                </ReactSortable>
                            </div>
                        );
                    })}
                </div>
            );
        };

        // Priority Sortable Column
        const PrioritySortableColumn = ({ items, onListChange, className, style, emptyText, isLocked, onItemDoubleClick }) => {
            const [localItems, setLocalItems] = React.useState(items);

            // Stable Sync
            const itemsIds = items.map(p => p.id).join(',');
            React.useEffect(() => {
                const localIds = localItems.map(p => p.id).join(',');
                if (itemsIds !== localIds) {
                    setLocalItems(items);
                }
            }, [itemsIds]);

            return (
                <ReactSortable
                    list={localItems}
                    setList={(newList) => {
                        setLocalItems(newList);
                        onListChange(newList);
                    }}
                    group="priorityGroup"
                    animation={150}
                    style={style}
                    className={className}
                    disabled={isLocked}
                >
                    {localItems.map(play => (
                        <div
                            key={play.id}
                            style={{ padding: '0.4rem', background: 'white', color: '#1f2937', border: '1px solid var(--border)', borderRadius: '4px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', cursor: isLocked ? 'default' : 'grab', marginBottom: '4px', userSelect: 'none' }}
                            onDoubleClick={(e) => {
                                if (isLocked) return;
                                e.stopPropagation();
                                if (onItemDoubleClick) onItemDoubleClick(play, e);
                            }}
                        >
                            <div style={{ overflow: 'hidden' }}>
                                <div style={{ fontWeight: 'bold', fontSize: '0.9rem', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>{getPlayDisplayName(play)}</div>
                            </div>
                            {!isLocked && (
                                <button
                                    onClick={(e) => {
                                        e.stopPropagation();
                                    }}
                                    style={{ color: '#ef4444', padding: '2px', marginLeft: '4px', visibility: 'hidden' }}
                                    className="btn-ghost"
                                >
                                    <Icon name="X" size={14} />
                                </button>
                            )}
                        </div>
                    ))}
                </ReactSortable>
            );
        };

        const OPS_CALENDAR = [
            "November", "December", "January", "February", "March", "April", "May",
            "Week 1 of Summer", "Week 2 of Summer", "Week 3 of Summer", "Week 4 of Summer",
            "Week 5 of Summer", "Week 6 of Summer", "Week 7 of Summer", "Week 8 of Summer",
            "Family Week", "Camp Week", "First Week of Practice",
            "Week 0", "Week 1", "Week 2", "Week 3", "Week 4", "Week 5",
            "Week 6", "Week 7", "Week 8", "Week 9", "Week 10", "Week 11",
            "Week 12", "Week 13", "First Week with No Game"
        ];

        const DirectorOpsView = ({ dutyAssignments, staff, currentWeek, currentUser }) => {
            // State for the selected period
            const [selectedPeriod, setSelectedPeriod] = useState(() => {
                // Initialize with active week if available, otherwise default
                return currentWeek?.name || "Week 1";
            });

            // Sync with global Active Week changes
            useEffect(() => {
                if (currentWeek?.name) {
                    setSelectedPeriod(currentWeek.name);
                }
            }, [currentWeek?.name]);

            // Is this period a "Standard Game Week" that should arguably have the template?
            // "Week 0" through "Week 13", "First Week of Practice" likely benefit from the standard template.
            const isStandardWeek = (period) => {
                return period.startsWith("Week") && !period.includes("Summer") || period === "First Week of Practice" || period === "Camp Week";
            };

            // Is this a Monthly period? (Nov-May)
            const isMonthly = (period) => {
                return ["November", "December", "January", "February", "March", "April", "May"].includes(period);
            };

            // Local state for tasks tailored for this session. 
            // We now load tasks *dependent* on the selectedPeriod.
            // We need a mechanism to switch tasks when period changes, without losing state.
            // Best way: Load ALL director ops data as a big object { "Week 1": [...], "November": [...] }
            // Or just load/save the specific key on change. Loading specific key is safer for memory if data grows.

            const [tasks, setTasks] = useState([]);

            // Load tasks when selectedPeriod changes
            useEffect(() => {
                const storageKey = `director_ops_tasks_${selectedPeriod}`;
                const saved = localStorage.getItem(storageKey);

                if (saved) {
                    setTasks(JSON.parse(saved));
                } else {
                    // Initialize New Period
                    if (isStandardWeek(selectedPeriod)) {
                        setTasks(WEEKLY_OPS_TASKS); // Preload Standard Template
                    } else {
                        setTasks([]); // Start Empty for custom periods (Monthly, Summer)
                    }
                }
            }, [selectedPeriod]);

            // Filter by Staff ID / Current User Roles
            // In Person-Centric view, we show tasks assigned to ANY of the user's roles.

            const [isAddingTask, setIsAddingTask] = useState(false);
            // Default day depends on view type. Monthly? No day usually, or just "General".
            const [newTask, setNewTask] = useState({ task: '', day: 'Monday', roles: [] });

            // Persist to localStorage whenever tasks change
            // We use a ref to track if the *initial load* has happened, to avoid overwriting with empty array on first render mount cycle if useEffects race.
            // Actually, useEffect dependency on [tasks] usually fires after hydration. 
            // We need to be careful not to save '[]' over existing data if the `setTasks` from the read-effect hasn't fired.
            // A safer pattern is: read in one effect, save in another, but ensure we don't save *until* we've read.
            // Simplified: The read effect is above.
            // The write effect:
            const isFirstRun = useRef(true);
            const loadedPeriod = useRef(null);

            useEffect(() => {
                if (loadedPeriod.current === selectedPeriod) {
                    const storageKey = `director_ops_tasks_${selectedPeriod}`;
                    localStorage.setItem(storageKey, JSON.stringify(tasks));
                }
            }, [tasks, selectedPeriod]);

            // Sync ref when period changes to indicate we are loading
            useEffect(() => {
                loadedPeriod.current = null; // Reset
                const storageKey = `director_ops_tasks_${selectedPeriod}`;
                const saved = localStorage.getItem(storageKey);
                if (saved) {
                    setTasks(JSON.parse(saved));
                } else {
                    if (isStandardWeek(selectedPeriod)) {
                        setTasks(WEEKLY_OPS_TASKS);
                    } else {
                        setTasks([]);
                    }
                }
                loadedPeriod.current = selectedPeriod; // Mark as loaded
            }, [selectedPeriod]);


            const toggleTask = (id) => {
                setTasks(prev => prev.map(t => t.id === id ? { ...t, completed: !t.completed } : t));
            };

            const resetTasks = () => {
                if (confirm(`Reset all tasks for ${selectedPeriod}?`)) {
                    if (isStandardWeek(selectedPeriod)) {
                        setTasks(WEEKLY_OPS_TASKS);
                    } else {
                        setTasks([]);
                    }
                }
            };

            // Sync function to merge recurring role tasks into current week
            const syncRoleTasks = () => {
                const savedRoleTasks = localStorage.getItem('staff_role_tasks');
                if (!savedRoleTasks) return;

                const roleTasksMap = JSON.parse(savedRoleTasks);
                if (!roleTasksMap) return;

                // Flatten all tasks from roles map
                const newRoleTasks = [];
                Object.values(roleTasksMap).forEach(roleList => {
                    if (Array.isArray(roleList)) {
                        newRoleTasks.push(...roleList);
                    }
                });

                if (newRoleTasks.length === 0) {
                    alert('No recurring role tasks found to sync.');
                    return;
                }

                // Merge logic: Check if task string already exists for that day?
                // Or just append. Appending with unique ID is safest but could double up.
                // Let's filter duplicates by task name + day
                const currentTaskSignatures = new Set(tasks.map(t => `${t.day}|${t.task}`));

                const tasksToAdd = newRoleTasks.filter(rt => !currentTaskSignatures.has(`${rt.day}|${rt.task}`)).map(rt => ({
                    ...rt,
                    id: `synced_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
                    completed: false
                }));

                if (tasksToAdd.length > 0) {
                    setTasks(prev => [...prev, ...tasksToAdd]);
                    alert(`Synced ${tasksToAdd.length} tasks from Role descriptions.`);
                } else {
                    alert('All role tasks are already present.');
                }
            };

            const handleAddTask = () => {
                if (!newTask.task.trim()) return;
                const taskToAdd = {
                    id: `custom_${Date.now()}`,
                    ...newTask,
                    completed: false,
                    roles: newTask.roles.length > 0 ? newTask.roles : ['ALL']
                };
                setTasks(prev => [...prev, taskToAdd]);
                setIsAddingTask(false);
                setNewTask({ task: '', day: isMonthly(selectedPeriod) ? 'General' : 'Monday', roles: [] });
            };

            const handleDeleteTask = (id) => {
                if (confirm('Delete this task?')) {
                    setTasks(tasks.filter(t => t.id !== id));
                }
            };

            const toggleNewTaskRole = (role) => {
                setNewTask(prev => {
                    const currentRoles = prev.roles;
                    if (currentRoles.includes(role)) {
                        return { ...prev, roles: currentRoles.filter(r => r !== role) };
                    } else {
                        return { ...prev, roles: [...currentRoles, role] };
                    }
                });
            };

            const handleImportDuties = () => {
                if (!dutyAssignments || Object.keys(dutyAssignments).length === 0) {
                    alert('No duty assignments found to import.');
                    return;
                }

                if (!confirm('Import assigned duties from Task Assigner? This will add them to your checklist.')) return;

                const newTasks = [];
                Object.entries(dutyAssignments).forEach(([key, coachIds]) => {
                    if (!coachIds || coachIds.length === 0) return;

                    const parts = key.split(' > ');
                    const dutyName = parts[parts.length - 1];
                    const category = parts[0];

                    let day = 'Monday';
                    if (isMonthly(selectedPeriod)) day = 'General';
                    else {
                        if (category === 'Practice') day = 'Monday';
                        if (category === 'Games') day = 'Friday';
                        if (category === 'Scouting') day = 'Sunday';
                        if (category === 'Medical') day = 'Wednesday';
                        if (category === 'Special Teams') day = 'Thursday';
                    }

                    const assignedRoles = [];
                    coachIds.forEach(id => {
                        const coach = staff.find(s => s.id === id);
                        if (coach) assignedRoles.push(coach.name);
                    });

                    // Avoid simple duplicates
                    const isDuplicate = tasks.some(t => t.task === `Duty: ${dutyName}` && t.day === day);
                    if (!isDuplicate) {
                        newTasks.push({
                            id: `duty_${Date.now()}_${Math.floor(Math.random() * 1000)}`,
                            day: day,
                            task: `Duty: ${dutyName}`,
                            roles: assignedRoles.length > 0 ? assignedRoles : ['Unassigned'],
                            completed: false
                        });
                    }
                });

                if (newTasks.length > 0) {
                    setTasks(prev => [...prev, ...newTasks]);
                    alert(`Imported ${newTasks.length} duties as tasks.`);
                } else {
                    alert('No new duties to import.');
                }
            };

            // Filter tasks based on Current User's Roles
            // Show task if 'ALL' is in task.roles OR any of currentUser.roles is in task.roles
            const displayTasks = tasks.filter(t => {
                if (!t.roles || t.roles.length === 0) return true; // Show unassigned
                if (t.roles.includes('ALL')) return true;

                // Check intersection
                const userRoles = currentUser?.roles || [];
                return t.roles.some(r => userRoles.includes(r));
            });



            // Grouping Logic
            let groupedTasks = {};

            if (isMonthly(selectedPeriod)) {
                // Monthly View: Just one list, or maybe grouped by "Week" if we added that field? 
                // For now, user asked for "Monthly Checklists", implying a simple list is fine.
                // We'll treat "General" as the main bucket, but handle if any stray days exist.
                groupedTasks["Monthly Tasks"] = displayTasks;
            } else {
                // Weekly View
                const orderedDays = ['Saturday', 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
                // We also need to catch tasks that might have been assigned to other days (or "General") if manual entry allowed it
                // But for now, let's just use the ordered days + an "Other" catch-all if needed
                groupedTasks = orderedDays.reduce((acc, day) => {
                    const dayTasks = displayTasks.filter(t => t.day === day);
                    if (dayTasks.length > 0) acc[day] = dayTasks;
                    return acc;
                }, {});

                // Catch-all for "General" or mis-assigned days in weekly view
                const otherTasks = displayTasks.filter(t => !orderedDays.includes(t.day));
                if (otherTasks.length > 0) groupedTasks["General"] = otherTasks;
            }


            const progress = tasks.length > 0 ? Math.round((tasks.filter(t => t.completed).length / tasks.length) * 100) : 0;

            return (
                <div className="animate-fade-in" style={{ padding: '1rem', maxWidth: '800px', margin: '0 auto' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                        <div>
                            <h1>Director of Football Operations</h1>
                            <div style={{ color: 'var(--text-secondary)' }}>Weekly Task Checklist</div>
                        </div>

                        <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                            <select
                                className="form-select"
                                value={selectedPeriod}
                                onChange={e => setSelectedPeriod(e.target.value)}
                                style={{ width: 'auto', minWidth: '200px', fontWeight: 'bold' }}
                            >
                                {OPS_CALENDAR.map(p => <option key={p} value={p}>{p}</option>)}
                            </select>
                        </div>
                    </div>

                    <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '0.5rem', marginBottom: '2rem', alignItems: 'center' }}>
                        <span style={{ fontSize: '0.9rem', color: 'var(--text-secondary)', marginRight: '0.5rem' }}>View:</span>
                        <select
                            className="form-select"
                            value={selectedRole}
                            onChange={e => setSelectedRole(e.target.value)}
                            style={{ width: 'auto', minWidth: '120px', fontSize: '0.85rem' }}
                        >
                            {ROLES.map(r => <option key={r} value={r}>{r === 'ALL' ? 'All Roles' : r}</option>)}
                        </select>
                        <button className="btn btn-primary" onClick={() => setIsAddingTask(true)} title="Add Custom Task">
                            <Icon name="PlusCircle" />
                        </button>
                        <button className="btn btn-secondary" onClick={syncRoleTasks} title="Sync Recurring Role Tasks">
                            <Icon name="Activity" /> Sync
                        </button>
                        <button className="btn btn-secondary" onClick={handleImportDuties} title="Import from Task Assigner">
                            <Icon name="List" /> Import
                        </button>
                        <button className="btn btn-secondary" onClick={resetTasks} title="Reset Tasks">
                            🔄
                        </button>
                    </div>

                    {/* Add Task Modal */}
                    {isAddingTask && (
                        <div style={{
                            position: 'fixed', top: 0, left: 0, width: '100%', height: '100%',
                            backgroundColor: 'rgba(0,0,0,0.5)', zIndex: 1000,
                            display: 'flex', alignItems: 'center', justifyContent: 'center'
                        }}>
                            <div style={{
                                backgroundColor: 'var(--bg-panel)', padding: '2rem', borderRadius: '12px',
                                border: '1px solid var(--border)', width: '90%', maxWidth: '500px'
                            }}>
                                <h3 style={{ marginBottom: '1.5rem' }}>Add New Task ({selectedPeriod})</h3>

                                <div style={{ marginBottom: '1rem' }}>
                                    <label style={{ display: 'block', marginBottom: '0.5rem', fontSize: '0.9rem' }}>Task Description</label>
                                    <input
                                        className="form-input"
                                        value={newTask.task}
                                        onChange={e => setNewTask({ ...newTask, task: e.target.value })}
                                        placeholder="Enter task details..."
                                    />
                                </div>

                                {/* Only show Day selector if not in Monthly mode (or stick to generic 'General') */}
                                {!isMonthly(selectedPeriod) && (
                                    <div style={{ marginBottom: '1rem' }}>
                                        <label style={{ display: 'block', marginBottom: '0.5rem', fontSize: '0.9rem' }}>Day</label>
                                        <select
                                            className="form-select"
                                            value={newTask.day}
                                            onChange={e => setNewTask({ ...newTask, day: e.target.value })}
                                        >
                                            {orderedDays.map(d => <option key={d} value={d}>{d}</option>)}
                                            <option value="General">General</option>
                                        </select>
                                    </div>
                                )}

                                <div style={{ marginBottom: '1.5rem' }}>
                                    <label style={{ display: 'block', marginBottom: '0.5rem', fontSize: '0.9rem' }}>Assign Roles (Optional)</label>
                                    <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                                        {ROLES.filter(r => r !== 'ALL').map(role => (
                                            <div
                                                key={role}
                                                onClick={() => toggleNewTaskRole(role)}
                                                style={{
                                                    padding: '0.25rem 0.5rem',
                                                    borderRadius: '4px',
                                                    border: `1px solid ${newTask.roles.includes(role) ? 'var(--accent)' : 'var(--border)'}`,
                                                    backgroundColor: newTask.roles.includes(role) ? 'rgba(56, 189, 248, 0.1)' : 'transparent',
                                                    cursor: 'pointer',
                                                    fontSize: '0.8rem',
                                                    color: newTask.roles.includes(role) ? 'var(--accent)' : 'var(--text-secondary)'
                                                }}
                                            >
                                                {role}
                                            </div>
                                        ))}
                                    </div>
                                </div>

                                <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '1rem' }}>
                                    <button className="btn btn-secondary" onClick={() => setIsAddingTask(false)}>Cancel</button>
                                    <button className="btn btn-primary" onClick={handleAddTask}>Save Task</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Progress Bar */}
                    <div style={{ marginBottom: '2rem', backgroundColor: 'var(--bg-input)', borderRadius: '999px', height: '10px', overflow: 'hidden' }}>
                        <div style={{ width: `${progress}%`, backgroundColor: 'var(--accent)', height: '100%', transition: 'width 0.5s ease' }} />
                    </div>
                    <div style={{ textAlign: 'right', marginBottom: '2rem', fontSize: '0.9rem', color: 'var(--accent)' }}>
                        {progress}% Completed
                    </div>

                    {Object.entries(groupedTasks).map(([groupName, groupTasks]) => (
                        <div key={groupName} style={{ marginBottom: '2rem', backgroundColor: 'var(--bg-panel)', borderRadius: '12px', padding: '1.5rem', border: '1px solid var(--border)' }}>
                            <h3 style={{ marginBottom: '1rem', borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem', color: 'var(--text-primary)' }}>{groupName}</h3>
                            <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                                {groupTasks.map(task => (
                                    <div
                                        key={task.id}
                                        onClick={() => toggleTask(task.id)}
                                        style={{
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '1rem',
                                            padding: '0.75rem',
                                            backgroundColor: 'var(--bg-app)',
                                            borderRadius: '8px',
                                            cursor: 'pointer',
                                            border: '1px solid transparent',
                                            transition: 'all 0.2s',
                                            opacity: task.completed ? 0.6 : 1
                                        }}
                                        onMouseEnter={e => e.currentTarget.style.borderColor = 'var(--accent)'}
                                        onMouseLeave={e => e.currentTarget.style.borderColor = 'transparent'}
                                    >
                                        <div style={{
                                            width: '24px',
                                            height: '24px',
                                            borderRadius: '6px',
                                            border: `2px solid ${task.completed ? 'var(--accent)' : 'var(--text-secondary)'}`,
                                            backgroundColor: task.completed ? 'var(--accent)' : 'transparent',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            color: '#0f172a'
                                        }}>
                                            {task.completed && <Icon name="Check" size={16} />}
                                        </div>
                                        <div style={{ flex: 1 }}>
                                            <div style={{
                                                textDecoration: task.completed ? 'line-through' : 'none',
                                                color: task.completed ? 'var(--text-secondary)' : 'var(--text-primary)',
                                                fontWeight: task.completed ? 'normal' : '500'
                                            }}>
                                                {task.task}
                                            </div>
                                            {/* Role Tags */}
                                            {selectedRole === 'ALL' && task.roles && (
                                                <div style={{ display: 'flex', gap: '0.25rem', flexWrap: 'wrap', marginTop: '0.25rem' }}>
                                                    {task.roles.map(role => (
                                                        <span key={role} style={{
                                                            fontSize: '0.7rem',
                                                            padding: '0.1rem 0.4rem',
                                                            borderRadius: '4px',
                                                            backgroundColor: 'rgba(255,255,255,0.1)',
                                                            color: 'var(--text-secondary)'
                                                        }}>
                                                            {role}
                                                        </span>
                                                    ))}
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    ))}

                    {/* BILLING TAB */}
                    {activeTab === 'billing' && (
                        <div className="animation-fade-in card">
                            <h3>Billing & Plans</h3>

                            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '2rem', marginTop: '1rem' }}>
                                <div style={{ background: 'var(--bg-body)', padding: '1.5rem', borderRadius: '8px', border: '1px solid var(--border)' }}>
                                    <h4 style={{ margin: '0 0 1rem 0', color: 'var(--text-secondary)' }}>Current Plan</h4>
                                    <div style={{ fontSize: '2rem', fontWeight: 'bold', color: currentPlanStatus.includes('PREMIUM') || currentPlanStatus === 'ALL_ACCESS' ? '#22c55e' : 'var(--text-primary)' }}>
                                        {currentPlanStatus.replace('_', ' ')}
                                    </div>
                                    <div style={{ marginTop: '0.5rem', opacity: 0.8 }}>
                                        {currentPlanStatus === 'PREMIUM_TRIAL' && billingInfo.trialEndsAt && `Trial Ends: ${new Date(billingInfo.trialEndsAt).toLocaleDateString()}`}
                                        {currentPlanStatus === 'PREMIUM' && billingInfo.subscriptionEndsAt && `Expires: ${new Date(billingInfo.subscriptionEndsAt).toLocaleDateString()}`}
                                        {currentPlanStatus === 'FREE' && "Limited Features Active"}
                                    </div>
                                </div>

                                <div style={{ background: 'var(--bg-body)', padding: '1.5rem', borderRadius: '8px', border: '1px solid var(--border)' }}>
                                    <h4 style={{ margin: '0 0 1rem 0', color: 'var(--text-secondary)' }}>Redeem Promo Code</h4>
                                    <div style={{ display: 'flex', gap: '0.5rem' }}>
                                        <input
                                            type="text"
                                            className="form-input"
                                            placeholder="Enter Code"
                                            value={promoCode}
                                            onChange={e => setPromoCode(e.target.value)}
                                        />
                                        <button className="btn btn-primary" disabled={redeeming || !promoCode} onClick={handleRedeemPromo}>
                                            {redeeming ? 'Applying...' : 'Redeem'}
                                        </button>
                                    </div>
                                    <p style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginTop: '0.5rem' }}>
                                        Enter a code provided by support to extend your premium access.
                                    </p>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const TagSelector = ({ selectedTags, onToggle }) => {
            return (
                <div className="space-y-4">
                    {Object.entries(TAG_CATEGORIES).map(([category, tags]) => (
                        <div key={category} className="tags-section">
                            <div className="tags-category-title">{category}</div>
                            <div className="tags-grid">
                                {(tags || []).map(tag => (
                                    <div
                                        key={tag}
                                        className={`tag-chip ${selectedTags.includes(tag) ? 'selected' : ''}`}
                                        onClick={() => onToggle(tag)}
                                    >
                                        {tag}
                                    </div>
                                ))}
                            </div>
                        </div>
                    ))}
                </div>
            );
        };

        // Helper to generate Zigzag Path
        const getZigZagPath = (points) => {
            if (points.length < 2) return '';
            let d = `M ${points[0].x},${points[0].y}`;
            for (let i = 0; i < points.length - 1; i++) {
                const A = points[i];
                const B = points[i + 1];
                const isLastSegment = i === points.length - 2;

                let targetB = B;
                let finalSegment = '';

                // If it's the last segment, leave a straight tail for the arrowhead
                if (isLastSegment) {
                    const totalDist = Math.hypot(B.x - A.x, B.y - A.y);
                    const arrowSpace = 5; // Reduced from 20 to 5 to hide transition inside arrow
                    if (totalDist > arrowSpace) {
                        const ratio = (totalDist - arrowSpace) / totalDist;
                        targetB = {
                            x: A.x + (B.x - A.x) * ratio,
                            y: A.y + (B.y - A.y) * ratio
                        };
                        finalSegment = ` L ${B.x},${B.y}`;
                    }
                }

                const dist = Math.hypot(targetB.x - A.x, targetB.y - A.y);
                const steps = Math.floor(dist / 10); // 10px zigzags

                if (steps <= 0) {
                    d += ` L ${targetB.x},${targetB.y}`;
                } else {
                    const dx = (targetB.x - A.x) / steps;
                    const dy = (targetB.y - A.y) / steps;
                    const nx = -dy * 0.5; // Width of zig
                    const ny = dx * 0.5;
                    for (let j = 1; j <= steps; j++) {
                        const mx = A.x + dx * j;
                        const my = A.y + dy * j;
                        if (j === steps) {
                            d += ` L ${mx},${my}`;
                        } else {
                            const side = j % 2 === 0 ? 1 : -1;
                            d += ` L ${mx + nx * side},${my + ny * side}`;
                        }
                    }
                }

                if (finalSegment) {
                    d += finalSegment;
                }
            }
            return d;
        };

        // --- PLAY DIAGRAM EDITOR ---
        const PlayDiagramEditor = ({ initialData, onSave, onCancel, mode = 'standard', formations = [], onAddFormation = () => { }, wizLibrary = [], setWizLibrary = () => { }, positionNames = {}, readOnly = false }) => {

            // Helper for default formation (Red QB, Blue Skill, Black OL)
            const getDefaultFormation = () => {
                const center = 400;
                const los = 340; // Shifted UP (was 400) to give ~8 yards depth (160px space below)

                const cOL = '#000000';
                const cQB = '#ef4444';
                const cSkill = '#3b82f6';

                // Y-Offsets: 100px = 5 yards.
                // OL radius=15. Place at +18 to clear line.
                // QB Shotgun at 5 yds = +100px.

                if (mode === 'wiz-oline') {
                    // O-Line Wiz Default (T-G-C-G-T) - Large Text, Arched
                    // Los is 340. C at LOS. G at +15, T at +30.
                    const initialSize = 170;
                    return [
                        { id: Date.now() + 1, type: 'player', points: [{ x: center, y: los }], color: cOL, label: 'C', shape: 'text-only', variant: 'filled', fontSize: initialSize },
                        { id: Date.now() + 2, type: 'player', points: [{ x: center - 170, y: los + 15 }], color: cOL, label: 'G', shape: 'text-only', variant: 'filled', fontSize: initialSize },
                        { id: Date.now() + 3, type: 'player', points: [{ x: center + 170, y: los + 15 }], color: cOL, label: 'G', shape: 'text-only', variant: 'filled', fontSize: initialSize },
                        { id: Date.now() + 4, type: 'player', points: [{ x: center - 340, y: los + 30 }], color: cOL, label: 'T', shape: 'text-only', variant: 'filled', fontSize: initialSize },
                        { id: Date.now() + 5, type: 'player', points: [{ x: center + 340, y: los + 30 }], color: cOL, label: 'T', shape: 'text-only', variant: 'filled', fontSize: initialSize },
                    ];
                }

                if (mode === 'wiz-skill') {
                    // Skill Wiz Default (11 Players)
                    // OL is smaller text to match skill player icon size (~24px)
                    // "Behind the LOS" -> Push Y down.
                    // WIZ Card visible area: y=60 to y=520 (460px)
                    // Position LOS at y=400 to allow ~340px above for routes (~17 yards) and ~120px below for backfield (~6 yards)
                    const wizLos = 400;
                    const initialSize = 24; // Reduced from 40 to match skill player circles
                    const spacing = 40;
                    const olY = wizLos + 20; // Push down 20px (stays within y=520)

                    return [
                        // OL
                        { id: Date.now() + 1, type: 'player', points: [{ x: center, y: olY }], color: cOL, label: 'C', shape: 'text-only', variant: 'filled', fontSize: initialSize },
                        { id: Date.now() + 2, type: 'player', points: [{ x: center - spacing, y: olY }], color: cOL, label: 'G', shape: 'text-only', variant: 'filled', fontSize: initialSize },
                        { id: Date.now() + 3, type: 'player', points: [{ x: center + spacing, y: olY }], color: cOL, label: 'G', shape: 'text-only', variant: 'filled', fontSize: initialSize },
                        { id: Date.now() + 4, type: 'player', points: [{ x: center - (spacing * 2), y: olY }], color: cOL, label: 'T', shape: 'text-only', variant: 'filled', fontSize: initialSize },
                        { id: Date.now() + 5, type: 'player', points: [{ x: center + (spacing * 2), y: olY }], color: cOL, label: 'T', shape: 'text-only', variant: 'filled', fontSize: initialSize },
                        // Skill Players (Custom Colors, Filled)
                        // QB at shotgun depth (60px behind LOS, stays within visible area)
                        { id: Date.now() + 6, type: 'player', points: [{ x: center, y: wizLos + 60 }], color: cQB, label: positionNames['QB'] || 'Q', shape: 'circle', variant: 'filled' },
                        // RB closer to QB (at y=460, within visible bounds)
                        { id: Date.now() + 7, type: 'player', points: [{ x: center - 60, y: wizLos + 60 }], color: '#3b82f6', label: positionNames['RB'] || 'B', shape: 'circle', variant: 'filled' }, // Blue
                        { id: Date.now() + 8, type: 'player', points: [{ x: 100, y: wizLos + 10 }], color: '#a855f7', label: positionNames['X'] || 'X', shape: 'circle', variant: 'filled' }, // Purple
                        { id: Date.now() + 9, type: 'player', points: [{ x: 700, y: wizLos + 10 }], color: '#22c55e', label: positionNames['Z'] || 'Z', shape: 'circle', variant: 'filled' }, // Green
                        { id: Date.now() + 10, type: 'player', points: [{ x: 200, y: wizLos + 25 }], color: '#ef4444', label: positionNames['A'] || 'A', shape: 'circle', variant: 'filled' }, // Red (A/Slot)
                        { id: Date.now() + 11, type: 'player', points: [{ x: center + 120, y: wizLos + 10 }], color: '#eab308', label: positionNames['Y'] || 'Y', shape: 'circle', variant: 'filled' }, // Yellow
                    ];
                }

                return [
                    // OL - Now Circles, Filled, Shifted back (+18)
                    { id: Date.now() + 1, type: 'player', points: [{ x: center, y: los + 18 }], color: cOL, label: positionNames['C'] || 'C', shape: 'circle', variant: 'filled' },
                    { id: Date.now() + 2, type: 'player', points: [{ x: center - 40, y: los + 18 }], color: cOL, label: positionNames['LG'] || 'G', shape: 'circle', variant: 'filled' },
                    { id: Date.now() + 3, type: 'player', points: [{ x: center + 40, y: los + 18 }], color: cOL, label: positionNames['RG'] || 'G', shape: 'circle', variant: 'filled' },
                    { id: Date.now() + 4, type: 'player', points: [{ x: center - 80, y: los + 18 }], color: cOL, label: positionNames['LT'] || 'T', shape: 'circle', variant: 'filled' },
                    { id: Date.now() + 5, type: 'player', points: [{ x: center + 80, y: los + 18 }], color: cOL, label: positionNames['RT'] || 'T', shape: 'circle', variant: 'filled' },
                    // QB
                    { id: Date.now() + 6, type: 'player', points: [{ x: center, y: los + 120 }], color: cQB, label: positionNames['QB'] || 'Q', shape: 'circle' },
                    // RB
                    { id: Date.now() + 7, type: 'player', points: [{ x: center, y: los + 220 }], color: cSkill, label: positionNames['RB'] || 'R', shape: 'circle' },
                    // WR Left
                    { id: Date.now() + 8, type: 'player', points: [{ x: 100, y: los + 15 }], color: cSkill, label: positionNames['X'] || 'X', shape: 'circle' },
                    // WR Right
                    { id: Date.now() + 9, type: 'player', points: [{ x: 700, y: los + 15 }], color: cSkill, label: positionNames['Z'] || 'Z', shape: 'circle' },
                    // Slot Left
                    { id: Date.now() + 10, type: 'player', points: [{ x: 200, y: los + 35 }], color: cSkill, label: positionNames['A'] || 'H', shape: 'circle' },
                    // TE Right
                    { id: Date.now() + 11, type: 'player', points: [{ x: center + 120, y: los + 15 }], color: cSkill, label: positionNames['Y'] || 'Y', shape: 'circle' },
                ];
            };

            // Scout Defense Defaults (4-3 Over)
            const getScoutDefenseFormation = () => {
                const center = 400;
                const los = 340;
                // Defense is ABOVE the LOS (smaller Y values)

                const cDL = '#1f2937'; // Dark Grey
                const cLB = '#374151';
                const cDB = '#4b5563';

                return [
                    // DL
                    { id: Date.now() + 1, type: 'player', points: [{ x: center - 90, y: los - 18 }], color: cDL, label: 'E', shape: 'square', variant: 'filled' }, // LE
                    { id: Date.now() + 2, type: 'player', points: [{ x: center - 30, y: los - 18 }], color: cDL, label: 'T', shape: 'square', variant: 'filled' }, // LT (3-tech)
                    { id: Date.now() + 3, type: 'player', points: [{ x: center + 30, y: los - 18 }], color: cDL, label: 'N', shape: 'square', variant: 'filled' }, // RT (1-tech)
                    { id: Date.now() + 4, type: 'player', points: [{ x: center + 90, y: los - 18 }], color: cDL, label: 'E', shape: 'square', variant: 'filled' }, // RE

                    // LB
                    { id: Date.now() + 5, type: 'player', points: [{ x: center - 110, y: los - 80 }], color: cLB, label: 'W', shape: 'square' }, // Will
                    { id: Date.now() + 6, type: 'player', points: [{ x: center, y: los - 80 }], color: cLB, label: 'M', shape: 'square' },       // Mike
                    { id: Date.now() + 7, type: 'player', points: [{ x: center + 110, y: los - 80 }], color: cLB, label: 'S', shape: 'star', variant: 'filled' }, // Sam (Star)

                    // DB
                    { id: Date.now() + 8, type: 'player', points: [{ x: center - 180, y: los - 35 }], color: cDB, label: 'C', shape: 'circle' }, // LCB
                    { id: Date.now() + 9, type: 'player', points: [{ x: center + 180, y: los - 35 }], color: cDB, label: 'C', shape: 'circle' }, // RCB
                    { id: Date.now() + 10, type: 'player', points: [{ x: center - 60, y: los - 200 }], color: cDB, label: 'F', shape: 'circle' }, // FS
                    { id: Date.now() + 11, type: 'player', points: [{ x: center + 60, y: los - 180 }], color: cDB, label: 'R', shape: 'circle' }, // Rover/SS
                ];
            };

            const handleScoutDefense = () => {
                if (elements.length > 0 && !window.confirm('Replace current diagram with Scout Defense?')) return;
                setElements(getScoutDefenseFormation());
            };

            const getScoutOffenseFormation = () => {
                const center = 400;
                const los = 340;
                const cScout = '#eab308'; // Yellow

                return [
                    // OL
                    { id: Date.now() + 1, type: 'player', points: [{ x: center, y: los + 18 }], color: cScout, label: positionNames['C'] || 'C', shape: 'circle', variant: 'filled' },
                    { id: Date.now() + 2, type: 'player', points: [{ x: center - 40, y: los + 18 }], color: cScout, label: positionNames['LG'] || 'G', shape: 'circle', variant: 'filled' },
                    { id: Date.now() + 3, type: 'player', points: [{ x: center + 40, y: los + 18 }], color: cScout, label: positionNames['RG'] || 'G', shape: 'circle', variant: 'filled' },
                    { id: Date.now() + 4, type: 'player', points: [{ x: center - 80, y: los + 18 }], color: cScout, label: positionNames['LT'] || 'T', shape: 'circle', variant: 'filled' },
                    { id: Date.now() + 5, type: 'player', points: [{ x: center + 80, y: los + 18 }], color: cScout, label: positionNames['RT'] || 'T', shape: 'circle', variant: 'filled' },
                    // QB
                    { id: Date.now() + 6, type: 'player', points: [{ x: center, y: los + 50 }], color: cScout, label: positionNames['QB'] || 'Q', shape: 'circle' },
                    // RB
                    { id: Date.now() + 7, type: 'player', points: [{ x: center, y: los + 120 }], color: cScout, label: positionNames['RB'] || 'R', shape: 'circle' },
                    // WRs
                    { id: Date.now() + 8, type: 'player', points: [{ x: 100, y: los + 15 }], color: cScout, label: positionNames['X'] || 'X', shape: 'circle' },
                    { id: Date.now() + 9, type: 'player', points: [{ x: 700, y: los + 15 }], color: cScout, label: positionNames['Z'] || 'Z', shape: 'circle' },
                    // TE/Slot
                    { id: Date.now() + 10, type: 'player', points: [{ x: center + 120, y: los + 15 }], color: cScout, label: positionNames['Y'] || 'Y', shape: 'circle' },
                    { id: Date.now() + 11, type: 'player', points: [{ x: 200, y: los + 35 }], color: cScout, label: positionNames['A'] || 'H', shape: 'circle' },
                ];
            };

            const handleScoutOffense = () => {
                if (elements.length > 0 && !window.confirm('Replace current diagram with Scout Offense?')) return;
                setElements(getScoutOffenseFormation());
            };

            // Initialize with data OR default formation
            const [elements, setElements] = useState(() => {
                if (initialData && initialData.elements && initialData.elements.length > 0) {
                    return initialData.elements;
                }
                return getDefaultFormation();
            });

            const [selectedTool, setSelectedTool] = useState('select'); // select, free, line, player, delete
            const [color, setColor] = useState('#000000');
            const [lineStyle, setLineStyle] = useState('solid'); // solid, dashed, zigzag
            const [lineWidth, setLineWidth] = useState(4); // 2, 4, 6, 8
            const [endType, setEndType] = useState('arrow'); // arrow, t, none
            const [showLineOptions, setShowLineOptions] = useState(false); // Dropdown for line options
            const [selectedPlayerIcon, setSelectedPlayerIcon] = useState({ label: 'Q', shape: 'circle' });

            // Text Size State for Wiz OL
            const [wizTextSize, setWizTextSize] = useState(170);
            const [customLetterInput, setCustomLetterInput] = useState('');

            // Field Position State (for dynamic yard lines)
            const [fieldPosition, setFieldPosition] = useState(50); // Starting yard line (0-100)

            // Field View Mode State (for WIZ Card view that matches print output)
            // 'standard' = full 900x600 viewBox, 'wiz-card' = cropped 800x460 viewBox matching WIZ grid cells
            const [fieldViewMode, setFieldViewMode] = useState(mode === 'wiz-skill' ? 'wiz-card' : 'standard');

            // Formation Selector State (for Wiz Skill)
            const [selectedFormationId, setSelectedFormationId] = useState('');



            // History State for Undo/Redo
            const [history, setHistory] = useState([elements]);
            const [historyIndex, setHistoryIndex] = useState(0);

            const updateHistory = (newElements) => {
                const newHistory = history.slice(0, historyIndex + 1);
                newHistory.push(newElements);
                setHistory(newHistory);
                setHistoryIndex(newHistory.length - 1);
            };

            // Load Formation from Library
            const loadFormation = (formationId) => {
                const formation = formations.find(f => f.id === formationId);
                if (!formation || !formation.positions) return;

                const center = 400;
                const los = 340;
                const newElements = [];

                // Position label to color/shape mapping
                const positionConfig = {
                    'C': { color: '#000000', shape: 'text-only', fontSize: 40 },
                    'G': { color: '#000000', shape: 'text-only', fontSize: 40 },
                    'T': { color: '#000000', shape: 'text-only', fontSize: 40 },
                    'LT': { color: '#000000', shape: 'text-only', fontSize: 40 },
                    'LG': { color: '#000000', shape: 'text-only', fontSize: 40 },
                    'RG': { color: '#000000', shape: 'text-only', fontSize: 40 },
                    'RT': { color: '#000000', shape: 'text-only', fontSize: 40 },
                    'QB': { color: '#ef4444', shape: 'circle', variant: 'filled', label: 'Q' },
                    'Q': { color: '#ef4444', shape: 'circle', variant: 'filled' },
                    'RB': { color: '#3b82f6', shape: 'circle', variant: 'filled', label: 'B' },
                    'B': { color: '#3b82f6', shape: 'circle', variant: 'filled' },
                    'X': { color: '#a855f7', shape: 'circle', variant: 'filled' },
                    'Z': { color: '#22c55e', shape: 'circle', variant: 'filled' },
                    'Y': { color: '#eab308', shape: 'circle', variant: 'filled' },
                    'A': { color: '#ef4444', shape: 'circle', variant: 'filled' },
                    'F': { color: '#f97316', shape: 'circle', variant: 'filled' },
                    'H': { color: '#06b6d4', shape: 'circle', variant: 'filled' }
                };

                formation.positions.forEach((pos, idx) => {
                    // Convert percentage (0-100) to pixel coordinates (0-800 width, 0-500 height)
                    const x = (pos.x / 100) * 800;
                    const y = (pos.y / 100) * 500;

                    const config = positionConfig[pos.label] || { color: '#3b82f6', shape: 'circle', variant: 'filled' };

                    newElements.push({
                        id: Date.now() + idx,
                        type: 'player',
                        points: [{ x, y }],
                        color: config.color,
                        label: positionNames[pos.label] || config.label || pos.label,
                        shape: config.shape || 'circle',
                        variant: config.variant || 'filled',
                        fontSize: config.fontSize
                    });
                });

                setElements(newElements);
                updateHistory(newElements);
            };

            // Selection State
            const [selectedIds, setSelectedIds] = useState(new Set());
            const [selectionBox, setSelectionBox] = useState(null);

            // Wiz Library State (Lifted to App)
            // wizLibrary passed as prop
            const [showSaveModal, setShowSaveModal] = useState(false);
            const [saveName, setSaveName] = useState('');

            // Library Helpers
            const initiateSave = () => {
                setSaveName('');
                setShowSaveModal(true);
            };

            const confirmSave = () => {
                if (!saveName) return;

                const newPreset = {
                    id: Date.now(),
                    name: saveName,
                    elements: elements
                };

                const updatedLibrary = [...wizLibrary, newPreset];
                setWizLibrary(updatedLibrary);
                localStorage.setItem('wiz_ol_library', JSON.stringify(updatedLibrary));
                setShowSaveModal(false);
            };

            const loadWizPreset = (presetId) => {
                const preset = wizLibrary.find(p => p.id === parseInt(presetId));
                if (preset) {
                    if (elements.length > 0 && !window.confirm(`Load "${preset.name}"? This will replace current drawing.`)) return;
                    // Ensure IDs are unique to avoid conflicts if re-saving?
                    // For now, just load as is.
                    const loadedElements = preset.elements.map(el => ({
                        ...el,
                        id: Date.now() + Math.random() // Regenerate IDs to avoid collision with history stacks
                    }));
                    updateElements(loadedElements);
                }
            };

            const deleteWizPreset = (presetId) => {
                if (!window.confirm("Delete this preset?")) return;
                const updatedLibrary = wizLibrary.filter(p => p.id !== parseInt(presetId));
                setWizLibrary(updatedLibrary);
                localStorage.setItem('wiz_ol_library', JSON.stringify(updatedLibrary));
            };

            // Formation Actions
            const flipFormation = () => {
                const flippedElements = elements.map(el => {
                    if (el.type === 'player' || el.type === 'poly' || el.type === 'free') {
                        return {
                            ...el,
                            points: el.points.map(p => ({
                                x: 800 - p.x,
                                y: p.y
                            }))
                        };
                    }
                    return el;
                });
                updateElements(flippedElements);
            };

            const saveAsFormationTemplate = () => {
                const name = window.prompt("Enter Formation Name:");
                if (!name) return;

                // Convert pixel coords back to percentages (0-100)
                // Editor width is 800, height is 500 (based on loadFormation logic)
                const positions = elements
                    .filter(el => el.type === 'player')
                    .map(el => ({
                        label: el.label,
                        x: (el.points[0].x / 800) * 100,
                        y: (el.points[0].y / 500) * 100
                    }));

                const newFormation = {
                    id: `form-${Date.now()}`,
                    name: name,
                    type: mode === 'scout-defense' ? 'Defense' : 'Offense',
                    positions: positions
                };

                onAddFormation(newFormation);
                alert(`Formation "${name}" saved to library!`);
            };

            // Drag State
            const [isDraggingElements, setIsDraggingElements] = useState(false);
            const [lastMousePos, setLastMousePos] = useState({ x: 0, y: 0 });

            // Helper to update elements with history
            const updateElements = (newElements, addToHistory = true) => {
                setElements(newElements);
                if (addToHistory) {
                    const newHistory = history.slice(0, historyIndex + 1);
                    newHistory.push(newElements);
                    setHistory(newHistory);
                    setHistoryIndex(newHistory.length - 1);
                }
            };

            const undo = () => {
                if (historyIndex > 0) {
                    const newIndex = historyIndex - 1;
                    setHistoryIndex(newIndex);
                    setElements(history[newIndex]);
                }
            };

            const redo = () => {
                if (historyIndex < history.length - 1) {
                    const newIndex = historyIndex + 1;
                    setHistoryIndex(newIndex);
                    setElements(history[newIndex]);
                }
            };

            const [isDrawing, setIsDrawing] = useState(false);
            const [currentPath, setCurrentPath] = useState(null);

            // Drag State
            const [draggedId, setDraggedId] = useState(null);

            // Ref for SVG container to get coordinates
            const svgRef = useRef(null);

            // Tools configuration
            const TOOLS = [
                { id: 'select', icon: 'MousePointer', label: 'Select / Move' },
                { id: 'free', icon: 'Edit3', label: 'Freehand' },
                { id: 'line', icon: 'Minus', label: 'Polyline / Straight' },
                // Arrow tool removed, now an option on line
                { id: 'player', icon: 'User', label: 'Player Icon' },
                { id: 'delete', icon: 'Trash', label: 'Delete Mode' }
            ];

            const COLORS = ['#000000', '#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#a855f7', '#22c55e', '#eab308'];

            const PLAYER_ICONS = [
                { label: 'Q', shape: 'circle' },
                { label: 'R', shape: 'circle' },
                { label: 'X', shape: 'circle' },
                { label: 'Y', shape: 'circle' },
                { label: 'Z', shape: 'circle' },
                { label: 'H', shape: 'circle' },
                { label: 'F', shape: 'circle' },
                { label: 'C', shape: 'square' },
                { label: 'G', shape: 'square' },
                { label: 'T', shape: 'square' },
                { label: 'S', shape: 'star' },  // Scout/Star
                { label: 'T', shape: 'target' } // Target
            ];

            // Coordinate calibration: Map mouse event to SVG coordinates
            const getPoint = (e) => {
                if (!svgRef.current) return { x: 0, y: 0 };
                const CTM = svgRef.current.getScreenCTM();
                if (!CTM) return { x: 0, y: 0 };
                return {
                    x: (e.clientX - CTM.e) / CTM.a,
                    y: (e.clientY - CTM.f) / CTM.d
                };
            };

            const handleMouseDown = (e) => {
                if (readOnly) return; // Disable interaction
                if (isDraggingElements) return; // Already dragging?
                if (selectedTool === 'delete') return;

                const point = getPoint(e);

                // Selection Box Logic (if Select tool)
                if (selectedTool === 'select') {
                    if (!e.shiftKey) setSelectedIds(new Set()); // Deselect unless shift
                    setSelectionBox({ start: point, current: point });
                    return;
                }

                // If clicking empty space...
                if (selectedTool === 'player') {
                    const newElement = {
                        id: Date.now(),
                        type: 'player',
                        points: [point],
                        color,
                        label: selectedPlayerIcon.label,
                        shape: selectedPlayerIcon.shape
                    };
                    updateElements([...elements, newElement]);
                    setSelectedIds(new Set([newElement.id])); // Select new element
                    return;
                }

                // Polyline Interaction
                if (selectedTool === 'line') {
                    if (!isDrawing) {
                        setIsDrawing(true);

                        // Smart Color Logic: Check if we clicked on a player
                        let drawColor = color;
                        const hitPlayer = elements.find(el => {
                            if (el.type !== 'player') return false;
                            const p = el.points[0];
                            // Rough hit test (circle radius ~30, text ~40)
                            const dist = Math.hypot(p.x - point.x, p.y - point.y);
                            return dist < 40; // generous hit radius
                        });

                        if (hitPlayer) {
                            drawColor = hitPlayer.color;
                            setColor(drawColor); // Update tool color for feedback
                        }

                        setCurrentPath({
                            id: Date.now(),
                            type: 'poly', // Generic polyline
                            color: drawColor,
                            style: lineStyle,
                            endType,
                            strokeWidth: lineWidth, // Save width
                            points: [point, { x: point.x + 1, y: point.y + 1 }] // Follower point
                        });
                    } else {
                        // Add segment anchor
                        setCurrentPath(prev => ({
                            ...prev,
                            points: [...prev.points.slice(0, -1), point, point] // Replace follower with actual point, then add new follower
                        }));
                    }
                } else if (selectedTool === 'free') {
                    setIsDrawing(true);

                    // Smart Color Logic
                    let drawColor = color;
                    const hitPlayer = elements.find(el => {
                        if (el.type !== 'player') return false;
                        const p = el.points[0];
                        const dist = Math.hypot(p.x - point.x, p.y - point.y);
                        return dist < 40;
                    });

                    if (hitPlayer) {
                        drawColor = hitPlayer.color;
                        setColor(drawColor);
                    }

                    setCurrentPath({
                        id: Date.now(),
                        type: 'free',
                        color: drawColor,
                        strokeWidth: lineWidth,
                        points: [point]
                    });
                }
            };

            const handleElementMouseDown = (e, elId) => {
                e.stopPropagation();
                if (selectedTool === 'delete') return; // Let click handle delete

                // Selection Logic
                const newSelected = new Set(selectedIds);
                if (e.shiftKey) {
                    if (newSelected.has(elId)) newSelected.delete(elId);
                    else newSelected.add(elId);
                } else {
                    if (!newSelected.has(elId)) {
                        newSelected.clear();
                        newSelected.add(elId);
                    }
                }
                setSelectedIds(newSelected);

                // Start Drag
                setIsDraggingElements(true);
                setLastMousePos(getPoint(e));
                setDraggedId(elId); // Keep for legacy check or visual ref if needed
            };

            const handleMouseMove = (e) => {
                const point = getPoint(e);

                // Selection Box Update
                if (selectionBox) {
                    setSelectionBox(prev => ({ ...prev, current: point }));
                    return;
                }

                // Bulk Dragging Logic
                if (isDraggingElements) {
                    const dx = point.x - lastMousePos.x;
                    const dy = point.y - lastMousePos.y;

                    setElements(prev => prev.map(el => {
                        if (selectedIds.has(el.id)) {
                            // Move all points
                            return {
                                ...el,
                                points: el.points.map(p => ({ x: p.x + dx, y: p.y + dy }))
                            };
                        }
                        return el;
                    }));
                    setLastMousePos(point);
                    return;
                }

                // Drawing Logic
                if (!isDrawing || !currentPath) return;

                if (selectedTool === 'free') {
                    setCurrentPath(prev => ({
                        ...prev,
                        points: [...prev.points, point]
                    }));
                } else if (selectedTool === 'line') {
                    // Update the generic "follower" point (last point in array)
                    setCurrentPath(prev => {
                        const newPoints = [...prev.points];
                        newPoints[newPoints.length - 1] = point;
                        return { ...prev, points: newPoints };
                    });
                }
            };

            const handleDoubleClick = (e) => {
                if (!isDrawing || !currentPath) return;
                if (selectedTool === 'line') {
                    const finalPath = { ...currentPath };
                    // Remove the last point if it's just the cursor follower (already done in logic, but let's be safe)
                    // The 'follower' is usually the last point. 

                    // Filter out duplicate/too-close points
                    const uniquePoints = [];
                    if (finalPath.points.length > 0) {
                        uniquePoints.push(finalPath.points[0]);
                        for (let i = 1; i < finalPath.points.length; i++) {
                            const prev = uniquePoints[uniquePoints.length - 1];
                            const curr = finalPath.points[i];
                            const dist = Math.hypot(curr.x - prev.x, curr.y - prev.y);
                            if (dist > 2) { // Minimum 2px distance
                                uniquePoints.push(curr);
                            }
                        }
                    }

                    finalPath.points = uniquePoints;

                    setIsDrawing(false);
                    // Must have at least 2 points to be a line
                    if (finalPath.points.length > 1) {
                        updateElements([...elements, finalPath]);
                        setSelectedIds(new Set([finalPath.id]));
                    }
                    setCurrentPath(null);
                }
            };

            const handleMouseUp = () => {
                // Finish Selection Box
                if (selectionBox) {
                    // Calc bounds
                    const x1 = Math.min(selectionBox.start.x, selectionBox.current.x);
                    const y1 = Math.min(selectionBox.start.y, selectionBox.current.y);
                    const x2 = Math.max(selectionBox.start.x, selectionBox.current.x);
                    const y2 = Math.max(selectionBox.start.y, selectionBox.current.y);

                    const newSelected = new Set(selectedIds);
                    if (!selectionBox.start.shiftKey) { // Assuming we track shift? Actually handled in MouseDown clearing
                        // We already cleared in MouseDown if no shift.
                    }

                    elements.forEach(el => {
                        // Check if ANY point is in box
                        const isInside = el.points.some(p => p.x >= x1 && p.x <= x2 && p.y >= y1 && p.y <= y2);
                        if (isInside) newSelected.add(el.id);
                    });

                    setSelectedIds(newSelected);
                    setSelectionBox(null);
                    return;
                }

                // Finish Dragging
                if (isDraggingElements) {
                    setIsDraggingElements(false);
                    setDraggedId(null);
                    updateElements(elements); // Commit history
                    return;
                }

                // Stop Freehand Drawing
                if (selectedTool === 'free') {
                    setIsDrawing(false);
                    if (currentPath && currentPath.points.length > 1) {
                        updateElements([...elements, currentPath]);
                        setSelectedIds(new Set([currentPath.id]));
                    }
                    setCurrentPath(null);
                }
                // Line tool does NOT finish on mouse up, waits for double click
                // (Drag Logic moved up)
            };

            // Wiz Skill Formation (Custom Colors/Labels)
            const getWizFormation = (forcedSize) => {
                const center = 400;
                const los = 340; // Same geometry as default

                const cOL = '#000000';
                const cQB = '#ef4444'; // Red

                // Custom Skill Colors
                const cX = '#a855f7'; // Purple
                const cZ = '#22c55e'; // Green
                const cY = '#eab308'; // Yellow
                const cA = '#ef4444'; // Red (Slot)
                const cB = '#3b82f6'; // Blue (RB)

                return [
                    // OL - Text Only (Respects wizTextSize)
                    { id: Date.now() + 1, type: 'player', points: [{ x: center, y: los + 18 }], color: cOL, label: 'C', shape: 'text-only', fontSize: forcedSize || wizTextSize },
                    { id: Date.now() + 2, type: 'player', points: [{ x: center - 170, y: los + 18 + 15 }], color: cOL, label: 'G', shape: 'text-only', fontSize: forcedSize || wizTextSize },
                    { id: Date.now() + 3, type: 'player', points: [{ x: center + 170, y: los + 18 + 15 }], color: cOL, label: 'G', shape: 'text-only', fontSize: forcedSize || wizTextSize },
                    { id: Date.now() + 4, type: 'player', points: [{ x: center - 340, y: los + 18 + 30 }], color: cOL, label: 'T', shape: 'text-only', fontSize: forcedSize || wizTextSize },
                    { id: Date.now() + 5, type: 'player', points: [{ x: center + 340, y: los + 18 + 30 }], color: cOL, label: 'T', shape: 'text-only', fontSize: forcedSize || wizTextSize },
                    // QB - Red
                    { id: Date.now() + 6, type: 'player', points: [{ x: center, y: los + 100 }], color: cQB, label: 'Q', shape: 'circle' },
                    // B (was RB) - Blue
                    { id: Date.now() + 7, type: 'player', points: [{ x: center, y: los + 140 }], color: cB, label: 'B', shape: 'circle' },
                    // X - Purple
                    { id: Date.now() + 8, type: 'player', points: [{ x: 100, y: los + 15 }], color: cX, label: 'X', shape: 'circle' },
                    // Z - Green
                    { id: Date.now() + 9, type: 'player', points: [{ x: 700, y: los + 15 }], color: cZ, label: 'Z', shape: 'circle' },
                    // A (was H) - Red
                    { id: Date.now() + 10, type: 'player', points: [{ x: 200, y: los + 35 }], color: cA, label: 'A', shape: 'circle' },
                    // Y - Yellow
                    { id: Date.now() + 11, type: 'player', points: [{ x: center + 120, y: los + 15 }], color: cY, label: 'Y', shape: 'circle' },
                ];
            };

            const handleQuickOffense = () => {
                if (elements.length > 0 && !window.confirm('Clear current diagram?')) return;
                updateElements(getDefaultFormation());
            };

            const handleWizOffense = () => {
                if (elements.length > 0 && !window.confirm('Clear current diagram?')) return;
                setWizTextSize(170); // Ensure state is updated for controls
                updateElements(getWizFormation(170)); // Pass explicit size
            };

            const handleClickElement = (elId) => {
                if (selectedTool === 'delete') {
                    updateElements(elements.filter(el => el.id !== elId));
                } else {
                    // Logic handled in MouseDown now
                }
            };

            // Keyboard Shortcuts
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                    // Delete / Backspace
                    if (e.key === 'Delete' || e.key === 'Backspace') {
                        if (selectedIds.size > 0) {
                            updateElements(elements.filter(el => !selectedIds.has(el.id)));
                            setSelectedIds(new Set());
                        }
                    }

                    // Undo / Redo
                    if ((e.metaKey || e.ctrlKey) && e.key === 'z') {
                        e.preventDefault();
                        if (e.shiftKey) {
                            redo();
                        } else {
                            undo();
                        }
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [selectedIds, elements, history, historyIndex]);

            // Render SVG contents
            const renderElement = (el, isPreview = false) => {
                if (el.type === 'player') {
                    // ... (existing player render code) ...
                    // Update: Pass strokeWidth if needed, but usually players have fixed stroke?
                    // Let's keep players standard for now unless requested.
                    const { x, y } = el.points[0];
                    const size = 30; // Icon size
                    const isRect = el.shape === 'square';
                    const isFilled = el.variant === 'filled';
                    const fillColor = isFilled ? el.color : 'white';
                    const strokeColor = el.color; // Stroke matches color
                    const textColor = isFilled ? 'white' : el.color;


                    const isSelected = selectedIds.has(el.id);
                    // Critical Fix: If we are drawing (line/free) or placing players, ignore existing elements logic.
                    // Only allow interaction if tool is Select/Move or Delete.
                    const isInteractionTool = selectedTool === 'select' || selectedTool === 'delete';
                    const pointerEvents = isInteractionTool ? 'all' : 'none';

                    return (
                        <g
                            key={el.id}
                            onMouseDown={(e) => !isPreview && handleElementMouseDown(e, el.id)}
                            onClick={(e) => { e.stopPropagation(); !isPreview && handleClickElement(el.id); }}
                            style={{
                                cursor: selectedTool === 'delete' ? 'pointer' : (isPreview ? 'default' : 'move'),
                                opacity: isPreview ? 0.8 : 1,
                                pointerEvents: pointerEvents
                            }}
                        >
                            {/* Selection Highlight */}
                            {isSelected && !isPreview && (
                                isRect ? (
                                    <rect x={x - size / 2 - 4} y={y - size / 2 - 4} width={size + 8} height={size + 8} fill="none" stroke="#2563eb" strokeWidth="2" strokeDasharray="4,2" />
                                ) : (
                                    <circle cx={x} cy={y} r={size / 2 + 4} fill="none" stroke="#2563eb" strokeWidth="2" strokeDasharray="4,2" />
                                )
                            )}

                            {isRect ? (
                                <rect x={x - size / 2} y={y - size / 2} width={size} height={size} fill={fillColor} stroke={strokeColor} strokeWidth="2" />
                            ) : el.shape === 'star' ? (
                                <polygon
                                    points={`${x},${y - size / 1.5} ${x + size / 3},${y - size / 4} ${x + size / 1.2},${y - size / 4} ${x + size / 2},${y + size / 4} ${x + size / 1.5},${y + size / 1.2} ${x},${y + size / 2} ${x - size / 1.5},${y + size / 1.2} ${x - size / 2},${y + size / 4} ${x - size / 1.2},${y - size / 4} ${x - size / 3},${y - size / 4}`}
                                    fill={fillColor} stroke={strokeColor} strokeWidth="2"
                                />
                            ) : el.shape === 'target' ? (
                                <g>
                                    <circle cx={x} cy={y} r={size / 2} fill="none" stroke={strokeColor} strokeWidth="2" />
                                    <circle cx={x} cy={y} r={size / 4} fill={fillColor} stroke={strokeColor} strokeWidth="1" />
                                    <line x1={x - size / 2} y1={y} x2={x + size / 2} y2={y} stroke={strokeColor} strokeWidth="1" />
                                    <line x1={x} y1={y - size / 2} x2={x} y2={y + size / 2} stroke={strokeColor} strokeWidth="1" />
                                </g>
                            ) : el.shape === 'text-only' ? (
                                // No shape, just big text
                                // We need a transparent hit box so dragging works
                                (() => {
                                    // Calculate size once - prioritize element's saved size
                                    const tSize = el.fontSize || 170;
                                    return (
                                        <React.Fragment>
                                            <rect
                                                x={x - (tSize * 0.6) / 2}
                                                y={y - (tSize * 0.8) / 2}
                                                width={tSize * 0.6}
                                                height={tSize * 0.8}
                                                fill="transparent"
                                                stroke="none"
                                            />
                                            {isSelected && !isPreview && (
                                                <rect
                                                    x={x - (tSize * 0.6) / 2 - 4}
                                                    y={y - (tSize * 0.8) / 2 - 4}
                                                    width={(tSize * 0.6) + 8}
                                                    height={(tSize * 0.8) + 8}
                                                    fill="none"
                                                    stroke="#2563eb"
                                                    strokeWidth="2"
                                                    strokeDasharray="4,2"
                                                />
                                            )}
                                        </React.Fragment>
                                    );
                                })()
                            ) : (
                                <circle cx={x} cy={y} r={size / 2} fill={fillColor} stroke={strokeColor} strokeWidth="2" />
                            )}
                            <text
                                x={x}
                                y={y}
                                dy={el.shape === 'text-only' ? "0.35em" : "0.35em"}
                                textAnchor="middle"
                                fontSize={el.shape === 'text-only' ? (el.fontSize || 170) : "16"}
                                fontWeight="bold"
                                fill={el.shape === 'text-only' ? (el.color || 'black') : textColor}
                                style={{ pointerEvents: 'none', userSelect: 'none', fontFamily: 'Arial, sans-serif' }}
                            >
                                {el.type === 'player' ? (positionNames[el.label] || el.label) : el.label}
                            </text>
                        </g>
                    );
                }

                if (el.points.length < 2) return null;

                // Path Data Generation
                let d = '';
                if (el.style === 'zigzag') {
                    d = getZigZagPath(el.points);
                } else if (el.type === 'free' || el.type === 'poly') {
                    d = `M ${el.points.map(p => `${p.x},${p.y}`).join(' L ')}`;
                }

                // T-Block Marker (Custom logic since SVG markers are limited)
                let markerEnd = undefined;
                let tBlock = null;

                if (el.endType === 'arrow') {
                    markerEnd = `url(#arrowhead-${el.color})`;
                } else if (el.endType === 't') {
                    // Calculate perpendicular line at end
                    const end = el.points[el.points.length - 1];
                    const prev = el.points[el.points.length - 2] || el.points[0]; // Need vector
                    const dx = end.x - prev.x;
                    const dy = end.y - prev.y;
                    const len = Math.hypot(dx, dy) || 1;
                    const sWidth = parseInt(el.strokeWidth || 2);
                    // Scale T-width slightly with stroke, but mostly fixed length. 
                    // Length of T-bar: 30px total (15 scale).
                    // Thickness: match line width.
                    const perpX = (-dy / len) * 15;
                    const perpY = (dx / len) * 15;

                    tBlock = (
                        <line
                            x1={end.x - perpX} y1={end.y - perpY}
                            x2={end.x + perpX} y2={end.y + perpY}
                            stroke={el.color}
                            strokeWidth={sWidth}
                            strokeLinecap="round"
                        />
                    );
                } else if (el.endType === 'dot') {
                    const end = el.points[el.points.length - 1];
                    tBlock = (
                        <circle cx={end.x} cy={end.y} r="6" fill={el.color} />
                    );
                }

                const isSelected = selectedIds.has(el.id);
                const strokeWidth = el.strokeWidth || 4;
                const isInteractionTool = selectedTool === 'select' || selectedTool === 'delete';

                // Add click handler for ReadOnly mode
                const handleElementClick = (e) => {
                    if (!readOnly) return;
                    if (el.link || el.conceptLabel) {
                        e.stopPropagation();
                        if (el.link) {
                            const url = el.link.startsWith('http') ? el.link : null;
                            if (url) window.open(url, '_blank');
                            else alert(`Linked: ${el.conceptLabel}\n(No valid URL found)`);
                        } else {
                            alert(`Note: ${el.conceptLabel}`);
                        }
                    }
                };

                return (
                    <g key={el.id || 'current'} onClick={handleElementClick} style={{ cursor: (readOnly && (el.link || el.conceptLabel)) ? 'pointer' : (selectedTool === 'delete' ? 'pointer' : 'default'), opacity: isPreview ? 0.6 : 1, pointerEvents: (readOnly || isInteractionTool) ? 'all' : 'none' }}>
                        <path
                            d={d}
                            stroke={isSelected ? '#2563eb' : el.color}
                            strokeWidth={isSelected ? strokeWidth + 2 : strokeWidth}
                            fill="none"
                            strokeDasharray={el.style === 'dashed' ? "10,5" : "none"}
                            markerEnd={markerEnd}
                            filter={isSelected ? "drop-shadow(0 0 2px #2563eb)" : "none"}
                        />
                        {tBlock}
                        {/* Title for hover tooltip */}
                        {(el.link || el.conceptLabel) && <title>{`Linked: ${el.conceptLabel || 'Video'} ${el.link ? `(${el.link})` : ''}`}</title>}
                    </g>
                );
            };

            // Toggle Wiz Node (Y or F)
            // Toggle Wiz Node (Generic)
            const toggleWizNode = (label) => {
                setElements(prev => {
                    const exists = prev.find(e => e.label === label && e.type === 'player');
                    if (exists) {
                        return prev.filter(e => e.id !== exists.id);
                    } else {
                        const center = 400;
                        const los = 340 + 18;
                        let newPoint = { x: center + 60, y: los + 60 };
                        let shape = 'square';
                        let color = '#3b82f6'; // Skill blue default

                        if (mode === 'wiz-oline') {
                            shape = 'text-only';
                            color = '#000000';
                            // Place below the main line so user can drag into place
                            newPoint = { x: center, y: los + 150 };
                        } else {
                            if (label === 'Y') {
                                newPoint = { x: center + 180, y: los };
                            } else if (label === 'F') {
                                newPoint = { x: center + 60, y: los + 60 };
                            }
                        }

                        return [...prev, {
                            id: Date.now(),
                            type: 'player',
                            points: [newPoint],
                            color: color,
                            label: label,
                            shape: shape,
                            variant: 'filled',
                            fontSize: mode === 'wiz-oline' ? wizTextSize : undefined
                        }];
                    }
                });
            };

            return (
                <div style={{ position: 'fixed', top: 0, left: 0, width: '100%', height: '100%', background: 'rgba(0,0,0,0.8)', zIndex: 11000, display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
                    <div className="animate-fade-in" style={{ width: '95%', height: '90%', background: 'white', borderRadius: '12px', display: 'flex', flexDirection: 'column', overflow: 'hidden', boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.25)' }}>
                        {/* Header / Toolbar */}
                        <div style={{ padding: '0.75rem 1rem', borderBottom: '1px solid #e5e7eb', display: readOnly ? 'none' : 'flex', alignItems: 'center', background: '#f8fafc', gap: '0.5rem', flexWrap: 'wrap' }}>
                            <h3 style={{ margin: 0, marginRight: '0.5rem', fontSize: '1rem' }}>Diagrammer</h3>

                            {/* --- GROUP 1: DRAWING TOOLS & COLORS (LEFT) --- */}
                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                <div className="btn-group" style={{ display: 'flex', gap: '0.25rem' }}>
                                    {TOOLS.filter(t => t.id !== 'delete' && !(mode === 'wiz-oline' && t.id === 'player')).map(tool => {
                                        if (tool.id === 'line') {
                                            return (
                                                <div key={tool.id} style={{ position: 'relative' }}>
                                                    <button
                                                        className={`btn ${selectedTool === tool.id ? 'btn-primary' : 'btn-secondary'}`}
                                                        onClick={() => selectedTool === 'line' ? setShowLineOptions(!showLineOptions) : (setSelectedTool('line'), setEndType('arrow'), setShowLineOptions(false))}
                                                        title="Line Tool"
                                                        style={{ padding: '0.4rem 0.6rem', display: 'flex', gap: '0.25rem', alignItems: 'center', color: '#1e293b' }}
                                                    >
                                                        <Icon name={tool.icon} size={16} />
                                                        <span style={{ fontSize: '0.8rem' }}>Line</span>
                                                        {selectedTool === 'line' && <span style={{ fontSize: '0.7rem', opacity: 0.7 }}>▼</span>}
                                                    </button>
                                                    {showLineOptions && selectedTool === 'line' && (
                                                        <div style={{ position: 'absolute', top: '100%', left: 0, marginTop: '4px', background: 'white', border: '1px solid #ccc', borderRadius: '4px', boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)', zIndex: 50, display: 'flex', flexDirection: 'column', minWidth: '120px' }}>
                                                            {[{ id: 'arrow', label: 'Start → End' }, { id: 't', label: '—| Block' }, { id: 'dot', label: '• Dot' }, { id: 'none', label: 'Straight Line' }].map(opt => (
                                                                <button key={opt.id} onClick={(e) => { e.stopPropagation(); setEndType(opt.id); setShowLineOptions(false); }} style={{ padding: '0.5rem', textAlign: 'left', background: endType === opt.id ? '#f0f9ff' : 'white', border: 'none', borderBottom: '1px solid #eee', cursor: 'pointer', fontSize: '0.8rem', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                                    {opt.label}
                                                                    {endType === opt.id && <Icon name="CheckCircle" size={12} color="#0284c7" />}
                                                                </button>
                                                            ))}
                                                        </div>
                                                    )}
                                                </div>
                                            );
                                        }
                                        return (
                                            <button key={tool.id} className={`btn ${selectedTool === tool.id ? 'btn-primary' : 'btn-secondary'}`} onClick={() => { setSelectedTool(tool.id); if (tool.id !== 'line') setShowLineOptions(false); }} title={tool.label} style={{ padding: '0.4rem 0.6rem', display: 'flex', gap: '0.25rem', alignItems: 'center', color: '#1e293b' }}>
                                                <Icon name={tool.icon} size={16} /><span style={{ fontSize: '0.8rem' }}>{tool.label}</span>
                                            </button>
                                        );
                                    })}
                                </div>

                                <div style={{ display: 'flex', gap: '0.2rem', alignItems: 'center', background: '#f1f5f9', padding: '0.2rem', borderRadius: '20px', border: '1px solid #e2e8f0' }}>
                                    {COLORS.map(c => (
                                        <button key={c} onClick={() => { setColor(c); if (selectedIds.size > 0) updateElements(elements.map(el => selectedIds.has(el.id) ? { ...el, color: c } : el)); }} style={{ width: '18px', height: '18px', borderRadius: '50%', background: c, border: color === c ? '2px solid white' : '1px solid rgba(0,0,0,0.1)', boxShadow: color === c ? '0 0 0 2px var(--accent)' : 'none' }}></button>
                                    ))}
                                </div>

                                {(selectedTool === 'line' || selectedTool === 'free') && (
                                    <div style={{ display: 'flex', gap: '0.25rem', alignItems: 'center', background: '#e2e8f0', padding: '0.25rem', borderRadius: '4px' }}>
                                        <select value={lineStyle} onChange={(e) => setLineStyle(e.target.value)} className="form-input" style={{ padding: '2px', fontSize: '0.8rem', width: 'auto', background: 'white' }}>
                                            <option value="solid">Solid</option>
                                            <option value="dashed">Dashed</option>
                                            <option value="zigzag">Zigzag</option>
                                        </select>
                                        <select value={lineWidth} onChange={(e) => { const w = parseInt(e.target.value); setLineWidth(w); if (selectedIds.size > 0) updateElements(elements.map(el => (selectedIds.has(el.id) && (el.type === 'line' || el.type === 'free' || el.type === 'poly')) ? { ...el, strokeWidth: w } : el)); }} className="form-input" style={{ padding: '2px', fontSize: '0.8rem', width: 'auto', background: 'white' }}>
                                            <option value={2}>Thin</option>
                                            <option value={4}>Med</option>
                                            <option value={6}>Thick</option>
                                        </select>
                                    </div>
                                )}
                            </div>

                            <div style={{ width: '1px', height: '24px', background: '#cbd5e1', margin: '0 0.25rem' }}></div>

                            {/* --- GROUP 2: CONFIG & SELECTORS (CENTER) --- */}
                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                {mode !== 'wiz-oline' && (
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '0.25rem' }}>
                                        <label style={{ fontSize: '0.8rem', color: '#1e293b', fontWeight: 'bold' }}>Field:</label>
                                        <select value={fieldPosition} onChange={(e) => setFieldPosition(parseInt(e.target.value))} style={{ padding: '0.25rem 0.5rem', fontSize: '0.8rem', borderRadius: '4px', border: '1px solid #ccc', color: '#1e293b', backgroundColor: 'white' }}>
                                            <option value={50}>Midfield</option><option value={20}>Red Zone</option><option value={5}>Goal Line</option><option value={35}>Open Field</option>
                                        </select>
                                    </div>
                                )}

                                {/* View Mode selector for WIZ skill mode - matches print output aspect ratio */}
                                {mode === 'wiz-skill' && (
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '0.25rem' }}>
                                        <label style={{ fontSize: '0.8rem', color: '#1e293b', fontWeight: 'bold' }}>View:</label>
                                        <select value={fieldViewMode} onChange={(e) => setFieldViewMode(e.target.value)} style={{ padding: '0.25rem 0.5rem', fontSize: '0.8rem', borderRadius: '4px', border: '1px solid #ccc', color: '#1e293b', backgroundColor: fieldViewMode === 'wiz-card' ? '#dcfce7' : 'white' }}>
                                            <option value="wiz-card">WIZ Card</option>
                                            <option value="standard">Full Field</option>
                                        </select>
                                    </div>
                                )}

                                {mode.startsWith('wiz') && formations.length > 0 && (
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '0.25rem' }}>
                                        <label style={{ fontSize: '0.8rem', color: '#1e293b', fontWeight: 'bold' }}>Formation:</label>
                                        <select value={selectedFormationId} onChange={(e) => { setSelectedFormationId(e.target.value); if (e.target.value) loadFormation(e.target.value); }} style={{ padding: '0.25rem 1.5rem 0.25rem 0.5rem', fontSize: '0.8rem', borderRadius: '4px', border: '1px solid #ccc', color: '#1e293b', backgroundColor: 'white' }}>
                                            <option value="">-- Formation --</option>
                                            {formations.map(f => (<option key={f.id} value={f.id}>{f.name}</option>))}
                                        </select>
                                    </div>
                                )}

                                {(mode === 'wiz-oline' || mode === 'wiz-skill') && (
                                    <div style={{ display: 'flex', gap: '0.4rem', alignItems: 'center', background: '#e0f2fe', padding: '0.25rem 0.4rem', borderRadius: '4px', border: '1px solid #7dd3fc' }}>
                                        <span style={{ fontSize: '0.8rem', fontWeight: 'bold', color: '#0369a1' }}>Personnel:</span>
                                        {mode === 'wiz-skill' && (
                                            <div style={{ display: 'flex', gap: '2px' }}>
                                                <button className={`btn ${elements.some(e => e.label === 'Y') ? 'btn-primary' : 'btn-secondary'}`} onClick={() => toggleWizNode('Y')} style={{ padding: '0.1rem 0.4rem', fontSize: '0.8rem', color: '#1e293b' }}>+ Y</button>
                                                <button className={`btn ${elements.some(e => e.label === 'F') ? 'btn-primary' : 'btn-secondary'}`} onClick={() => toggleWizNode('F')} style={{ padding: '0.1rem 0.4rem', fontSize: '0.8rem', color: '#1e293b' }}>+ F</button>
                                            </div>
                                        )}
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '2px' }}>
                                            <input type="text" value={customLetterInput} onChange={(e) => setCustomLetterInput(e.target.value.toUpperCase())} placeholder="A" maxLength={2} style={{ width: '25px', padding: '1px', textAlign: 'center', fontSize: '0.8rem', color: '#1e293b', border: '1px solid #94a3b8', borderRadius: '2px' }} />
                                            <button className="btn btn-secondary" onClick={() => { if (customLetterInput) { toggleWizNode(customLetterInput); setCustomLetterInput(''); } }} disabled={!customLetterInput} style={{ padding: '0.1rem 0.4rem', fontSize: '0.8rem', color: '#1e293b' }}>+ Add</button>
                                        </div>

                                        {mode === 'wiz-oline' && (
                                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.25rem', marginLeft: '0.25rem', padding: '0 0.25rem', borderLeft: '1px solid #7dd3fc' }}>
                                                <button className="btn btn-secondary" onClick={() => { const s = Math.max(12, wizTextSize - 4); setWizTextSize(s); if (selectedIds.size > 0) updateElements(elements.map(el => (selectedIds.has(el.id) && el.shape === 'text-only') ? { ...el, fontSize: s } : el)); }} style={{ padding: '0 0.3rem', fontSize: '0.9rem', color: '#1e293b' }}>-</button>
                                                <span style={{ fontSize: '0.75rem', fontWeight: 'bold', minWidth: '1.2rem', textAlign: 'center' }}>{wizTextSize}</span>
                                                <button className="btn btn-secondary" onClick={() => { const s = Math.min(200, wizTextSize + 4); setWizTextSize(s); if (selectedIds.size > 0) updateElements(elements.map(el => (selectedIds.has(el.id) && el.shape === 'text-only') ? { ...el, fontSize: s } : el)); }} style={{ padding: '0 0.3rem', fontSize: '0.9rem', color: '#1e293b' }}>+</button>
                                            </div>
                                        )}

                                        {mode === 'wiz-oline' && (
                                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.15rem', background: '#fffbeb', padding: '0.15rem 0.25rem', borderRadius: '4px', border: '1px solid #fcd34d' }}>
                                                <button className="btn btn-secondary" onClick={initiateSave} title="Save to library" style={{ padding: '0.1rem 0.3rem', fontSize: '0.75rem', color: '#1e293b', border: 'none', background: 'transparent' }}><Icon name="Save" size={12} /></button>
                                                <select style={{ padding: '1px', fontSize: '0.75rem', width: '80px', color: '#1e293b', border: 'none', background: 'transparent' }} onChange={(e) => { if (e.target.value) { loadWizPreset(e.target.value); e.target.value = ""; } }} defaultValue="">
                                                    <option value="" disabled>Lib...</option>
                                                    {wizLibrary.map(preset => (<option key={preset.id} value={preset.id}>{preset.name}</option>))}
                                                </select>
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>

                            <div style={{ width: '1px', height: '24px', background: '#cbd5e1', margin: '0 0.25rem' }}></div>

                            {/* --- GROUP 3: FORMATION ACTIONS (RIGHT) --- */}
                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginLeft: 'auto' }}>
                                <button
                                    className="btn btn-secondary"
                                    onClick={flipFormation}
                                    title="Flip Formation (Left/Right)"
                                    style={{ padding: '0.4rem 0.6rem', display: 'flex', gap: '0.25rem', alignItems: 'center', color: '#1e293b', backgroundColor: 'white' }}
                                >
                                    <Icon name="RefreshCw" size={16} />
                                    <span style={{ fontSize: '0.8rem' }}>Flip</span>
                                </button>
                                <button
                                    className="btn btn-primary"
                                    onClick={saveAsFormationTemplate}
                                    title="Save as Formation Template"
                                    style={{ padding: '0.4rem 0.6rem', display: 'flex', gap: '0.25rem', alignItems: 'center', color: 'white', background: '#0891b2' }}
                                >
                                    <Icon name="Layout" size={16} />
                                    <span style={{ fontSize: '0.8rem' }}>Save As Formation</span>
                                </button>
                            </div>

                            <div style={{ flex: 1 }}></div>

                            {/* --- GROUP 4: SYSTEM ACTIONS (RIGHT) --- */}
                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.4rem' }}>
                                <div className="btn-group" style={{ display: 'flex', gap: '0.2rem' }}>
                                    <button className="btn btn-secondary" onClick={undo} disabled={historyIndex === 0} title="Undo" style={{ padding: '0.3rem 0.5rem', display: 'flex', alignItems: 'center', gap: '0.25rem', color: '#1e293b', backgroundColor: 'white' }}>
                                        <Icon name="RotateCcw" size={14} /> <span style={{ fontSize: '0.7rem' }}>Undo</span>
                                    </button>
                                    <button className="btn btn-secondary" onClick={redo} disabled={historyIndex === history.length - 1} title="Redo" style={{ padding: '0.3rem 0.5rem', display: 'flex', alignItems: 'center', gap: '0.25rem', color: '#1e293b', backgroundColor: 'white' }}>
                                        <Icon name="RotateCw" size={14} /> <span style={{ fontSize: '0.7rem' }}>Redo</span>
                                    </button>
                                </div>
                                <button className={`btn ${selectedTool === 'delete' ? 'btn-danger' : 'btn-secondary'}`} onClick={() => { if (selectedIds.size > 0) { updateElements(elements.filter(el => !selectedIds.has(el.id))); setSelectedIds(new Set()); } else { setSelectedTool('delete'); } }} title="Delete" style={{ padding: '0.4rem 0.6rem', display: 'flex', gap: '0.25rem', alignItems: 'center', color: selectedTool === 'delete' ? 'white' : '#ef4444', backgroundColor: selectedTool === 'delete' ? '#ef4444' : 'white', border: '1px solid #ef4444' }}>
                                    <Icon name="Trash" size={14} /> <span style={{ fontSize: '0.8rem' }}>Delete</span>
                                </button>
                                <div style={{ width: '1px', height: '24px', background: '#cbd5e1', margin: '0 0.15rem' }}></div>
                                <button className="btn btn-secondary" onClick={onCancel} style={{ fontSize: '0.8rem', padding: '0.4rem 0.8rem', color: '#1e293b', background: 'white', border: '1px solid #ccc' }}>Cancel</button>
                                <button className="btn btn-primary" onClick={() => onSave({ elements })} style={{ fontSize: '0.8rem', padding: '0.4rem 0.8rem', color: 'white', backgroundColor: '#ef4444', fontWeight: 'bold', border: 'none' }}>
                                    <Icon name="Save" size={14} style={{ marginRight: '4px' }} /> Save
                                </button>
                            </div>

                            {/* --- OVERLAYS (Floating within the toolbar wrap context) --- */}
                            {selectedTool === 'player' && (
                                <div style={{ display: 'flex', gap: '0.25rem', alignItems: 'center', background: '#e2e8f0', padding: '0.25rem', borderRadius: '4px', width: '100%', marginTop: '0.25rem' }}>
                                    {PLAYER_ICONS.map(p => (
                                        <button key={p.label + p.shape} onClick={() => setSelectedPlayerIcon(p)} style={{ width: '24px', height: '24px', borderRadius: '4px', border: selectedPlayerIcon.label === p.label && selectedPlayerIcon.shape === p.shape ? '2px solid var(--accent)' : '1px solid #ccc', background: 'white', fontWeight: 'bold', fontSize: '0.7rem', color: 'black', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>{p.shape === 'star' ? '★' : p.shape === 'target' ? '⌖' : p.label}</button>
                                    ))}
                                    <button className="btn btn-secondary" onClick={handleQuickOffense} title="11-Man Formation" style={{ fontSize: '0.7rem', padding: '0.25rem 0.4rem', color: '#1e293b', background: 'white', border: '1px solid #ccc' }}>⚡ Quick 11</button>
                                    <button className="btn btn-secondary" onClick={handleScoutDefense} title="Scout Defense Formation" style={{ fontSize: '0.7rem', padding: '0.25rem 0.4rem', backgroundColor: '#374151', color: 'white' }}>🛡 Scout Def</button>
                                    <button className="btn btn-secondary" onClick={handleScoutOffense} title="Scout Offense Formation" style={{ fontSize: '0.7rem', padding: '0.25rem 0.4rem', backgroundColor: '#eab308', color: 'black' }}>⚔️ Scout Off</button>
                                    <button className="btn btn-secondary" onClick={handleWizOffense} title="Wiz Skill Colors" style={{ fontSize: '0.7rem', padding: '0.25rem 0.4rem', background: '#e0f2fe', color: '#0369a1', borderColor: '#bae6fd' }}>🎨 Wiz</button>
                                </div>
                            )}

                            {showSaveModal && (
                                <div style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 100 }}>
                                    <div style={{ background: 'white', padding: '1.5rem', borderRadius: '8px', boxShadow: '0 4px 6px rgba(0,0,0,0.1)', width: '300px' }}>
                                        <h3 style={{ marginTop: 0, fontSize: '1.1rem' }}>Save to Library</h3>
                                        <input type="text" className="form-input" placeholder="Enter play name..." value={saveName} onChange={e => setSaveName(e.target.value)} style={{ width: '100%', marginBottom: '1rem', background: 'white', color: 'black' }} autoFocus />
                                        <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '0.5rem' }}>
                                            <button className="btn btn-secondary" onClick={() => setShowSaveModal(false)}>Cancel</button>
                                            <button className="btn btn-primary" onClick={confirmSave} disabled={!saveName}>Save</button>
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>

                        {/* Help Text */}
                        <div style={{ background: '#fff', borderBottom: '1px solid #eee', padding: '0.25rem 1rem', fontSize: '0.75rem', color: '#666', display: 'flex', justifyContent: 'center' }}>
                            {selectedTool === 'line' ? 'Tip: Click to start • Click to turn corner • Double-Click to finish' :
                                selectedTool === 'player' ? 'Tip: Drag icons to move • Click on field to add new' : 'Drag to draw'}
                        </div>

                        {/* Canvas */}
                        <div style={{
                            flex: 1,
                            position: 'relative',
                            background: '#e5e7eb',
                            cursor: selectedTool === 'delete' ? 'no-drop' : (selectedTool === 'player' ? 'default' : 'crosshair'),
                            overflow: 'hidden',
                            display: 'flex',
                            justifyContent: 'center',
                            alignItems: 'center'
                        }}>
                            {/* Inner container with correct aspect ratio for WIZ Card mode */}
                            <div style={{
                                width: fieldViewMode === 'wiz-card' ? 'auto' : '100%',
                                height: fieldViewMode === 'wiz-card' ? '100%' : '100%',
                                aspectRatio: fieldViewMode === 'wiz-card' ? '800 / 460' : 'auto',
                                maxWidth: '100%',
                                maxHeight: '100%',
                                background: '#ffffff',
                                boxShadow: fieldViewMode === 'wiz-card' ? '0 4px 6px -1px rgba(0, 0, 0, 0.1)' : 'none'
                            }}>
                                <svg
                                    ref={svgRef}
                                    width="100%"
                                    height="100%"
                                    viewBox={fieldViewMode === 'wiz-card' ? '0 60 800 460' : '0 0 900 600'}
                                    preserveAspectRatio="none"
                                    onMouseDown={handleMouseDown}
                                    onMouseMove={handleMouseMove}
                                    onMouseUp={handleMouseUp}
                                    onDoubleClick={handleDoubleClick}
                                    onMouseLeave={handleMouseUp}
                                >
                                <defs>
                                    {COLORS.map(c => (
                                        <marker key={c} id={`arrowhead-${c}`} markerWidth="6" markerHeight="4" refX="5" refY="2" orient="auto">
                                            <polygon points="0 0, 6 2, 0 4" fill={c} />
                                        </marker>
                                    ))}
                                    {/* Grid Pattern */}
                                    <pattern id="grid" width="100" height="100" patternUnits="userSpaceOnUse">
                                        <path d="M 100 0 L 0 0 0 100" fill="none" stroke="#f0f0f0" strokeWidth="1" />
                                    </pattern>
                                </defs>

                                {/* Field Background Logic */}
                                {mode === 'detailed' ? (
                                    <g>
                                        <rect width="100%" height="100%" fill="white" />
                                        {/* Detailed grid/field lines (High School Specs) */}
                                        {/* Field Width 53.33 yards = 800px => 15px/yard */}
                                        {/* Hashes: Equal Thirds => 17.78 yds from sideline => 266.6px */}
                                        {/* Numbers: Top of numbers 9 yards from sideline => 135px */}

                                        {[0, 1, 2, 3, 4, 5, 6, 7].map(i => {
                                            // Lines every 5 yards (75px)
                                            // LOS at 350
                                            const y = 50 + (i * 75); // 50, 125, 200, 275, 350, 425, 500

                                            return (
                                                <g key={i}>
                                                    {/* Yard Line */}
                                                    <line x1="0" y1={y} x2="800" y2={y} stroke={y === 350 ? "#000" : "#e2e8f0"} strokeWidth={y === 350 ? 3 : 2} />

                                                    {/* High School Hashes (Thirds) */}
                                                    <line x1="266" y1={y - 8} x2="266" y2={y + 8} stroke="#000" strokeWidth="2" />
                                                    <line x1="534" y1={y - 8} x2="534" y2={y + 8} stroke="#000" strokeWidth="2" />

                                                    {/* Yard Numbers (Contrast Fixed) */}
                                                    {Math.abs(350 - y) % 150 === 0 && y !== 350 && (
                                                        <React.Fragment>
                                                            <text x="135" y={y + 8} fill="#64748b" fontSize="24" fontWeight="bold" textAnchor="middle" style={{ opacity: 0.6 }}>{(350 - y) / 15}</text>
                                                            <text x="665" y={y + 8} fill="#64748b" fontSize="24" fontWeight="bold" textAnchor="middle" style={{ opacity: 0.6 }}>{(350 - y) / 15}</text>
                                                        </React.Fragment>
                                                    )}
                                                </g>
                                            );
                                        })}
                                        {/* LOS Marker */}
                                        <text x="20" y="345" fontSize="12" fontWeight="bold" fill="#000">LOS</text>
                                        <text x="780" y="345" fontSize="12" fontWeight="bold" fill="#000" textAnchor="end">LOS</text>
                                    </g>
                                ) : mode === 'wiz-oline' ? (
                                    <g>
                                        <rect width="100%" height="100%" fill="white" />
                                        {/* No grid lines or yard markers for Wiz OL */}
                                    </g>
                                ) : (
                                    <g>
                                        {/* Simple/Wiz Field */}
                                        <rect width="100%" height="100%" fill="white" />
                                        <rect width="100%" height="100%" fill="url(#grid)" />

                                        {/* Yard Lines - Dynamic based on field position */}
                                        {(() => {
                                            // fieldPosition is 0-100 (yards from own goal line)
                                            // LOS is at y=340 (center of 25-yard window)
                                            // Each 100px = 5 yards
                                            // Show 25 yards total (12.5 yards back, 12.5 yards forward from LOS)

                                            const yardLines = [];
                                            const startYard = Math.max(0, fieldPosition - 10); // 10 yards back from LOS
                                            const endYard = Math.min(100, fieldPosition + 15); // 15 yards forward from LOS

                                            // Generate yard lines every 5 yards
                                            for (let yard = Math.ceil(startYard / 5) * 5; yard <= endYard; yard += 5) {
                                                const yardsFromLOS = yard - fieldPosition;
                                                const yPos = 340 - (yardsFromLOS * 20); // 20px per yard (100px = 5 yards)

                                                if (yPos < 0 || yPos > 480) continue; // Skip if outside canvas

                                                // Determine yard label
                                                let label;
                                                if (yard === 0) label = 'GL'; // Own goal line
                                                else if (yard === 100) label = 'GL'; // Opponent goal line
                                                else if (yard === 50) label = '50';
                                                else if (yard < 50) label = `${yard}`;
                                                else label = `${100 - yard}`;

                                                const isLOS = yard === fieldPosition;
                                                const isMajor = yard % 10 === 0;
                                                const isGoalLine = yard === 0 || yard === 100;

                                                yardLines.push(
                                                    <g key={yard}>
                                                        <line
                                                            x1="0"
                                                            y1={yPos}
                                                            x2="100%"
                                                            y2={yPos}
                                                            stroke={isGoalLine ? '#dc2626' : isLOS ? '#000' : isMajor ? '#000' : '#ccc'}
                                                            strokeWidth={isLOS ? 3 : isGoalLine ? 2 : 1}
                                                            strokeDasharray={isMajor || isGoalLine || isLOS ? 'none' : '5,5'}
                                                        />
                                                        <text x="20" y={yPos - 5} fontSize="12" fill={isGoalLine ? '#dc2626' : '#666'}>
                                                            {isLOS ? `LOS (${label})` : label}
                                                        </text>
                                                        <text x="780" y={yPos - 5} fontSize="12" fill={isGoalLine ? '#dc2626' : '#666'} textAnchor="end">
                                                            {isLOS ? `LOS (${label})` : label}
                                                        </text>
                                                    </g>
                                                );
                                            }

                                            // Add end zone shading if in red zone
                                            if (fieldPosition >= 80) {
                                                const goalLineYard = 100;
                                                const yardsFromLOS = goalLineYard - fieldPosition;
                                                const goalLineY = 340 - (yardsFromLOS * 20);

                                                if (goalLineY >= 0 && goalLineY <= 480) {
                                                    yardLines.push(
                                                        <rect
                                                            key="endzone"
                                                            x="0"
                                                            y="0"
                                                            width="100%"
                                                            height={goalLineY}
                                                            fill="#dc2626"
                                                            opacity="0.1"
                                                        />
                                                    );
                                                }
                                            }

                                            return yardLines;
                                        })()}

                                        {/* Hash Marks - High School Field (53.3 yards wide, hash marks at thirds = 17.77 yards from sideline) */}
                                        {/* Canvas width is 800px, so: */}
                                        {/* Left hash: 800 * (17.77/53.3) = 267px */}
                                        {/* Right hash: 800 * (35.53/53.3) = 533px */}
                                        {(() => {
                                            const hashMarks = [];
                                            const startYard = Math.max(0, fieldPosition - 10);
                                            const endYard = Math.min(100, fieldPosition + 15);

                                            // Generate hash marks every 5 yards
                                            for (let yard = Math.ceil(startYard / 5) * 5; yard <= endYard; yard += 5) {
                                                const yardsFromLOS = yard - fieldPosition;
                                                const yPos = 340 - (yardsFromLOS * 20);

                                                if (yPos < 0 || yPos > 480) continue;

                                                hashMarks.push(
                                                    <g key={`hash-${yard}`}>
                                                        <line x1="267" y1={yPos - 8} x2="267" y2={yPos + 8} stroke="#000" strokeWidth="2" />
                                                        <line x1="533" y1={yPos - 8} x2="533" y2={yPos + 8} stroke="#000" strokeWidth="2" />
                                                    </g>
                                                );
                                            }
                                            return hashMarks;
                                        })()}

                                        {/* Field Numbers - 9 yards from sideline, facing outward */}
                                        {/* Left numbers: 800 * (9/53.3) = 135px */}
                                        {/* Right numbers: 800 * (44.3/53.3) = 665px */}
                                        {(() => {
                                            const fieldNumbers = [];
                                            const startYard = Math.max(0, fieldPosition - 10);
                                            const endYard = Math.min(100, fieldPosition + 15);

                                            // Generate field numbers every 10 yards
                                            for (let yard = Math.ceil(startYard / 10) * 10; yard <= endYard; yard += 10) {
                                                if (yard === 0 || yard === 100) continue; // Skip goal lines

                                                const yardsFromLOS = yard - fieldPosition;
                                                const yPos = 340 - (yardsFromLOS * 20);

                                                if (yPos < 20 || yPos > 460) continue; // Keep numbers away from edges

                                                // Determine label
                                                let label;
                                                if (yard === 50) label = '50';
                                                else if (yard < 50) label = `${yard}`;
                                                else label = `${100 - yard}`;

                                                fieldNumbers.push(
                                                    <g key={`num-${yard}`}>
                                                        {/* Left side number (rotated 90° to face left sideline) */}
                                                        <text
                                                            x="135"
                                                            y={yPos}
                                                            fontSize="24"
                                                            fontWeight="bold"
                                                            fill="#999"
                                                            textAnchor="middle"
                                                            transform={`rotate(90, 135, ${yPos})`}
                                                        >
                                                            {label}
                                                        </text>
                                                        {/* Right side number (rotated 270° to face right sideline) */}
                                                        <text
                                                            x="665"
                                                            y={yPos}
                                                            fontSize="24"
                                                            fontWeight="bold"
                                                            fill="#999"
                                                            textAnchor="middle"
                                                            transform={`rotate(270, 665, ${yPos})`}
                                                        >
                                                            {label}
                                                        </text>
                                                    </g>
                                                );
                                            }
                                            return fieldNumbers;
                                        })()}
                                    </g>
                                )}

                                {/* WIZ Card Boundary Guides - shown when in wiz-skill mode with Full Field view to indicate what will be visible on printed WIZ cards */}
                                {mode === 'wiz-skill' && fieldViewMode === 'standard' && (
                                    <g>
                                        {/* Dimmed areas outside WIZ card visible bounds (y < 60 and y > 520) */}
                                        <rect x="0" y="0" width="900" height="60" fill="rgba(0,0,0,0.15)" />
                                        <rect x="0" y="520" width="900" height="80" fill="rgba(0,0,0,0.15)" />
                                        <rect x="800" y="60" width="100" height="460" fill="rgba(0,0,0,0.15)" />

                                        {/* Border showing exact WIZ card visible area (0-800 x, 60-520 y) */}
                                        <rect
                                            x="0"
                                            y="60"
                                            width="800"
                                            height="460"
                                            fill="none"
                                            stroke="#22c55e"
                                            strokeWidth="2"
                                            strokeDasharray="8,4"
                                        />

                                        {/* Label for visible area */}
                                        <text x="10" y="75" fontSize="10" fill="#22c55e" fontWeight="bold">WIZ Card Visible Area</text>
                                    </g>
                                )}

                                {elements.map(el => renderElement(el))}

                                {/* Selection Box */}
                                {selectionBox && (
                                    <rect
                                        x={Math.min(selectionBox.start.x, selectionBox.current.x)}
                                        y={Math.min(selectionBox.start.y, selectionBox.current.y)}
                                        width={Math.abs(selectionBox.current.x - selectionBox.start.x)}
                                        height={Math.abs(selectionBox.current.y - selectionBox.start.y)}
                                        fill="rgba(59, 130, 246, 0.1)"
                                        stroke="#3b82f6"
                                        strokeWidth="1"
                                        strokeDasharray="4,2"
                                        style={{ pointerEvents: 'none' }}
                                    />
                                )}

                                {/* Drawing Path Preview */}
                                {currentPath && renderElement(currentPath, true)}
                            </svg>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // Play Name Parser Utility
        const parsePlayName = (playName) => {
            if (!playName || typeof playName !== 'string') {
                return { numbers: [], formations: [], directions: [], tags: [], special: [], quoted: [], unassigned: [], orderedTokens: [] };
            }

            const result = {
                numbers: [],
                formations: [],
                directions: [],
                tags: [],
                special: [],
                quoted: [],
                unassigned: [],
                orderedTokens: []
            };

            const formationPatterns = [
                'DIAMOND', 'BUNCH', 'GRN', 'GREEN', 'RED', 'BLUE', 'BRT', 'BRIGHT',
                'ORNG', 'ORANGE', 'GOLD', 'BRN', 'BROWN', 'METAL', 'OVER', 'TANK'
            ];
            const directionPatterns = ['RT', 'LT', 'RIP', 'LIZ', 'RN'];
            const tagPatterns = [
                'GAMBLE', 'BOOMER', 'KNIFE', 'SMOKE', 'WILLY', 'CAPONE', 'SUPER', 'RPO',
                'STICK', 'JET', 'RICE', 'SHALLOW', 'LEAK', 'GOT7', 'ARC', 'MUSTANG',
                'SALT', 'VEER', 'STASH', 'MICKEY', 'CROSS', 'SHARK', 'DITCH', 'JUKE',
                'OPTION', 'WHEEL', 'SMASH', 'SWING', 'FIST', 'INVERTED', 'SPECIAL',
                'BULLS', 'TAG', 'DEPOT', 'NOLES'
            ];

            // Ordered tokenization
            const tokens = [];
            let current = "";
            let inQuotes = false;

            for (let i = 0; i < playName.length; i++) {
                const char = playName[i];
                if (char === '"') {
                    if (inQuotes) {
                        tokens.push(current);
                        current = "";
                        inQuotes = false;
                    } else {
                        if (current.trim()) tokens.push(current.trim());
                        current = "";
                        inQuotes = true;
                    }
                } else if (!inQuotes && (/\s/.test(char) || ['+', '*', '(', ')'].includes(char))) {
                    if (current.trim()) tokens.push(current.trim());
                    if (['+', '*', '(', ')'].includes(char)) tokens.push(char);
                    current = "";
                } else {
                    current += char;
                }
            }
            if (current.trim()) tokens.push(current.trim());

            tokens.forEach(token => {
                const upperToken = token.toUpperCase().trim();
                let type = 'unassigned';

                if (!upperToken) return;

                if (/^\d+[A-Z]?$/.test(upperToken)) {
                    type = 'number';
                    result.numbers.push(token);
                } else if (formationPatterns.includes(upperToken)) {
                    type = 'formation';
                    result.formations.push(token);
                } else if (directionPatterns.includes(upperToken)) {
                    type = 'direction';
                    result.directions.push(token);
                } else if (tagPatterns.includes(upperToken)) {
                    type = 'tag';
                    result.tags.push(token);
                } else if (['+', '*', '(', ')'].includes(token)) {
                    type = 'special';
                    result.special.push(token);
                } else if (playName.includes(`"${token}"`)) {
                    type = 'quoted';
                    result.quoted.push(token);
                } else {
                    type = 'unassigned';
                    result.unassigned.push(token);
                }

                result.orderedTokens.push({ text: token, type });
            });

            return result;
        };


        const PlayInput = ({ onSave, onCancel, onDelete, initialData, availableMiniScripts = [], initialAssignedScriptIds = [], wizLibrary, setWizLibrary, formations = [], positionNames = {}, playSyntax = [], termLibrary = {}, programLevels = ['Varsity', 'JV', 'JV2'], drills = [], playBuckets = [], playCategories = [], onAddFormation = () => { } }) => {
            const [isDiagramming, setIsDiagramming] = useState(false);
            const [activeScenarioId, setActiveScenarioId] = useState(null); // ID of scenario being edited
            const [activeDiagramMode, setActiveDiagramMode] = useState(null); // null, 'wiz-oline', 'wiz-skill', 'detailed'
            const [formData, setFormData] = useState({
                playCategory: '', // Existing field
                bucketId: '', // [NEW] Play Bucket ID
                formation: '',
                formationTag: '',
                name: '',
                color: '',
                motion: '',
                playAction: false,
                tag1: '',
                tag2: '',
                tags: [],
                levelTags: [], // [NEW] Level Tagging
                image: null,
                diagramData: null, // New: Diagram elements
                wizOlineData: null, // O-Line Wiz
                wizOlineMode: 'diagram', // 'diagram' or 'image'
                wizSkillData: null, // Skill Wiz
                wizSkillMode: 'diagram', // 'diagram' or 'image'
                wizSkillImage: null,
                scenarios: [], // Array of Detailed Scenarios
                activeScenarioId: null, // ID of scenario being edited
                wristbandSlot: '',
                staplesSlot: '', // [NEW] Staples Wristband Slot (10-89)
                // New call sheet fields
                playType: '', // Fastball, Curveball, Change Up, Strikeout
                actionTypes: [], // Array: Strong Run, Weak Run, Quick Game, etc.
                hashPreference: 'Any', // Left, Right, Middle, Any
                baseType: '', // Run, Pass, RPO, Gadget
                fieldZones: [], // Array: Fringe, Red Zone, Gold Zone, Goal Line
                downDistance: [], // Array: from existing tags
                sequenceName: '', // Look-alike sequence
                sequenceOrder: '', // Order in sequence
                assignedScriptIds: initialAssignedScriptIds, // New: Tracks mini script assignments
                // Extended "Play Call Chain" fields
                scramble: '',
                show: '',
                concept: '',
                backsideTag: '',
                navTag: '',
                autoCompleteValues: {}, // For suggestions
                syntaxValues: {}, // Keep existing syntax values just in case
                ...(() => {
                    const merged = { ...initialData };
                    // Migration for backward compatibility
                    if (merged.wizOlineData || merged.rooskiOlineData) merged.wizOlineData = merged.wizOlineData || merged.rooskiOlineData;
                    if (merged.wizSkillData || merged.rooskiSkillData) merged.wizSkillData = merged.wizSkillData || merged.rooskiSkillData;
                    if (merged.wizOlineMode || merged.rooskiMode) merged.wizOlineMode = merged.wizOlineMode || merged.rooskiMode;
                    if (merged.wizSkillMode || merged.rooskiSkillMode) merged.wizSkillMode = merged.wizSkillMode || merged.rooskiSkillMode;
                    if (merged.wizOlineImage || merged.rooskiImage) merged.wizOlineImage = merged.wizOlineImage || merged.rooskiImage;
                    return merged;
                })()
            });

            // Play Name Parser State
            const [parsedComponents, setParsedComponents] = useState(null);
            const [draggedComponent, setDraggedComponent] = useState(null);
            const [usedComponents, setUsedComponents] = useState(new Set());

            // Parse play name when it changes
            useEffect(() => {
                if (formData.name && formData.name.trim()) {
                    const parsed = parsePlayName(formData.name);
                    setParsedComponents(parsed);
                } else {
                    setParsedComponents(null);
                }
            }, [formData.name]);




            // Auto-calculate Name and Formation when Syntax Values change
            useEffect(() => {
                if (playSyntax && playSyntax.length > 0) {
                    // 1. Calculate Name: Join all values
                    const nameParts = playSyntax.map(s => (formData.syntaxValues && formData.syntaxValues[s.id])).filter(v => v);
                    const newName = nameParts.join(' ').toUpperCase();

                    // 2. Extract Formation: Find component with label containing "Formation"
                    const formationComp = playSyntax.find(s => s.label.toLowerCase().includes('formation'));
                    const newFormation = formationComp ? ((formData.syntaxValues && formData.syntaxValues[formationComp.id]) || '') : formData.formation;

                    setFormData(prev => {
                        // FIX: If no syntax values are selected (nameParts empty), DO NOT wipe out the existing name.
                        if (nameParts.length === 0) return prev;

                        // Only update if changed to avoid loops
                        if (prev.name === newName && prev.formation === newFormation) return prev;

                        // GUARD: If we are in "parsing mode" (have used some components but not all), 
                        // do not overwrite the full name with just the currently assigned parts.
                        // This prevents the "disappearing tags" issue.
                        const totalParsable = parsedComponents?.orderedTokens?.filter(t => t.type !== 'special')?.length || 0;
                        if (usedComponents.size > 0 && usedComponents.size < totalParsable) {
                            return { ...prev, formation: newFormation };
                        }

                        return { ...prev, name: newName, formation: newFormation };
                    });
                }
            }, [formData.syntaxValues, playSyntax, usedComponents.size, parsedComponents]);

            // If initialData has diagramData but no image, we can render it? 
            // Currently the system uses 'image' for display. We might need to generate an SVG string as image or support rendering diagramData.
            // For now, let's allow saving and editing.

            const handleSaveDiagram = (data) => {
                try {
                    // CRITICAL DEBUG: Confirm function is called
                    window.alert("handleSaveDiagram CALLED! Data keys: " + (data ? Object.keys(data).join(',') : 'null'));

                    // Initialize sync objects
                    const newPlayerNotes = { ...(formData.playerNotes || {}) };
                    const newPlayerLinks = { ...(formData.playerLinks || {}) };

                    if (data && data.elements) {
                        const players = data.elements.filter(el => el.type === 'player');
                        // Find potential link lines (drills)
                        const links = data.elements.filter(el => (el.link || el.conceptLabel) &&
                            ['line', 'curve', 'zigzag', 'poly', 'free'].includes(el.type) &&
                            el.points && el.points.length > 0
                        );

                        // DEBUG: Confirm data discovery
                        window.alert(`Saving... Found ${players.length} players and ${links.length} potential links.`);

                        players.forEach(player => {
                            if (!player.points || !player.points[0]) return;
                            const pPos = player.points[0];

                            // Find lines starting OR ending near this player (within 80px)
                            const relevantLink = links.find(link => {
                                if (!link.points || link.points.length === 0) return false;
                                const startPoint = link.points[0];
                                const endPoint = link.points[link.points.length - 1];

                                const distStart = Math.sqrt(Math.pow(startPoint.x - pPos.x, 2) + Math.pow(startPoint.y - pPos.y, 2));
                                const distEnd = Math.sqrt(Math.pow(endPoint.x - pPos.x, 2) + Math.pow(endPoint.y - pPos.y, 2));

                                return distStart < 80 || distEnd < 80;
                            });

                            if (relevantLink) {
                                // Sync Note Text (Label)
                                const noteText = relevantLink.conceptLabel;
                                if (noteText) {
                                    newPlayerNotes[player.label] = noteText;
                                }

                                // Sync Link URL
                                if (relevantLink.link) {
                                    newPlayerLinks[player.label] = relevantLink.link;
                                }
                            }
                        });
                    }

                    // Update State
                    setFormData(prev => ({
                        ...prev,
                        diagramData: data,
                        playerNotes: newPlayerNotes,
                        playerLinks: newPlayerLinks
                    }));

                } catch (e) {
                    console.error("Save Error:", e);
                    window.alert("Save Error: " + e.message);
                } finally {
                    setIsDiagramming(false);
                }

                // Optional: Generate a thumbnail image from the diagram? 
                // Simple SVG data URI approach
                // Note: Converting elements to SVG string
                const svgContent = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="900" height="600" viewBox="0 0 900 600" style="background: white">
                        <g opacity="0.1">
                                    <line x1="0" y1="10%" x2="100%" y2="10%" stroke="#000" stroke-width="2" />
                                    <line x1="0" y1="30%" x2="100%" y2="30%" stroke="#000" stroke-width="2" />
                                    <line x1="0" y1="50%" x2="100%" y2="50%" stroke="#000" stroke-width="4" />
                                    <line x1="0" y1="70%" x2="100%" y2="70%" stroke="#000" stroke-width="2" />
                                    <line x1="0" y1="90%" x2="100%" y2="90%" stroke="#000" stroke-width="2" />
                        </g>
                        ${data.elements.map(el => {
                    let d = '';
                    if (el.type === 'free') {
                        d = `M ${el.points.map(p => `${p.x},${p.y}`).join(' L ')}`;
                    } else {
                        const start = el.points[0];
                        const end = el.points[el.points.length - 1];
                        d = `M ${start.x},${start.y} L ${end.x},${end.y}`;
                    }
                    // Markers are tricky in data URI without definitions.
                    // Simply defining markers in the SVG string
                    return `<path d="${d}" stroke="${el.color}" stroke-width="4" fill="none" stroke-dasharray="${el.style === 'dashed' ? '10,5' : 'none'}" />`;
                }).join('')}
                    </svg>
                `;
                const encoded = 'data:image/svg+xml;base64,' + btoa(svgContent);
                // setFormData(prev => ({ ...prev, diagramData: data, image: encoded })); // Use this if we want to preview it as image
                // Actually, let's keep diagramData separate and prefer it for rendering if available, falling back to image.
            };

            const toggleTag = (tag) => {
                setFormData(prev => ({
                    ...prev,
                    tags: prev.tags.includes(tag)
                        ? prev.tags.filter(t => t !== tag)
                        : [...prev.tags, tag]
                }));
            };

            const toggleLevelTag = (tag) => {
                setFormData(prev => ({
                    ...prev,
                    levelTags: (prev.levelTags || []).includes(tag)
                        ? prev.levelTags.filter(t => t !== tag)
                        : [...(prev.levelTags || []), tag]
                }));
            };

            const toggleActionType = (type) => {
                setFormData(prev => ({
                    ...prev,
                    actionTypes: prev.actionTypes.includes(type)
                        ? prev.actionTypes.filter(t => t !== type)
                        : [...prev.actionTypes, type]
                }));
            };

            const toggleFieldZone = (zone) => {
                setFormData(prev => ({
                    ...prev,
                    fieldZones: prev.fieldZones.includes(zone)
                        ? prev.fieldZones.filter(z => z !== zone)
                        : [...prev.fieldZones, zone]
                }));
            };

            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        setFormData(prev => ({ ...prev, image: reader.result, diagramData: null })); // Clear diagramData if image is uploaded
                    };
                    reader.readAsDataURL(file);
                }
            };

            const handleSkillImageUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        setFormData(prev => ({ ...prev, wizSkillImage: reader.result }));
                    };
                    reader.readAsDataURL(file);
                }
            };

            // SCENARIO HELPERS
            const handleAddScenario = () => {
                const newScenario = {
                    id: Date.now(),
                    front: 'Over',
                    coverage: 'Cover 3',
                    diagramData: null,
                    notes: { 'QB': '', 'RB': '', 'X': '', 'Z': '', 'Y': '', 'F': '', 'OL': '' }
                };
                setFormData(prev => ({
                    ...prev,
                    scenarios: [...(prev.scenarios || []), newScenario]
                }));
                setActiveScenarioId(newScenario.id); // Auto-select
            };

            const handleUpdateScenario = (id, field, value) => {
                setFormData(prev => ({
                    ...prev,
                    scenarios: prev.scenarios.map(s => s.id === id ? { ...s, [field]: value } : s)
                }));
            };

            const handleUpdateScenarioNote = (id, player, note) => {
                setFormData(prev => ({
                    ...prev,
                    scenarios: prev.scenarios.map(s => s.id === id ? {
                        ...s,
                        notes: { ...s.notes, [player]: note }
                    } : s)
                }));
            };

            const handleDeleteScenario = (id) => {
                if (window.confirm('Delete this scenario?')) {
                    setFormData(prev => ({
                        ...prev,
                        scenarios: prev.scenarios.filter(s => s.id !== id)
                    }));
                    if (activeScenarioId === id) setActiveScenarioId(null);
                }
            };


            // Drag-and-Drop Handlers
            const handleDragStart = (component, type) => {
                setDraggedComponent({ text: component, type: type });
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            };

            const handleDrop = (e, targetField) => {
                e.preventDefault();
                // Generic handler for all fields
                if (draggedComponent) {
                    const { text } = draggedComponent;
                    setFormData(prev => ({
                        ...prev,
                        [targetField]: text
                    }));
                    setUsedComponents(prev => new Set(prev).add(text));
                    setDraggedComponent(null);
                } else {
                    // Fallback for native text selection drag
                    const text = e.dataTransfer.getData("text/plain");
                    if (text) {
                        setFormData(prev => ({
                            ...prev,
                            [targetField]: text
                        }));
                    }
                }
            };

            const handleSubmit = (e) => {
                e.preventDefault();
                onSave({ ...formData, id: formData.id || Date.now().toString() });
            };

            const handleDelete = () => {
                if (window.confirm('Are you sure you want to delete this play? This cannot be undone.')) {
                    onDelete(formData.id);
                }
            };

            const renderDiagramPreview = (elements, useWizCardView = false) => {
                if (!elements || elements.length === 0) return (
                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', height: '100%', color: 'var(--text-secondary)', gap: '0.5rem' }}>
                        <Icon name="Image" size={24} style={{ opacity: 0.5 }} />
                        <span style={{ fontSize: '0.9rem' }}>No Diagram Data</span>
                    </div>
                );

                // Use WIZ card viewBox (0 60 800 460) for skill diagrams to match print output
                const viewBox = useWizCardView ? '0 60 800 460' : '0 0 900 600';

                return (
                    <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox={viewBox} preserveAspectRatio="xMidYMid meet" style={{ background: 'white', borderRadius: '8px' }}>
                        <g opacity="0.1">
                            <line x1="0" y1="10%" x2="100%" y2="10%" stroke="#000" strokeWidth="2" />
                            <line x1="0" y1="30%" x2="100%" y2="30%" stroke="#000" strokeWidth="2" />
                            <line x1="0" y1="50%" x2="100%" y2="50%" stroke="#000" strokeWidth="4" />
                            <line x1="0" y1="70%" x2="100%" y2="70%" stroke="#000" strokeWidth="2" />
                            <line x1="0" y1="90%" x2="100%" y2="90%" stroke="#000" strokeWidth="2" />
                        </g>
                        {elements.map((el, index) => {
                            let d = '';
                            if (el.type === 'free') {
                                if (el.points && el.points.length) {
                                    d = `M ${el.points.map(p => `${p.x},${p.y}`).join(' L ')}`;
                                }
                            } else if (el.points && el.points.length >= 2) { // Determine if line-like
                                const start = el.points[0];
                                const end = el.points[el.points.length - 1];
                                d = `M ${start.x},${start.y} L ${end.x},${end.y}`;
                            } else {
                                // Fallback for simple shapes/players if needed, or skip
                            }

                            // Render text for players/labels
                            if (el.type === 'player' && el.points && el.points[0]) {
                                return (
                                    <text key={index} x={el.points[0].x} y={el.points[0].y} textAnchor="middle" dominantBaseline="middle" fontSize="24" fontWeight="bold" fill={el.color || '#000'}>{el.label}</text>
                                );
                            }
                            if (el.label && el.points && el.points[0]) {
                                // Simple label logic if any
                            }

                            return <path key={index} d={d} stroke={el.color || '#000'} strokeWidth="4" fill="none" strokeDasharray={el.style === 'dashed' ? '10,5' : 'none'} />;
                        })}
                    </svg>
                );
            };

            return (
                <div className="animate-fade-in">
                    {/* Diagram Editor Modal */}
                    {isDiagramming && (
                        <PlayDiagramEditor
                            initialData={formData.diagramData}
                            onSave={handleSaveDiagram}
                            onCancel={() => setIsDiagramming(false)}
                            wizLibrary={wizLibrary}
                            setWizLibrary={setWizLibrary}
                            positionNames={positionNames}
                            onAddFormation={onAddFormation}
                        />
                    )}

                    {/* Wiz O-Line Editor Modal */}
                    {activeDiagramMode === 'wiz-oline' && (
                        <PlayDiagramEditor
                            initialData={formData.wizOlineData ? { elements: formData.wizOlineData } : null}
                            mode="wiz-oline"
                            onSave={(data) => {
                                setFormData({ ...formData, wizOlineData: data.elements });
                                setActiveDiagramMode(null);
                            }}
                            onCancel={() => setActiveDiagramMode(null)}
                            wizLibrary={wizLibrary}
                            setWizLibrary={setWizLibrary}
                            positionNames={positionNames}
                            onAddFormation={onAddFormation}
                        />
                    )}

                    {/* Wiz Skill Editor Modal */}
                    {activeDiagramMode === 'wiz-skill' && (
                        <PlayDiagramEditor
                            initialData={formData.wizSkillData ? { elements: formData.wizSkillData } : null}
                            mode="wiz-skill"
                            formations={formations}
                            onSave={(data) => {
                                setFormData({ ...formData, wizSkillData: data.elements });
                                setActiveDiagramMode(null);
                            }}
                            onCancel={() => setActiveDiagramMode(null)}
                            wizLibrary={wizLibrary}
                            setWizLibrary={setWizLibrary}
                            positionNames={positionNames}
                            onAddFormation={onAddFormation}
                        />
                    )}

                    {/* Detailed Scenario Editor Modal */}
                    {activeDiagramMode === 'detailed' && activeScenarioId && (
                        <PlayDiagramEditor
                            initialData={formData.scenarios.find(s => s.id === activeScenarioId)?.diagramData ? { elements: formData.scenarios.find(s => s.id === activeScenarioId).diagramData } : null}
                            mode="detailed"
                            onSave={(data) => {
                                handleUpdateScenario(activeScenarioId, 'diagramData', data.elements);
                                setActiveDiagramMode(null);
                            }}
                            onCancel={() => setActiveDiagramMode(null)}
                            wizLibrary={wizLibrary}
                            setWizLibrary={setWizLibrary}
                            positionNames={positionNames}
                            onAddFormation={onAddFormation}
                        />
                    )}

                    <div style={{
                        display: 'flex',
                        justifyContent: 'space-between',
                        alignItems: 'center',
                        marginBottom: '1.5rem',
                        position: 'sticky',
                        top: 0,
                        zIndex: 100,
                        backgroundColor: 'var(--bg-app)',
                        padding: '1rem 0',
                        borderBottom: '1px solid var(--border)',
                        marginTop: '-1rem' // Pull up slightly to counteract padding if needed, or just normal flow
                    }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                            <h2 style={{ margin: 0 }}>{initialData ? 'Edit Play' : 'New Play Design'}</h2>
                        </div>
                        <div style={{ display: 'flex', gap: '0.5rem' }}>
                            <button
                                type="button"
                                onClick={onCancel}
                                className="btn btn-secondary"
                            >
                                Cancel
                            </button>
                            <button
                                type="button"
                                onClick={handleSubmit}
                                className="btn btn-primary"
                                style={{
                                    boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)'
                                }}
                            >
                                💾 Save Play
                            </button>
                            {initialData && (
                                <button
                                    type="button"
                                    onClick={handleDelete}
                                    className="btn"
                                    style={{ backgroundColor: 'rgba(239, 68, 68, 0.1)', color: '#ef4444', border: '1px solid #ef4444' }}
                                >
                                    🗑️
                                </button>
                            )}
                        </div>
                    </div>
                    <form onSubmit={handleSubmit}>


                        {/* NEW TOP SECTION: PLAY CALL */}
                        <div style={{ marginBottom: '1.5rem' }}>
                            {playSyntax && playSyntax.length > 0 && (
                                <div style={{ background: 'var(--bg-main)', padding: '1.5rem', borderRadius: '12px', border: '1px solid var(--border)', boxShadow: 'var(--shadow-sm)' }}>
                                    <div style={{ borderBottom: '1px solid var(--border)', paddingBottom: '0.75rem', marginBottom: '1.25rem', fontSize: '1.1rem', fontWeight: '800', color: 'var(--text-primary)', textTransform: 'uppercase', letterSpacing: '0.05em', display: 'flex', alignItems: 'center', gap: '0.75rem' }}>
                                        <Icon name="ClipboardList" size={20} style={{ color: 'var(--accent)' }} />
                                        PLAY CALL
                                    </div>
                                    <div className="form-group" style={{ marginBottom: '1.25rem' }}>
                                        <label className="form-label">Play Call</label>
                                        <input
                                            className="form-input"
                                            value={formData.name}
                                            onChange={e => setFormData({ ...formData, name: e.target.value.toUpperCase() })}
                                            placeholder="e.g. TRIBE / Spider 2 Y Banana"
                                            required
                                        />
                                    </div>
                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginBottom: '1.25rem' }}>
                                        <div className="form-group" style={{ marginBottom: 0 }}>
                                            <label className="form-label">Category</label>
                                            <select
                                                className="form-input"
                                                value={formData.playCategory || ''}
                                                onChange={e => setFormData({ ...formData, playCategory: e.target.value, bucketId: '' })}
                                            >
                                                <option value="">Select Category...</option>
                                                {playCategories.map(cat => (
                                                    <option key={cat.id} value={cat.id}>{cat.label}</option>
                                                ))}
                                            </select>
                                        </div>
                                        <div className="form-group" style={{ marginBottom: 0 }}>
                                            <label className="form-label">Play Family</label>
                                            <select
                                                className="form-input"
                                                value={formData.bucketId || ''}
                                                onChange={e => setFormData({ ...formData, bucketId: e.target.value })}
                                                disabled={!formData.playCategory}
                                            >
                                                <option value="">Select Play Family...</option>
                                                {playBuckets
                                                    .filter(b => b.categoryId === formData.playCategory)
                                                    .map(bucket => (
                                                        <option key={bucket.id} value={bucket.id}>{bucket.label}</option>
                                                    ))
                                                }
                                            </select>
                                        </div>
                                    </div>
                                    <div className="form-group" style={{ marginBottom: '1.25rem' }}>
                                        <label className="form-label">Wiz / Short Name <span style={{ fontSize: '0.8em', color: '#64748b', fontWeight: 'normal' }}>(Optional)</span></label>
                                        <input
                                            className="form-input"
                                            value={formData.wizName || ''}
                                            onChange={e => setFormData({ ...formData, wizName: e.target.value })}
                                            placeholder="Short name for 4x4 grids..."
                                        />
                                    </div>
                                    {/* Draggable Parsed Components */}
                                    {parsedComponents && (
                                        <div style={{ marginBottom: '1rem', padding: '0.75rem', background: '#f8fafc', border: '1px solid #e2e8f0', borderRadius: '8px' }}>
                                            <div style={{ fontSize: '0.85rem', fontWeight: 'bold', marginBottom: '0.5rem', color: '#64748b' }}>
                                                Parsed Components (drag to fields below)
                                            </div>
                                            <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.5rem' }}>
                                                {parsedComponents.orderedTokens && parsedComponents.orderedTokens.map((token, idx) => {
                                                    const isUsed = usedComponents.has(token.text);
                                                    if (isUsed || token.type === 'special') return null;

                                                    // Use the same color scheme as before
                                                    let bgColor = '#94a3b8'; // unassigned
                                                    if (token.type === 'number') bgColor = '#3b82f6';
                                                    else if (token.type === 'formation') bgColor = '#10b981';
                                                    else if (token.type === 'direction') bgColor = '#f97316';
                                                    else if (token.type === 'tag') bgColor = '#8b5cf6';
                                                    else if (token.type === 'quoted') bgColor = '#6b7280';

                                                    return (
                                                        <div
                                                            key={`${token.text}-${idx}`}
                                                            draggable
                                                            onDragStart={() => handleDragStart(token.text, token.type)}
                                                            style={{
                                                                padding: '0.25rem 0.65rem',
                                                                background: bgColor,
                                                                color: 'white',
                                                                borderRadius: '4px',
                                                                fontSize: '0.85rem',
                                                                fontWeight: '600',
                                                                cursor: 'grab',
                                                                userSelect: 'none',
                                                                boxShadow: '0 1px 2px rgba(0,0,0,0.1)'
                                                            }}
                                                        >
                                                            {token.type === 'quoted' ? `"${token.text}"` : token.text}
                                                        </div>
                                                    );
                                                })}
                                                {(!parsedComponents.orderedTokens || parsedComponents.orderedTokens.filter(t => t.type !== 'special' && !usedComponents.has(t.text)).length === 0) && (
                                                    <div style={{ fontSize: '0.8rem', color: '#94a3b8', fontStyle: 'italic' }}>
                                                        All components assigned or no components found
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    )}
                                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))', gap: '1.25rem' }}>
                                        {playSyntax.map(comp => (
                                            <div key={comp.id} className="form-group" style={{ margin: 0 }}>
                                                <label className="form-label">{comp.label}</label>
                                                <input
                                                    className="form-input"
                                                    list={`terms-${comp.id}`}
                                                    value={formData.syntaxValues?.[comp.id] || ''}
                                                    onDragOver={handleDragOver}
                                                    onDrop={(e) => {
                                                        e.preventDefault();
                                                        if (draggedComponent) {
                                                            const { text } = draggedComponent;
                                                            setFormData(prev => ({
                                                                ...prev,
                                                                syntaxValues: {
                                                                    ...(prev.syntaxValues || {}),
                                                                    [comp.id]: text
                                                                }
                                                            }));
                                                            setUsedComponents(prev => new Set(prev).add(text));
                                                            setDraggedComponent(null);
                                                        } else {
                                                            const text = e.dataTransfer.getData("text/plain");
                                                            if (text) {
                                                                setFormData(prev => ({
                                                                    ...prev,
                                                                    syntaxValues: {
                                                                        ...(prev.syntaxValues || {}),
                                                                        [comp.id]: text
                                                                    }
                                                                }));
                                                            }
                                                        }
                                                    }}
                                                    onChange={e => {
                                                        const newVal = e.target.value;
                                                        setFormData(prev => ({
                                                            ...prev,
                                                            syntaxValues: {
                                                                ...(prev.syntaxValues || {}),
                                                                [comp.id]: newVal
                                                            }
                                                        }));
                                                    }}
                                                    placeholder={`Select or typing ${comp.label}...`}
                                                />
                                                <datalist id={`terms-${comp.id}`}>
                                                    {termLibrary[comp.id]?.map(t => (
                                                        <option key={t.id} value={t.label} />
                                                    ))}
                                                </datalist>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}

                            {(!playSyntax || playSyntax.length === 0) && (
                                <div style={{ background: 'var(--bg-main)', padding: '1.5rem', borderRadius: '12px', border: '1px solid var(--border)', boxShadow: 'var(--shadow-sm)' }}>
                                    <div style={{ borderBottom: '1px solid var(--border)', paddingBottom: '0.75rem', marginBottom: '1.25rem', fontSize: '1.1rem', fontWeight: '800', color: 'var(--text-primary)', textTransform: 'uppercase', letterSpacing: '0.05em', display: 'flex', alignItems: 'center', gap: '0.75rem' }}>
                                        <Icon name="ClipboardList" size={20} style={{ color: 'var(--accent)' }} />
                                        PLAY CALL
                                    </div>
                                    <div className="form-group" style={{ marginBottom: '1.25rem' }}>
                                        <label className="form-label">Play Call</label>
                                        <input
                                            className="form-input"
                                            value={formData.name}
                                            onChange={e => setFormData({ ...formData, name: e.target.value.toUpperCase() })}
                                            placeholder="e.g. TRIBE / Spider 2 Y Banana"
                                            required
                                        />
                                    </div>
                                    <div className="form-group" style={{ marginBottom: '1.25rem' }}>
                                        <label className="form-label">Wiz / Short Name <span style={{ fontSize: '0.8em', color: '#64748b', fontWeight: 'normal' }}>(Optional)</span></label>
                                        <input
                                            className="form-input"
                                            value={formData.wizName || ''}
                                            onChange={e => setFormData({ ...formData, wizName: e.target.value })}
                                            placeholder="Short name for 4x4 grids..."
                                        />
                                    </div>

                                    {parsedComponents && (
                                        <div style={{ marginBottom: '1rem', padding: '0.75rem', background: '#f8fafc', border: '1px solid #e2e8f0', borderRadius: '8px' }}>
                                            <div style={{ fontSize: '0.85rem', fontWeight: 'bold', marginBottom: '0.5rem', color: '#64748b' }}>
                                                Parsed Components (drag to fields below)
                                            </div>
                                            <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.5rem' }}>
                                                {parsedComponents.orderedTokens && parsedComponents.orderedTokens.map((token, idx) => {
                                                    const isUsed = usedComponents.has(token.text);
                                                    if (isUsed || token.type === 'special') return null;

                                                    let bgColor = '#94a3b8';
                                                    if (token.type === 'number') bgColor = '#3b82f6';
                                                    else if (token.type === 'formation') bgColor = '#10b981';
                                                    else if (token.type === 'direction') bgColor = '#f97316';
                                                    else if (token.type === 'tag') bgColor = '#8b5cf6';
                                                    else if (token.type === 'quoted') bgColor = '#6b7280';

                                                    return (
                                                        <div
                                                            key={`${token.text}-${idx}`}
                                                            draggable
                                                            onDragStart={() => handleDragStart(token.text, token.type)}
                                                            style={{
                                                                padding: '0.25rem 0.5rem',
                                                                background: bgColor,
                                                                color: 'white',
                                                                borderRadius: '4px',
                                                                fontSize: '0.8rem',
                                                                cursor: 'grab'
                                                            }}
                                                        >
                                                            {token.type === 'quoted' ? `"${token.text}"` : token.text}
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                    )}

                                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))', gap: '1.25rem' }}>
                                        <div className="form-group">
                                            <label className="form-label">Formation</label>
                                            <input className="form-input" value={formData.formation} onChange={e => setFormData({ ...formData, formation: e.target.value })} />
                                        </div>
                                    </div>

                                    {/* Level Tags */}
                                    <div style={{ marginTop: '1rem', borderTop: '1px solid var(--border)', paddingTop: '1rem' }}>
                                        <label className="form-label" style={{ marginBottom: '0.5rem' }}>Level Tags</label>
                                        <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                                            {(programLevels || []).map(level => (
                                                <div
                                                    key={level}
                                                    onClick={() => toggleLevelTag(level)}
                                                    style={{ display: 'flex', alignItems: 'center', cursor: 'pointer', padding: '0.4rem 0.8rem', background: (formData.levelTags || []).includes(level) ? 'var(--accent)' : 'transparent', color: (formData.levelTags || []).includes(level) ? 'white' : 'var(--text-primary)', border: '1px solid var(--accent)', borderRadius: '20px', fontSize: '0.85rem', transition: 'all 0.2s', userSelect: 'none' }}
                                                >
                                                    {level}
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                        {/* DIAGRAMS SECTION: SIDE-BY-SIDE DIAGRAMS */}
                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1.5rem', marginTop: '1.5rem' }}>
                            {/* Wiz O-Line Diagram */}
                            <div className="form-group" style={{ background: 'var(--bg-main)', padding: '1rem', borderRadius: '12px', border: '1px solid var(--border)' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem', borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem' }}>
                                    <label className="form-label" style={{ margin: 0, fontSize: '0.85rem', textTransform: 'uppercase', letterSpacing: '0.05em', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                        <Icon name="Users" size={16} style={{ color: 'var(--accent)' }} />
                                        Wiz O-Line Diagram
                                    </label>
                                    <div style={{ display: 'flex', gap: '0.5rem', fontSize: '0.8rem' }}>
                                        <button type="button" onClick={() => setFormData(prev => ({ ...prev, wizOlineMode: 'diagram' }))} style={{ background: 'none', border: 'none', color: (formData.wizOlineMode || 'diagram') === 'diagram' ? 'var(--accent)' : 'var(--text-secondary)', fontWeight: (formData.wizOlineMode || 'diagram') === 'diagram' ? 'bold' : 'normal', cursor: 'pointer' }}>Diagram</button>
                                        <button type="button" onClick={() => setFormData(prev => ({ ...prev, wizOlineMode: 'upload' }))} style={{ background: 'none', border: 'none', color: formData.wizOlineMode === 'upload' ? 'var(--accent)' : 'var(--text-secondary)', fontWeight: formData.wizOlineMode === 'upload' ? 'bold' : 'normal', cursor: 'pointer' }}>Upload</button>
                                    </div>
                                </div>
                                <div style={{ minHeight: '150px', background: 'var(--bg-input)', borderRadius: '8px', overflow: 'hidden', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'var(--text-secondary)', fontSize: '0.9rem', position: 'relative' }}>
                                    {formData.wizOlineMode === 'upload' ? (
                                        formData.image ? (
                                            <div style={{ position: 'relative', width: '100%', height: '100%' }}>
                                                <img src={formData.image} alt="O-Line" style={{ width: '100%', height: '100%', objectFit: 'contain' }} />
                                                <button
                                                    type="button"
                                                    onClick={(e) => { e.stopPropagation(); setFormData(prev => ({ ...prev, image: null })); }}
                                                    style={{ position: 'absolute', top: 5, right: 5, background: 'rgba(0,0,0,0.5)', color: 'white', border: 'none', borderRadius: '50%', width: 24, height: 24, cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center' }}
                                                >
                                                    ×
                                                </button>
                                            </div>
                                        ) : (
                                            <div style={{ textAlign: 'center' }}>
                                                <input type="file" accept="image/*" onChange={handleImageUpload} style={{ display: 'none' }} id="oline-upload" />
                                                <label htmlFor="oline-upload" className="btn btn-secondary" style={{ cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                    <Icon name="Upload" size={16} /> Upload Image
                                                </label>
                                            </div>
                                        )
                                    ) : (
                                        formData.wizOlineData && formData.wizOlineData.length > 0 ? (
                                            <div onClick={() => setActiveDiagramMode('wiz-oline')} style={{ width: '100%', height: '100%', cursor: 'pointer' }}>
                                                {renderDiagramPreview(formData.wizOlineData)}
                                            </div>
                                        ) : (
                                            <button type="button" className="btn btn-secondary" onClick={() => setActiveDiagramMode('wiz-oline')}>
                                                <Icon name="Plus" size={16} /> Create Diagram
                                            </button>
                                        )
                                    )}
                                </div>
                            </div>

                            {/* Wiz Skill Diagram */}
                            <div className="form-group" style={{ background: 'var(--bg-main)', padding: '1rem', borderRadius: '12px', border: '1px solid var(--border)' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem', borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem' }}>
                                    <label className="form-label" style={{ margin: 0, fontSize: '0.85rem', textTransform: 'uppercase', letterSpacing: '0.05em', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                        <Icon name="Target" size={16} style={{ color: 'var(--accent)' }} />
                                        Wiz Skill Diagram
                                    </label>
                                    <div style={{ display: 'flex', gap: '0.5rem', fontSize: '0.8rem' }}>
                                        <button type="button" onClick={() => setFormData(prev => ({ ...prev, wizSkillMode: 'diagram' }))} style={{ background: 'none', border: 'none', color: (formData.wizSkillMode || 'diagram') === 'diagram' ? 'var(--accent)' : 'var(--text-secondary)', fontWeight: (formData.wizSkillMode || 'diagram') === 'diagram' ? 'bold' : 'normal', cursor: 'pointer' }}>Diagram</button>
                                        <button type="button" onClick={() => setFormData(prev => ({ ...prev, wizSkillMode: 'upload' }))} style={{ background: 'none', border: 'none', color: formData.wizSkillMode === 'upload' ? 'var(--accent)' : 'var(--text-secondary)', fontWeight: formData.wizSkillMode === 'upload' ? 'bold' : 'normal', cursor: 'pointer' }}>Upload</button>
                                    </div>
                                </div>
                                <div style={{ minHeight: '150px', background: 'var(--bg-input)', borderRadius: '8px', overflow: 'hidden', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'var(--text-secondary)', fontSize: '0.9rem', position: 'relative' }}>
                                    {formData.wizSkillMode === 'upload' ? (
                                        formData.wizSkillImage ? (
                                            <div style={{ position: 'relative', width: '100%', height: '100%' }}>
                                                <img src={formData.wizSkillImage} alt="Skill" style={{ width: '100%', height: '100%', objectFit: 'contain' }} />
                                                <button
                                                    type="button"
                                                    onClick={(e) => { e.stopPropagation(); setFormData(prev => ({ ...prev, wizSkillImage: null })); }}
                                                    style={{ position: 'absolute', top: 5, right: 5, background: 'rgba(0,0,0,0.5)', color: 'white', border: 'none', borderRadius: '50%', width: 24, height: 24, cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center' }}
                                                >
                                                    ×
                                                </button>
                                            </div>
                                        ) : (
                                            <div style={{ textAlign: 'center' }}>
                                                <input type="file" accept="image/*" onChange={handleSkillImageUpload} style={{ display: 'none' }} id="skill-upload" />
                                                <label htmlFor="skill-upload" className="btn btn-secondary" style={{ cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                    <Icon name="Upload" size={16} /> Upload Image
                                                </label>
                                            </div>
                                        )
                                    ) : (
                                        formData.wizSkillData && formData.wizSkillData.length > 0 ? (
                                            <div onClick={() => setActiveDiagramMode('wiz-skill')} style={{ width: '100%', height: '100%', cursor: 'pointer' }}>
                                                {renderDiagramPreview(formData.wizSkillData, true)}
                                            </div>
                                        ) : (
                                            <button type="button" className="btn btn-secondary" onClick={() => setActiveDiagramMode('wiz-skill')}>
                                                <Icon name="Plus" size={16} /> Create Diagram
                                            </button>
                                        )
                                    )}
                                </div>
                            </div>
                        </div>

                        {/* SECTION: PLAYER ASSIGNMENT NOTES */}
                        <div style={{ marginTop: '1.5rem' }}>
                            <div style={{
                                padding: '1.5rem', background: 'var(--bg-main)', borderRadius: '12px', border: '1px solid var(--border)',
                                display: 'flex', flexDirection: 'column'
                            }}>
                                <label className="form-label" style={{ marginBottom: '1rem', fontWeight: 'bold' }}>Player Assignment Notes</label>
                                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '0.75rem', flex: 1, overflowY: 'auto', maxHeight: '500px' }}>
                                    {(() => {
                                        // 1. Get default/configured positions + any extra from diagram
                                        const standardKeys = ['QB', 'RB', 'X', 'Z', 'Y', 'A', 'F', 'H', 'LT', 'LG', 'C', 'RG', 'RT'];
                                        const defaultPos = standardKeys.map(key => positionNames[key] || key);

                                        // 2. Extract unique player labels from diagramData
                                        const diagramPlayers = (formData.diagramData?.elements || [])
                                            .filter(el => el.type === 'player' && el.label)
                                            .map(el => el.label);

                                        // Merge and dedupe
                                        const allPositions = Array.from(new Set([...defaultPos, ...diagramPlayers]));

                                        return allPositions.map(pos => (
                                            <div key={pos} style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '0.5rem' }}>
                                                <span style={{ width: '40px', fontWeight: 'bold', fontSize: '0.9rem', color: 'var(--text-primary)', flexShrink: 0 }}>{pos}</span>
                                                <input
                                                    className="form-input"
                                                    style={{ padding: '0.4rem 0.6rem', flex: 1, fontSize: '0.9rem' }}
                                                    placeholder={`Notes for ${pos}...`}
                                                    value={formData.playerNotes?.[pos] || ''}
                                                    onChange={(e) => setFormData(prev => ({
                                                        ...prev,
                                                        playerNotes: { ...prev.playerNotes, [pos]: e.target.value }
                                                    }))}
                                                />
                                                <select
                                                    style={{ width: '120px', fontSize: '0.8rem', padding: '0.2rem' }}
                                                    value={formData.playerLinks?.[pos] || ''}
                                                    onChange={(e) => setFormData(prev => ({
                                                        ...prev,
                                                        playerLinks: { ...prev.playerLinks, [pos]: e.target.value }
                                                    }))}
                                                >
                                                    <option value="">Link Drill...</option>
                                                    {drills.map(drill => (
                                                        <option key={drill.id} value={drill.videoUrl || drill.youtubeId || ''}>
                                                            {drill.category}: {drill.title}
                                                        </option>
                                                    ))}
                                                </select>
                                            </div>
                                        ));
                                    })()}
                                </div>
                            </div>
                        </div>


                        <div className="form-group" style={{ marginTop: '1.5rem', background: 'var(--bg-main)', padding: '1.5rem', borderRadius: '12px', border: '1px solid var(--border)' }}>
                            <label className="form-label" style={{ marginBottom: '1rem' }}>Situational Tags (or drag tags here)</label>
                            <div
                                onDrop={(e) => {
                                    e.preventDefault();
                                    if (draggedComponent) {
                                        toggleTag(draggedComponent.text);
                                        setDraggedComponent(null);
                                    }
                                }}
                                onDragOver={(e) => {
                                    e.preventDefault();
                                    e.dataTransfer.dropEffect = 'copy';
                                }}
                                style={{
                                    border: draggedComponent ? '2px dashed #3b82f6' : '1px solid transparent',
                                    borderRadius: '8px', padding: draggedComponent ? '0.5rem' : '0', transition: 'all 0.2s'
                                }}
                            >
                                <TagSelector selectedTags={formData.tags} onToggle={toggleTag} />
                            </div>
                        </div>

                        <div style={{ display: 'flex', gap: '1rem', marginTop: '2rem', paddingBottom: '2rem' }}>
                            <button type="submit" className="btn btn-primary">Save Play</button>
                            <button type="button" onClick={() => setIsEditing(false)} className="btn btn-secondary">Cancel</button>
                        </div>
                    </form >
                </div >

            );
        };

        const PlayCard = ({ play, onEdit, isSelected, onToggleSelect = () => { }, onQuickEdit }) => {
            return (
                <div
                    className={`play-card ${isSelected ? 'selected' : ''}`}
                    onClick={(e) => {
                        // If quick edit exists, use it. Otherwise fallback to edit.
                        if (onQuickEdit) {
                            onQuickEdit(play, e.clientX, e.clientY);
                        } else {
                            onEdit(play);
                        }
                    }}
                    onDoubleClick={(e) => {
                        e.stopPropagation();
                        onEdit(play);
                    }}
                    style={{ cursor: 'pointer', position: 'relative', border: isSelected ? '2px solid var(--accent)' : '1px solid var(--border)' }}
                >
                    <div
                        onClick={(e) => {
                            e.stopPropagation();
                            onToggleSelect(play.id, e);
                        }}
                        style={{
                            position: 'absolute', right: '5px', top: '5px', zIndex: 10,
                            width: '24px', height: '24px', display: 'flex', alignItems: 'center', justifyContent: 'center',
                            background: 'rgba(255,255,255,0.8)', borderRadius: '4px'
                        }}
                    >
                        <input
                            type="checkbox"
                            checked={isSelected}
                            onChange={() => { }} // Handled by div click
                            style={{ width: '18px', height: '18px', cursor: 'pointer' }}
                        />
                    </div>
                    {/* Explicit Edit Pencil */}
                    <div
                        onClick={(e) => {
                            e.stopPropagation();
                            onEdit(play);
                        }}
                        style={{
                            position: 'absolute', right: '35px', top: '5px', zIndex: 10,
                            width: '24px', height: '24px', display: 'flex', alignItems: 'center', justifyContent: 'center',
                            background: 'rgba(255,255,255,0.8)', borderRadius: '4px', cursor: 'pointer', color: 'var(--text-secondary)'
                        }}
                        title="Edit Play Details"
                    >
                        <Icon name="Edit2" size={14} />
                    </div>

                    {
                        play.image ? (
                            <img src={play.image} className="play-image" alt={play.name} />
                        ) : (
                            <div className="play-diagram" style={{ height: '180px', background: 'white' }}>
                                <svg viewBox="0 0 900 600" width="100%" height="100%" style={{ display: 'block' }} preserveAspectRatio="xMidYMid meet">
                                    <g opacity="0.1">
                                        <line x1="0" y1="10%" x2="100%" y2="10%" stroke="#000" strokeWidth="2" />
                                        <line x1="0" y1="90%" x2="100%" y2="90%" stroke="#000" strokeWidth="2" />
                                    </g>
                                    {play.diagramData && play.diagramData.elements && play.diagramData.elements.map(el => {
                                        if (el.type === 'player') {
                                            const size = 16;
                                            const x = el.points[0].x;
                                            const y = el.points[0].y;
                                            return (
                                                <g key={el.id}>
                                                    <circle cx={x} cy={y} r={size} fill="white" stroke={el.color} strokeWidth="2" />
                                                    <text x={x} y={y} dy=".35em" textAnchor="middle" fontSize="16" fontWeight="bold" fill={el.color}>{el.label}</text>
                                                </g>
                                            );
                                        }
                                        let d = '';
                                        if (el.style === 'zigzag') {
                                            d = getZigZagPath(el.points);
                                        } else if (el.type === 'free' || el.points.length > 1) {
                                            d = `M ${el.points.map(p => `${p.x},${p.y}`).join(' L ')}`;
                                        }

                                        let markerEnd = undefined;
                                        let tBlock = null;

                                        if (el.endType === 'arrow' || (!el.endType && el.type !== 'free')) {
                                            markerEnd = `url(#arrowhead-${el.color})`;
                                        } else if (el.endType === 't') {
                                            const end = el.points[el.points.length - 1];
                                            const prev = el.points[el.points.length - 2] || el.points[0];
                                            const dx = end.x - prev.x;
                                            const dy = end.y - prev.y;
                                            const len = Math.hypot(dx, dy) || 1;
                                            const perpX = (-dy / len) * 15;
                                            const perpY = (dx / len) * 15;
                                            tBlock = (
                                                <line
                                                    x1={end.x - perpX} y1={end.y - perpY}
                                                    x2={end.x + perpX} y2={end.y + perpY}
                                                    stroke={el.color}
                                                    strokeWidth="4"
                                                />
                                            );
                                        } else if (el.endType === 'dot') {
                                            const end = el.points[el.points.length - 1];
                                            tBlock = (
                                                <circle cx={end.x} cy={end.y} r="6" fill={el.color} />
                                            );
                                        } else if (el.endType === 'none') {
                                            markerEnd = undefined;
                                        } else if (el.type !== 'free') {
                                            markerEnd = `url(#arrowhead-${el.color})`;
                                        }

                                        return (
                                            <g key={el.id}>
                                                <path
                                                    d={d}
                                                    stroke={el.color}
                                                    strokeWidth="4"
                                                    fill="none"
                                                    style={el.style === 'dashed' ? { strokeDasharray: '10,10' } : {}}
                                                    markerEnd={markerEnd}
                                                />
                                                {tBlock}
                                            </g>
                                        );
                                    })}
                                </svg>
                            </div>
                        )
                    }
                    <div className="play-content">
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start' }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', flex: 1 }}>
                                <h3 className="play-title">{getPlayDisplayName(play)}</h3>
                                {play.incomplete && (
                                    <span style={{
                                        background: '#eab308',
                                        color: 'white',
                                        padding: '0.25rem 0.5rem',
                                        borderRadius: '4px',
                                        fontSize: '0.7rem',
                                        fontWeight: 'bold',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '0.25rem'
                                    }}>
                                        ⚠️ INCOMPLETE
                                    </span>
                                )}
                            </div>
                            {play.wristbandSlot && <span className="mini-tag" style={{ background: 'var(--accent)', color: '#000' }}>#{play.wristbandSlot}</span>} {play.staplesSlot && <span className="mini-tag" style={{ background: '#f59e0b', color: '#000', marginLeft: '2px' }}>S:{play.staplesSlot}</span>}
                        </div>
                        <div className="play-meta">
                            {(() => {
                                const nameLower = play.name.toLowerCase();
                                const parts = [];
                                // Logic for Formation & Formation Tag
                                const normalize = (s) => (s || '').toLowerCase()
                                    .replace(/green/g, 'grn').replace(/bright/g, 'brt')
                                    .replace(/black/g, 'blk').replace(/white/g, 'wht')
                                    .replace(/blue/g, 'blu').replace(/brown/g, 'brn')
                                    .replace(/right/g, 'rt').replace(/left/g, 'lt');

                                const nName = normalize(play.name);
                                const showForm = play.formation && !nName.includes(normalize(play.formation));
                                const showFormTag = play.formationTag && !nName.includes(normalize(play.formationTag));

                                if (showForm) {
                                    let txt = play.formation;
                                    if (showFormTag) txt += ` (${play.formationTag})`;
                                    parts.push(txt);
                                } else if (showFormTag) {
                                    parts.push(`(${play.formationTag})`);
                                }

                                // Logic for Color - REMOVED


                                return parts.map((part, i) => (
                                    <React.Fragment key={i}>
                                        {i > 0 && " • "}
                                        {part}
                                    </React.Fragment>
                                ));
                            })()}
                        </div>
                        <div className="play-tags">
                            {/* Tag 1 */}
                            {/* Tag 1 */}
                            {play.tag1 && !play.name.toLowerCase().includes(play.tag1.toLowerCase()) && (
                                <span className="mini-tag">
                                    {(TAG_CATEGORIES["Motion"] || []).includes(play.tag1) ? `"${play.tag1}"` : play.tag1}
                                </span>
                            )}

                            {/* Tag 2 */}
                            {play.tag2 && !play.name.toLowerCase().includes(play.tag2.toLowerCase()) && (
                                <span className="mini-tag">
                                    ({play.tag2})
                                </span>
                            )}

                            {/* Other Tags array (deduplicated) */}
                            {play.tags && play.tags.map(tag => {
                                // Deduplicate if tag matches fields OR Play Name
                                if (tag === play.tag1 || tag === play.tag2) return null;
                                if (play.name.toLowerCase().includes(tag.toLowerCase())) return null;

                                const isMotion = (TAG_CATEGORIES["Motion"] || []).includes(tag);
                                return <span key={tag} className="mini-tag">{isMotion ? `"${tag}"` : tag}</span>
                            })}
                        </div>
                    </div>
                </div >
            );
        };

        const WristbandPrintCard = ({ title, start, end, slotMap, colorClass }) => {
            // Split range into two columns
            const totalSlots = end - start + 1;
            const mid = Math.ceil(totalSlots / 2);

            // Column 1: start to start + mid - 1
            // Column 2: start + mid to end
            // Wait, for table layout, we likely want just one long list if it's a single column card? 
            // Or if it's 2 columns per card (User image shows 4 columns total on page, so 2 per card).
            // Let's stick to the 2-column per card layout but use TABLES.

            // Actually, HTML tables are great for single columns. To do 2 columns, we can use 2 tables side-by-side.

            const col1Slots = [];
            const col2Slots = [];
            const rowsPerCol = Math.ceil((end - start + 1) / 2);
            // Or fixed 24?

            for (let i = 0; i < rowsPerCol; i++) {
                if (start + i <= end) col1Slots.push(start + i);
                if (start + rowsPerCol + i <= end) col2Slots.push(start + rowsPerCol + i);
            }

            const renderTable = (slots) => (
                <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '8pt', tableLayout: 'fixed' }}>
                    <thead>
                        <tr style={{ background: '#eee', borderBottom: '1px solid black' }}>
                            <th style={{ width: '25px', padding: '2px', borderRight: '1px solid #ccc', textAlign: 'center' }}>#</th>
                            <th style={{ textAlign: 'left', padding: '2px 4px' }}>Play Call</th>
                        </tr>
                    </thead>
                    <tbody>
                        {slots.map((slot, idx) => {
                            const play = slot ? slotMap[slot] : null;
                            return (
                                <tr key={slot} style={{ borderBottom: '1px solid #ccc', height: '18px', backgroundColor: idx % 2 === 1 ? '#f9fafb' : 'white' }}>
                                    <td style={{ textAlign: 'center', borderRight: '1px solid #ccc', fontWeight: 'bold' }}>{slot}</td>
                                    <td style={{ padding: '0 4px', overflow: 'hidden', whiteSpace: 'nowrap', textOverflow: 'ellipsis', fontWeight: '600' }}>
                                        {play?.name || ''}
                                    </td>
                                </tr>
                            );
                        })}
                    </tbody>
                </table>
            );

            return (
                <div className={`wristband-card ${colorClass} text-list`} style={{ display: 'flex', flexDirection: 'column' }}>
                    <div className="wristband-card-header">{title}</div>
                    <div className="wristband-content" style={{ display: 'flex' }}>
                        <div className="wristband-col" style={{ width: '50%', borderRight: '1px solid black' }}>
                            {renderTable(col1Slots)}
                        </div>
                        <div className="wristband-col" style={{ width: '50%' }}>
                            {renderTable(col2Slots)}
                        </div>
                    </div>
                </div>
            );
        };

        // Helper for SVG rendering to avoid duplication
        const WristbandDiagramSVG = ({ data, minimal }) => {
            return (
                <svg
                    viewBox="0 0 900 600"
                    width="100%"
                    height="100%"
                    style={{ display: 'block' }}
                    preserveAspectRatio="xMidYMid meet"
                >
                    <g opacity="0.15">
                        <line x1="0" y1="10%" x2="100%" y2="10%" stroke="#000" strokeWidth={minimal ? 4 : 2} />
                        <line x1="0" y1="30%" x2="100%" y2="30%" stroke="#000" strokeWidth={minimal ? 4 : 2} />
                        <line x1="0" y1="50%" x2="100%" y2="50%" stroke="#000" strokeWidth={minimal ? 6 : 4} />
                        <line x1="0" y1="70%" x2="100%" y2="70%" stroke="#000" strokeWidth={minimal ? 4 : 2} />
                        <line x1="0" y1="90%" x2="100%" y2="90%" stroke="#000" strokeWidth={minimal ? 4 : 2} />
                    </g>
                    {data.elements && data.elements.map(el => {
                        if (el.type === 'player') {
                            const { x, y } = el.points[0];
                            const size = minimal ? 50 : 30; // Larger relative dots for small print
                            const isRect = el.shape === 'square';
                            return (
                                <g key={el.id}>
                                    {isRect ? (
                                        <rect x={x - size / 2} y={y - size / 2} width={size} height={size} fill="white" stroke={el.color} strokeWidth={minimal ? 4 : 2} />
                                    ) : (
                                        <circle cx={x} cy={y} r={size / 2} fill="white" stroke={el.color} strokeWidth={minimal ? 4 : 2} />
                                    )}
                                    {!minimal && <text x={x} y={y} dy="0.35em" textAnchor="middle" fontSize="16" fontWeight="bold" fill={el.color}>{el.label}</text>}
                                </g>
                            );
                        }

                        let d = '';
                        if (el.style === 'zigzag') {
                            d = getZigZagPath(el.points);
                        } else if (el.style === 'curved' && el.points.length >= 2) {
                            const p = el.points;
                            d = `M ${p[0].x} ${p[0].y} Q ${p[1].x} ${p[1].y} ${p[p.length - 1].x} ${p[p.length - 1].y}`;
                        } else {
                            d = `M ${el.points.map(p => `${p.x},${p.y}`).join(' L ')}`;
                        }

                        return (
                            <g key={el.id}>
                                <path d={d} stroke={el.color} strokeWidth={minimal ? 6 : 3} fill="none" strokeDasharray={el.style === 'dashed' ? '10,5' : 'none'} />
                                {el.endMarker === 'arrow' && (
                                    <polygon points="-6,-6 6,0 -6,6" fill={el.color} transform={`translate(${el.points[el.points.length - 1].x}, ${el.points[el.points.length - 1].y})`} />
                                )}
                            </g>
                        );
                    })}
                </svg>
            );
        };

        const WristbandDiagramCard = ({ slot, play }) => {
            return (
                <div className="wristband-card" style={{ display: 'flex', flexDirection: 'column' }}>
                    <div className="wristband-card-header">#{slot} - {play?.name || 'Empty'}</div>
                    <div style={{ flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '0.25rem', overflow: 'hidden', background: '#fff' }}>
                        {play?.diagramData ? (
                            <WristbandDiagramSVG data={play.diagramData} minimal={false} />
                        ) : (
                            <span style={{ color: '#ccc' }}>No Diagram</span>
                        )}
                    </div>
                </div>
            );
        };

        const WristbandGridCard = ({ startSlot, endSlot, slotMap, onUpdatePlay }) => {
            const slots = [];
            for (let i = startSlot; i <= endSlot; i++) {
                slots.push(i);
            }
            while (slots.length < 20) {
                slots.push(null);
            }

            return (
                <div className="wristband-grid-card">
                    {slots.map((slot, index) => {
                        const play = slot ? slotMap[slot] : null;
                        return (
                            <div key={index} className="wristband-grid-cell" style={{ display: 'flex', flexDirection: 'column', height: '100%', border: '1px solid black', overflow: 'hidden', position: 'relative' }}>
                                {/* Clear button in top-right corner */}
                                {play && onUpdatePlay && (
                                    <button
                                        className="wristband-clear-btn"
                                        onClick={(e) => { e.stopPropagation(); onUpdatePlay({ ...play, wristbandSlot: '' }); }}
                                        style={{
                                            position: 'absolute',
                                            top: '2px',
                                            right: '2px',
                                            zIndex: 10,
                                            fontSize: '10px',
                                            padding: '0 4px',
                                            lineHeight: '14px',
                                            background: 'rgba(255, 255, 255, 0.9)',
                                            borderRadius: '2px'
                                        }}
                                    >
                                        ×
                                    </button>
                                )}
                                {/* Top: Diagram (80%) */}
                                <div className="wristband-grid-cell-body" style={{ flex: '0 0 75%', borderBottom: '1px solid black', display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '2px' }}>
                                    {play?.diagramData ? (
                                        <div style={{ width: '100%', height: '100%' }}>
                                            <WristbandDiagramSVG data={play.diagramData} minimal={true} />
                                        </div>
                                    ) : (
                                        <span style={{ fontSize: '8pt', color: '#ddd' }}>-</span>
                                    )}
                                </div>
                                {/* Bottom: Info (20%) */}
                                <div className="wristband-grid-cell-header" style={{ flex: '1', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '6pt', fontWeight: 'bold', background: '#f5f5f5', textAlign: 'center', lineHeight: '1.1' }}>
                                    {slot ? (
                                        <span>#{slot} {play?.name ? `- ${getPlayDisplayName(play).substring(0, 15)}` : ''}</span>
                                    ) : null}
                                </div>
                            </div>
                        );
                    })}
                </div>
            );
        };

        const PlayModalHeader = ({ play, playBuckets = [], onUpdatePlay, onClose, title, subtitle }) => {
            if (!play) return null;

            // Helper to get play display name
            const displayName = title || play.name || 'Unknown Play';

            return (
                <div style={{ padding: '8px 12px', borderBottom: '1px solid #f1f5f9', background: '#f8fafc' }}>
                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '8px' }}>
                        <div style={{ fontWeight: 'bold', color: '#1e293b', fontSize: '0.9rem' }}>
                            {displayName}
                            {subtitle && <div style={{ fontSize: '0.7rem', color: '#64748b', fontWeight: 'normal' }}>{subtitle}</div>}
                        </div>
                        {onClose && (
                            <button
                                onClick={onClose}
                                style={{ background: 'none', border: 'none', cursor: 'pointer', fontSize: '1.2rem', color: '#94a3b8', lineHeight: 1 }}
                            >
                                ×
                            </button>
                        )}
                    </div>

                    {/* Play Type Toggles */}
                    <div style={{ marginBottom: '12px', borderBottom: '1px solid #e2e8f0', paddingBottom: '12px' }}>
                        <div style={{ fontSize: '0.75rem', fontWeight: 'bold', color: '#64748b', marginBottom: '4px', textTransform: 'uppercase' }}>Play Type</div>
                        <div style={{ display: 'flex', flexWrap: 'wrap', gap: '4px' }}>
                            {playBuckets.filter(b => !b.categoryId).map(bucket => {
                                const isSelected = play.bucketId === bucket.id || (
                                    !play.bucketId && play.type && (
                                        play.type.toLowerCase() === bucket.id ||
                                        play.type.toLowerCase() === bucket.label.toLowerCase() ||
                                        (play.type.toLowerCase().includes('run') && (bucket.id === 'run' || bucket.id === 'run-root'))
                                    )
                                );
                                return (
                                    <button
                                        key={bucket.id}
                                        onClick={() => {
                                            if (onUpdatePlay) onUpdatePlay(play.id, {
                                                type: bucket.label,
                                                bucketId: bucket.id
                                            });
                                        }}
                                        className="btn-xs"
                                        style={{
                                            background: isSelected ? bucket.color || '#3b82f6' : 'white',
                                            color: isSelected ? (bucket.textColor || 'white') : '#64748b',
                                            border: isSelected ? '1px solid rgba(0,0,0,0.1)' : '1px solid #cbd5e1',
                                            fontSize: '0.7rem',
                                            padding: '2px 8px',
                                            cursor: 'pointer',
                                            borderRadius: '4px',
                                            fontWeight: isSelected ? 'bold' : 'normal'
                                        }}
                                    >
                                        {bucket.label}
                                    </button>
                                );
                            })}
                        </div>
                    </div>

                    {/* Concept Family */}
                    <div style={{ marginBottom: '12px', borderBottom: '1px solid #e2e8f0', paddingBottom: '12px' }}>
                        <div style={{ fontSize: '0.75rem', fontWeight: 'bold', color: '#64748b', marginBottom: '4px', textTransform: 'uppercase' }}>Concept Family</div>
                        <select
                            value={play.conceptFamily || ''}
                            onChange={(e) => {
                                if (onUpdatePlay) onUpdatePlay(play.id, { conceptFamily: e.target.value });
                            }}
                            style={{ width: '100%', padding: '4px', fontSize: '0.8rem', borderRadius: '4px', border: '1px solid #cbd5e1' }}
                        >
                            <option value="">-- No Concept Assigned --</option>
                            {/* Filter buckets that have a categoryId matching the play's bucketId OR generic if needed */}
                            {playBuckets
                                .filter(b => b.categoryId && (
                                    b.categoryId === play.bucketId
                                    // Relaxed check: or if no bucketId, show all? No, strict to bucket usually best.
                                    // Or if play has no bucketId but type matches?
                                    // Let's assume bucketId is set or synched.
                                ))
                                .sort((a, b) => (a.label || '').localeCompare(b.label || ''))
                                .map(b => (
                                    <option key={b.id} value={b.label}>{b.label}</option>
                                ))}
                        </select>
                    </div>
                </div>
            );
        };

        /* -------------------------------------------------------------------------- */
        /*                           PLAY CHIP COMPONENTS                             */
        /* -------------------------------------------------------------------------- */

        // Context for opening PlayDetailsModal from any PlayChip
        const PlayDetailsModalContext = React.createContext({
            openPlayDetails: () => { },
        });

        const usePlayDetailsModal = () => React.useContext(PlayDetailsModalContext);

        // PlayChip - Visual chip/pill component for a play
        const PlayChip = ({
            play,              // Play object (required if no playId+plays)
            playId,            // Alternative: just pass ID
            plays,             // Required if using playId
            playBuckets = [],  // For category color
            onRemove,          // Optional - shows X button if provided
            showFlags = true,  // Show Priority/Wiz/MiniScript indicators
            size = 'md',       // 'sm' | 'md' | 'lg'
            draggable = false, // Enable drag
            onClick,           // Optional click handler
            className = '',
        }) => {
            const { openPlayDetails } = usePlayDetailsModal();

            // Resolve play object
            const resolvedPlay = play || (plays && plays.find(p => p.id === playId));
            if (!resolvedPlay) return null;

            // Get bucket color
            const bucket = playBuckets.find(b => b.id === resolvedPlay.bucketId);
            const bgColor = bucket?.color || '#e2e8f0';
            const textColor = bucket?.textColor || '#1e293b';

            // Size variants
            const sizes = {
                sm: { padding: '2px 8px', fontSize: '0.7rem', gap: '3px', iconSize: 10 },
                md: { padding: '4px 10px', fontSize: '0.8rem', gap: '4px', iconSize: 12 },
                lg: { padding: '6px 12px', fontSize: '0.9rem', gap: '5px', iconSize: 14 },
            };
            const s = sizes[size] || sizes.md;

            // Flags
            const isPriority = resolvedPlay.priority;
            const isWiz = resolvedPlay.isWiz || resolvedPlay.isRooski;
            const isMiniScript = resolvedPlay.isMiniScript;

            // Drag handlers
            const handleDragStart = (e) => {
                if (!draggable) return;
                e.dataTransfer.setData('text/plain', resolvedPlay.id);
                e.dataTransfer.setData('application/x-play-id', resolvedPlay.id);
                e.dataTransfer.effectAllowed = 'copy';
            };

            // Right-click to open modal
            const handleContextMenu = (e) => {
                e.preventDefault();
                openPlayDetails(resolvedPlay.id);
            };

            return (
                <span
                    className={`play-chip ${className}`}
                    draggable={draggable}
                    onDragStart={handleDragStart}
                    onContextMenu={handleContextMenu}
                    onClick={onClick}
                    style={{
                        display: 'inline-flex',
                        alignItems: 'center',
                        gap: s.gap,
                        padding: s.padding,
                        fontSize: s.fontSize,
                        fontWeight: 600,
                        borderRadius: '6px',
                        background: bgColor,
                        color: textColor,
                        cursor: draggable ? 'grab' : (onClick ? 'pointer' : 'default'),
                        userSelect: 'none',
                        whiteSpace: 'nowrap',
                        transition: 'all 0.15s ease',
                    }}
                    title="Right-click to edit details"
                >
                    {/* Flag indicators */}
                    {showFlags && isPriority && <span style={{ opacity: 0.9 }}>★</span>}
                    {showFlags && isWiz && <span style={{ opacity: 0.9 }}>⚡</span>}
                    {showFlags && isMiniScript && <span style={{ opacity: 0.9 }}>📋</span>}

                    {/* Play name */}
                    <span>{resolvedPlay.name}</span>

                    {/* Remove button */}
                    {onRemove && (
                        <button
                            onClick={(e) => {
                                e.stopPropagation();
                                onRemove(resolvedPlay.id);
                            }}
                            style={{
                                background: 'transparent',
                                border: 'none',
                                cursor: 'pointer',
                                padding: '0 2px',
                                marginLeft: '2px',
                                color: textColor,
                                opacity: 0.6,
                                display: 'flex',
                                alignItems: 'center',
                            }}
                            onMouseEnter={(e) => e.target.style.opacity = 1}
                            onMouseLeave={(e) => e.target.style.opacity = 0.6}
                        >
                            <Icon name="X" size={s.iconSize} />
                        </button>
                    )}
                </span>
            );
        };

        // PracticeScriptTable - Unified script table for practice segments
        // Supports both modal view and Practice Scripts page with all features
        const PracticeScriptTable = ({
            script = [],              // Array of script rows
            onUpdateScript,           // Callback to update script
            plays = [],               // All plays for lookup
            playCategories = [],      // For PlayChip colors (buckets)
            isLocked = false,         // Disable editing
            onDrop,                   // Optional custom drop handler
            onQuickAddPlay,           // Callback to create new play on blur
            // Segment info (optional - for header and segment-specific behavior)
            segment = null,           // { id, type, situation, startTime, duration }
            showHeader = false,       // Show segment header with time/type/duration
            // Column visibility
            visibleColumns = {        // Which columns to show
                hash: true,
                down: true,
                dist: true,
                situation: true,
                playCall: true,
                defense: true,
                notes: true,
                actions: true
            },
            // Behavior options
            downAsDropdown = false,   // Use dropdown for down (1-4) vs text input
            situationDropdown = false, // Use dropdown for situation (S/M/L/XL for 3rd down)
            showYardLine = false,     // Show YardLine column instead of Situation
            compact = false,          // Compact padding for denser view
            tableId = null,           // For datalist IDs
            // Advanced features for Practice Scripts page
            notesAsButton = false,    // Render notes as button instead of input
            onEditNotes,              // Callback when notes button clicked: (segmentId, rowId) => void
            onInsertRow,              // Custom insert row handler: (idx, script) => newScript
            onDeleteRow,              // Custom delete handler: (idx, slot, script) => void (if returns false, skips default)
            confirmDelete = false,    // Show confirm dialog before delete
            onFieldKeyDown,           // Keyboard handler: (e, segmentId, slotId, field, script, updateFn) => void
            getNotesDisplay,          // Custom function to get notes display: (slot) => { hasNotes, label }
        }) => {
            const { openPlayDetails } = usePlayDetailsModal();
            const padding = compact ? '4px' : '0.5rem';

            // Support both 'dist' and 'distance' field names
            const getDistance = (slot) => slot.dist || slot.distance || '';
            const setDistance = (slot, value) => {
                // Use whichever field already exists, default to 'dist'
                if ('distance' in slot) return { distance: value };
                return { dist: value };
            };

            const updateRow = (idx, updates) => {
                const newScript = [...script];
                newScript[idx] = { ...newScript[idx], ...updates };
                onUpdateScript(newScript);
            };

            const updateRowById = (slotId, updates) => {
                const newScript = script.map(s => s.id === slotId ? { ...s, ...updates } : s);
                onUpdateScript(newScript);
            };

            const insertRowAfter = (idx) => {
                const newScript = [...script];
                const newRow = {
                    id: `row_${Date.now()}`,
                    hash: 'M',
                    down: '',
                    dist: '',
                    situation: '',
                    playName: '',
                    playId: '',
                    defense: '',
                    notes: '',
                    yardLine: ''
                };
                newScript.splice(idx + 1, 0, newRow);
                onUpdateScript(newScript);
            };

            const deleteRow = (idx) => {
                const newScript = script.filter((_, i) => i !== idx);
                onUpdateScript(newScript);
            };

            const addRow = () => {
                const newRow = {
                    id: `row_${Date.now()}`,
                    hash: 'M',
                    down: '',
                    dist: '',
                    situation: '',
                    playName: '',
                    playId: '',
                    defense: '',
                    notes: '',
                    yardLine: ''
                };
                onUpdateScript([...script, newRow]);
            };

            const handleRowDrop = (e, idx) => {
                e.preventDefault();
                if (onDrop) {
                    onDrop(e, idx);
                    return;
                }
                try {
                    const data = JSON.parse(e.dataTransfer.getData('application/react-dnd'));
                    if (data && (data.playId || data.name)) {
                        updateRow(idx, {
                            playName: data.name || script[idx].playName,
                            playId: data.playId || ''
                        });
                    }
                } catch (err) {
                    // Try plain text format
                    const playId = e.dataTransfer.getData('application/x-play-id') || e.dataTransfer.getData('text/plain');
                    if (playId) {
                        const play = plays.find(p => p.id === playId);
                        if (play) {
                            updateRow(idx, { playName: play.name, playId: play.id });
                        }
                    }
                }
            };

            const handlePlayInputChange = (idx, slot, value) => {
                const val = value.toUpperCase();
                const foundPlay = plays.find(p => p.name === val);
                updateRow(idx, {
                    playName: val,
                    playId: foundPlay ? foundPlay.id : ''
                });
            };

            const handlePlayInputBlur = (idx, slot) => {
                if (slot.playName && !slot.playId && onQuickAddPlay) {
                    const newPlay = onQuickAddPlay(slot.playName);
                    if (newPlay) {
                        updateRow(idx, { playName: newPlay.name, playId: newPlay.id });
                    }
                }
            };

            // Count visible columns for colspan
            const colCount = 1 + // # column always shown
                (visibleColumns.hash ? 1 : 0) +
                (visibleColumns.down ? 1 : 0) +
                (visibleColumns.dist ? 1 : 0) +
                (visibleColumns.situation || showYardLine ? 1 : 0) +
                (visibleColumns.playCall ? 1 : 0) +
                (visibleColumns.defense ? 1 : 0) +
                (visibleColumns.notes ? 1 : 0) +
                (visibleColumns.actions && !isLocked ? 1 : 0);

            return (
                <div style={{
                    border: showHeader ? '1px solid var(--border)' : 'none',
                    borderRadius: showHeader ? '8px' : '0',
                    backgroundColor: showHeader ? 'var(--bg-panel)' : 'transparent',
                    overflow: 'hidden'
                }}>
                    {/* Optional Segment Header */}
                    {showHeader && segment && (
                        <div style={{
                            backgroundColor: 'var(--bg-surface)',
                            padding: '0.5rem 0.75rem',
                            borderBottom: '1px solid var(--border)',
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center',
                            minHeight: '40px'
                        }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.75rem' }}>
                                <span style={{ color: 'var(--accent)', fontWeight: 'bold' }}>{segment.startTime || ''}</span>
                                <span style={{ textTransform: 'uppercase', fontWeight: '600', fontSize: '0.95rem' }}>{segment.type}</span>
                                {segment.duration && (
                                    <span style={{ color: 'var(--text-secondary)', fontSize: '0.85rem' }}>({segment.duration} min)</span>
                                )}
                                {segment.situation && (
                                    <span style={{ backgroundColor: 'var(--bg-body)', border: '1px solid var(--border)', padding: '1px 6px', borderRadius: '4px', fontSize: '0.8rem', color: 'var(--text-secondary)' }}>
                                        {segment.situation}
                                    </span>
                                )}
                            </div>
                        </div>
                    )}

                    {/* Datalist for play autocomplete */}
                    {tableId && (
                        <datalist id={`play-options-${tableId}`}>
                            {plays.map(p => (
                                <option key={p.id} value={p.name}>{p.formation}</option>
                            ))}
                        </datalist>
                    )}

                    <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '0.9rem' }}>
                        <thead style={{ background: 'var(--bg-panel)' }}>
                            <tr style={{ borderBottom: '2px solid var(--border)', backgroundColor: 'var(--bg-body)' }}>
                                <th style={{ padding, textAlign: 'center', width: '40px', color: 'var(--text-secondary)' }}>#</th>
                                {visibleColumns.hash && (
                                    <th style={{ padding, textAlign: 'center', width: '70px' }}>Hash</th>
                                )}
                                {visibleColumns.down && (
                                    <th style={{ padding, textAlign: 'center', width: '50px' }}>Dn</th>
                                )}
                                {visibleColumns.dist && (
                                    <th style={{ padding, textAlign: 'center', width: '50px' }}>Dist</th>
                                )}
                                {showYardLine ? (
                                    <th style={{ padding, textAlign: 'left', width: '60px' }}>Yd</th>
                                ) : visibleColumns.situation && (
                                    <th style={{ padding, textAlign: 'left', width: '120px' }}>Situation</th>
                                )}
                                {visibleColumns.playCall && (
                                    <th style={{ padding, textAlign: 'left' }}>Play Call</th>
                                )}
                                {visibleColumns.defense && (
                                    <th style={{ padding, textAlign: 'left', width: '140px' }}>Defense</th>
                                )}
                                {visibleColumns.notes && (
                                    <th style={{ padding, textAlign: 'left', width: '140px' }}>Notes</th>
                                )}
                                {visibleColumns.actions && !isLocked && (
                                    <th style={{ padding, width: '70px', textAlign: 'center' }}>Act</th>
                                )}
                            </tr>
                        </thead>
                        <tbody>
                            {script.map((slot, idx) => (
                                <tr
                                    key={slot.id || idx}
                                    style={{ borderBottom: '1px solid var(--border)' }}
                                    onDragOver={(e) => e.preventDefault()}
                                    onDrop={(e) => handleRowDrop(e, idx)}
                                >
                                    <td style={{ padding, textAlign: 'center', fontWeight: 'bold', color: 'var(--text-secondary)' }}>{idx + 1}</td>

                                    {/* Hash */}
                                    {visibleColumns.hash && (
                                        <td style={{ padding }}>
                                            {isLocked ? (
                                                <span style={{ fontWeight: 'bold', textAlign: 'center', display: 'block' }}>{slot.hash}</span>
                                            ) : (
                                                <select
                                                    className="form-input"
                                                    style={{ padding: compact ? '2px' : '0.25rem', textAlign: 'center', fontWeight: 'bold', width: '100%' }}
                                                    value={slot.hash || 'M'}
                                                    onChange={e => updateRow(idx, { hash: e.target.value })}
                                                >
                                                    <option value="R">R</option>
                                                    <option value="RM">RM</option>
                                                    <option value="M">M</option>
                                                    <option value="LM">LM</option>
                                                    <option value="L">L</option>
                                                </select>
                                            )}
                                        </td>
                                    )}

                                    {/* Down */}
                                    {visibleColumns.down && (
                                        <td style={{ padding }}>
                                            {isLocked ? (
                                                <span style={{ textAlign: 'center', display: 'block' }}>{slot.down}</span>
                                            ) : downAsDropdown ? (
                                                <select
                                                    className="form-input"
                                                    style={{ padding: compact ? '4px' : '0.25rem', width: '100%', textAlign: 'center' }}
                                                    value={slot.down || ''}
                                                    onChange={e => updateRow(idx, { down: e.target.value })}
                                                >
                                                    <option value=""></option>
                                                    <option value="1">1</option>
                                                    <option value="2">2</option>
                                                    <option value="3">3</option>
                                                    <option value="4">4</option>
                                                </select>
                                            ) : (
                                                <input
                                                    className="form-input"
                                                    style={{ padding: compact ? '4px' : '0.25rem', width: '100%', textAlign: 'center' }}
                                                    value={slot.down || ''}
                                                    onChange={e => updateRow(idx, { down: e.target.value })}
                                                />
                                            )}
                                        </td>
                                    )}

                                    {/* Distance */}
                                    {visibleColumns.dist && (
                                        <td style={{ padding }}>
                                            {isLocked ? (
                                                <span style={{ textAlign: 'center', display: 'block' }}>{getDistance(slot)}</span>
                                            ) : (
                                                <input
                                                    className="form-input"
                                                    style={{ padding: compact ? '4px' : '0.25rem', width: '100%', textAlign: 'center' }}
                                                    value={getDistance(slot)}
                                                    onChange={e => updateRow(idx, setDistance(slot, e.target.value))}
                                                />
                                            )}
                                        </td>
                                    )}

                                    {/* YardLine or Situation */}
                                    {showYardLine ? (
                                        <td style={{ padding }}>
                                            {isLocked ? (
                                                <span>{slot.yardLine}</span>
                                            ) : (
                                                <input
                                                    className="form-input"
                                                    style={{ padding: compact ? '4px' : '0.25rem', width: '100%', backgroundColor: 'var(--bg-body)' }}
                                                    value={slot.yardLine || ''}
                                                    onChange={e => updateRow(idx, { yardLine: e.target.value })}
                                                    placeholder="-30"
                                                />
                                            )}
                                        </td>
                                    ) : visibleColumns.situation && (
                                        <td style={{ padding }}>
                                            {isLocked ? (
                                                <span>{slot.situation}</span>
                                            ) : situationDropdown ? (
                                                <select
                                                    className="form-input"
                                                    style={{ padding: compact ? '4px' : '0.25rem', width: '100%' }}
                                                    value={slot.situation || ''}
                                                    onChange={e => updateRow(idx, { situation: e.target.value })}
                                                >
                                                    <option value="">--</option>
                                                    <option value="S">S (Short)</option>
                                                    <option value="M">M (Medium)</option>
                                                    <option value="L">L (Long)</option>
                                                    <option value="XL">XL (Extra Long)</option>
                                                </select>
                                            ) : (
                                                <input
                                                    className="form-input"
                                                    style={{ padding: compact ? '4px' : '0.25rem', width: '100%' }}
                                                    value={slot.situation || ''}
                                                    onChange={e => updateRow(idx, { situation: e.target.value })}
                                                    placeholder="Situation"
                                                />
                                            )}
                                        </td>
                                    )}

                                    {/* Play Call */}
                                    {visibleColumns.playCall && (
                                        <td style={{ padding }}>
                                            {isLocked ? (
                                                slot.playId ? (
                                                    <PlayChip
                                                        play={plays.find(p => p.id === slot.playId) || { id: slot.playId, name: slot.playName }}
                                                        playBuckets={playCategories}
                                                    />
                                                ) : (
                                                    <span style={{ fontWeight: 'bold' }}>{slot.playName}</span>
                                                )
                                            ) : slot.playId ? (
                                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                    <PlayChip
                                                        play={plays.find(p => p.id === slot.playId) || { id: slot.playId, name: slot.playName }}
                                                        playBuckets={playCategories}
                                                    />
                                                    <button
                                                        className="btn"
                                                        style={{ color: '#94a3b8', padding: '0.1rem', fontSize: '0.7rem' }}
                                                        onClick={() => updateRow(idx, { playName: '', playId: '' })}
                                                        title="Clear play"
                                                    >
                                                        ✕
                                                    </button>
                                                </div>
                                            ) : (
                                                <input
                                                    className="form-input"
                                                    list={tableId ? `play-options-${tableId}` : undefined}
                                                    style={{ padding: compact ? '4px' : '0.25rem', width: '100%', fontWeight: 'bold' }}
                                                    value={slot.playName || ''}
                                                    onChange={e => handlePlayInputChange(idx, slot, e.target.value)}
                                                    onBlur={() => handlePlayInputBlur(idx, slot)}
                                                    onDragOver={(e) => e.preventDefault()}
                                                    onDrop={(e) => handleRowDrop(e, idx)}
                                                    placeholder="Play Call..."
                                                />
                                            )}
                                        </td>
                                    )}

                                    {/* Defense */}
                                    {visibleColumns.defense && (
                                        <td style={{ padding }}>
                                            {isLocked ? (
                                                <span>{slot.defense}</span>
                                            ) : (
                                                <input
                                                    className="form-input"
                                                    style={{ padding: compact ? '4px' : '0.25rem', width: '100%' }}
                                                    value={slot.defense || ''}
                                                    onChange={e => updateRow(idx, { defense: e.target.value })}
                                                    placeholder="Defense"
                                                />
                                            )}
                                        </td>
                                    )}

                                    {/* Notes */}
                                    {visibleColumns.notes && (
                                        <td style={{ padding }}>
                                            {isLocked ? (
                                                <span>{slot.notes}</span>
                                            ) : notesAsButton ? (
                                                (() => {
                                                    const notesInfo = getNotesDisplay ? getNotesDisplay(slot) : { hasNotes: !!slot.notes, label: slot.notes ? '📝 Notes' : 'Add Note...' };
                                                    return (
                                                        <button
                                                            className="btn btn-secondary"
                                                            style={{
                                                                width: '100%',
                                                                padding: compact ? '4px' : '0.25rem',
                                                                textAlign: 'left',
                                                                fontSize: '0.8rem',
                                                                color: notesInfo.hasNotes ? 'var(--primary)' : 'var(--text-secondary)',
                                                                borderColor: notesInfo.hasNotes ? 'var(--primary)' : 'var(--border)'
                                                            }}
                                                            onClick={() => onEditNotes && onEditNotes(segment?.id, slot.id)}
                                                        >
                                                            {notesInfo.label}
                                                        </button>
                                                    );
                                                })()
                                            ) : (
                                                <input
                                                    className="form-input"
                                                    style={{ padding: compact ? '4px' : '0.25rem', width: '100%' }}
                                                    value={slot.notes || ''}
                                                    onChange={e => updateRow(idx, { notes: e.target.value })}
                                                    placeholder="Add Note..."
                                                />
                                            )}
                                        </td>
                                    )}

                                    {/* Actions */}
                                    {visibleColumns.actions && !isLocked && (
                                        <td style={{ padding, textAlign: 'center', whiteSpace: 'nowrap' }}>
                                            <div style={{ display: 'flex', gap: '0.25rem', justifyContent: 'center' }}>
                                                <button
                                                    className={compact ? "btn btn-secondary" : "btn"}
                                                    style={{
                                                        color: 'var(--accent)',
                                                        padding: compact ? '2px 6px' : '0.25rem',
                                                        fontWeight: 'bold',
                                                        fontSize: compact ? '0.8rem' : undefined
                                                    }}
                                                    onClick={() => {
                                                        if (onInsertRow) {
                                                            const newScript = onInsertRow(idx, script);
                                                            if (newScript) onUpdateScript(newScript);
                                                        } else {
                                                            insertRowAfter(idx);
                                                        }
                                                    }}
                                                    tabIndex={-1}
                                                    title="Insert row below"
                                                >
                                                    +
                                                </button>
                                                <button
                                                    className={compact ? "btn btn-secondary" : "btn"}
                                                    style={{
                                                        color: '#ef4444',
                                                        padding: compact ? '2px 6px' : '0.25rem',
                                                        fontSize: compact ? '0.8rem' : undefined
                                                    }}
                                                    onClick={() => {
                                                        if (onDeleteRow) {
                                                            onDeleteRow(idx, slot, script);
                                                        } else if (confirmDelete) {
                                                            if (confirm('Delete this row?')) {
                                                                deleteRow(idx);
                                                            }
                                                        } else {
                                                            deleteRow(idx);
                                                        }
                                                    }}
                                                    tabIndex={-1}
                                                    title="Delete row"
                                                >
                                                    ×
                                                </button>
                                            </div>
                                        </td>
                                    )}
                                </tr>
                            ))}
                            {!isLocked && (
                                <tr>
                                    <td colSpan={colCount} style={{ padding: '1rem', textAlign: 'center' }}>
                                        <button className="btn btn-secondary" onClick={addRow}>
                                            + Add Play Row
                                        </button>
                                    </td>
                                </tr>
                            )}
                        </tbody>
                    </table>
                </div>
            );
        };

        // PlayChipInput - Input field with autocomplete that creates PlayChips
        const PlayChipInput = ({
            plays = [],             // All plays for autocomplete
            selectedPlayIds = [],   // Currently selected plays (array of IDs)
            onChange,               // Called with updated array of play IDs
            onQuickAddPlay,         // Creates new play if not found
            playBuckets = [],       // For chip colors
            placeholder = 'Type play name...',
            allowCreate = true,     // Allow creating new plays
            disabled = false,
        }) => {
            const [inputValue, setInputValue] = useState('');
            const [showDropdown, setShowDropdown] = useState(false);
            const [highlightedIndex, setHighlightedIndex] = useState(0);
            const inputRef = useRef(null);
            const dropdownRef = useRef(null);

            // Filter plays for autocomplete
            const filteredPlays = useMemo(() => {
                if (!inputValue.trim()) return [];
                const search = inputValue.toLowerCase();
                return plays
                    .filter(p =>
                        p.name.toLowerCase().includes(search) &&
                        !selectedPlayIds.includes(p.id)
                    )
                    .slice(0, 8); // Limit results
            }, [inputValue, plays, selectedPlayIds]);

            // Check if input matches existing play exactly
            const exactMatch = plays.find(p =>
                p.name.toLowerCase() === inputValue.trim().toLowerCase()
            );

            // Show create option?
            const showCreateOption = allowCreate &&
                inputValue.trim() &&
                !exactMatch &&
                onQuickAddPlay;

            // Handle selecting a play from dropdown
            const handleSelectPlay = (playId) => {
                if (!selectedPlayIds.includes(playId)) {
                    onChange([...selectedPlayIds, playId]);
                }
                setInputValue('');
                setShowDropdown(false);
                setHighlightedIndex(0);
                inputRef.current?.focus();
            };

            // Handle creating a new play
            const handleCreatePlay = async () => {
                if (!inputValue.trim() || !onQuickAddPlay) return;
                const newPlay = await onQuickAddPlay(inputValue.trim());
                if (newPlay?.id) {
                    onChange([...selectedPlayIds, newPlay.id]);
                }
                setInputValue('');
                setShowDropdown(false);
                setHighlightedIndex(0);
            };

            // Handle removing a chip
            const handleRemoveChip = (playId) => {
                onChange(selectedPlayIds.filter(id => id !== playId));
            };

            // Handle keyboard navigation
            const handleKeyDown = (e) => {
                const totalItems = filteredPlays.length + (showCreateOption ? 1 : 0);

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    setHighlightedIndex(i => Math.min(i + 1, totalItems - 1));
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    setHighlightedIndex(i => Math.max(i - 1, 0));
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (highlightedIndex < filteredPlays.length) {
                        handleSelectPlay(filteredPlays[highlightedIndex].id);
                    } else if (showCreateOption) {
                        handleCreatePlay();
                    }
                } else if (e.key === 'Escape') {
                    setShowDropdown(false);
                } else if (e.key === 'Backspace' && !inputValue && selectedPlayIds.length > 0) {
                    // Remove last chip on backspace with empty input
                    handleRemoveChip(selectedPlayIds[selectedPlayIds.length - 1]);
                }
            };

            // Handle drop
            const handleDrop = (e) => {
                e.preventDefault();
                const playId = e.dataTransfer.getData('application/x-play-id') ||
                    e.dataTransfer.getData('text/plain');
                if (playId && !selectedPlayIds.includes(playId)) {
                    const playExists = plays.some(p => p.id === playId);
                    if (playExists) {
                        onChange([...selectedPlayIds, playId]);
                    }
                }
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            };

            // Close dropdown on outside click
            useEffect(() => {
                const handleClickOutside = (e) => {
                    if (dropdownRef.current && !dropdownRef.current.contains(e.target) &&
                        inputRef.current && !inputRef.current.contains(e.target)) {
                        setShowDropdown(false);
                    }
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, []);

            return (
                <div
                    style={{
                        display: 'flex',
                        flexWrap: 'wrap',
                        alignItems: 'center',
                        gap: '6px',
                        padding: '6px 10px',
                        background: disabled ? '#f1f5f9' : 'white',
                        border: '1px solid #e2e8f0',
                        borderRadius: '8px',
                        minHeight: '42px',
                        position: 'relative',
                    }}
                    onDrop={handleDrop}
                    onDragOver={handleDragOver}
                >
                    {/* Existing chips */}
                    {selectedPlayIds.map(playId => {
                        const play = plays.find(p => p.id === playId);
                        if (!play) return null;
                        return (
                            <PlayChip
                                key={playId}
                                play={play}
                                playBuckets={playBuckets}
                                onRemove={handleRemoveChip}
                                size="sm"
                                showFlags={true}
                            />
                        );
                    })}

                    {/* Input field */}
                    <input
                        ref={inputRef}
                        type="text"
                        value={inputValue}
                        onChange={(e) => {
                            setInputValue(e.target.value);
                            setShowDropdown(true);
                            setHighlightedIndex(0);
                        }}
                        onFocus={() => inputValue && setShowDropdown(true)}
                        onKeyDown={handleKeyDown}
                        placeholder={selectedPlayIds.length === 0 ? placeholder : ''}
                        disabled={disabled}
                        style={{
                            flex: 1,
                            minWidth: '120px',
                            border: 'none',
                            outline: 'none',
                            fontSize: '0.9rem',
                            background: 'transparent',
                            padding: '4px 0',
                        }}
                    />

                    {/* Dropdown */}
                    {showDropdown && (filteredPlays.length > 0 || showCreateOption) && (
                        <div
                            ref={dropdownRef}
                            style={{
                                position: 'absolute',
                                top: '100%',
                                left: 0,
                                right: 0,
                                marginTop: '4px',
                                background: 'white',
                                border: '1px solid #e2e8f0',
                                borderRadius: '8px',
                                boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)',
                                zIndex: 50,
                                maxHeight: '240px',
                                overflowY: 'auto',
                            }}
                        >
                            {filteredPlays.map((play, idx) => (
                                <div
                                    key={play.id}
                                    onClick={() => handleSelectPlay(play.id)}
                                    style={{
                                        padding: '8px 12px',
                                        cursor: 'pointer',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'space-between',
                                        background: idx === highlightedIndex ? '#f1f5f9' : 'white',
                                        borderBottom: idx < filteredPlays.length - 1 || showCreateOption ? '1px solid #f1f5f9' : 'none',
                                    }}
                                    onMouseEnter={() => setHighlightedIndex(idx)}
                                >
                                    <span style={{ fontWeight: 500, color: '#1e293b' }}>{play.name}</span>
                                    {play.wristbandSlot && (
                                        <span style={{ fontSize: '0.75rem', color: '#94a3b8' }}>
                                            {play.wristbandSlot}
                                        </span>
                                    )}
                                </div>
                            ))}

                            {showCreateOption && (
                                <div
                                    onClick={handleCreatePlay}
                                    style={{
                                        padding: '8px 12px',
                                        cursor: 'pointer',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '6px',
                                        background: highlightedIndex === filteredPlays.length ? '#f1f5f9' : 'white',
                                        color: '#3b82f6',
                                        fontWeight: 500,
                                        borderTop: filteredPlays.length > 0 ? '1px solid #e2e8f0' : 'none',
                                    }}
                                    onMouseEnter={() => setHighlightedIndex(filteredPlays.length)}
                                >
                                    <Icon name="Plus" size={14} />
                                    <span>Create "{inputValue.trim().toUpperCase()}"</span>
                                </div>
                            )}
                        </div>
                    )}
                </div>
            );
        };

        /* -------------------------------------------------------------------------- */
        /*                           PLAY DETAILS MODAL                               */
        /* -------------------------------------------------------------------------- */

        const PlayDetailsModal = ({
            playId,
            plays,
            weekDate, // Can be null if not applicable
            newInstallIds = [],
            gamePlanLayouts = GAME_PLAN_LAYOUTS,
            assignedIds = new Set(), // Set of situation IDs this play is assigned to
            onClose,
            onUpdateWeek, // Optional: function(date, field, val)
            onUpdatePlay, // Required: function(id, updates)
            onAssignSituation, // Optional: function(playId, box) -> adds to script/situation
            position = { x: 0, y: 0 },
            playBuckets = [], // Concept families (nested under categories)
            playCategories = [], // Top-level buckets (Run, Pass, Screen)
            currentWeek, // Added for validation
        }) => {
            const play = plays.find(p => p.id === playId);
            if (!play) return null;

            // Local state for immediate visual feedback on situation assignments
            const [localAssignedIds, setLocalAssignedIds] = useState(() => new Set(assignedIds));

            // Sync with prop when it changes (e.g., modal reopens with different play)
            useEffect(() => {
                setLocalAssignedIds(new Set(assignedIds));
            }, [playId]);

            // Handle situation assignment with immediate visual feedback
            const handleSituationClick = (box) => {
                if (!onAssignSituation) return;

                // Toggle local state immediately for visual feedback
                setLocalAssignedIds(prev => {
                    const newSet = new Set(prev);
                    if (newSet.has(box.setId)) {
                        newSet.delete(box.setId);
                    } else {
                        newSet.add(box.setId);
                    }
                    return newSet;
                });

                // Call the actual handler to persist the change
                onAssignSituation(playId, box);
            };

            const isNew = (newInstallIds || []).includes(playId);
            const isPriority = play.priority || false;
            const isWiz = !!(play.isWiz || play.isRooski);
            const isMiniScript = !!play.isMiniScript;

            // Toggle handlers
            const handleToggleNew = () => {
                if (!onUpdateWeek || !weekDate) return;
                const currentNewIds = newInstallIds || [];
                let newIds;
                if (currentNewIds.includes(playId)) {
                    newIds = currentNewIds.filter(id => id !== playId);
                } else {
                    newIds = [...currentNewIds, playId];
                }
                onUpdateWeek(weekDate, 'newInstallIds', newIds);
            };

            const handleTogglePriority = () => {
                if (!onUpdatePlay) return;
                onUpdatePlay(playId, { priority: !isPriority });
            };

            const handleToggleWiz = () => {
                if (!onUpdatePlay) return;
                onUpdatePlay(playId, { isWiz: !isWiz });
            };

            const handleToggleMiniScript = () => {
                if (!onUpdatePlay) return;
                onUpdatePlay(playId, { isMiniScript: !isMiniScript });
            };

            const popoverHeight = 450;
            const popoverWidth = 300; // Increase width slightly for better fit

            // Simple collision detection
            let top = position.y;
            let left = position.x;
            if (top + popoverHeight > window.innerHeight) top = window.innerHeight - popoverHeight - 10;
            if (left + popoverWidth > window.innerWidth) left = window.innerWidth - popoverWidth - 10;

            return (
                <div style={{
                    position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
                    background: 'rgba(0,0,0,0.4)', zIndex: 9999, // Darker backdrop
                    display: 'flex', alignItems: 'center', justifyContent: 'center' // Center it
                }} onClick={onClose}>
                    <div style={{
                        background: 'white', width: '420px', maxHeight: '600px', // Wider and taller
                        borderRadius: '12px', boxShadow: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',
                        display: 'flex', flexDirection: 'column', overflow: 'hidden'
                    }} onClick={e => e.stopPropagation()}>

                        {/* UNIFIED HEADER */}
                        <div style={{ padding: '16px', borderBottom: '1px solid #e2e8f0', display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                            <div>
                                <h3 style={{ margin: 0, fontSize: '1.25rem', fontWeight: 700, color: '#0f172a' }}>
                                    {play.name}
                                </h3>
                                {/* Show play's assigned bucket and concept family */}
                                {(play.bucketId || play.conceptFamily) && (
                                    <div style={{ display: 'flex', gap: '4px', marginTop: '6px', flexWrap: 'wrap' }}>
                                        {play.bucketId && (() => {
                                            const bucket = playCategories.find(c => c.id === play.bucketId);
                                            return bucket ? (
                                                <span style={{
                                                    fontSize: '0.7rem', padding: '2px 6px', borderRadius: '4px',
                                                    background: bucket.color || '#64748b', color: bucket.textColor || '#fff', fontWeight: 600
                                                }}>
                                                    {bucket.label}
                                                </span>
                                            ) : null;
                                        })()}
                                        {play.conceptFamily && (() => {
                                            const family = playBuckets.find(b => b.label === play.conceptFamily);
                                            return (
                                                <span style={{
                                                    fontSize: '0.7rem', padding: '2px 6px', borderRadius: '4px',
                                                    background: family?.color || '#94a3b8', color: family?.textColor || '#fff', fontWeight: 600
                                                }}>
                                                    {play.conceptFamily}
                                                </span>
                                            );
                                        })()}
                                    </div>
                                )}
                            </div>
                            <button onClick={onClose} style={{
                                background: 'transparent', border: 'none', cursor: 'pointer',
                                color: '#94a3b8', padding: '4px'
                            }}>
                                <Icon name="X" size={20} />
                            </button>
                        </div>

                        {/* TOGGLES ROW */}
                        <div style={{ padding: '12px 16px', borderBottom: '1px solid #e2e8f0', display: 'flex', flexWrap: 'wrap', gap: '8px', alignItems: 'center' }}>
                            <button
                                onClick={handleTogglePriority}
                                style={{
                                    padding: '6px 12px', borderRadius: '6px', fontSize: '0.85rem', fontWeight: 600, cursor: 'pointer',
                                    border: isPriority ? '1px solid #f59e0b' : '1px solid #cbd5e1',
                                    background: isPriority ? '#fffbeb' : 'white',
                                    color: isPriority ? '#b45309' : '#64748b',
                                }}
                            >
                                Priority
                            </button>
                            <button
                                onClick={handleToggleWiz}
                                style={{
                                    padding: '6px 12px', borderRadius: '6px', fontSize: '0.85rem', fontWeight: 600, cursor: 'pointer',
                                    border: isWiz ? '1px solid #8b5cf6' : '1px solid #cbd5e1',
                                    background: isWiz ? '#f3e8ff' : 'white',
                                    color: isWiz ? '#7c3aed' : '#64748b',
                                }}
                            >
                                Wiz
                            </button>
                            <button
                                onClick={handleToggleMiniScript}
                                style={{
                                    padding: '6px 12px', borderRadius: '6px', fontSize: '0.85rem', fontWeight: 600, cursor: 'pointer',
                                    border: isMiniScript ? '1px solid #06b6d4' : '1px solid #cbd5e1',
                                    background: isMiniScript ? '#ecfeff' : 'white',
                                    color: isMiniScript ? '#0891b2' : '#64748b',
                                }}
                            >
                                Mini Script
                            </button>
                            <div style={{ marginLeft: 'auto', display: 'flex', alignItems: 'center', gap: '4px' }}>
                                <label style={{ fontSize: '0.85rem', fontWeight: 600, color: '#64748b' }}>WB:</label>
                                <div style={{ position: 'relative', width: '60px' }}>
                                    <input
                                        type="text"
                                        value={play.wristbandSlot || ''}
                                        onChange={(e) => {
                                            const val = e.target.value;

                                            // Validation Logic
                                            let isBlocked = false;
                                            const currentWbSettings = currentWeek?.wristbands || {};
                                            const enabledSections = currentWbSettings.enabledSections || {};

                                            const cardKeys = ['card1', 'card2', 'card3', 'card4', 'card5', 'card6'];
                                            for (const key of cardKeys) {
                                                if (enabledSections[key] !== false) continue;
                                                const card = currentWbSettings[key];
                                                if (!card) continue;
                                                const cardNum = parseInt(key.replace('card', ''));

                                                if (card.type && (card.type === 'rooski' || card.type === 'wiz')) {
                                                    for (let i = 1; i <= 16; i++) {
                                                        if (val === `${cardNum}${String(i).padStart(2, '0')}`) isBlocked = true;
                                                    }
                                                } else {
                                                    const start = cardNum * 100 + 1;
                                                    const end = start + 47;
                                                    const num = parseInt(val);
                                                    if (!isNaN(num) && num >= start && num <= end && String(num) === val) isBlocked = true;
                                                }
                                            }

                                            // Check Staples
                                            if (enabledSections.staples === false) {
                                                const num = parseInt(val);
                                                if (!isNaN(num) && num >= 10 && num <= 89 && String(num) === val) isBlocked = true;
                                            }

                                            if (isBlocked) {
                                                alert("This wristband section is disabled.");
                                                return;
                                            }

                                            onUpdatePlay(playId, { wristbandSlot: val });
                                        }}
                                        style={{
                                            width: '100%', padding: '4px 6px', fontSize: '0.9rem', fontWeight: 600,
                                            borderRadius: '4px', border: '1px solid #cbd5e1',
                                            color: '#0f172a', textAlign: 'center'
                                        }}
                                    />
                                </div>
                            </div>
                        </div>

                        {/* BUCKET SELECTION */}
                        {playCategories && playCategories.length > 0 && (
                            <div style={{ padding: '12px 16px', borderBottom: '1px solid #e2e8f0' }}>
                                <div style={{
                                    fontSize: '0.7rem', fontWeight: '700', color: '#94a3b8',
                                    marginBottom: '8px', textTransform: 'uppercase', letterSpacing: '0.05em'
                                }}>
                                    Bucket
                                </div>
                                <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px' }}>
                                    {playCategories.map(cat => {
                                        const isSelected = play.bucketId === cat.id;
                                        return (
                                            <button
                                                key={cat.id}
                                                onClick={() => onUpdatePlay && onUpdatePlay(playId, {
                                                    bucketId: isSelected ? null : cat.id,
                                                    conceptFamily: isSelected ? null : play.conceptFamily // Clear family if deselecting bucket
                                                })}
                                                style={{
                                                    padding: '5px 10px',
                                                    borderRadius: '6px',
                                                    fontSize: '0.8rem',
                                                    fontWeight: 600,
                                                    cursor: 'pointer',
                                                    border: isSelected ? `2px solid ${cat.color || '#3b82f6'}` : '1px solid #e2e8f0',
                                                    background: isSelected ? (cat.color || '#3b82f6') : 'white',
                                                    color: isSelected ? (cat.textColor || '#fff') : '#64748b',
                                                    transition: 'all 0.15s ease',
                                                }}
                                            >
                                                {cat.label}
                                            </button>
                                        );
                                    })}
                                </div>
                            </div>
                        )}

                        {/* CONCEPT FAMILY SELECTION (nested under selected bucket) */}
                        {play.bucketId && playBuckets && playBuckets.filter(b => b.categoryId === play.bucketId).length > 0 && (
                            <div style={{ padding: '12px 16px', borderBottom: '1px solid #e2e8f0' }}>
                                <div style={{
                                    fontSize: '0.7rem', fontWeight: '700', color: '#94a3b8',
                                    marginBottom: '8px', textTransform: 'uppercase', letterSpacing: '0.05em'
                                }}>
                                    Concept Family
                                </div>
                                <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px' }}>
                                    {playBuckets
                                        .filter(b => b.categoryId === play.bucketId)
                                        .map(family => {
                                            const isSelected = play.conceptFamily === family.label;
                                            return (
                                                <button
                                                    key={family.id}
                                                    onClick={() => onUpdatePlay && onUpdatePlay(playId, {
                                                        conceptFamily: isSelected ? null : family.label
                                                    })}
                                                    style={{
                                                        padding: '5px 10px',
                                                        borderRadius: '6px',
                                                        fontSize: '0.8rem',
                                                        fontWeight: 600,
                                                        cursor: 'pointer',
                                                        border: isSelected ? `2px solid ${family.color || '#64748b'}` : '1px solid #e2e8f0',
                                                        background: isSelected ? (family.color || '#64748b') : 'white',
                                                        color: isSelected ? (family.textColor || '#fff') : '#64748b',
                                                        transition: 'all 0.15s ease',
                                                    }}
                                                >
                                                    {family.label}
                                                </button>
                                            );
                                        })}
                                </div>
                            </div>
                        )}

                        {/* BODY - SCROLLABLE CHIPS */}
                        <div style={{ padding: '16px', overflowY: 'auto', flex: 1 }}>
                            {(gamePlanLayouts?.CALL_SHEET?.sections || []).map((section, sIdx) => {
                                const relevantBoxes = (section.boxes || []).filter(b => b.header && !b.hidden);
                                if (relevantBoxes.length === 0) return null;

                                return (
                                    <div key={sIdx} style={{ marginBottom: '20px' }}>
                                        <div style={{
                                            fontSize: '0.75rem', fontWeight: '800', color: '#94a3b8',
                                            marginBottom: '8px', textTransform: 'uppercase', letterSpacing: '0.05em'
                                        }}>
                                            {section.title || `Section ${sIdx + 1}`}
                                        </div>
                                        <div style={{ display: 'flex', flexWrap: 'wrap', gap: '8px' }}>
                                            {relevantBoxes.map((box, bIdx) => {
                                                const isCheck = localAssignedIds.has(box.setId);
                                                // Determine active color based on box config or fallbacks
                                                const activeBorderColor = box.color || '#3b82f6';

                                                return (
                                                    <button
                                                        key={bIdx}
                                                        onClick={() => handleSituationClick(box)}
                                                        style={{
                                                            padding: '6px 10px',
                                                            borderRadius: '6px',
                                                            cursor: 'pointer',
                                                            fontSize: '0.8rem',
                                                            fontWeight: isCheck ? '600' : '500',
                                                            border: isCheck ? `2px solid ${activeBorderColor}` : '1px solid #e2e8f0',
                                                            background: isCheck ? `${activeBorderColor}15` : 'white',
                                                            color: isCheck ? activeBorderColor : '#64748b',
                                                            boxShadow: isCheck ? `0 0 0 1px ${activeBorderColor}40` : 'none',
                                                            transition: 'all 0.15s ease',
                                                            position: 'relative',
                                                            overflow: 'hidden'
                                                        }}
                                                    >
                                                        {isCheck && (
                                                            <div style={{
                                                                position: 'absolute', left: 0, top: 0, bottom: 0, width: '4px',
                                                                background: activeBorderColor
                                                            }} />
                                                        )}
                                                        {box.header}
                                                    </button>
                                                );
                                            })}
                                        </div>
                                    </div>
                                );
                            })}
                        </div >
                    </div >
                </div >
            );
        };

        const checkRedundantFormation = (playName, formationName) => {
            if (!playName || !formationName) return false;
            const pName = playName.toLowerCase();
            const fName = formationName.toLowerCase();

            // 1. Direct Check
            if (pName.includes(fName)) return true;

            // 2. Abbreviation Check
            const abbreviations = {
                'green': 'grn',
                'orange': 'orng',
                'yellow': 'ylw',
                'blue': 'blu',
                'gold': 'gld',
                'black': 'blk',
                'white': 'wht',
                'brown': 'brn',
                'right': 'rt',
                'left': 'lt'
            };

            let normalizedFormation = fName;
            Object.keys(abbreviations).forEach(full => {
                normalizedFormation = normalizedFormation.replace(new RegExp(full, 'g'), abbreviations[full]);
            });

            if (pName.includes(normalizedFormation)) return true;

            return false;
        };

        const WristbandBuilder = ({ plays, weeks, currentWeek, gamePlan, onUpdatePlay, onUpdateWeek, wbSettings, setWbSettings, onNavigate, installList = [], seasonOpponent, playCategories = [], onQuickAddPlay }) => {
            const { currentUser } = useAuth();
            const [selectedCardId, setSelectedCardId] = useState('card1'); // Default to Card 1
            const [sidebarMode, setSidebarMode] = useState('plays'); // 'plays' or 'scripts'
            const [selectedPlayId, setSelectedPlayId] = useState(null);
            const [searchTerm, setSearchTerm] = useState('');
            const [confirmModal, setConfirmModal] = useState(null); // { action: 'wb1'|'wb2'|'both', message: string }
            const [quickAddSlot, setQuickAddSlot] = useState(null);
            const [quickAddValue, setQuickAddValue] = useState('');
            const [quickAddSuggestions, setQuickAddSuggestions] = useState([]);
            const [selectedDay, setSelectedDay] = useState('Monday');
            const [staplesInputs, setStaplesInputs] = useState({}); // Track input values for Staples slots

            // Layout constants
            const rowHeight = 11;
            const fontSize = 0.55;

            // Header customization helpers
            const updateCard = (cardId, updates) => {
                setWbSettings(prev => ({
                    ...prev,
                    [cardId]: { ...prev[cardId], ...updates }
                }));
            };

            // Migration effect: Convert old flat settings to new nested structure
            useEffect(() => {
                if (!wbSettings.card1) {
                    // It's the old structure or empty
                    const newWb = {
                        card1: { type: 'standard', opp: wbSettings.wb1Opp || '', iter: wbSettings.wb1Iter || '1', rows: [] },
                        card2: { type: 'standard', opp: wbSettings.wb2Opp || '', iter: wbSettings.wb2Iter || '1', rows: [] },
                        card3: { type: 'standard', opp: '', iter: '1', rows: [] },
                        card4: { type: 'standard', opp: '', iter: '1', rows: [] },
                        card5: { type: 'standard', opp: '', iter: '1', rows: [] },
                        card6: { type: 'standard', opp: '', iter: '1', rows: [] },
                        version: 'v3'
                    };
                    setWbSettings(newWb);
                } else if (!wbSettings.card4) {
                    // Migrate from v2 to v3 (add new cards)
                    setWbSettings(prev => ({
                        ...prev,
                        card4: { type: 'standard', opp: '', iter: '1', rows: [] },
                        card5: { type: 'standard', opp: '', iter: '1', rows: [] },
                        card6: { type: 'standard', opp: '', iter: '1', rows: [] },
                        version: 'v3'
                    }));
                } else {
                    // Check for old 'modular' type and auto-migrate to 'mini-scripts'
                    let hasMigration = false;
                    const updates = {};
                    ['card1', 'card2', 'card3', 'card4', 'card5', 'card6'].forEach(cardKey => {
                        const card = wbSettings[cardKey];
                        if (card && card.type === 'modular' && card.rows && !card.version) {
                            // If it has 'rows' and NO version (legacy), migrate to mini-scripts
                            updates[cardKey] = { ...card, type: 'mini-scripts', version: 'v1' };
                            hasMigration = true;
                        }
                    });

                    if (hasMigration) {
                        setWbSettings(prev => ({ ...prev, ...updates }));
                    }
                }
            }, []);

            // Auto-sync to Firestore (debounced or just when changed)
            // REMOVED: Now handled by 'weeks' sync in App component
            // useEffect(() => {
            //     if (currentUser && (wbSettings.version === 'v2' || wbSettings.version === 'v3')) {
            //         syncToFirestore(currentUser.uid, 'wbSettings', wbSettings);
            //     }
            // }, [wbSettings, currentUser]);

            // Quick add state

            // Filter plays for the sidebar list
            const filteredPlays = useMemo(() => {
                // 1. Filter
                const filtered = plays.filter(p =>
                    p.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    p.formation.toLowerCase().includes(searchTerm.toLowerCase())
                );

                // 2. Sort: Priority > Install > Rest
                return filtered.sort((a, b) => {
                    // Tier 1: Priority (Stars)
                    if (a.priority && !b.priority) return -1;
                    if (!a.priority && b.priority) return 1;

                    // Tier 2: Install List (if priorities are equal)
                    // Only check this if both are NOT priority (or both ARE priority, but usually priority > install)
                    if (!a.priority && !b.priority) {
                        const aInstalled = installList.includes(a.id);
                        const bInstalled = installList.includes(b.id);
                        if (aInstalled && !bInstalled) return -1;
                        if (!aInstalled && bInstalled) return 1;
                    }

                    // Tier 3: Alphabetical Name
                    return a.name.localeCompare(b.name);
                });
            }, [plays, searchTerm, installList]);

            // Group plays by slot for easy lookup
            const slotMap = useMemo(() => {
                const map = {};
                plays.forEach(p => {
                    if (p.wristbandSlot) map[p.wristbandSlot] = p;
                    if (p.staplesSlot) map[p.staplesSlot] = p;
                });
                return map;
            }, [plays]);

            // Initialize Staples inputs based on current play assignments
            useEffect(() => {
                const inputs = {};
                for (let slot = 10; slot <= 89; slot++) {
                    const play = slotMap[slot];
                    if (play) {
                        inputs[slot] = getPlaySignature(play);
                    }
                }
                setStaplesInputs(inputs);
            }, [slotMap]);

            // Auto-cleanup Ghost Assignments (Wiz/Mini-Scripts overflow)
            useEffect(() => {
                if (!wbSettings || !selectedCardId) return;

                const card = wbSettings[selectedCardId];
                if (!card) return;

                let startSlot = 0;
                if (selectedCardId === 'card1') startSlot = 101;
                else if (selectedCardId === 'card2') startSlot = 201;
                else if (selectedCardId === 'card3') startSlot = 301;
                else if (selectedCardId === 'card4') startSlot = 401;
                else if (selectedCardId === 'card5') startSlot = 501;
                else if (selectedCardId === 'card6') startSlot = 601;

                if (startSlot === 0) return;

                const updates = [];

                if (card.type === 'rooski' || card.type === 'wiz') {
                    const maxWiz = startSlot + 15;
                    const maxStandard = startSlot + 47; // Standard 48 slots

                    // Identify ghosts: plays assigned to > maxRooski but within standard range
                    plays.forEach(p => {
                        if (!p.wristbandSlot) return;
                        const slotStr = p.wristbandSlot.toString();
                        const slot = parseInt(slotStr, 10);

                        if (slot > maxWiz && slot <= maxStandard) {
                            updates.push({ ...p, wristbandSlot: '' });
                        }
                    });

                } else if (card.type === 'mini-scripts') {
                    const minStandard = startSlot;
                    const maxStandard = startSlot + 99; // Wide net

                    // Identify ghosts: plays assigned to numeric slots (Traditional) when in Mini-Scripts
                    plays.forEach(p => {
                        if (!p.wristbandSlot) return;
                        const slotStr = p.wristbandSlot.toString();

                        // If it's pure number, it's a Traditional ghost in Mini-Scripts land
                        // Mini-Scripts use "101A", "101B"
                        if (/^\d+$/.test(slotStr)) {
                            const slot = parseInt(slotStr, 10);
                            if (slot >= minStandard && slot <= maxStandard) {
                                updates.push({ ...p, wristbandSlot: '' });
                            }
                        }
                    });
                }

                if (updates.length > 0) {
                    // Use setTimeout to avoid render-cycle conflicts if immediate
                    setTimeout(() => onUpdatePlay(updates), 0);
                }
            }, [wbSettings, selectedCardId, plays]); // Dependency on plays ensures we re-check if data loads later


            // Sync Mini-Script assignments (101A/101B)
            useEffect(() => {
                // Prevent running if no plays or settings
                if (!plays || plays.length === 0 || !wbSettings) return;

                const newAssignments = new Map(); // playId -> slot string

                ['card1', 'card2', 'card3', 'card4', 'card5', 'card6'].forEach(cardId => {
                    const card = wbSettings[cardId];
                    if (card && card.type === 'mini-scripts' && card.rows) {
                        const startCoord = cardId === 'card1' ? 101 : (cardId === 'card2' ? 201 : (cardId === 'card3' ? 301 : (cardId === 'card4' ? 401 : (cardId === 'card5' ? 501 : 601))));
                        let currentCoord = startCoord;

                        card.rows.forEach(row => {
                            if (row.type !== 'header') {
                                const coord = currentCoord++;

                                // Slot A (Play 1)
                                if (row.col1Id) {
                                    newAssignments.set(row.col1Id, `${coord}A`);
                                } else if (row.col1) {
                                    // Try find by name
                                    const p = plays.find(pl => pl.name === row.col1);
                                    if (p) newAssignments.set(p.id, `${coord}A`);
                                }

                                // Slot B (Play 2)
                                if (row.col3Id) {
                                    newAssignments.set(row.col3Id, `${coord}B`);
                                } else if (row.col3) {
                                    // Try find by name
                                    const p = plays.find(pl => pl.name === row.col3);
                                    if (p) newAssignments.set(p.id, `${coord}B`);
                                }
                            }
                        });
                    }
                });

                // Calculate updates to plays
                const updates = [];
                plays.forEach(p => {
                    const target = newAssignments.get(p.id);
                    const current = p.wristbandSlot;

                    if (target) {
                        if (current !== target) {
                            updates.push({ ...p, wristbandSlot: target });
                        }
                    } else {
                        // If Play has a Mini-Script slot (digits + A/B) but is no longer mapped, clear it.
                        // Explicitly check for A/B suffix to avoid clearing standard wristband slots (integers)
                        if (current && /^\d+[AB]$/.test(current)) {
                            updates.push({ ...p, wristbandSlot: '' });
                        }
                    }
                });

                if (updates.length > 0) {
                    onUpdatePlay(updates);
                }

            }, [wbSettings, plays]);


            // Helper to match Staples concept + color
            const getPlaySignature = (p) => {
                if (!p.name) return '';

                let s = p.name.trim();
                const form = (p.formation || '').trim();

                // 1. Strip structural formations from start
                // We define "Structural" as anything not in the usual color list
                const colors = ['RED', 'BLUE', 'GRN', 'GREEN', 'BRIGHT', 'BRT', 'ORNG', 'ORANGE', 'GOLD', 'BRN', 'BROWN', 'TEAL', 'PINK', 'PURPLE', 'YELLOW'];
                const isColorFormation = colors.includes(form.toUpperCase());

                if (form && !isColorFormation) {
                    // Case-insensitive strip from start
                    const regex = new RegExp('^' + form.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\s+', 'i');
                    s = s.replace(regex, '');
                }

                // 2. Strip explicit tags if they are in the tags array
                if (p.tags && p.tags.length > 0) {
                    p.tags.forEach(tag => {
                        if (tag) {
                            // Strip tag as a word everywhere
                            const regex = new RegExp('\\b' + tag.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'gi');
                            s = s.replace(regex, '');
                        }
                    });
                }

                // 3. Final cleanup: strip common non-concept chars but keep + for variations
                // We keep + because the user specifically said "+ TRIBE" should stay distinct.
                return s.replace(/\s+/g, ' ').replace(/\*$/, '').trim();
            };

            const assignPlayToSlot = (play, slot, cardId) => {
                const card = wbSettings[cardId];
                if (!card) return;

                const isWiz = card.layout === 'wiz';
                const isMiniScript = card.layout === 'mini-scripts';

                if (card.type === 'staples') {
                    const signature = getPlaySignature(play);
                    const matchingPlays = plays.filter(p => getPlaySignature(p) === signature);
                    const updates = matchingPlays.map(p => ({
                        ...p,
                        staplesSlot: slot.toString(),
                    }));
                    onUpdatePlay(updates);
                } else {
                    onUpdatePlay({
                        ...play,
                        wristbandSlot: slot.toString(),
                        isWiz: isWiz,
                        isMiniScript: isMiniScript,
                        isWiz: false
                    });
                }
            };

            const handleAutoAssign = (play) => {
                const card = wbSettings[selectedCardId];
                if (!card) return;

                let availableSlot = null;
                if (card.type === 'staples') {
                    for (let i = 10; i <= 89; i++) {
                        if (!slotMap[i]) {
                            availableSlot = i;
                            break;
                        }
                    }
                } else {
                    const startSlot = selectedCardId === 'card1' ? 101 : (selectedCardId === 'card2' ? 201 : (selectedCardId === 'card3' ? 301 : (selectedCardId === 'card4' ? 401 : (selectedCardId === 'card5' ? 501 : 601))));
                    const maxSlots = (card.layout === 'wiz' || card.layout === 'rooski') ? 16 : 48;
                    for (let i = 0; i < maxSlots; i++) {
                        const slot = startSlot + i;
                        if (!slotMap[slot]) {
                            availableSlot = slot;
                            break;
                        }
                    }
                }

                if (availableSlot) {
                    assignPlayToSlot(play, availableSlot, selectedCardId);
                }
            };

            const handleAssignSlot = (slot) => {
                if (!selectedPlayId) return;
                const play = plays.find(p => p.id === selectedPlayId);
                if (play) {
                    assignPlayToSlot(play, slot, selectedCardId);
                    setSelectedPlayId(null);
                }
            };

            const handleUpdateRow = (cardId, rowId, updates) => {
                const card = wbSettings[cardId];
                const newRows = card.rows.map(r => r.id === rowId ? { ...r, ...updates } : r);
                updateCard(cardId, { rows: newRows });
            };

            const handleRemoveRow = (cardId, rowId) => {
                const card = wbSettings[cardId];
                const newRows = card.rows.filter(r => r.id !== rowId);
                updateCard(cardId, { rows: newRows });
            };

            const handleMoveRow = (cardId, rowId, direction) => {
                const card = wbSettings[cardId];
                const index = card.rows.findIndex(r => r.id === rowId);
                if (index === -1) return;
                const newIndex = index + direction;
                if (newIndex < 0 || newIndex >= card.rows.length) return;

                const newRows = [...card.rows];
                const [moved] = newRows.splice(index, 1);
                newRows.splice(newIndex, 0, moved);
                updateCard(cardId, { rows: newRows });
            };

            const handleAddPlayRow = (cardId, play) => {
                const card = wbSettings[cardId];
                const newRow = {
                    id: Date.now().toString(),
                    type: 'play-row',
                    col1: play.name,
                    col2: '',
                    col3: ''
                };
                updateCard(cardId, { rows: [...card.rows, newRow] });
            };

            const handleAddScriptRows = (cardId, miniScript) => {
                const card = wbSettings[cardId];
                const newRows = (miniScript.playIds || []).map(playId => ({
                    id: `row_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    type: 'play',
                    playId: playId,
                    playName: plays.find(p => p.id === playId)?.name || 'Unknown'
                }));
                updateCard(cardId, { rows: [...card.rows, ...newRows] });
            };

            const handleAddTempoRow = (cardId, tempoType) => {
                const card = wbSettings[cardId];
                const protocol = CALENDAR_CONSTANTS.PRACTICE_TEMPO_PROTOCOLS.find(p => p.id === tempoType);
                const newRow = {
                    id: `row_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    type: 'tempo',
                    tempoType: tempoType,
                    label: protocol ? protocol.code : tempoType
                };
                updateCard(cardId, { rows: [...card.rows, newRow] });
            };

            const handleAddHeaderRow = (cardId) => {
                const card = wbSettings[cardId];
                if (!card) return;

                const timestamp = Date.now();
                const newHeader = {
                    id: timestamp.toString(),
                    type: 'header',
                    label: '',
                    color: 'gray'
                };

                const newPlayRow = {
                    id: `row_${timestamp + 1}_${Math.random().toString(36).substr(2, 9)}`,
                    type: 'play-row',
                    col0: '',
                    col1: '',
                    col2: '',
                    col3: ''
                };

                updateCard(cardId, { rows: [...card.rows, newHeader, newPlayRow] });
            };

            const handleLayoutChange = (newType) => {
                let startSlot = 0;
                if (selectedCardId === 'card1') startSlot = 101;
                else if (selectedCardId === 'card2') startSlot = 201;
                else if (selectedCardId === 'card3') startSlot = 301;
                else if (selectedCardId === 'card4') startSlot = 401;
                else if (selectedCardId === 'card5') startSlot = 501;
                else if (selectedCardId === 'card6') startSlot = 601;

                const updates = [];

                // Unified Layout Change Logic
                updateCard(selectedCardId, { layout: newType, type: newType });

                if (startSlot > 0) {
                    const isWiz = newType === 'wiz';
                    const isMini = newType === 'mini-scripts';
                    const isWizType = newType === 'wiz' || newType === 'rooski';
                    const cardMin = startSlot;
                    const cardMax = startSlot + 99;
                    const wizMax = startSlot + 15;

                    const updatesToApply = [];

                    plays.forEach(p => {
                        const slot = parseInt(p.wristbandSlot || 0);
                        if (slot >= cardMin && slot <= cardMax) {
                            let update = { ...p };
                            let changed = false;

                            // 1. Update Layout Flags
                            if (p.isWiz !== isWiz || p.isMiniScript !== isMini || (isWizType && !p.isWiz)) {
                                update.isWiz = isWiz || isWizType;
                                update.isMiniScript = isMini;
                                changed = true;
                            }

                            // 2. Clear Out-of-Bounds (for 16-slot grids)
                            if (isWizType && slot > wizMax) {
                                update.wristbandSlot = '';
                                changed = true;
                            }

                            if (changed) updatesToApply.push(update);
                        }
                    });

                    if (updatesToApply.length > 0) {
                        onUpdatePlay(updatesToApply);
                    }
                }
            };


            const handleClearCard = (cardId) => {
                const cardName = cardId === 'card1' ? 'WB1 (100s)' : (cardId === 'card2' ? 'WB2 (200s)' : (cardId === 'card3' ? 'WB3 (300s)' : (cardId === 'card4' ? 'WB4 (400s)' : (cardId === 'card5' ? 'WB5 (500s)' : (cardId === 'card6' ? 'WB6 (600s)' : 'STAPLES')))));
                setConfirmModal({
                    action: cardId,
                    message: `Clear all plays from ${cardName}? This cannot be undone.`
                });
            };

            const handleClearBoth = () => {
                setConfirmModal({
                    action: 'all',
                    message: 'Clear ALL wristband assignments? This cannot be undone.'
                });
            };

            const confirmClear = () => {
                if (!confirmModal) return;

                const updates = [];

                if (confirmModal.action === 'all') {
                    // Clear all play linkings
                    plays.forEach(play => {
                        let needsUpdate = false;
                        const update = { ...play };
                        if (play.wristbandSlot) {
                            update.wristbandSlot = '';
                            needsUpdate = true;
                        }
                        if (play.staplesSlot) {
                            update.staplesSlot = '';
                            needsUpdate = true;
                        }
                        if (needsUpdate) updates.push(update);
                    });

                    // Clear all modular rows
                    setWbSettings(prev => ({
                        card1: { ...prev.card1, rows: [] },
                        card2: { ...prev.card2, rows: [] },
                        card3: { ...prev.card3, rows: [] },
                        card4: { ...prev.card4, rows: [] },
                        card5: { ...prev.card5, rows: [] },
                        card6: { ...prev.card6, rows: [] }
                    }));
                } else {
                    const cardId = confirmModal.action;
                    const card = wbSettings[cardId];

                    if (card && card.type === 'staples') {
                        // Clear Staples (10-89)
                        plays.forEach(play => {
                            if (play.staplesSlot) {
                                const slot = parseInt(play.staplesSlot, 10);
                                if (!isNaN(slot) && slot >= 10 && slot <= 89) {
                                    updates.push({ ...play, staplesSlot: '' });
                                }
                            }
                        });
                    } else {
                        // Standard Clear (works for Standard, Wiz, Mini-Scripts if they use slots)
                        const start = cardId === 'card1' ? 101 : (cardId === 'card2' ? 201 : (cardId === 'card3' ? 301 : (cardId === 'card4' ? 401 : (cardId === 'card5' ? 501 : 601))));
                        const end = start + 99; // Allow for wider range (e.g. up to 199) to catch A/B slots if parsed as int

                        plays.forEach(play => {
                            if (play.wristbandSlot) {
                                const slot = parseInt(play.wristbandSlot, 10);
                                // Check if slot matches the card range (e.g. 101-199)
                                if (!isNaN(slot) && slot >= start && slot < start + 100) {
                                    updates.push({ ...play, wristbandSlot: '' });
                                }
                            }
                        });
                    }

                    updateCard(cardId, { rows: [] });
                }

                if (updates.length > 0) {
                    onUpdatePlay(updates);
                }

                setConfirmModal(null);
            };

            const cancelClear = () => {
                setConfirmModal(null);
            };

            // Quick Add Functions
            const handleQuickAddStart = (slot) => {
                setQuickAddSlot(slot);
                setQuickAddValue('');
                setQuickAddSuggestions([]);
                setSelectedPlayId(null); // Clear any selected play
            };

            const handleQuickAddChange = (value) => {
                setQuickAddValue(value.toUpperCase());
                // Filter plays for autocomplete
                if (value.trim()) {
                    const suggestions = plays.filter(p =>
                        p.name.toLowerCase().includes(value.toLowerCase())
                    ).slice(0, 5);
                    setQuickAddSuggestions(suggestions);
                } else {
                    setQuickAddSuggestions([]);
                }
            };

            const handleQuickAddSubmit = (slot) => {
                if (!quickAddValue.trim()) return;

                // Check if play exists (case-insensitive exact match)
                const existingPlay = plays.find(p =>
                    p.name.toLowerCase() === quickAddValue.trim().toLowerCase()
                );

                if (existingPlay) {
                    // Link to existing play
                    onUpdatePlay({ ...existingPlay, wristbandSlot: slot.toString() });
                } else {
                    // Create minimal new play
                    const newPlay = {
                        id: `play_${Date.now()}`,
                        name: quickAddValue.trim(),
                        formation: '',
                        tags: [],
                        wristbandSlot: slot.toString(),
                        diagramData: null,
                        personnel: '',
                        concept: '',
                        notes: '',
                        incomplete: true // Mark as incomplete so user can upgrade later
                    };
                    onUpdatePlay(newPlay); // This will add to plays array
                }

                setQuickAddSlot(null);
                setQuickAddValue('');
                setQuickAddSuggestions([]);
            };

            const handleQuickAddSelectSuggestion = (play, slot) => {
                // User clicked autocomplete suggestion
                onUpdatePlay({ ...play, wristbandSlot: slot.toString() });
                setQuickAddSlot(null);
                setQuickAddValue('');
                setQuickAddSuggestions([]);
            };

            const handleQuickAddCancel = () => {
                setQuickAddSlot(null);
                setQuickAddValue('');
                setQuickAddSuggestions([]);
            };

            // Staples Input Handlers
            const handleStaplesInputChange = (slot, value) => {
                setStaplesInputs(prev => ({ ...prev, [slot]: value }));
            };

            const handleStaplesInputBlur = (slot) => {
                const inputValue = (staplesInputs[slot] || '').trim().toUpperCase();

                if (!inputValue) {
                    // Clear the slot if input is empty
                    const playsToUpdate = plays.filter(p => p.staplesSlot === slot.toString());
                    if (playsToUpdate.length > 0) {
                        const updates = playsToUpdate.map(p => ({ ...p, staplesSlot: '' }));
                        onUpdatePlay(updates);
                    }
                    return;
                }

                // Find all plays that match this signature (excluding formation)
                const matchingPlays = plays.filter(p => {
                    const playSignature = getPlaySignature(p).toUpperCase();
                    return playSignature === inputValue;
                });

                if (matchingPlays.length > 0) {
                    // Update all matching plays
                    const updates = matchingPlays.map(p => ({
                        ...p,
                        staplesSlot: slot.toString()
                    }));
                    onUpdatePlay(updates);
                } else {
                    // No matches found - optionally show warning
                    console.warn(`No plays found matching signature: ${inputValue}`);
                }
            };

            const handleStaplesInputKeyDown = (e, slot) => {
                if (e.key === 'Enter') {
                    e.target.blur(); // Trigger blur handler
                }
            };


            // Generate slots for tables
            const slots100 = [];
            const slots200 = [];
            for (let i = 101; i <= 148; i++) slots100.push(i);
            for (let i = 201; i <= 248; i++) slots200.push(i);


            const renderSpreadsheetTable = (slots, rangeClass, cardId, title = '') => {
                const card = wbSettings[cardId];
                if (!card) return null;
                const isMiniScripts = card.type === 'mini-scripts';


                // Determine row source
                let displayRows = [];
                if (isMiniScripts) {
                    // Mini-Scripts uses the sequence of rows defined in the card
                    displayRows = card.rows.map((row, idx) => {
                        if (row.type === 'play') {
                            const play = plays.find(p => p.id === row.playId);
                            const playName = row.playName || play?.name || 'Unknown';
                            const wristbandSlot = play?.wristbandSlot || '';
                            const displayText = wristbandSlot ? `[${wristbandSlot}] ${playName}` : playName;
                            return {
                                slot: slots[0] + idx, // This linear slot might not match the 3-column grouping perfectly if we just use idx, but it's consistent with existing logic. 
                                // Actually for 3-col grouping (A/B/C), if rows are linear, we chunk them.
                                type: row.type,
                                text: displayText,
                                playId: row.playId,
                                rowId: row.id
                            };
                        } else {
                            return {
                                slot: slots[0] + idx,
                                type: row.type,
                                text: row.label,
                                playId: row.playId,
                                rowId: row.id
                            };
                        }
                    });
                } else {
                    // Standard uses the absolute slots
                    displayRows = slots.map(slot => {
                        const play = slotMap[slot];
                        return {
                            slot: slot,
                            type: 'play',
                            text: play ? `${play.name}${play.formation && !checkRedundantFormation(play.name, play.formation) ? ' - ' + play.formation : ''}` : '',
                            play: play
                        };
                    });
                }

                if (isMiniScripts) {
                    // ---------------------------------------------------------
                    // MINI-SCRIPTS LAYOUT: 1 Coord Column + 3 Play Columns
                    // ---------------------------------------------------------

                    // Calculate start index for coord if not provided
                    // Calculate start index for coord if not provided
                    const startCoord = cardId === 'card1' ? 101 : (cardId === 'card2' ? 201 : (cardId === 'card3' ? 301 : (cardId === 'card4' ? 401 : (cardId === 'card5' ? 501 : 601))));
                    let currentCoord = startCoord;

                    return (
                        <div style={{ width: '100%', height: '100%', display: 'flex', flexDirection: 'column', border: '2px solid black' }}>
                            {/* Header */}
                            <div style={{
                                background: 'black',
                                color: 'white',
                                fontWeight: 'bold',
                                fontSize: '10pt',
                                padding: '2px 4px',
                                display: 'flex',
                                justifyContent: 'space-between',
                                alignItems: 'center'
                            }}>
                                <span style={{ textTransform: 'uppercase' }}>SCRIPT</span>
                                <span>{title}</span>
                            </div>

                            {/* Table */}
                            <div style={{ flex: 1, overflow: 'hidden' }}>
                                <table className="wristband-spreadsheet-table" style={{ width: '100%', tableLayout: 'fixed', borderCollapse: 'collapse' }}>
                                    <colgroup>
                                        <col style={{ width: '38px' }} />
                                        <col style={{ width: '45px' }} />
                                        <col style={{ width: 'auto' }} />
                                        <col style={{ width: '45px' }} />
                                        <col style={{ width: 'auto' }} />
                                    </colgroup>
                                    <thead>
                                        <tr style={{ background: '#e5e5e5', fontSize: '8pt', fontWeight: 'bold', textAlign: 'center', height: 'auto' }}>
                                            <th style={{ borderBottom: '1px solid #000', borderRight: '1px solid #000', padding: 0, textAlign: 'center' }}>#</th>
                                            <th style={{ borderBottom: '1px solid #000', borderRight: '1px solid #000', padding: 0, textAlign: 'center' }}>TEMPO</th>
                                            <th style={{ borderBottom: '1px solid #000', borderRight: '1px solid #000', padding: 0, textAlign: 'center' }}>PLAY A</th>
                                            <th style={{ borderBottom: '1px solid #000', borderRight: '1px solid #000', padding: 0, textAlign: 'center' }}>TEMPO</th>
                                            <th style={{ borderBottom: '1px solid #000', padding: 0, textAlign: 'center' }}>PLAY B</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {card.rows && card.rows.map((row, rowIndex) => {
                                            if (row.type === 'header') {
                                                // Header Row
                                                const bg = row.color === 'black' ? '#000' :
                                                    row.color === 'red' ? '#ef4444' :
                                                        row.color === 'blue' ? '#3b82f6' :
                                                            row.color === 'green' ? '#22c55e' :
                                                                row.color === 'orange' ? '#f97316' : '#d1d5db';
                                                const fg = row.color === 'black' || row.color === 'blue' || row.color === 'red' ? '#fff' : '#000';

                                                return (
                                                    <tr key={row.id}>
                                                        <td colSpan="5" style={{
                                                            background: bg,
                                                            color: fg,
                                                            fontWeight: 'bold',
                                                            textAlign: 'center',
                                                            padding: '2px 8px',
                                                            border: '1px solid #333',
                                                            fontSize: `${fontSize}rem`
                                                        }}>
                                                            {row.label}
                                                        </td>
                                                    </tr>
                                                );
                                            } else {
                                                // Play Row
                                                const thisCoord = currentCoord++;

                                                // Determine background shade
                                                let rowBackground = 'inherit';
                                                const effectiveColor = row.color || (card && card.color) || 'none';

                                                if (effectiveColor && effectiveColor !== 'none') {
                                                    const shades = ['light', 'medium'];
                                                    const shade = shades[rowIndex % 2]; // Use rowIndex for alternating colors
                                                    const colorMap = {
                                                        'green-light': '#d1fae5', 'green-medium': '#a7f3d0',
                                                        'orange-light': '#fed7aa', 'orange-medium': '#fdba74',
                                                        'red-light': '#fecaca', 'red-medium': '#fca5a5',
                                                        'blue-light': '#bfdbfe', 'blue-medium': '#93c5fd',
                                                        'yellow-light': '#fef08a', 'yellow-medium': '#fde047',
                                                        'purple-light': '#e9d5ff', 'purple-medium': '#d8b4fe',
                                                        'teal-light': '#99f6e4', 'teal-medium': '#5eead4',
                                                        'pink-light': '#fbcfe8', 'pink-medium': '#f9a8d4'
                                                    };
                                                    rowBackground = colorMap[`${effectiveColor}-${shade}`] || 'inherit';
                                                }

                                                return (
                                                    <tr key={row.id} style={{ height: `${rowHeight}px` }}>
                                                        {/* Coord */}
                                                        <td style={{
                                                            border: '1px solid #333',
                                                            textAlign: 'center',
                                                            fontWeight: 'bold',
                                                            fontSize: `${fontSize}rem`,
                                                            background: rowBackground
                                                        }}>
                                                            {thisCoord}
                                                        </td>
                                                        {/* Tempo Left */}
                                                        <td style={{
                                                            border: '1px solid #333',
                                                            padding: '0 2px',
                                                            fontSize: `${fontSize}rem`,
                                                            verticalAlign: 'middle',
                                                            overflow: 'hidden',
                                                            whiteSpace: 'nowrap',
                                                            textOverflow: 'ellipsis',
                                                            fontWeight: 'bold',
                                                            textAlign: 'center',
                                                            background: '#ffedd5'
                                                        }}>
                                                            {row.col0}
                                                        </td>
                                                        {/* Play 1 */}
                                                        <td style={{
                                                            border: '1px solid #333',
                                                            padding: '0 2px',
                                                            fontSize: `${fontSize}rem`,
                                                            verticalAlign: 'middle',
                                                            overflow: 'hidden',
                                                            whiteSpace: 'nowrap',
                                                            textOverflow: 'ellipsis',
                                                            background: rowBackground
                                                        }}>
                                                            {row.col1}
                                                        </td>
                                                        {/* Tempo */}
                                                        <td style={{
                                                            border: '1px solid #333',
                                                            padding: '0 2px',
                                                            fontSize: `${fontSize}rem`,
                                                            verticalAlign: 'middle',
                                                            overflow: 'hidden',
                                                            whiteSpace: 'nowrap',
                                                            textOverflow: 'ellipsis',
                                                            fontWeight: 'bold',
                                                            textAlign: 'center',
                                                            background: '#ffedd5' // Always light orange for tempo? Or maybe just inherit? Keeping tempo distinct is usually good.
                                                        }}>
                                                            {row.col2}
                                                        </td>
                                                        {/* Play 2 */}
                                                        <td style={{
                                                            border: '1px solid #333',
                                                            padding: '0 2px',
                                                            fontSize: `${fontSize}rem`,
                                                            verticalAlign: 'middle',
                                                            overflow: 'hidden',
                                                            whiteSpace: 'nowrap',
                                                            textOverflow: 'ellipsis',
                                                            background: rowBackground
                                                        }}>
                                                            {row.col3}
                                                        </td>
                                                    </tr>
                                                );
                                            }
                                        })}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    );
                }

                // ---------------------------------------------------------

                if (card && card.type === 'staples') {
                    // STAPLES LAYOUT: 4 Columns x 20 Rows (Slots 10-89)
                    // Col 1: 10-29
                    // Col 2: 30-49
                    // Col 3: 50-69
                    // Col 4: 70-89

                    const col1 = displayRows.slice(0, 20);
                    const col2 = displayRows.slice(20, 40);
                    const col3 = displayRows.slice(40, 60);
                    const col4 = displayRows.slice(60, 80);

                    // Create 20 rows
                    const tableRows = [];
                    for (let i = 0; i < 20; i++) {
                        tableRows.push([
                            col1[i] || null,
                            col2[i] || null,
                            col3[i] || null,
                            col4[i] || null
                        ]);
                    }

                    return (
                        <div style={{ width: '100%', height: '100%', display: 'flex', flexDirection: 'column', border: '2px solid black' }}>
                            {/* Header */}
                            <div style={{
                                background: 'black',
                                color: 'white',
                                fontWeight: 'bold',
                                fontSize: '10pt',
                                padding: '2px 4px',
                                display: 'flex',
                                justifyContent: 'space-between',
                                alignItems: 'center'
                            }}>
                                <span style={{ textTransform: 'uppercase' }}>STAPLES</span>
                                <span>{title}</span>
                            </div>

                            {/* Table */}
                            <div style={{ flex: 1, overflow: 'hidden' }}>
                                <table className="wristband-spreadsheet-table" style={{ width: '100%', tableLayout: 'fixed', borderCollapse: 'collapse' }}>
                                    {/* 4 sets of (Coord + Play) columns */}
                                    <colgroup>
                                        <col style={{ width: '30px' }} />
                                        <col style={{ width: '22%' }} />
                                        <col style={{ width: '30px' }} />
                                        <col style={{ width: '22%' }} />
                                        <col style={{ width: '30px' }} />
                                        <col style={{ width: '22%' }} />
                                        <col style={{ width: '30px' }} />
                                        <col style={{ width: '22%' }} />
                                    </colgroup>
                                    <tbody>
                                        {tableRows.map((rowGroup, rowIndex) => {
                                            // Calculate color background
                                            let cellBackground = 'inherit';
                                            if (card && card.color && card.color !== 'none') {
                                                const shades = ['light', 'medium'];
                                                const shade = shades[rowIndex % 2];
                                                const colorMap = {
                                                    'green-light': '#d1fae5', 'green-medium': '#a7f3d0',
                                                    'orange-light': '#fed7aa', 'orange-medium': '#fdba74',
                                                    'red-light': '#fecaca', 'red-medium': '#fca5a5',
                                                    'blue-light': '#bfdbfe', 'blue-medium': '#93c5fd',
                                                    'yellow-light': '#fef08a', 'yellow-medium': '#fde047',
                                                    'purple-light': '#e9d5ff', 'purple-medium': '#d8b4fe',
                                                    'teal-light': '#99f6e4', 'teal-medium': '#5eead4',
                                                    'pink-light': '#fbcfe8', 'pink-medium': '#f9a8d4'
                                                };
                                                cellBackground = colorMap[`${card.color}-${shade}`] || 'inherit';
                                            }

                                            return (
                                                <tr key={rowIndex} className={rangeClass} style={{ height: `${rowHeight}px` }}>
                                                    {rowGroup.map((cellData, colIdx) => {
                                                        // Render Pair: Slot + Play
                                                        // If no cell data, render empty cells
                                                        if (!cellData) {
                                                            return (
                                                                <React.Fragment key={colIdx}>
                                                                    <td style={{ border: '1px solid #333', background: cellBackground }}></td>
                                                                    <td style={{ border: '1px solid #333', background: cellBackground }}></td>
                                                                </React.Fragment>
                                                            );
                                                        }

                                                        const play = cellData.play;
                                                        // Since we are not in Editor mode here potentially, handleAssignSlot might not be needed if this is print view
                                                        // But previous code included onClick. I'll include it for consistency with Standard.
                                                        const isClickable = !isMiniScripts && selectedPlayId && !play;

                                                        return (
                                                            <React.Fragment key={colIdx}>
                                                                {/* Coord */}
                                                                <td style={{
                                                                    border: '1px solid #333',
                                                                    textAlign: 'center', fontWeight: 'bold',
                                                                    fontSize: `${fontSize}rem`,
                                                                    background: cellBackground
                                                                }}>
                                                                    {cellData.slot}
                                                                </td>
                                                                {/* Play */}
                                                                <td
                                                                    onClick={() => handleAssignSlot(cellData.slot)}
                                                                    style={{
                                                                        border: '1px solid #333',
                                                                        padding: '0 2px',
                                                                        fontSize: `${fontSize}rem`,
                                                                        verticalAlign: 'middle',
                                                                        overflow: 'hidden', whiteSpace: 'nowrap', textOverflow: 'ellipsis',
                                                                        background: cellBackground,
                                                                        cursor: isClickable ? 'pointer' : 'default',
                                                                        backgroundColor: isClickable ? '#dbeafe' : cellBackground
                                                                    }}>
                                                                    <input
                                                                        type="text"
                                                                        value={staplesInputs[cellData.slot] || ''}
                                                                        onChange={(e) => handleStaplesInputChange(cellData.slot, e.target.value)}
                                                                        onBlur={() => handleStaplesInputBlur(cellData.slot)}
                                                                        onKeyDown={(e) => handleStaplesInputKeyDown(e, cellData.slot)}
                                                                        placeholder="Type play..."
                                                                        style={{
                                                                            width: '100%',
                                                                            border: 'none',
                                                                            background: 'transparent',
                                                                            fontSize: 'inherit',
                                                                            padding: '0',
                                                                            outline: 'none',
                                                                            fontFamily: 'inherit'
                                                                        }}
                                                                    />
                                                                </td>
                                                            </React.Fragment>
                                                        );
                                                    })}
                                                </tr>
                                            );
                                        })}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    );
                }

                // STANDARD / TRADITIONAL LAYOUT (Original Logic)
                // ---------------------------------------------------------

                // Split into two columns: odd coordinates on left, even on right
                const col1 = []; // Odd coordinates (101, 103, 105, ...)
                const col2 = []; // Even coordinates (102, 104, 106, ...)

                displayRows.forEach(row => {
                    const slotNum = parseInt(row.slot);
                    // Standard (starts at 101/1), Odd is Left, Even is Right
                    if (slotNum % 2 === 1) {
                        col1.push(row);
                    } else {
                        col2.push(row);
                    }
                });

                // Ensure columns have equal length for rendering
                const rowCount = Math.max(col1.length, col2.length, 24);
                const tableRows = [];
                for (let i = 0; i < rowCount; i++) {
                    tableRows.push([col1[i] || null, col2[i] || null]);
                }

                return (
                    <div style={{ width: '100%', height: '100%', display: 'flex', flexDirection: 'column', border: '2px solid black' }}>
                        {/* Header - Split layout */}
                        <div style={{
                            background: 'black',
                            color: 'white',
                            fontWeight: 'bold',
                            fontSize: '10pt',
                            padding: '0 2px',
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center'
                        }}>
                            <span style={{ textTransform: 'uppercase' }}>TRADITIONAL</span>
                            <span>{title}</span>
                        </div>
                        {/* Table */}
                        <table className="wristband-spreadsheet-table">
                            <tbody>
                                {tableRows.map((rowGroup, rowIndex) => (
                                    <tr key={rowIndex} className={rangeClass}>
                                        {rowGroup.map((cellData, colIndex) => {
                                            if (cellData && cellData.type === 'spacer') return null;

                                            if (cellData && cellData.isHeader) {
                                                const isTempo = cellData.type === 'tempo';
                                                return (
                                                    <React.Fragment key={colIndex}>
                                                        <td colSpan={4} style={{
                                                            background: isTempo ? '#ffedd5' : '#333',
                                                            color: isTempo ? 'black' : 'white',
                                                            fontWeight: 'bold',
                                                            textAlign: 'center',
                                                            border: '1px solid #333',
                                                            fontSize: '8pt',
                                                            padding: '2px'
                                                        }}>
                                                            {cellData.text}
                                                        </td>
                                                    </React.Fragment>
                                                );
                                            }

                                            if (!cellData) return <React.Fragment key={colIndex}><td style={{ border: '1px solid #333', height: `${rowHeight}px` }} /><td style={{ border: '1px solid #333', height: `${rowHeight}px` }} /></React.Fragment>;

                                            const play = cellData.play;
                                            const isClickable = !isMiniScripts && selectedPlayId && !play;

                                            // Calculate color background for this row
                                            let cellBackground = 'inherit';
                                            if (card && card.color && card.color !== 'none') {
                                                const colorBase = card.color;
                                                const shadeIndex = rowIndex % 2;
                                                const shades = ['light', 'medium'];
                                                const shade = shades[shadeIndex];
                                                const colorMap = {
                                                    'green-light': '#d1fae5', 'green-medium': '#a7f3d0',
                                                    'orange-light': '#fed7aa', 'orange-medium': '#fdba74',
                                                    'red-light': '#fecaca', 'red-medium': '#fca5a5',
                                                    'blue-light': '#bfdbfe', 'blue-medium': '#93c5fd',
                                                    'yellow-light': '#fef08a', 'yellow-medium': '#fde047',
                                                    'purple-light': '#e9d5ff', 'purple-medium': '#d8b4fe',
                                                    'teal-light': '#99f6e4', 'teal-medium': '#5eead4',
                                                    'pink-light': '#fbcfe8', 'pink-medium': '#f9a8d4'
                                                };
                                                cellBackground = colorMap[`${colorBase}-${shade}`] || 'inherit';
                                            }

                                            // Header/Tempo Row Render
                                            if (cellData.isHeader) {
                                                const isTempo = cellData.type === 'tempo';
                                                return (
                                                    <React.Fragment key={`${colIndex}-${cellData.slot}`}>
                                                        <td
                                                            colSpan={2}
                                                            style={{
                                                                fontWeight: 'bold',
                                                                background: isTempo ? '#ffedd5' : '#333',
                                                                color: isTempo ? 'black' : 'white',
                                                                textAlign: 'center',
                                                                border: '1px solid #333',
                                                                height: `${rowHeight}px`,
                                                                maxHeight: `${rowHeight}px`,
                                                                fontSize: `${fontSize}rem`,
                                                                verticalAlign: 'middle',
                                                                overflow: 'hidden',
                                                                whiteSpace: 'nowrap'
                                                            }}
                                                        >
                                                            {cellData.text}
                                                        </td>
                                                    </React.Fragment>
                                                );
                                            }

                                            return (
                                                <React.Fragment key={`${colIndex}-${cellData.slot}`}>
                                                    <td
                                                        style={{
                                                            fontWeight: 'bold',
                                                            width: '45px',
                                                            cursor: isClickable ? 'pointer' : 'default',
                                                            background: isClickable ? 'rgba(56, 189, 248, 0.2)' : cellBackground,
                                                            padding: '0 2px',
                                                            border: '1px solid #333',
                                                            height: `${rowHeight}px`,
                                                            maxHeight: `${rowHeight}px`,
                                                            fontSize: `${fontSize}rem`,
                                                            verticalAlign: 'middle',
                                                            color: '#000',
                                                            overflow: 'hidden',
                                                            whiteSpace: 'nowrap',
                                                            lineHeight: `${rowHeight}px`,
                                                            boxSizing: 'border-box',
                                                            textAlign: 'center'
                                                        }}
                                                        onClick={() => !isMiniScripts && handleAssignSlot(cellData.slot)}
                                                    >
                                                        {cellData.slot}
                                                    </td>
                                                    <td
                                                        style={{
                                                            cursor: isClickable ? 'pointer' : 'default',
                                                            background: isClickable ? 'rgba(56, 189, 248, 0.2)' : (cellData.type === 'tempo' ? '#ffedd5' : cellBackground),
                                                            padding: '0 2px',
                                                            border: '1px solid #333',
                                                            height: `${rowHeight}px`,
                                                            maxHeight: `${rowHeight}px`,
                                                            fontSize: `${fontSize}rem`,
                                                            verticalAlign: 'middle',
                                                            fontWeight: cellData.type === 'tempo' ? 'bold' : 'normal',
                                                            color: '#000',
                                                            overflow: 'hidden',
                                                            textOverflow: 'ellipsis',
                                                            whiteSpace: 'nowrap',
                                                            lineHeight: `${rowHeight}px`,
                                                            boxSizing: 'border-box'
                                                        }}
                                                        onClick={() => !isMiniScripts && handleAssignSlot(cellData.slot)}
                                                    >
                                                        {quickAddSlot === cellData.slot ? (
                                                            <div style={{ position: 'relative', width: '100%', height: '100%' }} onClick={(e) => e.stopPropagation()}>
                                                                <input
                                                                    type="text"
                                                                    value={quickAddValue}
                                                                    onChange={(e) => handleQuickAddChange(e.target.value)}
                                                                    onKeyDown={(e) => {
                                                                        if (e.key === 'Enter') handleQuickAddSubmit(cellData.slot);
                                                                        if (e.key === 'Escape') handleQuickAddCancel();
                                                                    }}
                                                                    onBlur={() => setTimeout(() => handleQuickAddCancel(), 200)}
                                                                    autoFocus
                                                                    style={{ width: '100%', height: '100%', fontSize: `${fontSize}rem`, border: 'none', background: 'white' }}
                                                                />
                                                            </div>
                                                        ) : (
                                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                                <span>{cellData.text}</span>
                                                                {!isMiniScripts && !play && (
                                                                    <button
                                                                        onClick={(e) => { e.stopPropagation(); handleQuickAddStart(cellData.slot); }}
                                                                        style={{ fontSize: '0.5rem', color: '#999', background: 'none', border: 'none' }}
                                                                    >
                                                                        +
                                                                    </button>
                                                                )}
                                                                {!isMiniScripts && play && (
                                                                    <button
                                                                        className="wristband-clear-btn"
                                                                        onClick={(e) => { e.stopPropagation(); onUpdatePlay({ ...play, wristbandSlot: '' }); }}
                                                                        style={{ fontSize: '0.6rem', padding: '0 2px', height: '10px' }}
                                                                    >
                                                                        ×
                                                                    </button>
                                                                )}
                                                            </div>
                                                        )}
                                                    </td>
                                                </React.Fragment>
                                            );
                                        })}
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                );
            };

            // Audible wristband: Coordinate in left column, two play columns on right
            const renderAudibleTable = (slots, rangeClass, cardId, title = '') => {
                const card = wbSettings[cardId];
                if (!card) return null;

                // Get all plays for the slots
                const displayRows = slots.map(slot => {
                    const play = slotMap[slot];
                    return {
                        slot: slot,
                        text: play ? `${play.name}${play.formation && !checkRedundantFormation(play.name, play.formation) ? ' - ' + play.formation : ''}` : '',
                        play: play
                    };
                });

                // Group rows: each row shows coordinate + 2 plays
                const tableRows = [];
                for (let i = 0; i < displayRows.length; i += 2) {
                    const row1 = displayRows[i];
                    const row2 = displayRows[i + 1] || { slot: '', text: '', play: null };
                    tableRows.push({ coordinate: row1.slot, play1: row1, play2: row2 });
                }

                // Ensure minimum rows for consistent layout
                while (tableRows.length < 24) {
                    tableRows.push({ coordinate: '', play1: { slot: '', text: '', play: null }, play2: { slot: '', text: '', play: null } });
                }

                return (
                    <div style={{ width: '100%', height: '100%', display: 'flex', flexDirection: 'column', border: '2px solid black' }}>
                        {/* Header */}
                        <div style={{
                            background: 'black',
                            color: 'white',
                            fontWeight: 'bold',
                            fontSize: '10pt',
                            padding: '0 2px',
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center'
                        }}>
                            <span style={{ textTransform: 'uppercase' }}>AUDIBLE</span>
                            <span>{title}</span>
                        </div>
                        {/* Table */}
                        <table className="wristband-spreadsheet-table">
                            <tbody>
                                {tableRows.map((row, rowIndex) => {
                                    // Calculate color background for this row
                                    let cellBackground = 'inherit';
                                    if (card && card.color && card.color !== 'none') {
                                        const colorBase = card.color;
                                        const shadeIndex = rowIndex % 2;
                                        const shades = ['light', 'medium'];
                                        const shade = shades[shadeIndex];
                                        const colorMap = {
                                            'green-light': '#d1fae5', 'green-medium': '#a7f3d0',
                                            'orange-light': '#fed7aa', 'orange-medium': '#fdba74',
                                            'red-light': '#fecaca', 'red-medium': '#fca5a5',
                                            'blue-light': '#bfdbfe', 'blue-medium': '#93c5fd',
                                            'yellow-light': '#fef08a', 'yellow-medium': '#fde047',
                                            'purple-light': '#e9d5ff', 'purple-medium': '#d8b4fe',
                                            'teal-light': '#99f6e4', 'teal-medium': '#5eead4',
                                            'pink-light': '#fbcfe8', 'pink-medium': '#f9a8d4'
                                        };
                                        cellBackground = colorMap[`${colorBase}-${shade}`] || 'inherit';
                                    }

                                    return (
                                        <tr key={rowIndex} className={rangeClass}>
                                            {/* Coordinate Column */}
                                            <td style={{
                                                fontWeight: 'bold',
                                                width: '45px',
                                                background: cellBackground,
                                                padding: '0 2px',
                                                border: '1px solid #333',
                                                height: `${rowHeight}px`,
                                                fontSize: `${fontSize}rem`,
                                                verticalAlign: 'middle',
                                                color: '#000',
                                                textAlign: 'center',
                                                lineHeight: `${rowHeight}px`
                                            }}>
                                                {row.coordinate}
                                            </td>
                                            {/* Play 1 Column */}
                                            <td style={{
                                                background: cellBackground,
                                                padding: '0 2px',
                                                border: '1px solid #333',
                                                height: `${rowHeight}px`,
                                                fontSize: `${fontSize}rem`,
                                                verticalAlign: 'middle',
                                                color: '#000',
                                                overflow: 'hidden',
                                                textOverflow: 'ellipsis',
                                                whiteSpace: 'nowrap',
                                                lineHeight: `${rowHeight}px`,
                                                cursor: selectedPlayId && !row.play1.play ? 'pointer' : 'default'
                                            }}
                                                onClick={() => row.play1.slot && handleAssignSlot(row.play1.slot)}>
                                                {row.play1.text}
                                            </td>
                                            {/* Play 2 Column */}
                                            <td style={{
                                                background: cellBackground,
                                                padding: '0 2px',
                                                border: '1px solid #333',
                                                height: `${rowHeight}px`,
                                                fontSize: `${fontSize}rem`,
                                                verticalAlign: 'middle',
                                                color: '#000',
                                                overflow: 'hidden',
                                                textOverflow: 'ellipsis',
                                                whiteSpace: 'nowrap',
                                                lineHeight: `${rowHeight}px`,
                                                cursor: selectedPlayId && !row.play2.play ? 'pointer' : 'default'
                                            }}
                                                onClick={() => row.play2.slot && handleAssignSlot(row.play2.slot)}>
                                                {row.play2.text}
                                            </td>
                                        </tr>
                                    );
                                })}
                            </tbody>
                        </table>
                    </div>
                );
            };

            // Helper function to calculate bounding box of diagram elements
            const calculateDiagramBounds = (elements) => {
                if (!elements || elements.length === 0) {
                    return { minX: 0, minY: 0, maxX: 800, maxY: 500, width: 800, height: 500 };
                }

                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;
                const padding = 20; // Padding around the bounding box

                elements.forEach(el => {
                    if (el.type === 'player') {
                        const { x, y } = el.points[0];
                        const size = 30; // Player icon size
                        minX = Math.min(minX, x - size / 2);
                        minY = Math.min(minY, y - size / 2);
                        maxX = Math.max(maxX, x + size / 2);
                        maxY = Math.max(maxY, y + size / 2);
                    } else {
                        // Routes/arrows - check all points
                        el.points.forEach(p => {
                            minX = Math.min(minX, p.x);
                            minY = Math.min(minY, p.y);
                            maxX = Math.max(maxX, p.x);
                            maxY = Math.max(maxY, p.y);
                        });
                    }
                });

                // Add padding
                minX = Math.max(0, minX - padding);
                minY = Math.max(0, minY - padding);
                maxX = Math.min(800, maxX + padding);
                maxY = Math.min(500, maxY + padding);

                return {
                    minX,
                    minY,
                    maxX,
                    maxY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            };

            const renderPlayThumbnail = (play, type = 'standard') => {
                if (!play) return null;

                // Determine which data to use based on type
                let data = null;
                if (type === 'skill' && (play.wizSkillData || play.rooskiSkillData)) {
                    data = { elements: play.wizSkillData || play.rooskiSkillData };
                } else if (type === 'oline' && (play.wizOlineData || play.rooskiOlineData)) {
                    data = { elements: play.wizOlineData || play.rooskiOlineData };
                } else if (play.diagramData) {
                    data = play.diagramData;
                }

                if (!data || !data.elements || data.elements.length === 0) return null;

                // Fixed viewBox for consistent field representation
                // Cell aspect ratio on 5x3 card with 4x4 grid is ~1.75:1
                // Using 800x460 to match this ratio and fill cells better
                const fieldWidth = 800;
                const fieldHeight = 460;
                const viewBoxX = 0;
                const viewBoxY = 60; // Offset to show ~13 yards upfield and ~6 yards backfield from LOS at y=400

                // Define colors for route lines
                const routeColors = ['#ef4444', '#3b82f6', '#22c55e', '#eab308', '#a855f7', '#f97316', '#06b6d4', '#ec4899'];

                return (
                    <svg
                        viewBox={`${viewBoxX} ${viewBoxY} ${fieldWidth} ${fieldHeight}`}
                        width="100%"
                        height="100%"
                        style={{ display: 'block', background: 'white', flex: 1, minHeight: 0, minWidth: 0 }}
                        preserveAspectRatio="xMidYMid meet"
                    >
                        {/* Arrow markers for each color */}
                        <defs>
                            {routeColors.map(color => (
                                <marker
                                    key={color}
                                    id={`wiz-arrow-${color.replace('#', '')}`}
                                    markerWidth="10"
                                    markerHeight="10"
                                    refX="9"
                                    refY="3"
                                    orient="auto"
                                    markerUnits="strokeWidth"
                                >
                                    <path d="M0,0 L0,6 L9,3 z" fill={color} />
                                </marker>
                            ))}
                            <marker id="wiz-arrow-000000" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                                <path d="M0,0 L0,6 L9,3 z" fill="#000000" />
                            </marker>
                        </defs>

                        {/* Field background - white */}
                        <rect x={viewBoxX} y={viewBoxY} width={fieldWidth} height={fieldHeight} fill="white" />

                        {/* Yard lines on LEFT side - 5, 10, 15 going UP from bottom */}
                        {/* LOS is at bottom (y=450), each 5 yards = ~100px up */}
                        <g stroke="#c4a052" strokeWidth="2" fill="none">
                            {/* Hash marks at TOP (orange/gold) */}
                            <line x1="250" y1="20" x2="250" y2="50" />
                            <line x1="550" y1="20" x2="550" y2="50" />
                        </g>
                        <g fill="#888" fontSize="14" fontWeight="bold">
                            {/* Yard numbers on left - positioned from bottom going up */}
                            <text x="15" y="365">5</text>
                            <text x="10" y="265">10</text>
                            <text x="10" y="165">15</text>
                        </g>
                        {/* Faint yard lines across field */}
                        <g stroke="#ddd" strokeWidth="1">
                            <line x1="35" y1="350" x2={fieldWidth - 20} y2="350" />
                            <line x1="35" y1="250" x2={fieldWidth - 20} y2="250" />
                            <line x1="35" y1="150" x2={fieldWidth - 20} y2="150" />
                        </g>

                        {/* Render diagram elements */}
                        {data.elements && data.elements.map(el => {
                            if (el.type === 'player') {
                                const { x, y } = el.points[0];
                                const size = el.shape === 'text-only' ? 0 : 28;
                                const isRect = el.shape === 'square';
                                const isTextOnly = el.shape === 'text-only';
                                const fontSize = isTextOnly ? (el.fontSize ? Math.min(el.fontSize * 0.25, 40) : 24) : 14;

                                return (
                                    <g key={el.id}>
                                        {!isTextOnly && (isRect ? (
                                            <rect x={x - size / 2} y={y - size / 2} width={size} height={size} fill="white" stroke={el.color} strokeWidth="3" />
                                        ) : (
                                            <circle cx={x} cy={y} r={size / 2} fill="white" stroke={el.color} strokeWidth="3" />
                                        ))}
                                        <text
                                            x={x}
                                            y={y}
                                            dy={isTextOnly ? "0.35em" : "0.35em"}
                                            textAnchor="middle"
                                            fontSize={fontSize}
                                            fontWeight="bold"
                                            fill={el.color}
                                        >
                                            {el.label}
                                        </text>
                                    </g>
                                );
                            }

                            // Route/line rendering
                            let d = '';
                            if (el.style === 'zigzag') {
                                d = getZigZagPath(el.points);
                            } else if (el.type === 'free' || el.points.length > 1) {
                                d = `M ${el.points.map(p => `${p.x},${p.y}`).join(' L ')}`;
                            }

                            let markerEnd = undefined;
                            let tBlock = null;
                            const colorHex = (el.color || '#000000').replace('#', '');

                            if (el.endType === 'arrow' || (!el.endType && el.type !== 'free')) {
                                markerEnd = `url(#wiz-arrow-${colorHex})`;
                            } else if (el.endType === 't') {
                                const end = el.points[el.points.length - 1];
                                const prev = el.points[el.points.length - 2] || el.points[0];
                                const dx = end.x - prev.x;
                                const dy = end.y - prev.y;
                                const len = Math.hypot(dx, dy) || 1;
                                const perpX = (-dy / len) * 12;
                                const perpY = (dx / len) * 12;
                                tBlock = (
                                    <line
                                        x1={end.x - perpX} y1={end.y - perpY}
                                        x2={end.x + perpX} y2={end.y + perpY}
                                        stroke={el.color}
                                        strokeWidth="5"
                                    />
                                );
                            } else if (el.endType === 'dot') {
                                const end = el.points[el.points.length - 1];
                                tBlock = (
                                    <circle cx={end.x} cy={end.y} r="5" fill={el.color} />
                                );
                            } else if (el.endType === 'none') {
                                markerEnd = undefined;
                            } else if (el.type === 'arrow') {
                                markerEnd = `url(#wiz-arrow-${colorHex})`;
                            }

                            return (
                                <g key={el.id}>
                                    <path
                                        d={d}
                                        stroke={el.color}
                                        strokeWidth="5"
                                        fill="none"
                                        strokeDasharray={el.style === 'dashed' ? "8,4" : "none"}
                                        markerEnd={markerEnd}
                                    />
                                    {tBlock}
                                </g>
                            );
                        })}
                    </svg>
                );
            };

            const renderWizGrid = (slots, title, viewType) => {
                // 4x4 Grid for 3x5 card - each cell has diagram on top, coordinate/name below
                const rows = [];
                for (let i = 0; i < slots.length; i += 4) {
                    rows.push(slots.slice(i, i + 4));
                }

                return (
                    <div className="wiz-grid-container" style={{ width: '100%', height: '100%', display: 'flex', flexDirection: 'column', border: '2px solid black' }}>
                        {/* Header - Split layout */}
                        <div style={{
                            background: 'black',
                            color: 'white',
                            fontWeight: 'bold',
                            fontSize: '10pt',
                            padding: '2px 4px',
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center'
                        }}>
                            <span style={{ textTransform: 'uppercase' }}>WIZ</span>
                            <span>{title}</span>
                        </div>
                        {/* Grid */}
                        <div style={{ flex: 1, display: 'flex', flexDirection: 'column' }}>
                            {rows.map((rowSlots, rIndex) => (
                                <div key={rIndex} style={{ height: '25%', minHeight: '25%', maxHeight: '25%', display: 'flex', borderBottom: rIndex < rows.length - 1 ? '1px solid black' : 'none' }}>
                                    {rowSlots.map((slot, cIndex) => {
                                        const play = slotMap[slot];

                                        // Filter plays based on view type
                                        // Always show the play if it is assigned to the slot
                                        // The renderPlayThumbnail function will handle showing/hiding the diagram based on available data
                                        const displayPlay = play;
                                        const isClickable = selectedPlayId && !play;

                                        return (
                                            <div
                                                key={slot}
                                                style={{
                                                    flex: 1,
                                                    borderRight: cIndex < 3 ? '1px solid black' : 'none',
                                                    display: 'flex',
                                                    flexDirection: 'column',
                                                    cursor: isClickable ? 'pointer' : 'default',
                                                    background: isClickable ? 'rgba(56, 189, 248, 0.2)' : 'white',
                                                    overflow: 'hidden',
                                                    position: 'relative'
                                                }}
                                                onClick={() => handleAssignSlot(slot)}
                                            >
                                                {/* Clear button in top-right corner */}
                                                {displayPlay && (
                                                    <button
                                                        className="wristband-clear-btn"
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            onUpdatePlay({ ...displayPlay, wristbandSlot: '' });
                                                        }}
                                                        style={{
                                                            position: 'absolute',
                                                            top: '2px',
                                                            right: '2px',
                                                            zIndex: 10,
                                                            fontSize: '10px',
                                                            padding: '0 4px',
                                                            lineHeight: '14px',
                                                            background: 'rgba(255, 255, 255, 0.9)',
                                                            borderRadius: '2px'
                                                        }}
                                                    >
                                                        ×
                                                    </button>
                                                )}
                                                {/* Diagram area - takes up most of the cell */}
                                                <div style={{
                                                    flex: 1,
                                                    display: 'flex',
                                                    alignItems: 'stretch',
                                                    justifyContent: 'stretch',
                                                    overflow: 'hidden',
                                                    minHeight: 0,
                                                    background: 'white'
                                                }}>
                                                    {displayPlay && renderPlayThumbnail(displayPlay, viewType)}
                                                </div>

                                                {/* Bottom row: Coordinate (left) | Play Name (right) - compact like the reference */}
                                                <div style={{
                                                    display: 'flex',
                                                    borderTop: '1px solid black',
                                                    height: '14px',
                                                    minHeight: '14px',
                                                    maxHeight: '14px',
                                                    background: 'white'
                                                }}>
                                                    {/* Coordinate cell */}
                                                    <div style={{
                                                        width: '28px',
                                                        minWidth: '28px',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        fontSize: '8pt',
                                                        fontWeight: 'bold',
                                                        color: '#000',
                                                        borderRight: '1px solid black',
                                                        background: 'white'
                                                    }}>
                                                        {slot}
                                                    </div>

                                                    {/* Play name cell */}
                                                    <div style={{
                                                        flex: 1,
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        justifyContent: 'flex-start',
                                                        fontSize: '6pt',
                                                        fontWeight: 'bold',
                                                        padding: '0 3px',
                                                        textAlign: 'left',
                                                        overflow: 'hidden',
                                                        textOverflow: 'ellipsis',
                                                        whiteSpace: 'nowrap',
                                                        background: 'white',
                                                        color: '#000'
                                                    }}>
                                                        {displayPlay ? displayPlay.name : ''}
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            ))}
                        </div>
                    </div>
                );
            };

            // Card-specific slots
            const getSlotsForCard = (cardId) => {
                const card = wbSettings[cardId];

                if (card && card.type === 'staples') {
                    const slots = [];
                    for (let i = 10; i <= 89; i++) slots.push(i);
                    return slots;
                }

                if (card && (card.type === 'rooski' || card.type === 'wiz')) {
                    // Wiz uses 16 slots: X01-X16 where X is the series number
                    const series = cardId === 'card1' ? 1 : (cardId === 'card2' ? 2 : (cardId === 'card3' ? 3 : (cardId === 'card4' ? 4 : (cardId === 'card5' ? 5 : 6))));
                    const slots = [];
                    for (let i = 1; i <= 16; i++) {
                        slots.push(`${series}${String(i).padStart(2, '0')}`);
                    }
                    return slots;
                }

                // Standard/Modular use 48 slots
                const start = cardId === 'card1' ? 101 : (cardId === 'card2' ? 201 : (cardId === 'card3' ? 301 : (cardId === 'card4' ? 401 : (cardId === 'card5' ? 501 : 601))));
                const slots = [];
                for (let i = start; i <= start + 47; i++) slots.push(i);
                return slots;
            };

            const renderMiniScriptEditorRows = (card, cardId) => {
                const rows = [];
                const startCoord = cardId === 'card1' ? 101 : (cardId === 'card2' ? 201 : (cardId === 'card3' ? 301 : (cardId === 'card4' ? 401 : (cardId === 'card5' ? 501 : 601))));

                let currentCoord = startCoord;

                // Iterate through all rows directly
                if (card.rows && card.rows.length > 0) {
                    card.rows.forEach((item, i) => {
                        if (item.type === 'header') {
                            // Render Header
                            rows.push(
                                <div key={item.id} style={{ padding: '0.5rem', border: '1px solid var(--border)', borderRadius: '4px', background: 'var(--bg-input)', marginBottom: '0.5rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                    <div style={{ display: 'flex', flexDirection: 'column', flex: 1 }}>
                                        <label style={{ fontSize: '0.7rem', color: 'var(--text-secondary)', marginBottom: '2px' }}>Header Label</label>
                                        <input
                                            value={item.label}
                                            onChange={(e) => handleUpdateRow(selectedCardId, item.id, { label: e.target.value })}
                                            style={{ width: '100%', fontWeight: 'bold', fontSize: '0.9rem', padding: '4px', border: '1px solid var(--border)', borderRadius: '4px', background: 'var(--bg-panel)', color: 'var(--text-primary)' }}
                                            placeholder="SECTION HEADER"
                                        />
                                    </div>
                                    <div style={{ display: 'flex', flexDirection: 'column' }}>
                                        <label style={{ fontSize: '0.7rem', color: 'var(--text-secondary)', marginBottom: '2px' }}>Color</label>
                                        <select
                                            value={item.color || 'gray'}
                                            onChange={(e) => handleUpdateRow(selectedCardId, item.id, { color: e.target.value })}
                                            style={{ fontSize: '0.8rem', padding: '4px', border: '1px solid var(--border)', borderRadius: '4px', background: 'var(--bg-panel)', color: 'var(--text-primary)' }}
                                        >
                                            <option value="gray">Gray</option>
                                            <option value="black">Black</option>
                                            <option value="red">Red</option>
                                            <option value="blue">Blue</option>
                                            <option value="green">Green</option>
                                            <option value="orange">Orange</option>
                                        </select>
                                    </div>
                                    <div style={{ display: 'flex', gap: '2px', alignSelf: 'flex-end', paddingBottom: '2px' }}>
                                        <button className="btn btn-secondary" style={{ padding: '4px' }} onClick={() => handleMoveRow(selectedCardId, item.id, -1)} title="Move Up">↑</button>
                                        <button className="btn btn-secondary" style={{ padding: '4px' }} onClick={() => handleMoveRow(selectedCardId, item.id, 1)} title="Move Down">↓</button>
                                        <button className="btn btn-danger" style={{ padding: '4px 8px' }} onClick={() => handleRemoveRow(selectedCardId, item.id)} title="Delete Header">×</button>
                                    </div>
                                </div>
                            );
                        } else {
                            // Render Play Row (3 Inputs: Play1, Tempo, Play2)
                            rows.push(
                                <div key={item.id} style={{ display: 'grid', gridTemplateColumns: '40px 80px 1fr 80px 1fr 80px', gap: '0.5rem', alignItems: 'center', marginBottom: '0.5rem' }}>
                                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '2px' }}>
                                        <div style={{ fontSize: '0.8rem', fontWeight: 'bold', color: 'var(--text-secondary)' }}>
                                            {currentCoord}
                                        </div>
                                        <select
                                            value={item.color || ''}
                                            onChange={(e) => handleUpdateRow(selectedCardId, item.id, { color: e.target.value })}
                                            style={{ width: '100%', fontSize: '0.6rem', padding: '1px', border: '1px solid var(--border)', borderRadius: '2px', background: 'var(--bg-panel)', color: 'var(--text-primary)' }}
                                            title="Row Color"
                                        >
                                            <option value="">Default</option>
                                            <option value="blue">Blue</option>
                                            <option value="orange">Tan</option>
                                            <option value="green">Green</option>
                                            <option value="red">Red</option>
                                            <option value="yellow">Yel</option>
                                            <option value="purple">Purp</option>
                                        </select>
                                    </div>

                                    {/* Tempo (Left) */}
                                    <input
                                        value={item.col0 || ''}
                                        onChange={(e) => handleUpdateRow(selectedCardId, item.id, { col0: e.target.value })}
                                        placeholder="Tempo"
                                        style={{ width: '100%', padding: '6px', border: '1px solid var(--border)', borderRadius: '4px', background: 'var(--bg-panel)', color: 'var(--text-primary)', fontSize: '0.8rem', textAlign: 'center', fontWeight: 'bold' }}
                                    />

                                    {/* Play 1 */}
                                    <input
                                        value={item.col1 || ''}
                                        onChange={(e) => handleUpdateRow(selectedCardId, item.id, { col1: e.target.value.toUpperCase() })}
                                        onDragOver={(e) => e.preventDefault()}
                                        onDrop={(e) => {
                                            e.preventDefault();
                                            const playName = e.dataTransfer.getData('text/plain');
                                            if (playName) {
                                                const p = plays.find(p => p.name === playName);
                                                handleUpdateRow(selectedCardId, item.id, { col1: playName, col1Id: p ? p.id : null });
                                            }
                                        }}
                                        onBlur={() => {
                                            if (item.col1 && !item.col1Id && onQuickAddPlay) {
                                                const newPlay = onQuickAddPlay(item.col1);
                                                if (newPlay) {
                                                    handleUpdateRow(selectedCardId, item.id, { col1: newPlay.name, col1Id: newPlay.id });
                                                }
                                            }
                                        }}
                                        placeholder="Play A"
                                        style={{ width: '100%', padding: '6px', border: '1px solid var(--border)', borderRadius: '4px', background: 'var(--bg-panel)', color: 'var(--text-primary)', fontSize: '0.8rem' }}
                                    />

                                    {/* Tempo (Middle) */}
                                    <input
                                        value={item.col2 || ''}
                                        onChange={(e) => handleUpdateRow(selectedCardId, item.id, { col2: e.target.value })}
                                        placeholder="Tempo"
                                        style={{ width: '100%', padding: '6px', border: '1px solid var(--border)', borderRadius: '4px', background: 'var(--bg-panel)', color: 'var(--text-primary)', fontSize: '0.8rem', textAlign: 'center', fontWeight: 'bold' }}
                                    />

                                    {/* Play 2 */}
                                    <input
                                        value={item.col3 || ''}
                                        onChange={(e) => handleUpdateRow(selectedCardId, item.id, { col3: e.target.value.toUpperCase() })}
                                        onDragOver={(e) => e.preventDefault()}
                                        onDrop={(e) => {
                                            e.preventDefault();
                                            const playName = e.dataTransfer.getData('text/plain');
                                            if (playName) {
                                                const p = plays.find(p => p.name === playName);
                                                handleUpdateRow(selectedCardId, item.id, { col3: playName, col3Id: p ? p.id : null });
                                            }
                                        }}
                                        onBlur={() => {
                                            if (item.col3 && !item.col3Id && onQuickAddPlay) {
                                                const newPlay = onQuickAddPlay(item.col3);
                                                if (newPlay) {
                                                    handleUpdateRow(selectedCardId, item.id, { col3: newPlay.name, col3Id: newPlay.id });
                                                }
                                            }
                                        }}
                                        placeholder="Play B"
                                        style={{ width: '100%', padding: '6px', border: '1px solid var(--border)', borderRadius: '4px', background: 'var(--bg-panel)', color: 'var(--text-primary)', fontSize: '0.8rem' }}
                                    />

                                    {/* Actions */}
                                    <div style={{ display: 'flex', gap: '2px', justifyContent: 'flex-end' }}>
                                        <button className="btn btn-secondary" style={{ padding: '4px' }} onClick={() => handleMoveRow(selectedCardId, item.id, -1)} title="Move Up">↑</button>
                                        <button className="btn btn-secondary" style={{ padding: '4px' }} onClick={() => handleMoveRow(selectedCardId, item.id, 1)} title="Move Down">↓</button>
                                        <button className="btn btn-danger" style={{ padding: '4px 8px' }} onClick={() => handleRemoveRow(selectedCardId, item.id)} title="Delete">×</button>
                                    </div>
                                </div>
                            );
                            currentCoord++;
                        }
                    });
                }

                return rows;
            };

            const miniScripts = useMemo(() => {
                return (gamePlan?.miniScripts || []);
            }, [gamePlan]);

            const activeCard = wbSettings[selectedCardId];

            return (
                <div style={{ display: 'flex', height: 'calc(100vh - 100px)', gap: '2rem' }}>
                    {/* Left: Sidebar (Plays or Scripts) */}
                    <div style={{ width: '250px', display: 'flex', flexDirection: 'column', borderRight: '1px solid var(--border)', paddingRight: '1rem' }}>


                        {sidebarMode === 'plays' ? (
                            <>
                                <input
                                    className="form-input"
                                    placeholder="Search plays..."
                                    value={searchTerm}
                                    onChange={e => setSearchTerm(e.target.value)}
                                    style={{ marginBottom: '1rem' }}
                                />
                                <div style={{ flex: 1, overflowY: 'auto', display: 'flex', flexDirection: 'column', gap: '0.25rem' }}>
                                    {filteredPlays.map(play => (
                                        <div
                                            key={play.id}
                                            draggable={true}
                                            onDragStart={(e) => {
                                                e.dataTransfer.setData('text/plain', play.name);
                                            }}
                                            onClick={() => {
                                                if (activeCard && (activeCard.type === 'mini-scripts' || activeCard.type === 'modular')) {
                                                    handleAddPlayRow(selectedCardId, play);
                                                } else {
                                                    setSelectedPlayId(play.id);
                                                }
                                            }}
                                            onDoubleClick={() => handleAutoAssign(play)}
                                            style={{
                                                padding: '0.35rem 0.5rem',
                                                borderRadius: '4px',
                                                border: '1px solid',
                                                borderColor: selectedPlayId === play.id ? 'var(--accent)' : 'var(--border)',
                                                backgroundColor: selectedPlayId === play.id ? 'rgba(56, 189, 248, 0.1)' : 'var(--bg-panel)',
                                                cursor: 'pointer',
                                                opacity: play.wristbandSlot ? 0.5 : 1
                                            }}
                                        >
                                            <div style={{ fontWeight: 'bold', fontSize: '0.75rem', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                                                    {play.priority && <Icon name="Star" size={12} style={{ fill: '#eab308', color: '#eab308' }} />}

                                                    {/* Wiz Badge */}
                                                    {play.isWiz && (
                                                        <span style={{
                                                            fontSize: '0.6rem',
                                                            background: '#fee2e2',
                                                            color: '#991b1b',
                                                            padding: '1px 3px',
                                                            borderRadius: '4px',
                                                            fontWeight: 'bold',
                                                            border: '1px solid #fecaca'
                                                        }}>R</span>
                                                    )}

                                                    {/* Mini Script Badge */}
                                                    {play.isMiniScript && (
                                                        <span style={{
                                                            fontSize: '0.6rem',
                                                            background: '#e0e7ff',
                                                            color: '#3730a3',
                                                            padding: '1px 3px',
                                                            borderRadius: '4px',
                                                            fontWeight: 'bold',
                                                            border: '1px solid #c7d2fe'
                                                        }}>MS</span>
                                                    )}

                                                    <span>{play.name}</span>
                                                </div>
                                                <div style={{ display: 'flex', alignItems: 'center' }}>
                                                    {play.wristbandSlot && <span style={{ fontSize: '0.65rem', color: 'var(--accent)' }}>{getWristbandLabel(play)}</span>}
                                                    {play.staplesSlot && <span style={{ fontSize: '0.65rem', color: '#f59e0b', marginLeft: '4px' }}>[{play.staplesSlot}]</span>}
                                                </div>
                                            </div>

                                        </div>
                                    ))}
                                </div>
                            </>
                        ) : (
                            <>
                                <div style={{ flex: 1, overflowY: 'auto', display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                    <div style={{ padding: '0.5rem', background: 'rgba(56, 189, 248, 0.05)', borderRadius: '4px', marginBottom: '0.5rem' }}>
                                        <h4 style={{ fontSize: '0.8rem', marginBottom: '0.5rem' }}>Tempo Protocols</h4>
                                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '0.25rem' }}>
                                            {CALENDAR_CONSTANTS.PRACTICE_TEMPO_PROTOCOLS.map(p => (
                                                <button
                                                    key={p.id}
                                                    onClick={() => handleAddTempoRow(selectedCardId, p.id)}
                                                    className="btn btn-secondary"
                                                    style={{ fontSize: '0.7rem', padding: '4px' }}
                                                >
                                                    + {p.code}
                                                </button>
                                            ))}
                                        </div>
                                    </div>

                                    <h4 style={{ fontSize: '0.8rem', margin: '0.5rem 0' }}>Mini Scripts</h4>
                                    {miniScripts.map((script, idx) => (
                                        <div
                                            key={script.id || idx}
                                            onClick={() => handleAddScriptRows(selectedCardId, script)}
                                            style={{
                                                padding: '0.5rem',
                                                borderRadius: '4px',
                                                border: '1px solid var(--border)',
                                                background: 'var(--bg-panel)',
                                                cursor: 'pointer'
                                            }}
                                            onMouseEnter={e => e.currentTarget.style.borderColor = 'var(--accent)'}
                                            onMouseLeave={e => e.currentTarget.style.borderColor = 'var(--border)'}
                                        >
                                            <div style={{ fontWeight: 'bold', fontSize: '0.75rem' }}>{script.name}</div>
                                            <div style={{ fontSize: '0.7rem', color: 'var(--text-secondary)' }}>
                                                {script.playIds?.length || 0} plays
                                            </div>
                                        </div>
                                    ))}
                                    {miniScripts.length === 0 && (
                                        <div style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', textAlign: 'center', padding: '1rem' }}>
                                            No mini scripts found in game plan
                                        </div>
                                    )}
                                </div>
                            </>
                        )}
                    </div>

                    {/* Right: Main Content */}
                    <div style={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
                        {/* Header Tabs */}
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                            <div style={{ display: 'flex', gap: '0.5rem' }}>
                                {['staples', 'card1', 'card2', 'card3', 'card4', 'card5', 'card6'].map(id => (
                                    <button
                                        key={id}
                                        onClick={() => setSelectedCardId(id)}
                                        style={{
                                            padding: '0.5rem 1rem',
                                            borderRadius: '6px 6px 0 0',
                                            border: '1px solid var(--border)',
                                            borderBottom: selectedCardId === id ? '2px solid var(--accent)' : '1px solid var(--border)',
                                            background: selectedCardId === id ? 'var(--bg-panel)' : 'transparent',
                                            color: selectedCardId === id ? 'var(--text-primary)' : 'var(--text-secondary)',
                                            fontWeight: 'bold',
                                            cursor: 'pointer'
                                        }}
                                    >
                                        {id === 'card1' ? '100s' : (id === 'card2' ? '200s' : (id === 'card3' ? '300s' : (id === 'card4' ? '400s' : (id === 'card5' ? '500s' : (id === 'card6' ? '600s' : 'STAPLES')))))}
                                    </button>
                                ))}
                            </div>
                            <div style={{ display: 'flex', gap: '0.5rem' }}>
                                <button className="btn btn-secondary" onClick={() => onNavigate && onNavigate('print-hub')}>Print</button>
                                <button className="btn btn-danger" onClick={() => handleClearCard(selectedCardId)}>Clear Card</button>
                                <button className="btn btn-danger" onClick={handleClearBoth} style={{ fontWeight: 'bold' }}>Clear All</button>
                            </div>
                            {confirmModal && (
                                <div style={{
                                    position: 'fixed',
                                    top: 0,
                                    left: 0,
                                    right: 0,
                                    bottom: 0,
                                    backgroundColor: 'rgba(0,0,0,0.8)',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    zIndex: 9999
                                }}>
                                    <div style={{
                                        backgroundColor: 'var(--bg-panel)',
                                        padding: '2rem',
                                        borderRadius: '8px',
                                        maxWidth: '500px',
                                        textAlign: 'center',
                                        border: '1px solid var(--border)'
                                    }}>
                                        <h3 style={{ marginTop: 0 }}>Confirm Action</h3>
                                        <p>{confirmModal.message}</p>
                                        <div style={{ display: 'flex', gap: '1rem', justifyContent: 'center', marginTop: '1.5rem' }}>
                                            <button className="btn btn-secondary" onClick={() => setConfirmModal(null)}>Cancel</button>
                                            <button className="btn btn-danger" onClick={confirmClear}>Confirm</button>
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>


                        {/* Card Settings Bar */}
                        {activeCard && (
                            <div style={{
                                display: 'flex',
                                alignItems: 'center',
                                gap: '1rem',
                                padding: '0.75rem',
                                background: 'var(--bg-panel)',
                                border: '1px solid var(--border)',
                                borderRadius: '4px',
                                marginBottom: '1rem'
                            }}>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                    <label style={{ fontSize: '0.8rem', fontWeight: 'bold' }}>Layout:</label>
                                    <select
                                        className="form-input"
                                        style={{ width: 'auto', padding: '4px 8px' }}
                                        value={activeCard.type}
                                        onChange={e => handleLayoutChange(e.target.value)}
                                        disabled={selectedCardId === 'staples'}
                                    >
                                        <option value="standard">Standard (Traditional)</option>

                                        <option value="mini-scripts">Mini-Scripts</option>

                                        <option value="wiz">WIZ (16-slot grid)</option>

                                    </select>
                                </div>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                    <label style={{ fontSize: '0.8rem', fontWeight: 'bold' }}>Opponent:</label>
                                    <input
                                        className="form-input"
                                        style={{ width: '120px', padding: '4px 8px' }}
                                        onChange={e => updateCard(selectedCardId, { opp: e.target.value })}
                                        placeholder="Opponent"
                                    />
                                </div>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                    <label style={{ fontSize: '0.8rem', fontWeight: 'bold' }}>Iter:</label>
                                    <input
                                        style={{ width: '50px', padding: '4px 8px' }}
                                        value={activeCard.iter}
                                        onChange={e => updateCard(selectedCardId, { iter: e.target.value })}
                                        placeholder="1"
                                    />
                                </div>
                                {(activeCard.type === 'standard' || activeCard.type === 'audible') && (
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                        <label style={{ fontSize: '0.8rem', fontWeight: 'bold' }}>Color:</label>
                                        <select
                                            className="form-input"
                                            style={{ width: 'auto', padding: '4px 8px' }}
                                            value={activeCard.color || 'none'}
                                            onChange={e => updateCard(selectedCardId, { color: e.target.value })}
                                        >
                                            <option value="none">None (White)</option>
                                            <option value="green">Green</option>
                                            <option value="orange">Orange</option>
                                            <option value="red">Red</option>
                                            <option value="blue">Blue</option>
                                            <option value="yellow">Yellow</option>
                                            <option value="purple">Purple</option>
                                            <option value="teal">Teal</option>
                                            <option value="pink">Pink</option>
                                        </select>
                                    </div>
                                )}
                                {(activeCard.type === 'rooski' || activeCard.type === 'wiz') && (
                                    <>
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                            <label style={{ fontSize: '0.8rem', fontWeight: 'bold' }}>View:</label>
                                            <select
                                                className="form-input"
                                                style={{ width: 'auto', padding: '4px 8px' }}
                                                value={activeCard.wizView || 'skill'}
                                                onChange={e => updateCard(selectedCardId, { wizView: e.target.value })}
                                            >
                                                <option value="skill">Skill Positions</option>
                                                <option value="oline">O-Line</option>
                                            </select>
                                        </div>
                                    </>
                                )}
                            </div>
                        )}

                        {/* Rendering Logic */}
                        <div style={{ flex: 1, overflowY: 'auto', padding: '0.5rem' }}>
                            {selectedCardId === 'staples' ? (
                                <div style={{ maxWidth: '800px', width: '600px', margin: '0 auto', background: 'white', color: 'black', padding: '1.5rem', border: '2px solid #333', borderRadius: '8px', boxShadow: '0 4px 12px rgba(0,0,0,0.1)', aspectRatio: '5/3' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem', paddingBottom: '0.5rem', borderBottom: '2px solid var(--accent)' }}>
                                        <span style={{ fontWeight: 'bold', textTransform: 'uppercase' }}>STAPLES</span>
                                        <span style={{ fontWeight: 'bold' }}>10-89</span>
                                    </div>
                                    {renderSpreadsheetTable(getSlotsForCard(selectedCardId), 'standard-view', selectedCardId, 'STAPLES')}
                                </div>
                            ) : (activeCard.type === 'mini-scripts') ? (
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                                    <div style={{ display: 'flex', justifyContent: 'flex-end' }}>
                                        <button className="btn btn-secondary" onClick={() => handleAddHeaderRow(selectedCardId)} style={{ fontSize: '0.8rem' }}>+ Add Section Header</button>
                                    </div>
                                    {/* Modular Editor List */}
                                    <div style={{ flex: 1 }}>
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                            {/* Header */}
                                            <div style={{ display: 'grid', gridTemplateColumns: '40px 80px 1fr 80px 1fr 80px', gap: '0.5rem', padding: '0 0.5rem', fontSize: '0.75rem', fontWeight: 'bold', color: 'var(--text-secondary)' }}>
                                                <div style={{ textAlign: 'center' }}>#</div>
                                                <div style={{ textAlign: 'center' }}>Tempo</div>
                                                <div>Play A</div>
                                                <div style={{ textAlign: 'center' }}>Tempo</div>
                                                <div>Play B</div>
                                                <div></div>
                                            </div>
                                            {/* Rows */}
                                            {renderMiniScriptEditorRows(activeCard, selectedCardId)}
                                        </div>
                                    </div>

                                    {/* Split Preview */}
                                    <div style={{ width: '100%' }}>
                                        <h3 style={{ fontSize: '1rem', marginBottom: '1rem' }}>Preview</h3>
                                        {activeCard.type === 'mini-scripts' ? (
                                            <div style={{
                                                background: 'white',
                                                padding: '1rem',
                                                border: '2px solid #333',
                                                borderRadius: '4px',
                                                boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
                                                width: '100%',
                                                maxWidth: '600px',
                                                margin: '0 auto',
                                                aspectRatio: '5/3',
                                                color: 'black'
                                            }}>
                                                {/* Header REMOVED per user request
                                                <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem', paddingBottom: '0.5rem', borderBottom: '2px solid #333' }}>
                                                    <span style={{ fontWeight: 'bold', textTransform: 'uppercase', fontSize: '0.9rem' }}>{activeCard.opp || 'OPPONENT'}</span>
                                                    <span style={{ fontWeight: 'bold', fontSize: '0.9rem' }}>Card {selectedCardId === 'card1' ? '1' : (selectedCardId === 'card2' ? '2' : (selectedCardId === 'card3' ? '3' : (selectedCardId === 'card4' ? '4' : (selectedCardId === 'card5' ? '5' : '6'))))}{activeCard.iter ? ` - Iter ${activeCard.iter}` : ''}</span>
                                                </div>
                                                */}
                                                {renderSpreadsheetTable(getSlotsForCard(selectedCardId), 'modular-preview', selectedCardId, activeCard.opp || activeCard.opponent || '')}
                                            </div>
                                        ) : (
                                            <div style={{ maxWidth: '800px', width: '600px', margin: '0 auto', background: 'white', color: 'black', padding: '1.5rem', border: '2px solid #333', borderRadius: '8px', boxShadow: '0 4px 12px rgba(0,0,0,0.1)', aspectRatio: '5/3' }}>
                                                {/*
                                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem', paddingBottom: '0.5rem', borderBottom: '2px solid var(--accent)' }}>
                                                    <span style={{ fontWeight: 'bold', textTransform: 'uppercase' }}>{activeCard.opp || 'OPPONENT'}</span>
                                                    <span style={{ fontWeight: 'bold' }}>{selectedCardId === 'card1' ? '100s' : (selectedCardId === 'card2' ? '200s' : (selectedCardId === 'card3' ? '300s' : (selectedCardId === 'card4' ? '400s' : (selectedCardId === 'card5' ? '500s' : '600s'))))} (v{activeCard.iter || '1'})</span>
                                                </div>
                                                */}
                                                {renderSpreadsheetTable(getSlotsForCard(selectedCardId), 'standard-view', selectedCardId, activeCard.opp || activeCard.opponent || '')}
                                            </div>
                                        )}
                                    </div>
                                </div>
                            ) : activeCard ? (
                                <div style={{ maxWidth: '800px', width: '600px', margin: '0 auto', background: 'white', color: 'black', padding: '1.5rem', border: '2px solid #333', borderRadius: '8px', boxShadow: '0 4px 12px rgba(0,0,0,0.1)', aspectRatio: '5/3' }}>
                                    {/*
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem', paddingBottom: '0.5rem', borderBottom: '2px solid var(--accent)' }}>
                                        <span style={{ fontWeight: 'bold', textTransform: 'uppercase' }}>{activeCard.opp || 'OPPONENT'}</span>
                                        <span style={{ fontWeight: 'bold' }}>{selectedCardId === 'card1' ? '100s' : (selectedCardId === 'card2' ? '200s' : (selectedCardId === 'card3' ? '300s' : (selectedCardId === 'card4' ? '400s' : (selectedCardId === 'card5' ? '500s' : '600s'))))} (v{activeCard.iter || '1'})</span>
                                    </div>
                                    */}
                                    {activeCard.type === 'rooski' || activeCard.type === 'wiz' ? (
                                        <div style={{
                                            width: '100%',
                                            aspectRatio: '5 / 3',
                                            margin: '0 auto'
                                        }}>
                                            {renderWizGrid(
                                                getSlotsForCard(selectedCardId),
                                                `${activeCard.opponent || 'OPPONENT'} ${activeCard.iteration || '1'}`,
                                                activeCard.wizView || 'skill'
                                            )}
                                        </div>
                                    ) : activeCard.type === 'audible' ? (
                                        renderAudibleTable(getSlotsForCard(selectedCardId), 'standard-view', selectedCardId, activeCard.opp || activeCard.opponent || '')
                                    ) : (
                                        renderSpreadsheetTable(getSlotsForCard(selectedCardId), 'standard-view', selectedCardId, activeCard.opp || activeCard.opponent || '')
                                    )}
                                </div>
                            ) : null}\n                        </div>
                    </div>

                    {/* Print Layout (hidden on screen, shown when printing) */}
                    {selectedCardId === 'staples' ? (
                        <div className="wristband-print-container" style={{ display: 'none' }}>
                            <div className="wristband-print-grid">
                                {/* Render 4 identical copies of the Staples card */}
                                {[1, 2, 3, 4].map(copyNum => (
                                    <div key={copyNum} className="wristband-print-card">
                                        <>
                                            {/* Header */}
                                            <div className="print-card-header">
                                                <span>STAPLES</span>
                                                <span>10-89</span>
                                            </div>
                                            {/* Content */}
                                            <div className="print-card-content">
                                                {renderSpreadsheetTable(getSlotsForCard(selectedCardId), 'print-view', selectedCardId, 'STAPLES')}
                                            </div>
                                        </>
                                    </div>
                                ))}
                            </div>
                        </div>
                    ) : activeCard && (activeCard.type === 'rooski' || activeCard.type === 'wiz') ? (
                        <>
                            {/* Skill Version - Page 1 */}
                            <div className="wristband-print-container" style={{ display: 'none', pageBreakAfter: 'always' }}>
                                <div className="wristband-print-grid">
                                    {[1, 2, 3, 4].map(copyNum => (
                                        <div key={copyNum} className="wristband-print-card">
                                            {renderWizGrid(
                                                getSlotsForCard(selectedCardId),
                                                `${activeCard.opponent || 'OPPONENT'} ${activeCard.iteration || '1'}`,
                                                'skill'
                                            )}
                                        </div>
                                    ))}
                                </div>
                            </div>

                            {/* O-Line Version - Page 2 */}
                            <div className="wristband-print-container" style={{ display: 'none' }}>
                                <div className="wristband-print-grid">
                                    {[1, 2, 3, 4].map(copyNum => (
                                        <div key={copyNum} className="wristband-print-card">
                                            {renderWizGrid(
                                                getSlotsForCard(selectedCardId),
                                                `${activeCard.opponent || 'OPPONENT'} ${activeCard.iteration || '1'}`,
                                                'oline'
                                            )}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </>
                    ) : activeCard ? (
                        <div className="wristband-print-container" style={{ display: 'none' }}>
                            <div className="wristband-print-grid">
                                {/* Render 4 identical copies of the active card */}
                                {[1, 2, 3, 4].map(copyNum => {
                                    return (
                                        <div key={copyNum} className="wristband-print-card">
                                            <>
                                                {/* Header */}
                                                <div className="print-card-header">
                                                    <span>{activeCard.opp || 'OPPONENT'}</span>
                                                    <span>{selectedCardId === 'card1' ? '100s' : (selectedCardId === 'card2' ? '200s' : (selectedCardId === 'card3' ? '300s' : (selectedCardId === 'card4' ? '400s' : (selectedCardId === 'card5' ? '500s' : '600s'))))} (v{activeCard.iter || '1'})</span>
                                                </div>
                                                {/* Content */}
                                                <div className="print-card-content">
                                                    {activeCard.type === 'audible'
                                                        ? renderAudibleTable(getSlotsForCard(selectedCardId), 'print-view', selectedCardId, activeCard.opp || activeCard.opponent || '')
                                                        : renderSpreadsheetTable(getSlotsForCard(selectedCardId), 'print-view', selectedCardId, activeCard.opp || activeCard.opponent || '')
                                                    }
                                                </div>
                                            </>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    ) : null}
                </div>
            );

        };

        // New print card component for spreadsheet style

        // New print card component for spreadsheet style
        const WristbandPrintCardSpreadsheet = ({ title, slots, slotMap, colorClass }) => {
            // Split into two columns
            const mid = Math.ceil(slots.length / 2);
            const col1 = slots.slice(0, mid);
            const col2 = slots.slice(mid);

            const renderColumn = (columnSlots) => (
                <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                    <thead>
                        <tr>
                            <th style={{ width: '30px' }}>#</th>
                            <th>Play</th>
                        </tr>
                    </thead>
                    <tbody>
                        {columnSlots.map(slot => {
                            const play = slotMap[slot];
                            return (
                                <tr key={slot}>
                                    <td>{slot}</td>
                                    <td>{play?.name || ''}</td>
                                </tr>
                            );
                        })}
                    </tbody>
                </table>
            );

            return (
                <div className={`wristband-print-card-spreadsheet ${colorClass}`}>
                    <div className="card-header">{title}</div>
                    <div style={{ display: 'flex', height: 'calc(100% - 24px)' }}>
                        <div style={{ width: '50%', borderRight: '1px solid black' }}>
                            {renderColumn(col1)}
                        </div>
                        <div style={{ width: '50%' }}>
                            {renderColumn(col2)}
                        </div>
                    </div>
                </div>
            );
        };

        // --- HELPER FUNCTIONS & COMPONENTS ---
        const isOffenseSegment = (type) => {
            const offenseTypes = ['Team O', '7-on-7', 'Inside Run', 'Competition', 'O FUNDI', 'Take-Off', 'Goal Line', 'Short Yardage'];
            return offenseTypes.includes(type);
        };

        const migrateSegmentNotes = (segment) => {
            if (!segment.notes) {
                return { ...segment, notes: {} };
            }
            if (typeof segment.notes === 'string') {
                return {
                    ...segment,
                    notes: segment.notes ? { 'ALL_COACHES': segment.notes } : {}
                };
            }
            return segment;
        };

        const migrateScriptRowNotes = (row) => {
            if (!row.notes) return { ...row, notes: {} };
            if (typeof row.notes === 'string') {
                return { ...row, notes: { 'ALL_COACHES': row.notes } };
            }
            return row;
        };

        // --- NOTES MODAL COMPONENT (Re-implemented as top-level) ---
        const NotesModal = ({ plan, updateCurrentPlan, staff, segmentId, onClose, segment: providedSegment, onUpdateNotes }) => {
            if (!segmentId && !providedSegment) return null;

            // Use provided segment OR find it in the plan (safely)
            const segment = providedSegment || (
                segmentId === 'WARMUP'
                    ? { id: 'WARMUP', notes: plan?.warmupNotes || {} }
                    : plan?.segments?.find(s => s.id == segmentId)
            );

            if (!segment) return null;

            const migrated = segmentId === 'WARMUP'
                ? { notes: plan?.warmupNotes || {} }
                : migrateSegmentNotes(segment);

            // Helper to update notes
            const handleUpdateNotes = (staffId, value) => {
                // If a custom callback is provided, use it (e.g. for Pre-game Timeline)
                if (onUpdateNotes) {
                    onUpdateNotes(segment.id, staffId, value);
                    return;
                }

                const newNotes = { ...migrated.notes, [staffId]: value };

                if (segmentId === 'WARMUP') {
                    updateCurrentPlan({ ...plan, warmupNotes: newNotes });
                } else {
                    // Update segment in plan
                    const updatedSegments = plan.segments.map(s =>
                        s.id === segmentId ? { ...s, notes: newNotes } : s
                    );
                    updateCurrentPlan({ ...plan, segments: updatedSegments });
                }
            };

            // Get staff
            const allStaff = staff || [];
            const coaches = allStaff.filter(s => {
                const r = (s.role || '').toLowerCase();
                return r.includes('coach') || s.type === 'Coach' || (!s.role && !s.type);
            });
            const managers = allStaff.filter(s => {
                const r = (s.role || '').toLowerCase();
                return r.includes('manager') || r === 'trainer' || r === 'stats';
            });

            return (
                <div
                    style={{
                        position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
                        backgroundColor: 'rgba(0, 0, 0, 0.5)', backdropFilter: 'blur(2px)',
                        display: 'flex', alignItems: 'center', justifyContent: 'center',
                        zIndex: 10000, padding: '2rem'
                    }}
                    onClick={onClose}
                >
                    <div
                        style={{
                            backgroundColor: 'var(--bg-panel)',
                            borderRadius: 'var(--radius)',
                            border: '1px solid var(--border)',
                            boxShadow: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',
                            width: '100%', maxWidth: '900px', maxHeight: '85vh',
                            display: 'flex', flexDirection: 'column', overflow: 'hidden'
                        }}
                        onClick={e => e.stopPropagation()}
                    >
                        {/* Header */}
                        <div style={{
                            padding: '1.25rem 1.5rem',
                            borderBottom: '1px solid var(--border)',
                            display: 'flex', justifyContent: 'space-between', alignItems: 'center',
                            background: 'var(--bg-main)'
                        }}>
                            <h3 style={{ margin: 0, fontSize: '1.1rem', fontWeight: 600, display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                <Icon name="FileText" size={18} />
                                {segmentId === 'WARMUP' ? 'Warmup Notes' : `Segment Notes: ${segment.type} (${segment.duration}m)`}
                            </h3>
                            <button
                                onClick={onClose}
                                style={{
                                    background: 'transparent', border: 'none', color: 'var(--text-secondary)',
                                    cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center',
                                    padding: '4px', borderRadius: '4px'
                                }}
                            >
                                <Icon name="X" size={20} />
                            </button>
                        </div>

                        {/* Content */}
                        <div style={{ padding: '1.5rem', overflowY: 'auto', flex: 1, backgroundColor: 'var(--bg-app)' }}>
                            <table style={{ width: '100%', borderCollapse: 'collapse', border: '1px solid var(--border)' }}>
                                <thead>
                                    <tr style={{ background: 'var(--bg-main)', borderBottom: '2px solid var(--border)' }}>
                                        <th style={{ padding: '0.75rem', textAlign: 'left', width: '30%', borderRight: '1px solid var(--border)' }}>Staff Member</th>
                                        <th style={{ padding: '0.75rem', textAlign: 'left' }}>Notes</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {/* Global Note */}
                                    <tr style={{ borderBottom: '1px solid var(--border)', background: '#fff' }}>
                                        <td style={{ padding: '0.75rem', borderRight: '1px solid var(--border)', fontWeight: 'bold', color: '#0f172a' }}>
                                            ALL COACHES
                                        </td>
                                        <td style={{ padding: '0.75rem' }}>
                                            <textarea
                                                className="form-input"
                                                rows={2}
                                                value={migrated.notes['ALL_COACHES'] || ''}
                                                onChange={(e) => handleUpdateNotes('ALL_COACHES', e.target.value)}
                                                placeholder="Enter notes visible to everyone..."
                                                style={{ width: '100%', resize: 'vertical', border: '1px solid #ccc', backgroundColor: '#fff', color: '#0f172a', fontFamily: 'inherit' }}
                                            />
                                        </td>
                                    </tr>

                                    {/* Coaches */}
                                    {coaches.length > 0 && (
                                        <>
                                            <tr style={{ background: 'var(--bg-main)', borderBottom: '1px solid var(--border)' }}>
                                                <td colSpan={2} style={{ padding: '0.5rem', fontWeight: 'bold', fontSize: '0.8rem', color: 'var(--text-secondary)' }}>COACHES</td>
                                            </tr>
                                            {coaches.map(coach => (
                                                <tr key={coach.id} style={{ borderBottom: '1px solid var(--border)', background: '#fff' }}>
                                                    <td style={{ padding: '0.75rem', borderRight: '1px solid var(--border)', fontWeight: 500, color: '#0f172a' }}>
                                                        {coach.name}
                                                    </td>
                                                    <td style={{ padding: '0.75rem' }}>
                                                        <textarea
                                                            className="form-input"
                                                            rows={1}
                                                            value={migrated.notes[coach.id] || ''}
                                                            onChange={(e) => handleUpdateNotes(coach.id, e.target.value)}
                                                            placeholder=""
                                                            style={{ width: '100%', resize: 'vertical', border: '1px solid #ccc', backgroundColor: '#fff', color: '#0f172a', fontFamily: 'inherit' }}
                                                        />
                                                    </td>
                                                </tr>
                                            ))}
                                        </>
                                    )}

                                    {/* Managers */}
                                    {managers.length > 0 && (
                                        <>
                                            <tr style={{ background: 'var(--bg-main)', borderBottom: '1px solid var(--border)' }}>
                                                <td colSpan={2} style={{ padding: '0.5rem', fontWeight: 'bold', fontSize: '0.8rem', color: 'var(--text-secondary)' }}>STAFF & MANAGERS</td>
                                            </tr>
                                            {managers.map(mgr => (
                                                <tr key={mgr.id} style={{ borderBottom: '1px solid var(--border)', background: '#fff' }}>
                                                    <td style={{ padding: '0.75rem', borderRight: '1px solid var(--border)', fontWeight: 500, color: '#0f172a' }}>
                                                        {mgr.name}
                                                    </td>
                                                    <td style={{ padding: '0.75rem' }}>
                                                        <textarea
                                                            className="form-input"
                                                            rows={1}
                                                            value={migrated.notes[mgr.id] || ''}
                                                            onChange={(e) => handleUpdateNotes(mgr.id, e.target.value)}
                                                            placeholder=""
                                                            style={{ width: '100%', resize: 'vertical', border: '1px solid #ccc', backgroundColor: '#fff', color: '#0f172a', fontFamily: 'inherit' }}
                                                        />
                                                    </td>
                                                </tr>
                                            ))}
                                        </>
                                    )}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            );
        };



        const ScriptRowNotesModal = ({ plan, updateSegment, staff, segmentId, rowId, onClose }) => {
            const segment = plan?.segments?.find(s => s.id === segmentId);
            if (!segment) return null;

            const scriptRow = segment.script?.find(r => r.id === rowId);
            if (!scriptRow) return null;

            const migratedRow = migrateScriptRowNotes(scriptRow);

            const handleUpdateNotes = (staffId, value) => {
                const newNotes = { ...migratedRow.notes, [staffId]: value };
                // Filter out empty notes
                if (!value || value.trim() === '') {
                    delete newNotes[staffId];
                }

                const newScript = segment.script.map(r =>
                    r.id === rowId ? { ...r, notes: newNotes } : r
                );
                updateSegment(segmentId, 'script', newScript);
            };

            const allStaff = staff || [];
            const coaches = allStaff.filter(s => {
                const r = (s.role || '').toLowerCase();
                return r.includes('coach') || s.type === 'Coach' || (!s.role && !s.type);
            });

            return (
                <div
                    style={{
                        position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
                        backgroundColor: 'rgba(0, 0, 0, 0.5)', backdropFilter: 'blur(2px)',
                        display: 'flex', alignItems: 'center', justifyContent: 'center',
                        zIndex: 10001, padding: '2rem'
                    }}
                    onClick={onClose}
                >
                    <div
                        style={{
                            backgroundColor: 'var(--bg-panel)',
                            borderRadius: 'var(--radius)',
                            border: '1px solid var(--border)',
                            boxShadow: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',
                            width: '100%', maxWidth: '600px', maxHeight: '85vh',
                            display: 'flex', flexDirection: 'column', overflow: 'hidden'
                        }}
                        onClick={e => e.stopPropagation()}
                    >
                        <div style={{
                            padding: '1rem 1.5rem',
                            borderBottom: '1px solid var(--border)',
                            display: 'flex', justifyContent: 'space-between', alignItems: 'center',
                            background: 'var(--bg-main)'
                        }}>
                            <h3 style={{ margin: 0, fontSize: '1.1rem', fontWeight: 600 }}>
                                Notes for Play Row
                            </h3>
                            <button onClick={onClose} style={{ background: 'transparent', border: 'none', cursor: 'pointer' }}>
                                <Icon name="X" size={20} />
                            </button>
                        </div>

                        <div style={{ flex: 1, overflowY: 'auto', padding: '1.5rem' }}>
                            <div style={{ marginBottom: '1.5rem' }}>
                                <label style={{ display: 'block', fontWeight: 'bold', marginBottom: '0.5rem' }}>All Coaches</label>
                                <textarea
                                    className="form-input"
                                    style={{ width: '100%', minHeight: '80px' }}
                                    value={migratedRow.notes['ALL_COACHES'] || ''}
                                    onChange={e => handleUpdateNotes('ALL_COACHES', e.target.value)}
                                    placeholder="Shared notes..."
                                />
                            </div>
                            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}>
                                {coaches.map(coach => (
                                    <div key={coach.id}>
                                        <label style={{ fontWeight: 'bold', fontSize: '0.85rem' }}>{coach.name}</label>
                                        <textarea
                                            className="form-input"
                                            style={{ width: '100%', minHeight: '50px', fontSize: '0.85rem' }}
                                            value={migratedRow.notes[coach.id] || ''}
                                            onChange={e => handleUpdateNotes(coach.id, e.target.value)}
                                        />
                                    </div>
                                ))}
                            </div>
                        </div>
                        <div style={{ padding: '1rem', borderTop: '1px solid var(--border)', textAlign: 'right' }}>
                            <button className="btn btn-primary" onClick={onClose}>Done</button>
                        </div>
                    </div>
                </div>
            );
        };

        const MultiSelectDropdown = ({ options = [], value = [], onChange, placeholder = "Select...", className = "", center = false }) => {
            const [isOpen, setIsOpen] = useState(false);
            const [searchTerm, setSearchTerm] = useState("");
            const wrapperRef = useRef(null);

            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (wrapperRef.current && !wrapperRef.current.contains(event.target)) {
                        setIsOpen(false);
                    }
                };
                document.addEventListener("mousedown", handleClickOutside);
                return () => document.removeEventListener("mousedown", handleClickOutside);
            }, []);

            const toggleOption = (option) => {
                const newValue = value.includes(option)
                    ? value.filter(v => v !== option)
                    : [...value, option];
                onChange(newValue);
            };

            const filteredOptions = options.filter(opt => opt === '__ADD_CUSTOM__' ||
                opt.toLowerCase().includes(searchTerm.toLowerCase())
            );

            return (
                <div ref={wrapperRef} style={{ position: 'relative', width: '100%' }} className={className}>
                    <div
                        onClick={() => {
                            if (isOpen) setSearchTerm("");
                            setIsOpen(!isOpen);
                        }}
                        style={{
                            border: '1px solid #334155',
                            borderRadius: '0.375rem',
                            padding: '0.25rem 0.5rem',
                            fontSize: '0.875rem',
                            cursor: 'pointer',
                            background: 'var(--input-bg)',
                            minHeight: '30px',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: center ? 'center' : 'flex-start',
                            color: value.length === 0 ? '#9ca3af' : 'var(--text-primary)',
                            overflow: 'hidden',
                            textOverflow: 'ellipsis',
                            whiteSpace: 'nowrap'
                        }}
                    >
                        {value.length > 0 ? value.join(', ') : placeholder}
                    </div>
                    {isOpen && (
                        <div style={{
                            position: 'absolute',
                            zIndex: 50,
                            top: '100%',
                            left: 0,
                            right: 0,
                            marginTop: '0.25rem',
                            background: '#1e293b',
                            border: '1px solid #334155',
                            borderRadius: '0.375rem',
                            boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)',
                            maxHeight: '200px',
                            overflowY: 'auto'
                        }}>
                            <div style={{ position: 'sticky', top: 0, background: '#1e293b', zIndex: 10, borderBottom: '1px solid #334155' }}>
                                <input
                                    type="text"
                                    autoFocus
                                    placeholder="Search..."
                                    value={searchTerm}
                                    onClick={(e) => e.stopPropagation()}
                                    onChange={(e) => setSearchTerm(e.target.value)}
                                    style={{
                                        width: '100%',
                                        padding: '0.5rem',
                                        fontSize: '0.875rem',
                                        border: 'none',
                                        outline: 'none',
                                        background: '#1e293b',
                                        color: 'white'
                                    }}
                                />
                            </div>
                            {filteredOptions.length === 0 ? (
                                <div style={{ padding: '0.5rem', color: '#9ca3af', fontSize: '0.875rem' }}>
                                    No options found. {searchTerm && <span style={{ color: '#60a5fa', cursor: 'pointer' }} onClick={() => onChange([...value, searchTerm])}>Add "{searchTerm}"?</span>}
                                </div>
                            ) : (
                                filteredOptions.map(option => (
                                    <div
                                        key={option}
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            toggleOption(option);
                                        }}
                                        style={{
                                            padding: '0.5rem',
                                            cursor: 'pointer',
                                            fontSize: '0.875rem',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'space-between',
                                            background: value.includes(option) ? '#3b82f6' : 'transparent',
                                            color: value.includes(option) ? 'white' : '#cbd5e1',
                                        }}
                                        onMouseEnter={(e) => {
                                            if (!value.includes(option)) e.currentTarget.style.background = '#334155';
                                        }}
                                        onMouseLeave={(e) => {
                                            if (!value.includes(option)) e.currentTarget.style.background = 'transparent';
                                        }}
                                    >
                                        {option}
                                        {value.includes(option) && <span>✓</span>}
                                    </div>
                                ))
                            )}
                        </div>
                    )}
                </div>
            );
        };

        const PracticePlanPrintView = ({ plan, onBack, teamLogo = '🦅', weekData = {}, isBatchMode = false, coachFilter = 'ALL', roster, staff, drills = [], selectedDay = null }) => {
            console.log('PracticePlanPrintView debug:', { plan, weekData, teamLogo });
            if (!plan) return <div className="p-4">No plan data available <button onClick={onBack} className="btn btn-secondary">Back</button></div>;

            const totalDuration = plan.segments.reduce((acc, seg) => acc + parseInt(seg.duration || 0), 0);

            const dateDisplay = React.useMemo(() => {
                // If selectedDay is provided, use it as the primary day name
                if (selectedDay) {
                    // Try to get the actual date if available
                    if (plan.date && /^\d{4}-\d{2}-\d{2}$/.test(plan.date)) {
                        const d = new Date(plan.date + 'T12:00:00');
                        if (!isNaN(d.getTime())) {
                            // Use selectedDay for the day name, but keep the month and date
                            const monthDay = d.toLocaleDateString('en-US', { month: 'long', day: 'numeric' });
                            return `${selectedDay}, ${monthDay}`;
                        }
                    }
                    // If no valid date, just show the day name
                    return selectedDay;
                }

                // Debug Info
                const debugInfo = ` (Debug: weekDate="${weekData?.date || 'MISSING'}" selDay="${selectedDay}")`;

                // Live Calendar Logic
                if (weekData && weekData.date && selectedDay) {
                    let mondayDate = null;

                    // Try YYYY-MM-DD first (Split to avoid timezone shifts)
                    const parts = weekData.date.split('-');
                    if (parts.length === 3) {
                        const [y, m, d] = parts.map(Number);
                        if (y && m && d) {
                            mondayDate = new Date(y, m - 1, d);
                        }
                    }

                    // Fallback to standard parse if split failed
                    if (!mondayDate) {
                        const d = new Date(weekData.date);
                        if (!isNaN(d.getTime())) mondayDate = d;
                    }

                    if (mondayDate) {
                        const dayOffsets = {
                            'Monday': 0, 'Tuesday': 1, 'Wednesday': 2, 'Thursday': 3, 'Friday': 4, 'Saturday': 5, 'Sunday': 6
                        };

                        const offset = dayOffsets[selectedDay] || 0;
                        const finalDate = new Date(mondayDate);
                        finalDate.setDate(mondayDate.getDate() + offset);

                        return finalDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });
                    }
                }

                // Fallback to original logic
                if (!plan.date) return 'Date TBD' + debugInfo;
                let d = new Date(plan.date);
                if (!isNaN(d.getTime())) return d.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' }) + debugInfo;
                if (/^\d{4}-\d{2}-\d{2}$/.test(plan.date)) {
                    d = new Date(plan.date + 'T12:00:00');
                    if (!isNaN(d.getTime())) return d.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' }) + debugInfo;
                }
                return plan.date + debugInfo;
            }, [plan.date, selectedDay, weekData?.date]);

            // Time calculation helper
            let currentTime;
            if (plan.startTime) {
                currentTime = new Date(`2000-01-01T${plan.startTime}`);
                if (isNaN(currentTime.getTime())) currentTime = new Date('2000-01-01T00:00:00');
            } else {
                currentTime = new Date('2000-01-01T00:00:00');
            }
            const formatTime = (date) => date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' }).replace(' ', '');

            // Pre-practice notes
            const prePracticeNotes = plan.prePracticeNotes || plan.announcements;

            return (
                <div className="print-container" style={{ padding: '0.5in', background: 'white', minHeight: '100vh', color: 'black', fontFamily: 'sans-serif' }}>
                    <style>{`
                    @media print {
                        @page { margin: 0.3in; size: landscape; }
                        body { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
                        .no-print { display: none !important; }
                        .print-container { padding: 0 !important; width: 100% !important; max-width: none !important; margin: 0 !important; }
                        .page-break-avoid { break-inside: avoid; page-break-inside: avoid; }
                        .script-table-row { break-inside: avoid; page-break-inside: avoid; }
                    }
                    .compact-cell { padding: 4px !important; font-size: 0.85rem; border: 1px solid #000; }
                    .header-cell { padding: 4px !important; background: #e5e7eb; border: 1px solid #000; font-weight: bold; font-size: 0.85rem; text-align: center; }
                    `}</style>
                    {!isBatchMode && (
                        <div className="no-print" style={{ marginBottom: '1rem', display: 'flex', justifyContent: 'space-between' }}>
                            <button onClick={onBack} className="btn btn-secondary">
                                <Icon name="ArrowLeft" size={16} /> Back to Print Center
                            </button>
                            <button onClick={() => window.print()} className="btn btn-primary" style={{ display: 'flex', gap: '0.5rem', alignItems: 'center' }}>
                                <Icon name="Printer" size={16} /> Print Plan
                            </button>
                        </div>
                    )}
                    <header style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', borderBottom: '3px solid black', paddingBottom: '0.5rem', marginBottom: '0.5rem' }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                            <div style={{ height: '60px', display: 'flex', alignItems: 'center' }}>
                                {(teamLogo && (teamLogo.startsWith('http') || teamLogo.startsWith('data:'))) ? (
                                    <img src={teamLogo} alt="Logo" style={{ maxHeight: '100%', width: 'auto' }} />
                                ) : (
                                    <div style={{ fontSize: '2.5rem' }}>{teamLogo || '🦅'}</div>
                                )}
                            </div>
                            <div>
                                <h1 style={{ fontSize: '1.8rem', fontWeight: '800', margin: 0, textTransform: 'uppercase' }}>
                                    {`Week ${weekData?.weekNum || weekData?.week || '__'} vs. ${weekData?.opponent || '_______'} - ${dateDisplay}`}
                                </h1>
                            </div>
                        </div>
                        <div style={{ textAlign: 'right' }}>
                            <div style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>Start: {formatTime(currentTime)}</div>
                            <div style={{ fontSize: '1rem' }}>Duration: {Math.floor(totalDuration / 60)}h {totalDuration % 60}m</div>
                        </div>
                    </header>

                    {/* Pre-Practice Notes */}
                    {
                        prePracticeNotes && (
                            <div style={{ border: '1px solid #000', padding: '0.5rem', marginBottom: '1rem', background: '#f9fafb', fontSize: '0.9rem' }}>
                                <strong>Pre-Practice Notes:</strong> <span style={{ whiteSpace: 'pre-wrap' }}>{prePracticeNotes}</span>
                            </div>
                        )
                    }

                    {/* Main Schedule Table */}
                    <table style={{ width: '100%', borderCollapse: 'collapse', marginBottom: '1rem' }}>
                        <thead>
                            <tr>
                                <th className="header-cell" style={{ width: '30px' }}>#</th>
                                <th className="header-cell" style={{ width: '60px' }}>Time</th>
                                <th className="header-cell" style={{ width: '40px' }}>Dur</th>
                                <th className="header-cell" style={{ width: '80px' }}>Phase</th>
                                <th className="header-cell" style={{ width: '100px' }}>Type</th>
                                <th className="header-cell" style={{ width: '120px' }}>Focus</th>
                                <th className="header-cell" style={{ width: '60px' }}>Contact</th>
                                <th className="header-cell">Notes</th>
                            </tr>
                        </thead>
                        <tbody>
                            {plan.segments.map((seg, idx) => {
                                const startTimeStr = formatTime(currentTime);
                                currentTime.setMinutes(currentTime.getMinutes() + parseInt(seg.duration || 0));
                                const isRelevant = coachFilter === 'ALL' ||
                                    seg.staffId === coachFilter ||
                                    (seg.notes && typeof seg.notes === 'object' && seg.notes[coachFilter]);
                                if (!isRelevant) return null;

                                // Helper to format focus
                                const getFocusDisplay = (s) => {
                                    if (s.offenseFocus || s.defenseFocus) {
                                        const parts = [];
                                        if (s.offenseFocus) parts.push(`O: ${Array.isArray(s.offenseFocus) ? s.offenseFocus.join(', ') : s.offenseFocus}`);
                                        if (s.defenseFocus) parts.push(`D: ${Array.isArray(s.defenseFocus) ? s.defenseFocus.join(', ') : s.defenseFocus}`);
                                        return parts.join(' / ');
                                    }
                                    return Array.isArray(s.situation) ? s.situation.join(', ') : (s.situation || '-');
                                };

                                return (
                                    <tr key={idx} style={{ breakInside: 'avoid', pageBreakInside: 'avoid' }}>
                                        <td className="compact-cell" style={{ textAlign: 'center', fontWeight: 'bold' }}>{idx + 1}</td>
                                        <td className="compact-cell" style={{ textAlign: 'center' }}>{startTimeStr}</td>
                                        <td className="compact-cell" style={{ textAlign: 'center' }}>{seg.duration}</td>
                                        <td className="compact-cell" style={{ textAlign: 'center' }}>{seg.phase || 'ALL'}</td>
                                        <td className="compact-cell" style={{ textAlign: 'center' }}>{seg.type || '-'}</td>
                                        <td className="compact-cell" style={{ textAlign: 'center' }}>{getFocusDisplay(seg)}</td>
                                        <td className="compact-cell" style={{ textAlign: 'center' }}>{seg.contactLevel || '-'}</td>
                                        <td className="compact-cell">
                                            <div style={{ fontWeight: '600' }}>{seg.name}</div>
                                            {seg.notes ? (
                                                typeof seg.notes === 'string' ? (
                                                    <div>{seg.notes}</div>
                                                ) : (
                                                    Object.entries(seg.notes)
                                                        .filter(([coachId, note]) => {
                                                            const isGeneral = coachId === 'ALL_COACHES' || coachId === 'ALL';
                                                            if (coachFilter === 'ALL') return isGeneral;
                                                            return isGeneral || coachId === coachFilter;
                                                        })
                                                        .map(([coachId, note]) => (
                                                            <div key={coachId} style={{ marginTop: '2px' }}>
                                                                <strong style={{ color: '#666', marginRight: '4px' }}>
                                                                    {coachId === 'ALL_COACHES' || coachId === 'ALL' ? 'Staff' : (staff?.find(s => s.id === coachId)?.name || coachId)}:
                                                                </strong>
                                                                {note}
                                                            </div>
                                                        ))
                                                )
                                            ) : ''}
                                        </td>
                                    </tr>
                                );
                            })}
                        </tbody>
                    </table>

                    {/* Scripts Section */}
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                        {plan.segments.map((seg, idx) => {
                            // CRITICAL: Only show scripts if the "Script" checkbox is checked
                            if (!seg.hasScript) return null;

                            // Only show scripts if there's actual content (not just empty script arrays)
                            if (!seg.script || seg.script.length === 0) return null;

                            // Check if script has any actual content (playCall, situation, yardLine, etc.)
                            const hasActualContent = seg.script.some(row =>
                                row.playCall || row.situation || row.yardLine || row.hash
                            );
                            if (!hasActualContent) return null;

                            const isWarmup = seg.id === 'WARMUP';

                            return (
                                <div key={`script-${idx}`} className="page-break-avoid" style={{ border: '2px solid black', marginTop: '0.5rem', breakInside: 'avoid', pageBreakInside: 'avoid' }}>
                                    <div style={{ background: '#000', color: 'white', padding: '0.25rem 0.5rem', fontWeight: 'bold', display: 'flex', justifyContent: 'space-between' }}>
                                        <span>Script: {seg.name} ({seg.type})</span>
                                        <span>Phase: {seg.phase || seg.group || 'ALL'}</span>
                                    </div>
                                    <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '0.75rem' }}>
                                        <thead style={{ background: '#f3f4f6', borderBottom: '1px solid black' }}>
                                            <tr>
                                                <th style={{ padding: '4px', borderRight: '1px solid black', width: '25px', textAlign: 'center' }}>#</th>
                                                <th style={{ padding: '4px', borderRight: '1px solid black', width: '35px', textAlign: 'center' }}>Hash</th>
                                                <th style={{ padding: '4px', borderRight: '1px solid black', width: '50px', textAlign: 'center' }}>Dn</th>
                                                <th style={{ padding: '4px', borderRight: '1px solid black', width: '50px', textAlign: 'center' }}>Dist</th>
                                                <th style={{ padding: '4px', borderRight: '1px solid black', width: '80px', textAlign: 'center' }}>Situation</th>
                                                <th style={{ padding: '4px', borderRight: '1px solid black', textAlign: 'left' }}>Play Call</th>
                                                <th style={{ padding: '4px', borderRight: '1px solid black', width: '80px', textAlign: 'center' }}>Defense</th>
                                                <th style={{ padding: '4px', width: '280px', textAlign: 'left' }}>Notes</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {seg.script.map((row, rIdx) => {
                                                // Format notes for print
                                                let notesText = '';
                                                if (row.notes && typeof row.notes === 'object') {
                                                    const noteEntries = Object.entries(row.notes)
                                                        .filter(([_, note]) => note && note.trim())
                                                        .map(([coachId, note]) => {
                                                            const coachName = coachId === 'ALL_COACHES' || coachId === 'ALL'
                                                                ? 'Staff'
                                                                : (staff?.find(s => s.id === coachId)?.name || coachId);
                                                            return `${coachName}: ${note}`;
                                                        });
                                                    notesText = noteEntries.join('; ');
                                                } else if (typeof row.notes === 'string') {
                                                    notesText = row.notes;
                                                }

                                                return (
                                                    <tr key={rIdx} style={{ borderBottom: '1px solid #ddd' }}>
                                                        <td style={{ padding: '3px', borderRight: '1px solid black', textAlign: 'center', fontWeight: 'bold' }}>{rIdx + 1}</td>
                                                        <td style={{ padding: '3px', borderRight: '1px solid black', textAlign: 'center' }}>{row.hash || '-'}</td>
                                                        <td style={{ padding: '3px', borderRight: '1px solid black', textAlign: 'center', fontSize: '0.7rem' }}>
                                                            {row.yardLine || '-'}
                                                        </td>
                                                        <td style={{ padding: '3px', borderRight: '1px solid black', textAlign: 'center', fontSize: '0.7rem' }}>
                                                            {row.downDistance || '-'}
                                                        </td>
                                                        <td style={{ padding: '3px', borderRight: '1px solid black', textAlign: 'center', fontSize: '0.7rem' }}>
                                                            {row.situation || '-'}
                                                        </td>
                                                        <td style={{ padding: '3px', borderRight: '1px solid black', fontWeight: 'bold' }}>
                                                            {row.playName || row.playCall || '-'}
                                                        </td>
                                                        <td style={{ padding: '3px', borderRight: '1px solid black', textAlign: 'center', fontSize: '0.7rem' }}>
                                                            {row.defense || '-'}
                                                        </td>
                                                        <td style={{ padding: '3px', fontSize: '0.65rem', lineHeight: '1.2' }}>
                                                            {notesText || '-'}
                                                        </td>
                                                    </tr>
                                                );
                                            })}
                                        </tbody>
                                    </table>
                                </div>
                            );
                        })}
                    </div>

                    {/* Post-Practice Notes */}
                    {plan.postPracticeNotes && (
                        <div style={{ border: '1px solid #000', padding: '0.5rem', marginTop: '1rem', background: '#f9fafb', fontSize: '0.9rem' }}>
                            <strong>Post-Practice Notes:</strong> <span style={{ whiteSpace: 'pre-wrap' }}>{plan.postPracticeNotes}</span>
                        </div>
                    )}
                </div>
            );
        };

        const ScriptPrintView = ({ plan, onBack, teamLogo = '🦅', isBatchMode = false }) => {
            return (
                <div className="print-container" style={{ padding: '2rem', background: 'white', minHeight: '100vh', color: 'black' }}>
                    {!isBatchMode && (
                        <div className="no-print" style={{ marginBottom: '2rem', display: 'flex', justifyContent: 'space-between' }}>
                            <button onClick={onBack} className="btn btn-secondary">
                                <Icon name="ArrowLeft" size={16} /> Back
                            </button>
                            <button onClick={() => window.print()} className="btn btn-primary">
                                <Icon name="Printer" size={16} /> Print Script
                            </button>
                        </div>
                    )}
                    <h1 style={{ textAlign: 'center', fontSize: '2rem', textTransform: 'uppercase' }}>{teamLogo} {plan?.date ? new Date(plan.date + 'T12:00:00').toLocaleDateString('en-US', { weekday: 'long' }) : 'Day'} Practice Script</h1>
                    <div style={{ padding: '2rem', border: '1px solid black', textAlign: 'center', marginTop: '2rem', fontStyle: 'italic' }}>
                        Script content placeholder for {plan?.date || 'selected date'}...
                    </div>
                </div>
            );
        };

        const ScoutCardPrintView = ({ plan, onBack, teamLogo = '🦅', isBatchMode = false }) => {
            return (
                <div className="print-container" style={{ padding: '2rem', background: 'white', minHeight: '100vh', color: 'black' }}>
                    {!isBatchMode && (
                        <div className="no-print" style={{ marginBottom: '2rem', display: 'flex', justifyContent: 'space-between' }}>
                            <button onClick={onBack} className="btn btn-secondary">
                                <Icon name="ArrowLeft" size={16} /> Back
                            </button>
                            <button onClick={() => window.print()} className="btn btn-primary">
                                <Icon name="Printer" size={16} /> Print Cards
                            </button>
                        </div>
                    )}
                    <h1 style={{ textAlign: 'center', fontSize: '2rem', textTransform: 'uppercase' }}>{teamLogo} Scout Cards</h1>
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginTop: '2rem' }}>
                        {[1, 2, 3, 4].map(i => (
                            <div key={i} style={{ border: '2px dashed black', height: '300px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                                CARD {i}
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        const BatchPrintContainer = ({ components, onBack }) => {
            return (
                <div style={{ width: '100%' }}>
                    <style>{`
        @media print {
            @page { margin: 0; }
                            body { -webkit - print - color - adjust: exact; }
                            .no - print { display: none!important; }
        }
        `}</style>
                    <div className="no-print" style={{ padding: '1rem', background: '#333', color: 'white', marginBottom: '1rem', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                        <div>
                            <strong>Batch Print Preview</strong> - {components.length} pages ready.
                        </div>
                        <div style={{ display: 'flex', gap: '1rem' }}>
                            <button onClick={onBack} className="btn btn-secondary"><Icon name="ArrowLeft" /> Back</button>
                            <button onClick={() => window.print()} className="btn btn-primary"><Icon name="Printer" /> Print Batch</button>
                        </div>
                    </div>
                    {components.map((Comp, idx) => (
                        <div key={idx} style={{ pageBreakAfter: 'always', display: 'block' }}>
                            {Comp}
                        </div>
                    ))}
                </div>
            );
        };

        const PracticeScriptBuilder = ({ mode = 'plan', plays, plans, onUpdatePlans, onUpdateGamePlan, onUpdatePlay, staff, customFocusItems, addCustomFocusItem, user, isLocked, isSiteAdmin, segmentTypes = [], focusItems = [], segmentTypesMap = {}, focusItemsMap = {}, segmentSettings = {}, scriptPresets = [], gamePlan = {}, gamePlanLayouts = {}, playBuckets = [], playCategories = [], weeks = [], currentWeek = {}, onQuickAddPlay, setAppSidebarCollapsed, appSidebarCollapsed, closeSideMenuRef, roster, drills, teamLogo }) => {
            console.log('PracticeScriptBuilder debug:', { currentWeek, teamLogo });
            const { openPlayDetails } = usePlayDetailsModal();

            const [selectedDay, setSelectedDay] = useState('Monday');
            const [selectedSegmentId, setSelectedSegmentId] = useState(null);
            const [searchTerm, setSearchTerm] = useState('');
            const [selectedCoachFilter, setSelectedCoachFilter] = useState('ALL');
            const [selectedNotesCoach, setSelectedNotesCoach] = useState('ALL_COACHES');
            const [showScriptView, setShowScriptView] = useState(false);
            const [showSideMenu, setShowSideMenu] = useState(false);
            const [editingScriptRow, setEditingScriptRow] = useState(null);

            const [isFullScreen, setIsFullScreen] = useState(false);
            const [scoutCardUrls, setScoutCardUrls] = useState({}); // Session-only storage for blob URLs { [segmentId]: string }
            const [scriptTab, setScriptTab] = useState('gameplan');
            const [scriptPlaySearch, setScriptPlaySearch] = useState('');
            const [selectedGamePlanSection, setSelectedGamePlanSection] = useState(null);
            const [includePlayCards, setIncludePlayCards] = useState(false);
            const [customInputState, setCustomInputState] = useState(null); // { id: string, field: string }
            const [globalTemplates, setGlobalTemplates] = useState([]);
            const [notesModalSegmentId, setNotesModalSegmentId] = useState(null); // Track which segment's notes modal is open
            const [gameplanDropdownOpen, setGameplanDropdownOpen] = useState(false);

            // Effect to collapse global sidebar when local side menu is opened
            useEffect(() => {
                if (setAppSidebarCollapsed && showSideMenu) {
                    setAppSidebarCollapsed(true);
                }
            }, [showSideMenu, setAppSidebarCollapsed]);

            // Effect to close side menu when global sidebar is expanded
            useEffect(() => {
                console.log('Sidebar effect:', { appSidebarCollapsed, showSideMenu });
                if (appSidebarCollapsed === false && showSideMenu) {
                    console.log('Closing side menu because sidebar expanded');
                    setShowSideMenu(false);
                }
            }, [appSidebarCollapsed, showSideMenu]);

            // Register close function with ref if provided
            useEffect(() => {
                if (closeSideMenuRef) {
                    closeSideMenuRef.current = () => setShowSideMenu(false);
                }
                return () => {
                    if (closeSideMenuRef) closeSideMenuRef.current = null;
                };
            }, [closeSideMenuRef]);

            console.log('PracticeScriptBuilder render. notesModalSegmentId:', notesModalSegmentId);

            // Fetch global practice templates from Firestore
            useEffect(() => {
                const fetchGlobalTemplates = async () => {
                    try {
                        const snapshot = await window.db.collection('global_templates')
                            .where('type', '==', 'practice_plan')
                            .get();
                        const templates = snapshot.docs.map(doc => ({
                            id: doc.id,
                            name: doc.data().name,
                            category: doc.data().category,
                            segments: doc.data().data?.segments || []
                        }));
                        setGlobalTemplates(templates);
                    } catch (err) {
                        console.error("Error fetching global templates:", err);
                    }
                };
                fetchGlobalTemplates();
            }, []);

            // Helper to handle keyboard navigation in script inputs
            const handleScriptInputKeyDown = (e, segmentId, rowId, fieldName, rows, onUpdate) => {
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    // Find index of current row
                    const currentIndex = rows.findIndex(r => r.id === rowId);
                    if (currentIndex > 0) {
                        const prevRow = rows[currentIndex - 1];
                        const inputId = `input-${segmentId}-${prevRow.id}-${fieldName}`;
                        const el = document.getElementById(inputId);
                        if (el) el.focus();
                    }
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    const currentIndex = rows.findIndex(r => r.id === rowId);
                    if (currentIndex < rows.length - 1) {
                        const nextRow = rows[currentIndex + 1];
                        const inputId = `input-${segmentId}-${nextRow.id}-${fieldName}`;
                        const el = document.getElementById(inputId);
                        if (el) el.focus();
                    }
                } else if ((e.ctrlKey || e.metaKey) && (e.key === 'd' || e.key === 'D')) {
                    e.preventDefault(); // Prevent bookmark shortcut
                    const currentIndex = rows.findIndex(r => r.id === rowId);
                    if (currentIndex > 0) {
                        const prevRow = rows[currentIndex - 1];
                        // Copy value from previous row
                        const valueToCopy = prevRow[fieldName];
                        if (valueToCopy !== undefined) {
                            // Determine new script
                            const newScript = rows.map(r => r.id === rowId ? { ...r, [fieldName]: valueToCopy } : r);
                            if (onUpdate) onUpdate(newScript);
                        }
                    }
                }
            };

            const handlePlayDrop = (e, segmentId, rowId, rows, onUpdate) => {
                e.preventDefault();
                try {
                    const data = e.dataTransfer.getData('application/react-dnd');
                    if (data) {
                        const { playId, name } = JSON.parse(data);
                        const newScript = rows.map(r => r.id === rowId ? { ...r, playName: name, playId: playId } : r);
                        if (onUpdate) onUpdate(newScript);
                    }
                } catch (err) {
                    console.error('Failed to parse dropped play data:', err);
                }
            };

            // Merge hardcoded and global templates
            const allTemplates = [
                ...CALENDAR_CONSTANTS.PRACTICE_TEMPLATES,
                ...globalTemplates
            ];

            // const focusItems = ... (Removed, using prop)
            // Derive Game Plan Focus Items
            const gamePlanFocusItems = React.useMemo(() => {
                const items = new Set();

                // 1. From Layouts (Headers)
                if (gamePlanLayouts?.CALL_SHEET?.sections) {
                    gamePlanLayouts.CALL_SHEET.sections.forEach(section => {
                        if (section.boxes) {
                            section.boxes.forEach(box => {
                                if (box.header) items.add(`GP: ${box.header}`);
                            });
                        }
                    });
                }

                // 2. From Game Plan Data (Scripts & Sets created)
                if (gamePlan) {
                    if (gamePlan.miniScripts) {
                        Object.values(gamePlan.miniScripts).forEach(s => {
                            if (s.name) items.add(`GP: ${s.name}`);
                        });
                    }
                    if (gamePlan?.sets) {
                        Object.values(gamePlan?.sets).forEach(s => {
                            if (s.name) items.add(`GP: ${s.name}`);
                        });
                    }
                }
                return Array.from(items);
            }, [gamePlanLayouts, gamePlan]);

            const baseFocusItems = focusItems.length > 0 ? focusItems : ['Base Downs', 'Convert Downs', 'Red Zone', 'Gold Zone', 'Fringe', 'Goalline/Short YDG', 'Play Action', 'Motion', 'Tackling', 'Turnover', 'Pursuit', 'Board drill', 'Joust', 'Kickoff', 'Kick Return', 'Punt', 'Punt Return', 'Field Goal', 'Onside', 'Hands Team'];

            // Effect to manage body class for printing
            useEffect(() => {
                document.body.classList.add('allow-portal-print');
                return () => document.body.classList.remove('allow-portal-print');
            }, []);

            const availableFocusItems = [...new Set([...baseFocusItems, ...gamePlanFocusItems])];
            const availableSegmentTypes = segmentTypes.length > 0 ? segmentTypes : ['Competition', 'Take-Off', 'Fundi', '7-on-7', 'Inside Run', 'Team', 'Team Stationary', 'Circuit', 'Specials', 'Conditioning', 'Ghost Script', 'One-on-Ones'];

            // Scripts/Plays Data for Side Panel (Hoisted to top level)
            const gpPlays = React.useMemo(() => {
                const ids = new Set();
                if (gamePlan?.miniScripts) Object.values(gamePlan.miniScripts).forEach(s => s.assignedPlayIds?.forEach(id => ids.add(id)));
                if (gamePlan?.sets) Object.values(gamePlan.sets).forEach(s => s.assignedPlayIds?.forEach(id => ids.add(id)));
                return plays.filter(p => ids.has(p.id));
            }, [gamePlan, plays]);


            const priorityPlays = React.useMemo(() => plays.filter(p => p.priority), [plays]);

            // Replicated weekStats logic for Side Menu
            const weekStats = React.useMemo(() => {
                // Calculate unique plays in game plan
                const allGamePlanPlayIds = new Set();
                Object.values(gamePlan?.sets || {}).forEach(set => {
                    (set.playIds || []).forEach(item => {
                        const id = typeof item === 'object' ? item.id : item;
                        if (id) allGamePlanPlayIds.add(id);
                    });
                });
                Object.values(gamePlan?.miniScripts || {}).forEach(script => {
                    (script.playIds || []).forEach(item => {
                        const id = typeof item === 'object' ? item.id : item;
                        if (id) allGamePlanPlayIds.add(id);
                    });
                });
                const uniquePlaysCount = allGamePlanPlayIds.size;

                // Calculate new plays (plays added this week that weren't in previous weeks)
                const previousWeekPlayIds = new Set();
                weeks.forEach(w => {
                    if (w.weekNumber < currentWeek.weekNumber) {
                        const prevGamePlan = w.gamePlan || {};
                        Object.values(prevGamePlan.sets || {}).forEach(set => {
                            (set.playIds || []).forEach(item => {
                                const id = typeof item === 'object' ? item.id : item;
                                if (id) previousWeekPlayIds.add(id);
                            });
                        });
                        Object.values(prevGamePlan.miniScripts || {}).forEach(script => {
                            (script.playIds || []).forEach(item => {
                                const id = typeof item === 'object' ? item.id : item;
                                if (id) previousWeekPlayIds.add(id);
                            });
                        });
                    }
                });
                const newPlaysCount = Array.from(allGamePlanPlayIds).filter(id => !previousWeekPlayIds.has(id)).length;

                // Calculate total practice script slots for the week
                let totalScriptSlots = 0;
                const plansList = Array.isArray(plans) ? plans : Object.values(plans || {});

                plansList.forEach(p => {
                    (p.segments || []).forEach(seg => {
                        if (seg.hasScript && seg.script) {
                            totalScriptSlots += seg.script.length;
                        }
                    });
                });

                return { uniquePlaysCount, newPlaysCount, totalScriptSlots };
            }, [gamePlan, weeks, currentWeek, plans]);

            // Helper functions for phase-based filtering
            const getSegmentTypesForPhase = (phase) => {
                if (!phase || phase === 'ALL' || phase === 'C') {
                    // Return all types combined
                    const all = new Set([
                        ...(segmentTypesMap.OFFENSE || []),
                        ...(segmentTypesMap.DEFENSE || []),
                        ...(segmentTypesMap.SPECIAL_TEAMS || [])
                    ]);
                    // Add defaults if custom types are empty/missing, or use availableSegmentTypes as fallback
                    if (all.size === 0) return availableSegmentTypes;
                    return Array.from(all).sort();
                }

                let types = [];
                if (phase === 'O') types = segmentTypesMap.OFFENSE || [];
                else if (phase === 'D') types = segmentTypesMap.DEFENSE || [];
                else if (phase === 'K') types = segmentTypesMap.SPECIAL_TEAMS || [];

                return types.length > 0 ? types : availableSegmentTypes;
            };

            const getFocusItemsForPhase = (phase) => {
                let items = [];
                if (!phase || phase === 'ALL' || phase === 'C') {
                    // Return all items combined
                    const all = new Set([
                        ...(focusItemsMap.OFFENSE || []),
                        ...(focusItemsMap.DEFENSE || []),
                        ...(focusItemsMap.SPECIAL_TEAMS || []),
                        // Add All Play Buckets to ALL view
                        ...(playBuckets.map(b => b.label) || [])
                    ]);
                    items = Array.from(all);
                } else {
                    if (phase === 'O') {
                        items = focusItemsMap.OFFENSE || [];
                        // Add Play Buckets only to Offense phase
                        const bucketLabels = playBuckets.map(b => b.label);
                        items = [...items, ...bucketLabels];
                    }
                    else if (phase === 'D') items = focusItemsMap.DEFENSE || [];
                    else if (phase === 'K') items = focusItemsMap.SPECIAL_TEAMS || [];
                }

                // Always add Game Plan items
                const combined = new Set([...items, ...gamePlanFocusItems]);
                if (combined.size === 0) return availableFocusItems;

                return Array.from(combined).sort();
            };



            const saveAsGlobalTemplate = async () => {
                const name = prompt("Enter a name for this Template:");
                if (!name) return;

                const category = prompt("Enter a category (e.g. 'Monday', 'Situations', 'Base Install'):", selectedDay);

                try {
                    // Sanitize segments for template (only keeping structure, not specific data like staffId or scripts if they are too specific, 
                    // though user asked to save "it", so we keep types and durations and hasScript flag)
                    const templateSegments = plan.segments.map(seg => ({
                        type: seg.type,
                        duration: seg.duration,
                        situation: seg.situation || '',
                        hasScript: !!seg.hasScript
                    }));

                    await window.db.collection('global_templates').add({
                        type: 'practice_plan',
                        name: name,
                        category: category || '',
                        data: {
                            segments: templateSegments
                        },
                        createdAt: new Date().toISOString(),
                        createdBy: user?.email || 'Admin'
                    });

                    alert(`Template "${name}" saved successfully!`);

                    // Trigger a re-fetch of global templates to update the dropdown immediately
                    const fetchGlobalTemplates = async () => {
                        const snapshot = await window.db.collection('global_templates')
                            .where('type', '==', 'practice_plan')
                            .get();
                        const templates = snapshot.docs.map(doc => ({
                            id: doc.id,
                            name: doc.data().name,
                            category: doc.data().category,
                            segments: doc.data().data?.segments || []
                        }));
                        setGlobalTemplates(templates);
                    };
                    fetchGlobalTemplates();

                } catch (err) {
                    console.error("Error saving global template:", err);
                    alert("Error saving template. Check console for details.");
                }
            };

            const loadTemplate = (templateName) => {
                if (!templateName) return;
                const template = allTemplates.find(t => t.name === templateName);
                if (!template) return;

                if (confirm(`Load "${templateName}"? This will overwrite the current segments for ${selectedDay}.`)) {
                    const newSegments = template.segments.map(seg => ({
                        id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                        duration: seg.duration,
                        type: seg.type,
                        situation: seg.situation || '',
                        notes: {},
                        script: [],
                        staffId: '',
                        hasScript: !!seg.hasScript,
                        hasScoutCards: false
                    }));

                    updateCurrentPlan({
                        ...plan,
                        segments: newSegments
                    });
                }
            };

            const defaultPlan = {
                id: Date.now().toString(),
                date: new Date().toISOString().split('T')[0],
                startTime: '15:40',
                warmupDuration: 5,
                warmupNotes: {},
                warmupScript: [],
                warmupStaffId: '',
                prePracticeNotes: '',
                postPracticeNotes: '',
                segments: []
            };

            const plan = plans[selectedDay] ? { ...defaultPlan, ...plans[selectedDay] } : defaultPlan;

            // Helper to update the specific day's plan
            const updateCurrentPlan = (newPlan) => {
                onUpdatePlans({
                    ...plans,
                    [selectedDay]: newPlan
                });
            };

            // Helper to find preset based on Type and Situation (Focus)
            const findPreset = (type, situation) => {
                const normalize = (str) => (str || '').trim().toLowerCase().replace(/s$/, ''); // Remove trailing s
                const t = (type || '').trim().toLowerCase();
                const sitVal = Array.isArray(situation) ? (situation[0] || '') : situation;
                const s = normalize(sitVal);

                // 0. Explicit Type + Focus Match
                const exactExplicit = scriptPresets.find(p =>
                    p.type && p.type.toLowerCase() === t &&
                    p.focus && normalize(p.focus) === s
                );
                if (exactExplicit) return exactExplicit;

                // 1. Try Specific Combos (Legacy Name)
                if (t && s) {
                    const match = scriptPresets.find(p => {
                        const n = p.name.trim().toLowerCase();
                        // Use sitVal (first item) for matching, avoid calling toLowerCase on array
                        const val = typeof sitVal === 'string' ? sitVal.toLowerCase() : '';
                        return n === `${t} - ${val}` || n.includes(s);
                    });
                    if (match) return match;
                }

                // 2. Explicit Focus Match (Rare but possible)
                if (s) {
                    const focusExplicit = scriptPresets.find(p =>
                        p.focus && normalize(p.focus) === s && (!p.type || !p.type.trim())
                    );
                    if (focusExplicit) return focusExplicit;
                }

                // 3. Try Situation (Legacy Name)
                if (s) {
                    const match = scriptPresets.find(p => {
                        const n = normalize(p.name);
                        return n === s;
                    });
                    if (match) return match;
                }

                // 4. Explicit Type Match (Generic)
                if (t) {
                    const typeExplicit = scriptPresets.find(p =>
                        p.type && p.type.toLowerCase() === t && (!p.focus || !p.focus.trim())
                    );
                    if (typeExplicit) return typeExplicit;
                }

                // 5. Try Type (Legacy Name)
                if (t) {
                    const match = scriptPresets.find(p => p.name.trim().toLowerCase() === t);
                    if (match) return match;
                }

                return null;
            };

            const ensureScriptSlots = (currentScript, duration, segmentType = '', segmentSituation = '') => {
                const targetCount = Math.round((parseInt(duration) || 0) * 1.6) || 0;

                // Find matching preset
                // Note: scriptPresets is available in scope (passed as prop)
                const preset = findPreset(segmentType, segmentSituation);

                const PATTERN_A = ['L', 'LM', 'M', 'RM', 'R', 'RM', 'M', 'LM'];
                const PATTERN_B = ['R', 'RM', 'M', 'LM', 'L', 'LM', 'M', 'RM'];

                let pattern = Math.random() > 0.5 ? PATTERN_A : PATTERN_B;
                if (currentScript && currentScript.length > 0 && currentScript[0].hash) {
                    if (currentScript[0].hash === 'L') pattern = PATTERN_A;
                    else if (currentScript[0].hash === 'R') pattern = PATTERN_B;
                }

                const GHOST_SEQUENCE = [
                    'COIN TOSS', 'KICKOFF', 'TEAM D', 'PUNT RETURN', 'TEAM O', 'PAT',
                    'BACKED-UP PUNT', 'TEAM D', 'PAT BLOCK', 'KICKOFF RET', 'TEAM O',
                    'PUNT', 'HALFTIME', 'HANDS TEAM', 'HAIL MARY', '2-PT PLAY',
                    'ONSIDE KICK', 'PREVENT DEFENSE', 'VICTORY'
                ];

                let processedScript = [...(currentScript || [])];

                processedScript = processedScript.map((slot, i) => {
                    let newSlot = { ...slot };
                    let changed = false;

                    // Apply Preset Data (YardLines, Hashes, Situations from preset)
                    if (preset && preset.items && preset.items.length > 0) {
                        const pItem = preset.items[i % preset.items.length];

                        if (preset.useYardLine) {
                            if (pItem.yardLine && !newSlot.yardLine) { newSlot.yardLine = pItem.yardLine; changed = true; }
                            if (pItem.hash && !newSlot.hash) { newSlot.hash = pItem.hash; changed = true; }
                            if (pItem.down && !newSlot.downDistance) { newSlot.downDistance = pItem.down; changed = true; }
                            if (newSlot.situation) { delete newSlot.situation; changed = true; }
                        } else {
                            if (pItem.situation && !newSlot.situation) { newSlot.situation = pItem.situation; changed = true; }
                            if (newSlot.yardLine) { delete newSlot.yardLine; changed = true; }
                        }
                    }

                    // Fallback Defaults
                    if (!newSlot.hash) {
                        newSlot.hash = pattern[i % 8];
                        changed = true;
                    }

                    // Ghost Script Legacy Fallback
                    if (segmentType === 'Ghost Script' && !preset) {
                        if (!newSlot.situation && i < GHOST_SEQUENCE.length) {
                            newSlot.situation = GHOST_SEQUENCE[i];
                            changed = true;
                        }
                    }

                    return changed ? newSlot : slot;
                });

                let needed = targetCount - processedScript.length;
                if (segmentType === 'Ghost Script' && !preset && processedScript.length < GHOST_SEQUENCE.length) {
                    needed = GHOST_SEQUENCE.length - processedScript.length;
                }

                if (needed <= 0) return processedScript;

                const newSlots = Array(needed).fill(0).map((_, i) => {
                    const seqIndex = processedScript.length + i;
                    const slot = {
                        id: Date.now().toString() + Math.random(),
                        playId: '',
                        playName: '',
                        hash: pattern[seqIndex % 8]
                    };

                    if (preset && preset.items && preset.items.length > 0) {
                        const pItem = preset.items[seqIndex % preset.items.length];
                        if (preset.useYardLine) {
                            slot.yardLine = pItem.yardLine || '';
                            slot.downDistance = pItem.down || '';
                            if (pItem.hash) slot.hash = pItem.hash;
                        } else {
                            slot.situation = pItem.situation || '';
                            if (pItem.hash) slot.hash = pItem.hash;
                        }
                    } else if (segmentType === 'Ghost Script') {
                        slot.situation = seqIndex < GHOST_SEQUENCE.length ? GHOST_SEQUENCE[seqIndex] : '';
                    } else {
                        slot.situation = '';
                    }

                    return slot;
                });

                return [...processedScript, ...newSlots];
            };










            // Calculate segment times and ensure script consistency automatically
            useEffect(() => {
                if (!plan) return;

                let currentTime = new Date(`2000-01-01T${plan.startTime}`);

                // Add warmup offset
                if (plan.warmupDuration) {
                    currentTime.setMinutes(currentTime.getMinutes() + parseInt(plan.warmupDuration));
                }

                const updatedSegments = plan.segments.map((seg, index) => {
                    // Format as 12-hour time without AM/PM (e.g. 3:40)
                    let hours = currentTime.getHours();
                    const minutes = currentTime.getMinutes();
                    hours = hours % 12 || 12; // Convert to 12-hour format
                    const segStartTime = `${hours}:${minutes.toString().padStart(2, '0')}`;

                    // Add duration for next segment
                    currentTime.setMinutes(currentTime.getMinutes() + parseInt(seg.duration || 0));

                    // Ensure script slots are correct (including Take-Off yardlines)
                    const updatedScript = ensureScriptSlots(seg.script || [], parseInt(seg.duration || 0), seg.type, seg.situation);

                    // Force clear situation/focus for Ghost Script to resolve rendering issues
                    if (seg.type === 'Ghost Script' && seg.situation) {
                        return { ...seg, startTime: segStartTime, script: updatedScript, situation: '' };
                    }

                    return { ...seg, startTime: segStartTime, script: updatedScript };
                });

                // Only update if times actually changed to avoid infinite loop
                if (JSON.stringify(updatedSegments) !== JSON.stringify(plan.segments)) {
                    updateCurrentPlan({ ...plan, segments: updatedSegments });
                }
            }, [plan?.startTime, plan?.warmupDuration, plan?.segments.map(s => s.duration).join(','), plan?.segments.length]);



            const addSegment = () => {
                const duration = 5;
                const script = ensureScriptSlots([], duration, 'NEW SEGMENT', '');

                updateCurrentPlan({
                    ...plan,
                    segments: [
                        ...plan.segments,
                        {
                            id: Date.now().toString(),
                            duration,
                            type: 'NEW SEGMENT',
                            situation: '',
                            notes: {},
                            script,
                            staffId: '',
                            hasScript: false,
                            hasScoutCards: false
                        }
                    ]
                });
            };

            const updateSegment = (id, field, value) => {
                if (id === 'WARMUP') {
                    if (field === 'script') updateCurrentPlan({ ...plan, warmupScript: value });
                    if (field === 'staffId') updateCurrentPlan({ ...plan, warmupStaffId: value });
                    return;
                }

                if (field === 'duration') {
                    const segment = plan.segments.find(s => s.id === id);
                    const newScript = ensureScriptSlots(segment.script, value, segment.type, segment.situation);
                    updateCurrentPlan({
                        ...plan,
                        segments: plan.segments.map(s => s.id === id ? { ...s, duration: value, script: newScript } : s)
                    });
                    return;
                }

                if (field === 'type') {
                    const segment = plan.segments.find(s => s.id === id);
                    const newPreset = findPreset(value, segment.situation);

                    if (newPreset && segment.script && segment.script.length > 0) {
                        // Migrate compatible fields
                        const migratedScript = segment.script.map((slot, index) => {
                            const newSlot = { ...slot };
                            const pItem = newPreset.items[index % newPreset.items.length] || {};

                            if (newPreset.useYardLine) {
                                newSlot.yardLine = pItem.yardLine || '';
                                newSlot.downDistance = pItem.down || '';
                                if (pItem.hash) newSlot.hash = pItem.hash;
                                delete newSlot.situation;
                            } else {
                                newSlot.situation = pItem.situation || '';
                                delete newSlot.yardLine;
                                delete newSlot.downDistance;
                            }
                            return newSlot;
                        });

                        updateCurrentPlan({
                            ...plan,
                            segments: plan.segments.map(s => s.id === id ? { ...s, type: value, script: migratedScript } : s)
                        });
                        return;
                    }
                }

                updateCurrentPlan({
                    ...plan,
                    segments: plan.segments.map(s => s.id === id ? { ...s, [field]: value } : s)
                });
            };

            const handleAddSection = (sectionId) => {
                const activeSegment = plan?.segments?.find(s => s.id === selectedSegmentId);
                if (!activeSegment) return;

                let itemsToAdd = [];

                if (Array.isArray(sectionId)) {
                    // Direct play IDs passed
                    itemsToAdd = sectionId.map(id => plays.find(p => p.id === id)).filter(Boolean);
                } else {
                    // 1. Check Matrix Formation
                const matrixFormation = gamePlanLayouts?.MATRIX?.formations?.find(f => f.id === sectionId);
                if (matrixFormation) {
                    const playIds = new Set();
                    const layout = gamePlanLayouts.MATRIX;
                    layout.playTypes.forEach(pt => {
                        layout.cols.forEach(col => {
                            const setId = `matrix_${matrixFormation.id}_${pt.id}_${col.id}`;
                            const cellData = gamePlan?.sets?.[setId];
                            if (cellData && cellData.assignedPlayIds) {
                                cellData.assignedPlayIds.forEach(id => playIds.add(id));
                            } else if (cellData && cellData.playIds) {
                                cellData.playIds.forEach(id => playIds.add(id));
                            }
                        });
                    });
                    itemsToAdd = Array.from(playIds).map(id => plays.find(p => p.id === id)).filter(Boolean);
                } else {
                    let rawIds = [];

                    // 2. Standard Set/Script Lookup
                    let setData = gamePlan?.sets?.[sectionId] || (Array.isArray(gamePlan?.sets) ? gamePlan.sets.find(s => s.id === sectionId) : null) || gamePlan?.miniScripts?.[sectionId] || (Array.isArray(gamePlan?.miniScripts) ? gamePlan.miniScripts.find(s => s.id === sectionId) : null);

                    if (setData) {
                        rawIds = setData.assignedPlayIds || setData.playIds || [];
                    }

                    // 3. Fallback: Call Sheet Layouts
                    if (rawIds.length === 0 && gamePlanLayouts?.CALL_SHEET?.sections) {
                        for (const sec of gamePlanLayouts.CALL_SHEET.sections) {
                            if (!sec.boxes) continue;
                            const box = sec.boxes.find(b => b.setId === sectionId);
                            if (box) {
                                if (box.assignedPlayIds && box.assignedPlayIds.length > 0) {
                                    rawIds = box.assignedPlayIds;
                                } else if (box.rows) {
                                    const scriptIds = [];
                                    box.rows.forEach(r => {
                                        if (r.content) scriptIds.push(r.content);
                                        if (r.contentRight) scriptIds.push(r.contentRight);
                                    });
                                    rawIds = [...new Set(scriptIds)];
                                }
                                break;
                            }
                        }
                    }

                    // 4. Play Buckets Lookup
                    if (rawIds.length === 0) {
                        const bucket = playBuckets?.find(b => b.id === sectionId);
                        if (bucket && bucket.plays) {
                            rawIds = bucket.plays;
                        }
                    }

                    itemsToAdd = rawIds.map(id => {
                        const pid = typeof id === 'object' ? id.id : id;
                        return plays.find(p => p.id === pid);
                    }).filter(Boolean);
                }
            }

                if (itemsToAdd.length === 0) return;

                const currentScript = [...(activeSegment.script || [])];

                itemsToAdd.forEach(playDef => {
                    const name = playDef ? playDef.name : 'Unknown Play';
                    const emptyIndex = currentScript.findIndex(row => !row.playName && !row.playId);

                    const preset = findPreset(activeSegment.type, activeSegment.situation);
                    const showYardLine = preset ? preset.useYardLine : activeSegment.type === 'Take-Off';

                    if (emptyIndex !== -1) {
                        // Fill empty slot
                        currentScript[emptyIndex] = {
                            ...currentScript[emptyIndex],
                            playName: name,
                            playId: playDef ? playDef.id : ''
                        };
                    } else {
                        // Append new row
                        const newItem = {
                            id: `row_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                            hash: 'M',
                            playName: name,
                            playId: playDef ? playDef.id : ''
                        };

                        if (showYardLine) {
                            newItem.yardLine = '';
                            newItem.downDistance = '';
                        } else {
                            newItem.situation = '';
                        }
                        currentScript.push(newItem);
                    }
                });

                updateSegment(selectedSegmentId, 'script', currentScript);
            };

            const handleFocusChange = (segmentId, field, value) => {
                let updatedPlan = { ...plan };

                // 1. Update the Focus Field
                if (segmentId === 'WARMUP') {
                    updatedPlan[field] = value;
                } else {
                    updatedPlan.segments = updatedPlan.segments.map(s => s.id === segmentId ? { ...s, [field]: value } : s);
                }

                // 2. Check for Game Plan match
                let shouldUpdateScript = false;
                let newScript = [];

                if (value && gamePlanLayouts?.CALL_SHEET?.sections) {
                    let foundBox = null;
                    gamePlanLayouts.CALL_SHEET.sections.forEach(section => {
                        if (!foundBox && section.boxes) {
                            foundBox = section.boxes.find(b => b.header === value);
                        }
                    });

                    if (foundBox && foundBox.setId) {
                        if (window.confirm(`Populate script from Game Plan section "${value}"?`)) {
                            const safeGamePlan = gamePlan || {};
                            const isScript = foundBox.type === 'script';
                            const collectionList = isScript ? (safeGamePlan.miniScripts || []) : (safeGamePlan.sets || []);
                            const data = Array.isArray(collectionList) ? collectionList.find(item => item.id === foundBox.setId) : null;

                            if (data && data.assignedPlayIds && data.assignedPlayIds.length > 0) {
                                shouldUpdateScript = true;
                                newScript = data.assignedPlayIds.map(pid => {
                                    const p = plays.find(x => x.id === pid);
                                    return {
                                        id: Date.now().toString() + Math.random(),
                                        playId: pid,
                                        playName: p ? p.name : 'Unknown Play',
                                        hash: 'M',
                                        situation: value
                                    };
                                });
                            } else {
                                alert("No plays found in that Game Plan section.");
                            }
                        }
                    }
                }

                // 3. Apply Script Update if needed
                if (shouldUpdateScript) {
                    if (segmentId === 'WARMUP') {
                        updatedPlan.warmupScript = newScript;
                        updatedPlan.warmupHasScript = true;
                    } else {
                        updatedPlan.segments = updatedPlan.segments.map(s => s.id === segmentId ? { ...s, script: newScript, hasScript: true } : s);
                    }
                }

                updateCurrentPlan(updatedPlan);
            };

            const applyHashPreset = (segmentId, preset) => {
                const segment = plan.segments.find(s => s.id === segmentId);
                if (!segment) return;

                const currentScript = ensureScriptSlots(segment.script, parseInt(segment.duration || 0), segment.type, segment.situation);

                let newScript = [...currentScript];
                const count = newScript.length;

                if (preset === 'SERPENTINE_LR' || preset === 'SERPENTINE_RL') {
                    const patternLR = ['L', 'LM', 'M', 'RM', 'R', 'RM', 'M', 'LM'];
                    const patternRL = ['R', 'RM', 'M', 'LM', 'L', 'LM', 'M', 'RM'];
                    const pattern = preset === 'SERPENTINE_LR' ? patternLR : patternRL;

                    newScript = newScript.map((slot, idx) => ({
                        ...slot,
                        hash: pattern[idx % pattern.length]
                    }));
                } else if (preset === 'ZONES_LR' || preset === 'ZONES_RL') {
                    newScript = newScript.map((slot, idx) => {
                        const progress = idx / count;
                        let h = 'M';
                        if (progress < 0.33) h = (preset === 'ZONES_LR') ? 'L' : 'R';
                        else if (progress < 0.66) h = 'M';
                        else h = (preset === 'ZONES_LR') ? 'R' : 'L';
                        return { ...slot, hash: h };
                    });
                } else if (preset === 'RANDOM') {
                    const opts = ['L', 'LM', 'M', 'RM', 'R'];
                    newScript = newScript.map(slot => ({
                        ...slot,
                        hash: opts[Math.floor(Math.random() * opts.length)]
                    }));
                }

                updateSegment(segmentId, 'script', newScript);
            };

            // Special handler for notes to support coach-specific notes
            const updateSegmentNotes = (segmentId, coachId, noteText) => {
                if (segmentId === 'WARMUP') {
                    const currentNotes = plan.warmupNotes || {};
                    const updated = { ...currentNotes, [coachId]: noteText };
                    if (!noteText || noteText.trim() === '') {
                        delete updated[coachId];
                    }
                    updateCurrentPlan({ ...plan, warmupNotes: updated });
                    return;
                }

                const segment = plan.segments.find(s => s.id === segmentId);
                const migratedSegment = migrateSegmentNotes(segment);
                const updatedNotes = {
                    ...migratedSegment.notes,
                    [coachId]: noteText
                };
                // If note is empty, remove the key
                if (!noteText || noteText.trim() === '') {
                    delete updatedNotes[coachId];
                }
                updateSegment(segmentId, 'notes', updatedNotes);
            };

            const removeSegment = (id) => {
                updateCurrentPlan({
                    ...plan,
                    segments: plan.segments.filter(s => s.id !== id)
                });
            };







            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];

            if (mode === 'script') {
                const scriptedSegments = plan.segments.filter(s => s.hasScript && s.script && s.script.length > 0);
                // Also check warmup
                if (plan.warmupHasScript && plan.warmupScript && plan.warmupScript.length > 0) {
                    scriptedSegments.unshift({
                        id: 'WARMUP',
                        type: 'Warmup',
                        duration: plan.warmupDuration,
                        hasScript: true,
                        script: plan.warmupScript,
                        startTime: plan.startTime // Approximate, start of practice
                    });
                }

                return (
                    <div style={{ display: 'flex', flexDirection: 'column', height: 'calc(100vh - 100px)', border: 'none', outline: 'none' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem', paddingBottom: '0.5rem', border: 'none', outline: 'none', boxShadow: 'none' }}>
                            <div style={{ display: 'flex', gap: '0.5rem' }}>
                                {days.map(day => (
                                    <button
                                        key={day}
                                        className={`btn ${selectedDay === day ? 'btn-primary' : 'btn-secondary'}`}
                                        onClick={() => setSelectedDay(day)}
                                        style={{ textDecoration: 'none', border: 'none', outline: 'none', boxShadow: 'none' }}
                                    >
                                        {day}
                                    </button>
                                ))}
                            </div>
                            <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center' }}>

                                <button
                                    className={`btn ${showSideMenu ? 'btn-primary' : 'btn-secondary'}`}
                                    onClick={() => setShowSideMenu(!showSideMenu)}
                                >
                                    {showSideMenu ? 'Hide Plays' : 'Play Menu'}
                                </button>
                                <button className="btn btn-secondary" onClick={() => window.print()}>🖨️ Print Scripts</button>
                            </div>
                        </div>

                        <div style={{ display: 'flex', flex: 1, overflow: 'hidden' }}>
                            <div className="script-grid-container" style={{ flex: 1, overflowY: 'auto', padding: '1rem', display: 'grid', gridTemplateColumns: '1fr', gap: '2rem', alignContent: 'start' }}>
                                {scriptedSegments.length === 0 && (
                                    <div style={{ gridColumn: '1 / -1', textAlign: 'center', padding: '3rem', color: 'var(--text-secondary)' }}>
                                        No scripted segments for this day. Go to the "Plans" tab to enable scripting for segments.
                                    </div>
                                )}
                                {scriptedSegments.map(seg => {
                                    const settings = segmentSettings[seg.type] || { showHash: true, showDefense: true };
                                    const visibleCols = seg.visibleColumns || {
                                        hash: true,
                                        situation: true,
                                        tempo: true,
                                        defense: true,
                                        notes: true,
                                        actions: true
                                    };
                                    const preset = findPreset(seg.type, seg.situation);
                                    const segShowYardLine = preset ? preset.useYardLine : seg.type === 'Take-Off';
                                    const segSituationDropdown = (seg.situation || '').toLowerCase().includes('3rd');

                                    // Smart row creation helper
                                    const createSmartRow = (idx) => {
                                        const PATTERN_A = ['L', 'LM', 'M', 'RM', 'R', 'RM', 'M', 'LM'];
                                        const PATTERN_B = ['R', 'RM', 'M', 'LM', 'L', 'LM', 'M', 'RM'];
                                        let pattern = PATTERN_A;
                                        if (seg.script.length > 0 && seg.script[0].hash === 'R') pattern = PATTERN_B;

                                        let scriptItem = {
                                            id: Date.now().toString() + Math.random(),
                                            playId: '',
                                            playName: '',
                                            hash: pattern[idx % 8]
                                        };

                                        if (preset && preset.items && preset.items.length > 0) {
                                            const pItem = preset.items[idx % preset.items.length] || {};
                                            if (preset.useYardLine) {
                                                scriptItem.yardLine = pItem.yardLine || '';
                                                scriptItem.downDistance = pItem.down || '';
                                                if (pItem.hash) scriptItem.hash = pItem.hash;
                                            } else {
                                                scriptItem.situation = pItem.situation || '';
                                                if (pItem.hash) scriptItem.hash = pItem.hash;
                                            }
                                        } else if (seg.type === 'Take-Off') {
                                            const yardlines = ['-30', '-40', '50', '40', '30', '20', '10', '5'];
                                            scriptItem.yardLine = yardlines[idx % 8] || '';
                                            scriptItem.downDistance = '';
                                        } else {
                                            scriptItem.situation = '';
                                        }
                                        return scriptItem;
                                    };

                                    return (
                                        <PracticeScriptTable
                                            key={seg.id}
                                            script={ensureScriptSlots(seg.script, parseInt(seg.duration || 0), seg.type, seg.situation)}
                                            onUpdateScript={(newScript) => updateSegment(seg.id, 'script', newScript)}
                                            plays={plays}
                                            playCategories={playCategories}
                                            isLocked={isLocked}
                                            onQuickAddPlay={onQuickAddPlay}
                                            segment={seg}
                                            showHeader={true}
                                            visibleColumns={{
                                                hash: visibleCols.hash && settings.showHash !== false,
                                                down: visibleCols.situation,
                                                dist: visibleCols.situation,
                                                situation: visibleCols.situation && !segShowYardLine,
                                                playCall: true,
                                                defense: visibleCols.defense && settings.showDefense !== false,
                                                notes: visibleCols.notes,
                                                actions: visibleCols.actions
                                            }}
                                            downAsDropdown={true}
                                            situationDropdown={segSituationDropdown}
                                            showYardLine={segShowYardLine}
                                            compact={true}
                                            tableId={seg.id}
                                            notesAsButton={true}
                                            onEditNotes={(segId, rowId) => setEditingScriptRow({ segmentId: segId, rowId: rowId })}
                                            getNotesDisplay={(slot) => {
                                                const migrated = migrateScriptRowNotes(slot);
                                                const hasNotes = migrated.notes && Object.keys(migrated.notes).length > 0;
                                                return { hasNotes, label: hasNotes ? '📝 Notes' : 'Add Note...' };
                                            }}
                                            onInsertRow={(idx, currentScript) => {
                                                const newScript = [...currentScript];
                                                newScript.splice(idx + 1, 0, createSmartRow(idx));
                                                return newScript;
                                            }}
                                            onDeleteRow={(idx, slot, currentScript) => {
                                                if (confirm('Delete this play?')) {
                                                    const newScript = currentScript.filter(s => s.id !== slot.id);
                                                    updateSegment(seg.id, 'script', newScript);
                                                }
                                            }}
                                        />
                                    );
                                })}
                            </div>
                            {editingScriptRow && (
                                <ScriptRowNotesModal
                                    plan={plan}
                                    segmentId={editingScriptRow.segmentId}
                                    rowId={editingScriptRow.rowId}
                                    staff={staff}
                                    onClose={() => setEditingScriptRow(null)}
                                    updateSegment={updateSegment}
                                />
                            )}
                            {showSideMenu && (
                                <GamePlannerSideMenu
                                    plays={plays}
                                    practicePlans={plans}
                                    isOpen={showSideMenu}
                                    onToggle={() => setShowSideMenu(!showSideMenu)}
                                    weekStats={typeof weeks !== 'undefined' && currentWeek ? weeks.find(w => w.id === currentWeek.id) : null}
                                    gamePlan={gamePlan}
                                    gamePlanLayouts={gamePlanLayouts}
                                    playBuckets={typeof playBuckets !== 'undefined' ? playBuckets : []}
                                    playCategories={typeof playCategories !== 'undefined' ? playCategories : []}
                                    onUpdatePlay={onUpdatePlay}
                                    onUpdateGamePlan={onUpdateGamePlan}
                                    currentWeek={currentWeek}
                                    onQuickAddPlay={(play) => {
                                        // Quick add logic for script mode (might need to infer segment?)
                                        // In script mode, all segments are visible.
                                        // But typically user selects a segment to edit?
                                        // Script view here seems to just LIST segments.
                                        // If there is no 'selectedSegmentId' in this mode, Quick Add might not work directly unless we select a segment.
                                        // However, the props are required.
                                        if (selectedSegmentId && selectedSegmentId !== 'WARMUP') {
                                            const seg = plan.segments.find(s => s.id === selectedSegmentId);
                                            if (seg) {
                                                const newItem = {
                                                    id: Date.now().toString(),
                                                    playId: play.id,
                                                    playName: play.name,
                                                    concept: play.conceptFamily || '',
                                                    situation: seg.situation || '',
                                                    hash: '',
                                                    notes: ''
                                                };
                                                const currentScript = Array.isArray(seg.script) ? seg.script : [];
                                                const newScript = [...currentScript, newItem];
                                                updateSegment(seg.id, 'script', newScript);
                                            }
                                        }
                                    }}
                                />
                            )}
                        </div>
                    </div>
                );
            }

            const renderNotesModal = () => {
                const plan = plans[selectedDay];
                if (!plan) return null;
                const segment = plan.segments.find(s => s.id === notesModalSegmentId);
                if (!segment) return null;

                return (
                    <div style={{
                        position: 'fixed',
                        top: 0,
                        left: 0,
                        right: 0,
                        bottom: 0,
                        backgroundColor: 'rgba(0,0,0,0.5)',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        zIndex: 1000
                    }} onClick={() => setNotesModalSegmentId(null)}>
                        <div style={{
                            backgroundColor: 'white',
                            padding: '2rem',
                            borderRadius: '8px',
                            width: '90%',
                            maxWidth: '600px',
                            maxHeight: '80vh',
                            overflowY: 'auto'
                        }} onClick={e => e.stopPropagation()}>
                            <h2 style={{ marginBottom: '1rem', color: 'black' }}>Notes for {segment.name}</h2>
                            <textarea
                                value={segment.notes || ''}
                                onChange={(e) => updateSegment(segment.id, 'notes', e.target.value)}
                                style={{
                                    width: '100%',
                                    height: '200px',
                                    marginBottom: '1rem',
                                    padding: '0.5rem',
                                    border: '1px solid #ddd',
                                    borderRadius: '4px',
                                    resize: 'vertical'
                                }}
                                placeholder="Enter segment notes..."
                            />
                            <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '1rem' }}>
                                <button
                                    onClick={() => setNotesModalSegmentId(null)}
                                    className="btn btn-secondary"
                                >
                                    Close
                                </button>
                            </div>
                        </div>
                    </div>
                );
            };

            // State for Side Menu


            return (
                <div style={{ display: 'flex', flexDirection: 'column', height: 'calc(100vh - 100px)' }}>
                    {mode === 'plan' && plans && plans[selectedDay] && ReactDOM.createPortal(
                        <div className="print-portal">
                            <PracticePlanPrintView
                                plan={plans[selectedDay]}
                                onBack={() => { }}
                                teamLogo={teamLogo}
                                weekData={currentWeek}
                                isBatchMode={false}
                                coachFilter={selectedCoachFilter}
                                roster={roster}
                                staff={staff}
                                drills={drills}
                                selectedDay={selectedDay}
                            />
                        </div>,
                        document.body
                    )}
                    {/* Day Tabs */}
                    <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '1rem', paddingBottom: '0.5rem', border: 'none', outline: 'none', boxShadow: 'none' }}>
                        {days.map(day => (
                            <button
                                key={day}
                                className={`btn ${selectedDay === day ? 'btn-primary' : 'btn-secondary'}`}
                                onClick={() => { setSelectedDay(day); setSelectedSegmentId(null); }}
                                style={{ textDecoration: 'none', border: 'none', outline: 'none', boxShadow: 'none' }}
                            >
                                {day}
                            </button>
                        ))}
                    </div>

                    <div className="practice-flex-container" style={{ display: 'flex', flex: 1, overflow: 'hidden' }}>
                        {/* Left: Schedule View */}
                        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', overflowY: 'auto' }}>
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem', flexWrap: 'wrap', gap: '1rem' }}>
                                <h2>{selectedDay} Schedule</h2>
                                <div style={{ display: 'flex', gap: '0.75rem', alignItems: 'center', flexWrap: 'wrap' }}>
                                    {/* Side Menu Toggle */}
                                    <button
                                        className={`btn ${showSideMenu ? 'btn-primary' : 'btn-secondary'}`}
                                        onClick={() => setShowSideMenu(!showSideMenu)}
                                    >
                                        {showSideMenu ? 'Hide Plays' : 'Play Menu'}
                                    </button>

                                    {/* Template & Global Admin */}
                                    {!isLocked && (
                                        <div style={{ display: 'flex', gap: '0.25rem' }}>
                                            <select
                                                className="form-select"
                                                style={{
                                                    height: '36px',
                                                    width: 'auto',
                                                    backgroundColor: 'var(--bg-panel)',
                                                    border: '1px solid var(--accent)',
                                                    fontSize: '0.85rem',
                                                    padding: '0 2rem 0 0.75rem',
                                                    borderRadius: '6px'
                                                }}
                                                onChange={(e) => {
                                                    loadTemplate(e.target.value);
                                                    e.target.value = ""; // Reset
                                                }}
                                                defaultValue=""
                                            >
                                                <option value="" disabled>Load Template...</option>
                                                {allTemplates.map(t => (
                                                    <option key={t.name} value={t.name}>
                                                        {t.id ? '🌐 ' : '📋 '}{t.name}{t.category ? ` (${t.category})` : ''}
                                                    </option>
                                                ))}
                                            </select>
                                            <button
                                                className="btn btn-secondary"
                                                onClick={saveAsGlobalTemplate}
                                                title="Save as Template"
                                                style={{
                                                    height: '36px',
                                                    padding: '0 0.75rem',
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    gap: '0.25rem',
                                                    fontSize: '0.85rem',
                                                    borderRadius: '6px'
                                                }}
                                            >
                                                <Icon name="Save" size={14} />
                                            </button>
                                        </div>
                                    )}

                                    {/* 2-Platoon Toggle */}
                                    <div style={{
                                        height: '36px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '0.5rem',
                                        backgroundColor: 'var(--bg-panel)',
                                        padding: '0 0.75rem',
                                        borderRadius: '6px',
                                        border: '1px solid var(--border)'
                                    }}>
                                        <input
                                            type="checkbox"
                                            checked={plan.isTwoPlatoon || false}
                                            onChange={e => updateCurrentPlan({ ...plan, isTwoPlatoon: e.target.checked })}
                                            id="two-platoon-check"
                                            style={{ cursor: 'pointer' }}
                                        />
                                        <label htmlFor="two-platoon-check" style={{ fontSize: '0.85rem', cursor: 'pointer', userSelect: 'none', fontWeight: 'bold' }}>2-Platoon</label>
                                    </div>

                                    {/* Time Control */}
                                    <div style={{
                                        height: '36px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '0.5rem',
                                        backgroundColor: 'var(--bg-panel)',
                                        padding: '0 0.75rem',
                                        borderRadius: '6px',
                                        border: '1px solid var(--border)'
                                    }}>
                                        <label style={{ fontSize: '0.85rem', fontWeight: 'bold' }}>Start:</label>
                                        <input
                                            type="time"
                                            className="form-input"
                                            style={{
                                                width: 'auto',
                                                padding: '0',
                                                border: 'none',
                                                background: 'transparent',
                                                fontSize: '0.85rem',
                                                fontFamily: 'inherit',
                                                height: 'auto'
                                            }}
                                            value={plan.startTime}
                                            onChange={e => updateCurrentPlan({ ...plan, startTime: e.target.value })}
                                            disabled={isLocked}
                                        />
                                    </div>

                                    {/* Transition Time Input */}
                                    <div style={{
                                        height: '36px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '0.5rem',
                                        backgroundColor: 'var(--bg-panel)',
                                        padding: '0 0.75rem',
                                        borderRadius: '6px',
                                        border: '1px solid var(--border)'
                                    }}>
                                        <label style={{ fontSize: '0.85rem', fontWeight: 'bold' }}>Trans:</label>
                                        <input
                                            type="number"
                                            className="form-input"
                                            style={{
                                                width: '40px',
                                                padding: '0',
                                                border: 'none',
                                                background: 'transparent',
                                                fontSize: '0.85rem',
                                                fontFamily: 'inherit',
                                                height: 'auto'
                                            }}
                                            value={plan.transitionTime || 0}
                                            onChange={e => updateCurrentPlan({ ...plan, transitionTime: Math.max(0, parseInt(e.target.value) || 0) })}
                                            disabled={isLocked}
                                            min="0"
                                        />
                                        <span style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>m</span>
                                    </div>

                                    {/* Filters: Staff & Notes */}
                                    <div style={{ display: 'flex', gap: '0.5rem' }}>
                                        <select
                                            className="form-select"
                                            style={{
                                                height: '36px',
                                                width: 'auto',
                                                padding: '0 2rem 0 0.75rem',
                                                fontSize: '0.85rem',
                                                borderRadius: '6px'
                                            }}
                                            value={selectedCoachFilter}
                                            onChange={e => setSelectedCoachFilter(e.target.value)}
                                            title="Filter Schedule by Coach"
                                        >
                                            <option value="ALL">All Staff</option>
                                            {staff && staff.map(s => (
                                                <option key={s.id} value={s.id}>{s.name}</option>
                                            ))}
                                        </select>

                                        <select
                                            className="form-select"
                                            style={{
                                                height: '36px',
                                                width: 'auto',
                                                padding: '0 2rem 0 0.75rem',
                                                fontSize: '0.85rem',
                                                borderRadius: '6px'
                                            }}
                                            value={selectedNotesCoach}
                                            onChange={e => setSelectedNotesCoach(e.target.value)}
                                            title="View Notes For"
                                        >
                                            <option value="ALL_COACHES">All Notes</option>
                                            <optgroup label="Coaches">
                                                {staff && staff.map(s => (
                                                    <option key={`note-${s.id}`} value={s.id}>{s.name} Notes</option>
                                                ))}
                                            </optgroup>
                                        </select>
                                    </div>

                                    {/* "Include Play Cards" Checkbox - Only for Scout Offense/Defense */}
                                    {(() => {
                                        const coach = staff?.find(s => s.id === selectedCoachFilter);
                                        if (selectedCoachFilter === 'ALL') return null;

                                        const isScoutOffense = coach?.duties?.some(d => d.includes('Scout Offense') || d.includes('Scout Offensive'));
                                        const isDefense = coach?.duties?.some(d => d.includes('Defensive') || d.includes('Defense'));
                                        const isDefensePos = coach?.positions?.defense;

                                        if (isScoutOffense || isDefense || isDefensePos) {
                                            return (
                                                <div style={{
                                                    height: '36px',
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    gap: '0.5rem',
                                                    backgroundColor: 'var(--bg-panel)',
                                                    padding: '0 0.75rem',
                                                    borderRadius: '6px',
                                                    border: '1px solid var(--border)'
                                                }}>
                                                    <input
                                                        type="checkbox"
                                                        checked={includePlayCards}
                                                        onChange={e => setIncludePlayCards(e.target.checked)}
                                                        id="print-cards-check"
                                                        style={{ cursor: 'pointer' }}
                                                    />
                                                    <label htmlFor="print-cards-check" style={{ fontSize: '0.85rem', cursor: 'pointer', userSelect: 'none' }}>Cards</label>
                                                </div>
                                            );
                                        }
                                        return null;
                                    })()}

                                    <button className="btn btn-secondary"
                                        style={{
                                            height: '36px',
                                            padding: '0 1rem',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            borderRadius: '6px'
                                        }}
                                        onClick={() => {
                                            if (typeof includePlayCards !== 'undefined' && includePlayCards) {
                                                const visibleSegments = plan.segments.filter(seg => selectedCoachFilter === 'ALL' || seg.staffId === selectedCoachFilter);
                                                const urlsToOpen = new Set();
                                                visibleSegments.forEach(seg => {
                                                    if (scoutCardUrls[seg.id]) {
                                                        urlsToOpen.add(scoutCardUrls[seg.id]);
                                                    }
                                                });
                                                if (plan.warmupScoutCard && scoutCardUrls['WARMUP'] && (selectedCoachFilter === 'ALL' || plan.warmupStaffId === selectedCoachFilter)) {
                                                    urlsToOpen.add(scoutCardUrls['WARMUP']);
                                                }
                                                urlsToOpen.forEach(url => window.open(url, '_blank'));
                                            }
                                            window.print();
                                        }} title="Print Schedule">🖨️</button>
                                </div>
                            </div>



                            {/* Pre-Practice Notes */}
                            <div style={{ marginBottom: '1rem' }}>
                                <label style={{ fontWeight: 'bold', display: 'block', marginBottom: '0.25rem' }}>Pre-Practice Notes:</label>
                                <textarea
                                    className="form-input"
                                    style={{ width: '100%', minHeight: '60px', fontFamily: 'inherit' }}
                                    value={plan.prePracticeNotes || ''}
                                    onChange={e => updateCurrentPlan({ ...plan, prePracticeNotes: e.target.value })}
                                    placeholder="Announcements, weather, focus points..."
                                />
                            </div>


                            <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '0.9rem' }}>
                                <thead>
                                    <tr style={{ borderBottom: '2px solid var(--border)', textAlign: 'center' }}>
                                        <th style={{ padding: '0.5rem' }}>#</th>
                                        <th style={{ padding: '0.5rem' }}>Time</th>
                                        <th style={{ padding: '0.5rem' }}>Dur</th>
                                        <th style={{ padding: '0.5rem' }}>Phase</th>
                                        <th style={{ padding: '0.5rem' }}>Type</th>
                                        {plan.isTwoPlatoon ? (
                                            <>
                                                <th style={{ padding: '0.5rem' }}>Offense Focus</th>
                                                <th style={{ padding: '0.5rem' }}>Defense Focus</th>
                                            </>
                                        ) : (
                                            <th style={{ padding: '0.5rem' }}>Focus</th>
                                        )}
                                        <th style={{ padding: '0.5rem' }}>Contact</th>
                                        <th style={{ padding: '0.5rem' }}>Notes</th>
                                        <th style={{ padding: '0.5rem' }}>Script</th>
                                        <th className="no-print" style={{ padding: '0.5rem' }}>Scout Cards</th>
                                        <th className="no-print" style={{ padding: '0.5rem' }}>Delete</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {/* Warmup Row */}
                                    <tr
                                        style={{
                                            borderBottom: '1px solid var(--border)',
                                            backgroundColor: selectedSegmentId === 'WARMUP' ? 'rgba(56, 189, 248, 0.1)' : 'rgba(255, 255, 255, 0.02)',
                                            cursor: 'pointer'
                                        }}
                                        onClick={() => setSelectedSegmentId('WARMUP')}
                                    >
                                        <td style={{ padding: '0.5rem', fontWeight: 'bold', color: 'var(--accent)', textAlign: 'center' }}>0</td>
                                        <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                            {plan.startTime ? (() => {
                                                const date = new Date(`2000-01-01T${plan.startTime}`);
                                                let hours = date.getHours();
                                                const minutes = date.getMinutes();
                                                hours = hours % 12 || 12;
                                                return `${hours}:${minutes.toString().padStart(2, '0')}`;
                                            })() : ''}
                                        </td>
                                        <td style={{ padding: '0.5rem' }}>
                                            <input
                                                type="number"
                                                className="form-input"
                                                style={{ width: '50px', padding: '0.25rem', textAlign: 'center' }}
                                                value={plan.warmupDuration || 0}
                                                onChange={e => updateCurrentPlan({ ...plan, warmupDuration: parseInt(e.target.value) || 0 })}
                                                onClick={e => e.stopPropagation()}
                                            />
                                        </td>
                                        <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                            <select
                                                className="form-select"
                                                value={plan.warmupPhase || 'ALL'}
                                                onChange={e => updateCurrentPlan({ ...plan, warmupPhase: e.target.value })}
                                                onClick={e => e.stopPropagation()}
                                                style={{ width: '70px', padding: '0.25rem', fontSize: '0.85rem', textAlign: 'center' }}
                                            >
                                                <option value="ALL">ALL</option>
                                                <option value="O">O</option>
                                                <option value="D">D</option>
                                                <option value="K">K</option>
                                                <option value="C">C</option>
                                            </select>
                                        </td>
                                        <td style={{ padding: '0.5rem', fontStyle: 'italic', textAlign: 'center' }}>Warmup</td>
                                        {plan.isTwoPlatoon ? (
                                            <>
                                                <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                    <MultiSelectDropdown
                                                        center
                                                        options={getFocusItemsForPhase('O')}
                                                        value={Array.isArray(plan.warmupOffenseFocus) ? plan.warmupOffenseFocus : (plan.warmupOffenseFocus ? [plan.warmupOffenseFocus] : [])}
                                                        onChange={vals => handleFocusChange('WARMUP', 'warmupOffenseFocus', vals)}
                                                        placeholder="-- Offense --"
                                                    />
                                                </td>
                                                <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                    <MultiSelectDropdown
                                                        center
                                                        options={getFocusItemsForPhase('D')}
                                                        value={Array.isArray(plan.warmupDefenseFocus) ? plan.warmupDefenseFocus : (plan.warmupDefenseFocus ? [plan.warmupDefenseFocus] : [])}
                                                        onChange={vals => handleFocusChange('WARMUP', 'warmupDefenseFocus', vals)}
                                                        placeholder="-- Defense --"
                                                    />
                                                </td>
                                            </>
                                        ) : (
                                            <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                {customInputState?.id === 'WARMUP' ? (
                                                    <input
                                                        autoFocus
                                                        className="form-input"
                                                        style={{ padding: '0.25rem', width: '100%', textAlign: 'center' }}
                                                        defaultValue=""
                                                        placeholder="Custom focus..."
                                                        onBlur={(e) => {
                                                            const val = e.target.value.trim();
                                                            if (val) {
                                                                addCustomFocusItem(val);
                                                                updateCurrentPlan({ ...plan, warmupSituation: val });
                                                            }
                                                            setCustomInputState(null);
                                                        }}
                                                        onKeyDown={(e) => {
                                                            if (e.key === 'Enter') e.target.blur();
                                                            if (e.key === 'Escape') setCustomInputState(null);
                                                        }}
                                                        onClick={e => e.stopPropagation()}
                                                    />
                                                ) : (
                                                    <MultiSelectDropdown
                                                        center
                                                        options={[...getFocusItemsForPhase(plan.warmupPhase || 'ALL'), '__ADD_CUSTOM__']}
                                                        value={Array.isArray(plan.warmupSituation) ? plan.warmupSituation : (plan.warmupSituation ? [plan.warmupSituation] : [])}
                                                        onChange={(vals) => {
                                                            if (vals.includes('__ADD_CUSTOM__')) {
                                                                setCustomInputState({ id: 'WARMUP' });
                                                            } else {
                                                                updateCurrentPlan({ ...plan, warmupSituation: vals });
                                                            }
                                                        }}
                                                        placeholder="-- Select Focus --"
                                                    />
                                                )}
                                            </td>
                                        )}
                                        <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                            <select
                                                className="form-select"
                                                style={{ padding: '0.25rem', width: '90px' }}
                                                value={plan.warmupContact || ''}
                                                onChange={e => updateCurrentPlan({ ...plan, warmupContact: e.target.value })}
                                                onClick={e => e.stopPropagation()}
                                            >
                                                <option value="">--</option>
                                                <option value="Install">Install</option>
                                                <option value="On-Air">On-Air</option>
                                                <option value="Shields/Bags">Shields/Bags</option>
                                                <option value="Touch">Touch</option>
                                                <option value="Slight Resist">Slight Resist</option>
                                                <option value="Thud">Thud</option>
                                                <option value="Live">Live</option>
                                            </select>
                                        </td>
                                        <td style={{ padding: '0.5rem' }}>
                                            {(() => {
                                                const warmupNotes = plan.warmupNotes || {};
                                                const hasAnyNotes = Object.keys(warmupNotes).some(key => warmupNotes[key]);
                                                const allNotes = warmupNotes['ALL_COACHES'];

                                                return (
                                                    <button
                                                        className="form-input"
                                                        style={{
                                                            padding: '0.25rem 0.5rem',
                                                            textAlign: 'left',
                                                            cursor: 'pointer',
                                                            width: '100%',
                                                            backgroundColor: hasAnyNotes ? 'var(--bg-input)' : 'transparent',
                                                            border: hasAnyNotes ? '1px solid var(--accent)' : '1px solid var(--border)',
                                                            color: hasAnyNotes ? 'var(--text-primary)' : 'var(--text-secondary)',
                                                            fontStyle: hasAnyNotes ? 'normal' : 'italic',
                                                            overflow: 'hidden',
                                                            textOverflow: 'ellipsis',
                                                            whiteSpace: 'nowrap'
                                                        }}
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            setNotesModalSegmentId('WARMUP');
                                                        }}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                    >
                                                        {hasAnyNotes
                                                            ? (allNotes || Object.values(warmupNotes).find(n => n) || 'Click to view notes...')
                                                            : 'Click to add notes...'
                                                        }
                                                    </button>
                                                );
                                            })()}
                                        </td>
                                        <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                            {plan.warmupHasScript ? (
                                                <div style={{ display: 'flex', gap: '0.25rem', justifyContent: 'center', alignItems: 'center' }}>
                                                    <button
                                                        className="btn btn-primary"
                                                        style={{ padding: '0.25rem 0.5rem', fontSize: '0.8rem' }}
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            setSelectedSegmentId('WARMUP');
                                                            setShowScriptView(true);
                                                        }}
                                                    >
                                                        See Script
                                                    </button>
                                                    {!isLocked && (
                                                        <button
                                                            className="btn"
                                                            style={{ padding: '0.25rem 0.4rem', fontSize: '0.7rem', color: '#ef4444' }}
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                if (confirm('Disable scripting for warmup? This will clear the script.')) {
                                                                    updateCurrentPlan({ ...plan, warmupHasScript: false, warmupScript: [] });
                                                                    if (selectedSegmentId === 'WARMUP') {
                                                                        setSelectedSegmentId(null);
                                                                    }
                                                                }
                                                            }}
                                                            title="Disable scripting"
                                                        >
                                                            ×
                                                        </button>
                                                    )}
                                                </div>
                                            ) : (
                                                !isLocked ? (
                                                    <input
                                                        type="checkbox"
                                                        checked={false}
                                                        onChange={e => {
                                                            updateCurrentPlan({ ...plan, warmupHasScript: e.target.checked });
                                                            if (e.target.checked) {
                                                                setSelectedSegmentId('WARMUP');
                                                                // setShowScriptView(true); // Removed auto-popout
                                                            }
                                                        }}
                                                        onClick={e => e.stopPropagation()}
                                                        style={{ cursor: 'pointer' }}
                                                    />
                                                ) : null
                                            )}
                                        </td>
                                        <td className="no-print" style={{ padding: '0.5rem', textAlign: 'center' }}>
                                            <input
                                                type="file"
                                                id="warmup-scout-card"
                                                style={{ display: 'none' }}
                                                accept="application/pdf"
                                                onChange={(e) => {
                                                    const file = e.target.files[0];
                                                    if (file) {
                                                        const url = URL.createObjectURL(file);
                                                        setScoutCardUrls(prev => ({ ...prev, WARMUP: url }));
                                                        updateCurrentPlan({
                                                            ...plan,
                                                            warmupScoutCard: { name: file.name }
                                                        });
                                                    }
                                                }}
                                                disabled={isLocked}
                                            />
                                            <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '0.25rem' }}>
                                                {!isLocked && (
                                                    <button
                                                        className="btn btn-secondary"
                                                        style={{ padding: '0.25rem 0.5rem', fontSize: '0.7rem' }}
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            document.getElementById('warmup-scout-card').click();
                                                        }}
                                                        title="Upload PDF Card"
                                                    >
                                                        {plan.warmupScoutCard ? '📎 Replace' : '📎 Upload'}
                                                    </button>
                                                )}
                                                {plan.warmupScoutCard && (
                                                    <div style={{ fontSize: '0.7rem', maxWidth: '100px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                                                        {scoutCardUrls['WARMUP'] ? (
                                                            <a
                                                                href={scoutCardUrls['WARMUP']}
                                                                target="_blank"
                                                                rel="noopener noreferrer"
                                                                onClick={e => e.stopPropagation()}
                                                                style={{ color: 'var(--accent)', textDecoration: 'none' }}
                                                            >
                                                                {plan.warmupScoutCard.name}
                                                            </a>
                                                        ) : (
                                                            <span style={{ color: 'var(--text-secondary)', cursor: 'help' }} title="File lost on refresh. Re-upload to view.">
                                                                {plan.warmupScoutCard.name}
                                                            </span>
                                                        )}
                                                    </div>
                                                )}
                                            </div>
                                        </td>
                                        <td className="no-print" style={{ padding: '0.5rem' }}></td>
                                    </tr>

                                    {plan.segments
                                        .map((seg, index) => (
                                            <tr
                                                key={seg.id}
                                                style={{
                                                    borderBottom: '1px solid var(--border)',
                                                    backgroundColor: selectedSegmentId === seg.id ? 'rgba(56, 189, 248, 0.1)' : 'transparent',
                                                    cursor: 'pointer'
                                                }}
                                                onClick={() => setSelectedSegmentId(seg.id)}
                                            >
                                                <td style={{ padding: '0.5rem', fontWeight: 'bold', color: 'var(--accent)', textAlign: 'center' }}>
                                                    {index + 1}
                                                    {/* Insert Segment Button */}
                                                    {!isLocked && (
                                                        <button
                                                            className="btn btn-secondary no-print"
                                                            style={{ marginLeft: '4px', padding: '0 4px', fontSize: '0.7rem', height: '20px', lineHeight: '20px' }}
                                                            title="Insert new segment below"
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                const newSegment = {
                                                                    id: Date.now().toString(),
                                                                    type: 'Competition',
                                                                    duration: 5,
                                                                    startTime: '',
                                                                    phase: 'ALL',
                                                                    hasScript: false,
                                                                    script: [],
                                                                    notes: user?.role === 'HC' ? { 'ALL_COACHES': '' } : {}
                                                                };

                                                                const newSegments = [...plan.segments];
                                                                newSegments.splice(index + 1, 0, newSegment);

                                                                updateCurrentPlan({ ...plan, segments: newSegments });
                                                            }}
                                                        >
                                                            +
                                                        </button>
                                                    )}
                                                </td>
                                                <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                    {plan.startTime ? (() => {
                                                        const [startH, startM] = plan.startTime.split(':').map(Number);
                                                        const warmup = parseInt(plan.warmupDuration) || 0;
                                                        const transition = parseInt(plan.transitionTime) || 0;

                                                        // Calculate time elapsed before this segment
                                                        let elapsedMinutes = warmup;

                                                        // Add durations of prior segments
                                                        for (let i = 0; i < index; i++) {
                                                            elapsedMinutes += (parseInt(plan.segments[i].duration) || 0);
                                                        }

                                                        // Add transitions:
                                                        // User req: No transition between Warmup (Seg 0) and Seg 1.
                                                        // So transitions start applying AFTER Seg 1 (between 1 and 2, etc.)
                                                        // If index is 0 (Seg 1), 0 transitions.
                                                        // If index is 1 (Seg 2), 1 transition (between 1 and 2).
                                                        // Transitions = index.
                                                        if (index > 0) {
                                                            elapsedMinutes += (index * transition);
                                                        }

                                                        const date = new Date();
                                                        date.setHours(startH, startM + elapsedMinutes);

                                                        let hours = date.getHours();
                                                        const minutes = date.getMinutes();
                                                        hours = hours % 12 || 12;
                                                        return `${hours}:${minutes.toString().padStart(2, '0')}`;
                                                    })() : seg.startTime}
                                                </td>
                                                <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                    <span className="print-only-text">{seg.duration}</span>
                                                    {!isLocked && (
                                                        <input
                                                            type="number"
                                                            className="form-input no-print"
                                                            style={{ width: '60px', padding: '0.25rem', textAlign: 'center' }}
                                                            value={seg.duration}
                                                            onChange={e => updateSegment(seg.id, 'duration', parseInt(e.target.value))}
                                                            onClick={e => e.stopPropagation()}
                                                        />
                                                    )}
                                                </td>
                                                <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                    <span className="print-only-text">{seg.phase || 'ALL'}</span>
                                                    {!isLocked && (
                                                        <select
                                                            className="form-select no-print"
                                                            style={{ width: '70px', padding: '0.25rem', fontSize: '0.85rem', textAlign: 'center' }}
                                                            value={seg.phase || 'ALL'}
                                                            onChange={e => updateSegment(seg.id, 'phase', e.target.value)}
                                                            onClick={e => e.stopPropagation()}
                                                        >
                                                            <option value="ALL">ALL</option>
                                                            <option value="O">O</option>
                                                            <option value="D">D</option>
                                                            <option value="K">K</option>
                                                            <option value="C">C</option>
                                                        </select>
                                                    )}
                                                </td>
                                                <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                    <span className="print-only-text">{seg.type}</span>
                                                    {!isLocked && (
                                                        <select
                                                            className="form-select no-print"
                                                            style={{ width: '130px', padding: '0.25rem', textAlign: 'center' }}
                                                            value={seg.type}
                                                            onChange={e => {
                                                                const newType = e.target.value;
                                                                if (newType === 'Ghost Script') {
                                                                    const ghostSequence = [
                                                                        'COIN TOSS', 'KICKOFF', 'TEAM D', 'PUNT RETURN', 'TEAM O', 'PAT',
                                                                        'BACKED-UP PUNT', 'TEAM D', 'PAT BLOCK', 'KICKOFF RET', 'TEAM O',
                                                                        'PUNT', 'HALFTIME', 'HANDS TEAM', 'HAIL MARY', '2-PT PLAY',
                                                                        'ONSIDE KICK', 'PREVENT DEFENSE', 'VICTORY'
                                                                    ];

                                                                    const PATTERN_A = ['L', 'LM', 'RM', 'R', 'R', 'RM', 'LM', 'L'];
                                                                    const PATTERN_B = ['R', 'RM', 'LM', 'L', 'L', 'LM', 'RM', 'R'];
                                                                    const pattern = Math.random() > 0.5 ? PATTERN_A : PATTERN_B;

                                                                    const ghostScript = ghostSequence.map((situation, i) => ({
                                                                        id: Date.now().toString() + i,
                                                                        playId: '',
                                                                        playName: '',
                                                                        hash: pattern[i % 8],
                                                                        situation: situation
                                                                    }));

                                                                    updateCurrentPlan({
                                                                        ...plan,
                                                                        segments: plan.segments.map(s => s.id === seg.id ? {
                                                                            ...s,
                                                                            type: newType,
                                                                            hasScript: true,
                                                                            script: ghostScript,
                                                                            situation: '' // Clear focus to avoid 3rd down dropdown logic interactions
                                                                        } : s)
                                                                    });
                                                                } else {
                                                                    updateSegment(seg.id, 'type', newType);
                                                                }
                                                            }}
                                                            onClick={e => e.stopPropagation()}
                                                        // The onChange handler was duplicated, removed the second one.
                                                        >
                                                            <option value="">-- Select Type --</option>
                                                            {getSegmentTypesForPhase(seg.phase).map(t => (
                                                                <option key={t} value={t}>{t}</option>
                                                            ))}
                                                        </select>
                                                    )}
                                                </td>
                                                {plan.isTwoPlatoon ? (
                                                    <>
                                                        <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                            <span className="print-only-text">{Array.isArray(seg.offenseFocus || seg.situation) ? (seg.offenseFocus || seg.situation).join(', ') : (seg.offenseFocus || seg.situation)}</span>
                                                            {!isLocked && (
                                                                <MultiSelectDropdown
                                                                    center
                                                                    className="no-print"
                                                                    options={segmentSettings[seg.type]?.allowedFocusItems?.length > 0
                                                                        ? segmentSettings[seg.type].allowedFocusItems.filter(f => getFocusItemsForPhase('O').includes(f))
                                                                        : getFocusItemsForPhase('O')}
                                                                    value={Array.isArray(seg.offenseFocus || seg.situation) ? (seg.offenseFocus || seg.situation) : (seg.offenseFocus || seg.situation ? [seg.offenseFocus || seg.situation] : [])}
                                                                    onChange={vals => handleFocusChange(seg.id, 'offenseFocus', vals)}
                                                                    placeholder="-- Offense --"
                                                                />
                                                            )}
                                                        </td>
                                                        <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                            <span className="print-only-text">{Array.isArray(seg.defenseFocus) ? seg.defenseFocus.join(', ') : seg.defenseFocus}</span>
                                                            {!isLocked && (
                                                                <MultiSelectDropdown
                                                                    center
                                                                    className="no-print"
                                                                    options={segmentSettings[seg.type]?.allowedFocusItems?.length > 0
                                                                        ? segmentSettings[seg.type].allowedFocusItems.filter(f => getFocusItemsForPhase('D').includes(f))
                                                                        : getFocusItemsForPhase('D')}
                                                                    value={Array.isArray(seg.defenseFocus) ? seg.defenseFocus : (seg.defenseFocus ? [seg.defenseFocus] : [])}
                                                                    onChange={vals => handleFocusChange(seg.id, 'defenseFocus', vals)}
                                                                    placeholder="-- Defense --"
                                                                />
                                                            )}
                                                        </td>
                                                    </>
                                                ) : (
                                                    <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                        <span className="print-only-text">{Array.isArray(seg.situation) ? seg.situation.join(', ') : seg.situation}</span>
                                                        {!isLocked && (
                                                            customInputState?.id === seg.id ? (
                                                                <input
                                                                    autoFocus
                                                                    className="form-input no-print"
                                                                    style={{ padding: '0.25rem', width: '100%', textAlign: 'center' }}
                                                                    defaultValue=""
                                                                    placeholder="Custom focus..."
                                                                    onBlur={(e) => {
                                                                        const val = e.target.value.trim();
                                                                        if (val) {
                                                                            addCustomFocusItem(val);
                                                                            updateSegment(seg.id, 'situation', val);
                                                                        }
                                                                        setCustomInputState(null);
                                                                    }}
                                                                    onKeyDown={(e) => {
                                                                        if (e.key === 'Enter') e.target.blur();
                                                                        if (e.key === 'Escape') setCustomInputState(null);
                                                                    }}
                                                                    onClick={e => e.stopPropagation()}
                                                                />
                                                            ) : (
                                                                <MultiSelectDropdown
                                                                    center
                                                                    className="no-print"
                                                                    options={[
                                                                        ...(segmentSettings[seg.type]?.allowedFocusItems?.length > 0
                                                                            ? segmentSettings[seg.type].allowedFocusItems.filter(f => getFocusItemsForPhase(seg.phase).includes(f))
                                                                            : getFocusItemsForPhase(seg.phase)),
                                                                        '__ADD_CUSTOM__'
                                                                    ]}
                                                                    value={Array.isArray(seg.situation) ? seg.situation : (seg.situation ? [seg.situation] : [])}
                                                                    onChange={vals => {
                                                                        if (vals.includes('__ADD_CUSTOM__')) {
                                                                            setCustomInputState({ id: seg.id });
                                                                        } else {
                                                                            handleFocusChange(seg.id, 'situation', vals);
                                                                        }
                                                                    }}
                                                                    placeholder="-- Focus --"
                                                                />
                                                            )
                                                        )}
                                                    </td>
                                                )}
                                                <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                    <span className="print-only-text">{seg.contactLevel}</span>
                                                    {!isLocked && (
                                                        <select
                                                            className="form-select no-print"
                                                            style={{ padding: '0.25rem', width: '90px', textAlign: 'center' }}
                                                            value={seg.contactLevel || ''}
                                                            onChange={e => updateSegment(seg.id, 'contactLevel', e.target.value)}
                                                            onClick={e => e.stopPropagation()}
                                                        >
                                                            <option value="">--</option>
                                                            <option value="Install">Install</option>
                                                            <option value="On-Air">On-Air</option>
                                                            <option value="Shields/Bags">Shields/Bags</option>
                                                            <option value="Touch">Touch</option>
                                                            <option value="Slight Resist">Slight Resist</option>
                                                            <option value="Thud">Thud</option>
                                                            <option value="Live">Live</option>
                                                        </select>
                                                    )}
                                                </td>
                                                <td style={{ padding: '0.5rem', whiteSpace: 'pre-wrap' }}>
                                                    {(() => {
                                                        const migrated = migrateSegmentNotes(seg);
                                                        const allNotes = migrated.notes['ALL_COACHES'];
                                                        const hasAnyNotes = Object.keys(migrated.notes).some(key => migrated.notes[key]);

                                                        return (
                                                            <button
                                                                className="form-input"
                                                                style={{
                                                                    padding: '0.25rem 0.5rem',
                                                                    textAlign: 'left',
                                                                    cursor: 'pointer',
                                                                    backgroundColor: hasAnyNotes ? 'var(--bg-input)' : 'transparent',
                                                                    border: hasAnyNotes ? '1px solid var(--accent)' : '1px solid var(--border)',
                                                                    color: hasAnyNotes ? 'var(--text-primary)' : 'var(--text-secondary)',
                                                                    fontStyle: hasAnyNotes ? 'normal' : 'italic',
                                                                    overflow: 'hidden',
                                                                    textOverflow: 'ellipsis',
                                                                    whiteSpace: 'nowrap'
                                                                }}
                                                                onClick={(e) => {
                                                                    e.stopPropagation();
                                                                    setNotesModalSegmentId(seg.id);
                                                                }}
                                                                onMouseDown={(e) => e.stopPropagation()}
                                                            >
                                                                {hasAnyNotes
                                                                    ? (allNotes || Object.values(migrated.notes).find(n => n) || 'Click to view notes...')
                                                                    : 'Click to add notes...'
                                                                }
                                                            </button>
                                                        );
                                                    })()}
                                                </td>
                                                <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                    {seg.hasScript ? (
                                                        <div style={{ display: 'flex', gap: '0.25rem', justifyContent: 'center', alignItems: 'center' }}>
                                                            <button
                                                                className="btn btn-primary"
                                                                style={{ padding: '0.25rem 0.5rem', fontSize: '0.8rem' }}
                                                                onClick={(e) => {
                                                                    e.stopPropagation();
                                                                    setSelectedSegmentId(seg.id);
                                                                    setShowScriptView(true);
                                                                }}
                                                            >
                                                                See Script
                                                            </button>
                                                            {!isLocked && (
                                                                <button
                                                                    className="btn"
                                                                    style={{ padding: '0.25rem 0.4rem', fontSize: '0.7rem', color: '#ef4444' }}
                                                                    onClick={(e) => {
                                                                        e.stopPropagation();
                                                                        if (confirm('Disable scripting for this segment? This will clear the script.')) {
                                                                            // Perform single atomic update to avoid race condition
                                                                            updateCurrentPlan({
                                                                                ...plan,
                                                                                segments: plan.segments.map(s => s.id === seg.id ? { ...s, hasScript: false, script: [] } : s)
                                                                            });

                                                                            if (selectedSegmentId === seg.id) {
                                                                                setSelectedSegmentId(null);
                                                                            }
                                                                        }
                                                                    }}
                                                                    title="Disable scripting"
                                                                >
                                                                    ×
                                                                </button>
                                                            )}
                                                        </div>
                                                    ) : (
                                                        !isLocked ? (
                                                            <input
                                                                type="checkbox"
                                                                checked={false}
                                                                onChange={e => {
                                                                    if (e.target.checked) {
                                                                        // Atomically enable script AND populate slots based on duration/type
                                                                        const initializedScript = ensureScriptSlots([], parseInt(seg.duration || 0), seg.type);

                                                                        updateCurrentPlan({
                                                                            ...plan,
                                                                            segments: plan.segments.map(s => s.id === seg.id ? {
                                                                                ...s,
                                                                                hasScript: true,
                                                                                script: initializedScript
                                                                            } : s)
                                                                        });

                                                                        setSelectedSegmentId(seg.id);
                                                                        // setShowScriptView(true); // Removed auto-popout
                                                                    } else {
                                                                        // Should not happen as unchecked state renders button, but for safety:
                                                                        updateSegment(seg.id, 'hasScript', false);
                                                                    }
                                                                }}
                                                                onClick={e => e.stopPropagation()}
                                                                style={{ cursor: 'pointer' }}
                                                            />
                                                        ) : null
                                                    )}
                                                </td>
                                                <td className="no-print" style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                    <input
                                                        type="file"
                                                        id={`scout-card-${seg.id}`}
                                                        style={{ display: 'none' }}
                                                        accept="application/pdf"
                                                        onChange={(e) => {
                                                            const file = e.target.files[0];
                                                            if (file) {
                                                                const url = URL.createObjectURL(file);
                                                                setScoutCardUrls(prev => ({ ...prev, [seg.id]: url }));
                                                                updateSegment(seg.id, 'scoutCard', { name: file.name });
                                                            }
                                                        }}
                                                        disabled={isLocked}
                                                    />
                                                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '0.25rem' }}>
                                                        {!isLocked && (
                                                            <button
                                                                className="btn btn-secondary"
                                                                style={{ padding: '0.25rem 0.5rem', fontSize: '0.7rem' }}
                                                                onClick={(e) => {
                                                                    e.stopPropagation();
                                                                    document.getElementById(`scout-card-${seg.id}`).click();
                                                                }}
                                                                title="Upload PDF Card"
                                                            >
                                                                {seg.scoutCard ? '📎 Replace' : '📎 Upload'}
                                                            </button>
                                                        )}
                                                        {seg.scoutCard && (
                                                            <div style={{ fontSize: '0.7rem', maxWidth: '100px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                                                                {scoutCardUrls[seg.id] ? (
                                                                    <a
                                                                        href={scoutCardUrls[seg.id]}
                                                                        target="_blank"
                                                                        rel="noopener noreferrer"
                                                                        onClick={e => e.stopPropagation()}
                                                                        style={{ color: 'var(--accent)', textDecoration: 'none' }}
                                                                    >
                                                                        {seg.scoutCard.name}
                                                                    </a>
                                                                ) : (
                                                                    <span style={{ color: 'var(--text-secondary)', cursor: 'help' }} title="File lost on refresh. Re-upload to view.">
                                                                        {seg.scoutCard.name}
                                                                    </span>
                                                                )}
                                                            </div>
                                                        )}
                                                    </div>
                                                </td>
                                                <td className="no-print" style={{ padding: '0.5rem' }}>
                                                    {!isLocked && (
                                                        <button
                                                            className="btn"
                                                            style={{ padding: '0.25rem 0.5rem', fontSize: '0.8rem', color: '#ef4444' }}
                                                            onClick={(e) => { e.stopPropagation(); removeSegment(seg.id); }}
                                                        >
                                                            ×
                                                        </button>
                                                    )}
                                                </td>
                                            </tr>
                                        ))}
                                    {/* Shake it up Segment - Static unnumbered */}
                                    <tr>
                                        <td colSpan={12} style={{ padding: '0' }}>
                                            <div style={{
                                                border: '2px dashed var(--border)',
                                                borderRadius: 'var(--radius)',
                                                display: 'flex',
                                                alignItems: 'center',
                                                justifyContent: 'center',
                                                padding: '0.5rem',
                                                color: 'var(--text-secondary)',
                                                fontStyle: 'italic',
                                                marginTop: '1rem',
                                                marginBottom: '1rem',
                                                background: 'var(--bg-app)'
                                            }}>
                                                <div style={{ marginRight: '1rem', color: 'var(--accent)' }}>---</div>
                                                <div style={{ fontWeight: 'bold' }}>
                                                    Shake it up
                                                    {plan.startTime && (() => {
                                                        const [startH, startM] = plan.startTime.split(':').map(Number);
                                                        const warmup = parseInt(plan.warmupDuration) || 0;
                                                        const transition = parseInt(plan.transitionTime) || 0;

                                                        const segments = plan.segments || [];
                                                        const segmentCount = segments.length;
                                                        const segmentsDuration = segments.reduce((acc, s) => acc + (parseInt(s.duration) || 0), 0);

                                                        // Transitions:
                                                        // 0 -> 1: No
                                                        // 1 -> 2: Yes
                                                        // ...
                                                        // Last Seg -> Shake it up: Yes (User implied it adheres to space between *each* segment, usually applies to shake it up too as a block)
                                                        // User said "Universal between periods".
                                                        // If we have N segments (1..N).
                                                        // Transitions exist after 1, 2, ..., N-1.
                                                        // Does it exist after N (before Shake it up)?
                                                        // Assuming "Shake it up" is a segment-like block, there should probably be a transition into it.
                                                        // Let's assume standard practice: Period 1 -> Trans -> Period 2.
                                                        // If Shake it up follows last period, it likely needs a transition too.
                                                        // Total transitions = (segmentCount > 0 ? segmentCount : 0) ? - Wait, 0->1 is NO.
                                                        // Seg 1 -> Seg 2 (1 trans).
                                                        // Seg 2 -> Seg 3 (2 trans).
                                                        // Seg N -> Shake it up (N trans).
                                                        // If N=1: Warmup->Seg1->(Trans)->Shake. 1 Transition?
                                                        // If N=2: Warmup->Seg1->(Trans)->Seg2->(Trans)->Shake. 2 Transitions.
                                                        // So Total Transitions = segmentCount.

                                                        const totalTransitionTime = segmentCount * transition;

                                                        const totalMinutes = warmup + segmentsDuration + totalTransitionTime;

                                                        const date = new Date();
                                                        date.setHours(startH, startM + totalMinutes);

                                                        let hours = date.getHours();
                                                        const minutes = date.getMinutes();
                                                        hours = hours % 12 || 12;
                                                        return ` (End: ${hours}:${minutes.toString().padStart(2, '0')})`;
                                                    })()}
                                                </div>
                                                <div style={{ marginLeft: '1rem', color: 'var(--accent)' }}>---</div>
                                            </div>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>



                            {/* Add Segment Button */}
                            <div style={{ padding: '1rem', textAlign: 'center', marginTop: '1rem' }}>
                                <button
                                    className="btn btn-primary"
                                    onClick={addSegment}
                                    disabled={isLocked}
                                >
                                    + Add Segment
                                </button>
                            </div>

                            {/* Post Practice Notes Section */}
                            <div style={{ marginTop: '2rem', borderTop: '2px solid var(--border)', paddingTop: '1rem' }}>
                                <label style={{ fontWeight: 'bold', display: 'block', marginBottom: '0.5rem' }}>Post Practice Notes</label>
                                <div className="print-only-text screen-hidden" style={{ minHeight: '100px', whiteSpace: 'pre-wrap', border: '1px solid #ddd', padding: '0.5rem', borderRadius: '4px' }}>
                                    {plan.postPracticeNotes}
                                </div>
                                <textarea
                                    className="form-input no-print"
                                    style={{ width: '100%', minHeight: '100px', fontFamily: 'inherit' }}
                                    value={plan.postPracticeNotes || ''}
                                    onChange={e => updateCurrentPlan({ ...plan, postPracticeNotes: e.target.value })}
                                    placeholder="Post-practice thoughts or ideas for tomorrow..."
                                    disabled={isLocked}
                                />
                            </div>
                        </div> {/* Close Right Column */}

                    </div> {/* Close Practice Flex Container */}

                    {/* Print Only: Scripts View (Page 2) */}
                    <div className="print-only-scripts" style={{ display: 'none' }}>
                        <div style={{ pageBreakBefore: 'always', breakBefore: 'page' }}>
                            <h2 style={{ textAlign: 'center', marginBottom: '1rem', borderBottom: '2px solid black', paddingBottom: '0.5rem' }}>PRACTICE SCRIPTS</h2>
                            {plan.segments.filter(s => s.hasScript && s.script && s.script.length > 0).map(seg => (
                                <div key={seg.id} style={{ marginBottom: '2rem', pageBreakInside: 'avoid' }}>
                                    <div style={{
                                        borderBottom: '1px solid black',
                                        marginBottom: '0.5rem',
                                        display: 'flex', justifyContent: 'space-between', alignItems: 'center'
                                    }}>
                                        <h3 style={{ margin: 0 }}>{seg.name}</h3>
                                        <div style={{ fontStyle: 'italic' }}>{seg.duration} min</div>
                                        {/* Show Coach Notes for this segment if helpful. */}
                                    </div>
                                    <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '0.8rem' }}>
                                        <thead>
                                            <tr>
                                                <th style={{ textAlign: 'left', padding: '2px', width: '30px' }}>#</th>
                                                <th style={{ textAlign: 'left', padding: '2px' }}>Hash</th>
                                                {(() => {
                                                    const preset = findPreset(seg.type, seg.situation);
                                                    const showYardLine = preset ? preset.useYardLine : seg.type === 'Take-Off';
                                                    if (showYardLine) return (
                                                        <>
                                                            <th style={{ textAlign: 'left', padding: '2px' }}>YL</th>
                                                            <th style={{ textAlign: 'left', padding: '2px' }}>Dn/Dist</th>
                                                        </>
                                                    );
                                                    if (seg.type === 'Ghost Script') return null;
                                                    return <th style={{ textAlign: 'left', padding: '2px' }}>Situation</th>;
                                                })()}
                                                <th style={{ textAlign: 'left', padding: '2px' }}>Play</th>
                                                <th style={{ textAlign: 'left', padding: '2px', width: '150px' }}>Notes</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {seg.script.map((slot, idx) => (
                                                <tr key={idx} style={{ borderBottom: '1px solid #ddd' }}>
                                                    <td style={{ padding: '2px', width: '30px' }}>{idx + 1}</td>
                                                    <td style={{ padding: '2px', width: '40px' }}>{slot.hash}</td>
                                                    {(() => {
                                                        const preset = findPreset(seg.type, seg.situation);
                                                        const showYardLine = preset ? preset.useYardLine : seg.type === 'Take-Off';
                                                        if (showYardLine) return (
                                                            <>
                                                                <td style={{ padding: '2px', width: '50px' }}>{slot.yardLine}</td>
                                                                <td style={{ padding: '2px', width: '60px' }}>{slot.downDistance}</td>
                                                            </>
                                                        );
                                                        if (seg.type === 'Ghost Script') return null;
                                                        return <td style={{ padding: '2px' }}>{slot.situation}</td>;
                                                    })()}
                                                    <td style={{ padding: '2px', fontWeight: 'bold' }}>{slot.playName}</td>
                                                    <td style={{ padding: '2px', fontSize: '0.75rem', fontStyle: 'italic', color: '#555' }}>
                                                        {(() => {
                                                            const notes = migrateScriptRowNotes(slot).notes;
                                                            if (!notes || Object.keys(notes).length === 0) return '';
                                                            return Object.entries(notes).map(([k, v]) => {
                                                                const label = k === 'ALL_COACHES' ? '' : ((staff && staff.find(s => s.id === k)?.name) || k) + ': ';
                                                                return label + v;
                                                            }).join(' | ');
                                                        })()}
                                                    </td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>
                            ))}
                        </div>
                        {/* Right: Scripts Sidebar */}
                        <GamePlannerSideMenu
                            plays={plays}
                            practicePlans={plans}
                            isOpen={showSideMenu}
                            onToggle={() => setShowSideMenu(!showSideMenu)}
                            weekStats={typeof weeks !== 'undefined' && currentWeek ? weeks.find(w => w.id === currentWeek.id) : null}
                            gamePlan={gamePlan}
                            gamePlanLayouts={gamePlanLayouts}
                            playBuckets={typeof playBuckets !== 'undefined' ? playBuckets : []}
                            playCategories={typeof playCategories !== 'undefined' ? playCategories : []}
                            onUpdatePlay={onUpdatePlay}
                            currentWeek={currentWeek}
                            onQuickAddPlay={(play) => {
                                if (selectedSegmentId && selectedSegmentId !== 'WARMUP') {
                                    const seg = plan.segments.find(s => s.id === selectedSegmentId);
                                    if (seg) {
                                        const newItem = {
                                            id: Date.now().toString(),
                                            playId: play.id,
                                            playName: play.name,
                                            concept: play.conceptFamily || '',
                                            situation: seg.situation || '',
                                            hash: '',
                                            notes: ''
                                        };
                                        const currentScript = Array.isArray(seg.script) ? seg.script : [];
                                        const newScript = [...currentScript, newItem];
                                        updateSegment(seg.id, 'script', newScript);
                                    }
                                }
                            }}
                        />
                    </div>

                    {/* Script View Modal */}
                    {showScriptView && selectedSegmentId && (
                        <div style={{
                            position: 'fixed', top: 0, left: 0, width: '100vw', height: '100vh',
                            backgroundColor: 'rgba(0,0,0,0.5)', zIndex: 10000,
                            display: 'flex', justifyContent: 'center', alignItems: 'center', backdropFilter: 'blur(2px)'
                        }}
                            onClick={() => setShowScriptView(false)}
                        >
                            <div style={{
                                width: '95%', maxWidth: '1400px', height: '90vh',
                                backgroundColor: 'var(--bg-panel)', borderRadius: 'var(--radius)',
                                display: 'flex', flexDirection: 'column', overflow: 'hidden',
                                boxShadow: '0 20px 25px -5px rgba(0,0,0,0.1)'
                            }}
                                onClick={(e) => e.stopPropagation()}
                            >
                                {/* Modal Header */}
                                <div style={{
                                    padding: '1rem', borderBottom: '1px solid var(--border)',
                                    display: 'flex', justifyContent: 'space-between', alignItems: 'center',
                                    backgroundColor: 'var(--bg-main)'
                                }}>
                                    <h3 style={{ margin: 0 }}>Scripting: {plan.segments.find(s => s.id === selectedSegmentId)?.type}</h3>
                                    <div style={{ display: 'flex', gap: '1rem' }}>
                                        <button
                                            className="btn btn-secondary"
                                            onClick={() => setShowScriptView(false)}
                                        >
                                            Close
                                        </button>
                                    </div>
                                </div>

                                {/* Modal Content */}
                                <div style={{ flex: 1, overflow: 'hidden', display: 'flex', flexDirection: 'row' }}>
                                    <div style={{ flex: 1, overflowY: 'auto', padding: '1rem' }}>
                                        {(() => {
                                            const activeSegment = plan.segments.find(s => s.id === selectedSegmentId);
                                            if (!activeSegment) return <div>Segment not found</div>;

                                            const preset = findPreset(activeSegment.type, activeSegment.situation);
                                            const showYardLine = preset ? preset.useYardLine : activeSegment.type === 'Take-Off';

                                            const updateScript = (newScript) => {
                                                updateSegment(selectedSegmentId, 'script', newScript);
                                            };



                                            // Side Panel Helper Lists
                                            // gpPlays and priorityPlays are now computed at component level to avoid Hook errors.
                                            const handleAddFromSidePanel = (item, type) => {
                                                const currentScript = [...(activeSegment.script || [])];

                                                // Find the first empty slot
                                                const emptyIndex = currentScript.findIndex(row => !row.playName && !row.playId);

                                                if (emptyIndex !== -1) {
                                                    // Fill existing slot
                                                    if (type === 'situation') {
                                                        currentScript[emptyIndex] = { ...currentScript[emptyIndex], situation: item };
                                                    } else if (type === 'play') {
                                                        currentScript[emptyIndex] = {
                                                            ...currentScript[emptyIndex],
                                                            playName: item.name,
                                                            playId: item.id
                                                        };
                                                    }
                                                } else {
                                                    // Append new row with standardized structure
                                                    const newItem = { hash: 'M', down: '', dist: '', situation: '', playName: '', playId: '', defense: '', notes: '' };

                                                    if (type === 'situation') {
                                                        newItem.situation = item;
                                                    } else if (type === 'play') {
                                                        newItem.playName = item.name;
                                                        newItem.playId = item.id;
                                                    }
                                                    currentScript.push(newItem);
                                                }

                                                updateScript(currentScript);
                                            };

                                            const handleScriptDrop = (e, idx) => {
                                                e.preventDefault();
                                                try {
                                                    const data = JSON.parse(e.dataTransfer.getData('application/react-dnd'));
                                                    if (data && (data.playId || data.name)) {
                                                        const newScript = [...activeSegment.script];
                                                        if (idx >= 0 && idx < newScript.length) {
                                                            newScript[idx] = {
                                                                ...newScript[idx],
                                                                playName: data.name || newScript[idx].playName,
                                                                playId: data.playId || ''
                                                            };
                                                            updateScript(newScript);
                                                        }
                                                    }
                                                } catch (err) {
                                                    console.error("Drop failed", err);
                                                }
                                            };

                                            // Helper to filter plays for the side panel
                                            const getSidePanelItems = () => {
                                                let items = [];
                                                if (scriptTab === 'gameplan') {
                                                    if (!selectedGamePlanSection) {
                                                        // Return list of Sections from LAYOUTS
                                                        // Items removed as requested
                                                        return [];
                                                    } else {
                                                        // Return plays in selected section
                                                        // Check if it's a Matrix Formation
                                                        const matrixFormation = gamePlanLayouts?.MATRIX?.formations?.find(f => f.id === selectedGamePlanSection);

                                                        if (matrixFormation) {
                                                            // Aggregate plays from all cells in this formation row
                                                            const playIds = new Set();
                                                            const layout = gamePlanLayouts.MATRIX;

                                                            layout.playTypes.forEach(pt => {
                                                                layout.cols.forEach(col => {
                                                                    const setId = `matrix_${matrixFormation.id}_${pt.id}_${col.id}`;
                                                                    const cellData = gamePlan?.sets?.[setId];
                                                                    if (cellData && cellData.assignedPlayIds) {
                                                                        cellData.assignedPlayIds.forEach(id => playIds.add(id));
                                                                    } else if (cellData && cellData.playIds) {
                                                                        cellData.playIds.forEach(id => playIds.add(id));
                                                                    }
                                                                });
                                                            });

                                                            items = Array.from(playIds).map(id => plays.find(p => p.id === id)).filter(Boolean);

                                                        } else {
                                                            // Standard Set/Script Lookup
                                                            // Standard Set/Script Lookup
                                                            let setData = null;
                                                            // Handle sets as Array (primary) or Object (fallback)
                                                            if (gamePlan?.sets) {
                                                                if (Array.isArray(gamePlan.sets)) {
                                                                    setData = gamePlan.sets.find(s => s.id === selectedGamePlanSection);
                                                                } else {
                                                                    setData = gamePlan.sets[selectedGamePlanSection];
                                                                }
                                                            }
                                                            // Fallback to miniScripts
                                                            if (!setData && gamePlan?.miniScripts) {
                                                                if (Array.isArray(gamePlan.miniScripts)) {
                                                                    setData = gamePlan.miniScripts.find(s => s.id === selectedGamePlanSection);
                                                                } else {
                                                                    setData = gamePlan.miniScripts[selectedGamePlanSection];
                                                                }
                                                            }

                                                            if (setData && (setData.assignedPlayIds || setData.playIds)) {
                                                                const ids = setData.assignedPlayIds || setData.playIds || [];
                                                                items = ids.map(item => {
                                                                    // Handle both string IDs and object IDs (e.g. { id: '...', tempo: '...' })
                                                                    const playId = (typeof item === 'object' && item !== null && item.id) ? item.id : item;
                                                                    return plays.find(p => p.id === playId);
                                                                }).filter(Boolean);
                                                            }
                                                        }
                                                    }
                                                } else if (scriptTab === 'bank') {
                                                    items = plays;
                                                } else if (scriptTab === 'situations') {
                                                    // Return situations based on presets
                                                    // Filter based on search
                                                    let presets = scriptPresets.map(p => ({
                                                        id: p.name,
                                                        name: p.name,
                                                        type: 'situation',
                                                        details: p
                                                    }));
                                                    if (scriptPlaySearch) {
                                                        const q = scriptPlaySearch.toLowerCase();
                                                        presets = presets.filter(p => p.name.toLowerCase().includes(q));
                                                    }
                                                    return presets;
                                                }

                                                if (scriptPlaySearch) {
                                                    const q = scriptPlaySearch.toLowerCase();
                                                    items = items.filter(p =>
                                                        p.name.toLowerCase().includes(q) ||
                                                        (p.tags && p.tags.some(t => t.toLowerCase().includes(q)))
                                                    );
                                                }
                                                return items.sort((a, b) => a.name.localeCompare(b.name));
                                            };

                                            return (
                                                <div style={{ display: 'flex', height: '100%', overflow: 'hidden' }}>
                                                    {/* Left: Script Table */}
                                                    <div style={{ flex: 1, padding: '1rem', overflowY: 'auto' }}>
                                                        <PracticeScriptTable
                                                            script={activeSegment.script || []}
                                                            onUpdateScript={updateScript}
                                                            plays={plays}
                                                            playCategories={playCategories}
                                                            isLocked={isLocked}
                                                        />
                                                    </div>


                                                </div>
                                            );
                                        })()}
                                    </div>
                                    <GamePlannerSideMenu
                                        plays={plays}
                                        practicePlans={plans}
                                        onQuickAddPlay={onQuickAddPlay}
                                        isOpen={showSideMenu}
                                        onToggle={() => setShowSideMenu(!showSideMenu)}
                                        weekStats={weekStats}
                                        gamePlan={gamePlan}
                                        gamePlanLayouts={gamePlanLayouts}
                                        playBuckets={playBuckets}
                                        playCategories={playCategories}
                                        onAddSection={handleAddSection}
                                        onUpdatePlay={onUpdatePlay}
                                        currentWeek={currentWeek}
                                    />
                                </div>
                            </div>
                        </div>

                    )}

                    {/* Modals */}
                    {notesModalSegmentId && renderNotesModal()}
                </div>
            );
        };

        const GamedayDashboard = ({ plays }) => {
            const [filters, setFilters] = useState({
                down: 'Any',
                distance: 'Any',
                fieldPos: 'Any',
                hash: 'Any'
            });

            const filteredPlays = React.useMemo(() => {
                return plays.filter(play => {
                    if (filters.down === 'Any' && filters.distance === 'Any' && filters.fieldPos === 'Any' && filters.hash === 'Any') return true;
                    let targetTags = [];
                    if (filters.down !== 'Any' && filters.distance !== 'Any') {
                        targetTags.push(`${filters.down} & ${filters.distance}`);
                    }
                    if (filters.fieldPos !== 'Any') targetTags.push(filters.fieldPos);

                    if (targetTags.length === 0) return true;
                    return targetTags.some(t => play.tags.includes(t));
                });
            }, [plays, filters]);

            return (
                <div>
                    <h2 style={{ marginBottom: '1.5rem' }}>Gameday Dashboard</h2>

                    <div className="gameday-header">
                        <div>
                            <label className="form-label">Down</label>
                            <div className="situation-toggle">
                                {['Any', '1st', '2nd', '3rd', '4th'].map(opt => (
                                    <button
                                        key={opt}
                                        className={filters.down === opt ? 'active' : ''}
                                        onClick={() => setFilters({ ...filters, down: opt })}
                                    >
                                        {opt}
                                    </button>
                                ))}
                            </div>
                        </div>
                        <div>
                            <label className="form-label">Distance</label>
                            <div className="situation-toggle">
                                {['Any', 'Short', 'Med', 'Long', 'XL'].map(opt => (
                                    <button
                                        key={opt}
                                        className={filters.distance === opt ? 'active' : ''}
                                        onClick={() => setFilters({ ...filters, distance: opt })}
                                    >
                                        {opt}
                                    </button>
                                ))}
                            </div>
                        </div>
                        <div>
                            <label className="form-label">Field Position</label>
                            <select
                                className="form-select"
                                style={{ minWidth: '200px' }}
                                value={filters.fieldPos}
                                onChange={e => setFilters({ ...filters, fieldPos: e.target.value })}
                            >
                                <option value="Any">Any</option>
                                {(TAG_CATEGORIES["Field Position"] || []).map(pos => (
                                    <option key={pos} value={pos}>{pos}</option>
                                ))}
                            </select>
                        </div>
                    </div>

                    <div style={{ marginBottom: '1rem', color: 'var(--text-secondary)' }}>
                        Found {matchingPlays.length} plays matching situation...
                    </div>

                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))', gap: '1.5rem' }}>
                        {matchingPlays.map(play => (
                            <PlayCard key={play.id} play={play} onEdit={() => { }} />
                        ))}
                    </div>
                </div>
            );
        };


        const PregameTimeline = ({ plan = {}, onUpdatePlan, teamLogo, staff, user, isLocked }) => {
            const [kickoffTime, setKickoffTime] = useState(plan?.kickoffTime || '19:00');
            const [selectedCoachFilter, setSelectedCoachFilter] = useState('ALL');
            const [selectedNotesCoach, setSelectedNotesCoach] = useState('ALL_COACHES');
            const [notesModalSegmentId, setNotesModalSegmentId] = useState(null);

            // Helper function to migrate old notes format to new format
            const migrateSegmentNotes = (segment) => {
                if (!segment.notes) {
                    return { ...segment, notes: {} };
                }
                if (typeof segment.notes === 'string') {
                    return {
                        ...segment,
                        notes: segment.notes ? { 'ALL_COACHES': segment.notes } : {}
                    };
                }
                return segment;
            };

            const updateKickoff = (time) => {
                setKickoffTime(time);
                onUpdatePlan({ ...plan, kickoffTime: time });
            };

            const addSegment = () => {
                const newSegment = {
                    id: Date.now().toString(),
                    startTime: '17:00',
                    duration: 15,
                    activity: 'New Activity',
                    location: 'Field',
                    notes: {},
                    staffId: ''
                };
                onUpdatePlan({ ...plan, segments: [...(plan.segments || []), newSegment] });
            };

            const updateSegment = (id, field, value) => {
                onUpdatePlan({
                    ...plan,
                    segments: (plan.segments || []).map(s => s.id === id ? { ...s, [field]: value } : s)
                });
            };

            // Special handler for notes to support coach-specific notes
            const updateSegmentNotes = (segmentId, coachId, noteText) => {
                const segment = (plan.segments || []).find(s => s.id === segmentId);
                if (!segment) return;

                const migratedSegment = migrateSegmentNotes(segment);
                const updatedNotes = {
                    ...migratedSegment.notes,
                    [coachId]: noteText
                };
                // If note is empty, remove the key
                if (!noteText || noteText.trim() === '') {
                    delete updatedNotes[coachId];
                }
                updateSegment(segmentId, 'notes', updatedNotes);
            };

            const deleteSegment = (id) => {
                onUpdatePlan({ ...plan, segments: (plan.segments || []).filter(s => s.id !== id) });
            };

            // Auto-calculate segment times based on duration
            useEffect(() => {
                if (!plan || !plan.segments || plan.segments.length === 0) return;

                // Sort segments by their current start time to maintain order
                const sortedSegments = [...plan.segments].sort((a, b) =>
                    (a?.startTime || '').localeCompare(b?.startTime || '')
                );

                // Calculate times starting from the first segment
                let hasChanges = false;
                const updatedSegments = plan.segments.map(seg => {
                    // Find this segment's position in the sorted array
                    const sortedIndex = sortedSegments.findIndex(s => s.id === seg.id);

                    if (sortedIndex === 0) {
                        // Keep the first segment's time as-is
                        return seg;
                    }

                    // Calculate this segment's start time based on previous segment in sorted order
                    const prevSeg = sortedSegments[sortedIndex - 1];
                    const prevStartTime = new Date(`2000-01-01T${prevSeg.startTime}`);
                    prevStartTime.setMinutes(prevStartTime.getMinutes() + parseInt(prevSeg.duration || 0));

                    const calculatedTime = prevStartTime.toTimeString().slice(0, 5); // HH:MM format

                    if (seg.startTime !== calculatedTime) {
                        hasChanges = true;
                        return { ...seg, startTime: calculatedTime };
                    }
                    return seg;
                });

                // Only update if there are actual changes to avoid infinite loop
                if (hasChanges) {
                    onUpdatePlan({ ...plan, segments: updatedSegments });
                }
            }, [JSON.stringify(plan?.segments?.map(s => ({ id: s.id, duration: s.duration, startTime: s.startTime })))]);

            const calculateTMinus = (startTime) => {
                const start = new Date(`2000-01-01T${startTime}`);
                const kick = new Date(`2000-01-01T${kickoffTime}`);
                const diff = (kick - start) / 60000; // minutes
                return diff > 0 ? `T-${diff}` : `T+${Math.abs(diff)}`;
            };

            return (
                <div style={{ display: 'flex', flexDirection: 'column', height: 'calc(100vh - 100px)' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '2rem' }}>
                        <h2>Pre-game Timeline</h2>
                        <div style={{ display: 'flex', gap: '1rem', alignItems: 'center' }}>
                            <div>
                                <label style={{ marginRight: '0.5rem', fontWeight: 'bold' }}>Kickoff:</label>
                                <input
                                    type="time"
                                    className="form-input"
                                    style={{ width: 'auto', display: 'inline-block' }}
                                    value={kickoffTime}
                                    onChange={e => updateKickoff(e.target.value)}
                                    disabled={isLocked}
                                />
                            </div>
                            <button className="btn btn-secondary" onClick={() => window.print()}>🖨️ Print</button>
                        </div>
                    </div>

                    {/* Notes Modal */}
                    {notesModalSegmentId && (
                        <NotesModal
                            segmentId={notesModalSegmentId}
                            plan={plan}
                            staff={staff}
                            onClose={() => setNotesModalSegmentId(null)}
                            onUpdateNotes={(segmentId, coachId, note) => updateSegmentNotes(segmentId, coachId, note)}
                        />
                    )}

                    {/* Coach Filter */}
                    <div style={{ display: 'flex', gap: '1rem', marginBottom: '1rem', alignItems: 'center' }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                            <label style={{ fontWeight: 'bold' }}>Notes for:</label>
                            <select
                                className="form-select"
                                style={{ width: 'auto' }}
                                value={selectedNotesCoach}
                                onChange={e => setSelectedNotesCoach(e.target.value)}
                            >
                                <option value="ALL_COACHES">All Coaches</option>
                                {staff && staff.map(s => (
                                    <option key={s.id} value={s.id}>{s.name}</option>
                                ))}
                            </select>
                        </div>
                    </div>

                    <div style={{ flex: 1, overflowY: 'auto' }}>
                        <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                            <thead>
                                <tr style={{ borderBottom: '2px solid var(--border)', textAlign: 'left', color: 'var(--text-secondary)', fontSize: '0.9rem' }}>
                                    <th style={{ padding: '0.5rem' }}>Time</th>
                                    <th style={{ padding: '0.5rem' }}>Dur</th>
                                    <th style={{ padding: '0.5rem' }}>T-Minus</th>
                                    <th style={{ padding: '0.5rem' }}>Activity</th>
                                    <th style={{ padding: '0.5rem' }}>Location</th>
                                    <th style={{ padding: '0.5rem' }}>Notes</th>
                                    <th style={{ padding: '0.5rem', textAlign: 'right' }}>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {((plan.segments || [])).filter(segment => selectedCoachFilter === 'ALL' || segment.staffId === selectedCoachFilter)
                                    .sort((a, b) => (a?.startTime || '').localeCompare(b?.startTime || ''))
                                    .map(segment => (
                                        <tr key={segment.id} style={{ borderBottom: '1px solid var(--border)' }}>
                                            <td style={{ padding: '0.5rem' }}>
                                                <input
                                                    type="time"
                                                    className="form-input"
                                                    value={segment.startTime}
                                                    onChange={e => updateSegment(segment.id, 'startTime', e.target.value)}
                                                    disabled={isLocked}
                                                />
                                            </td>
                                            <td style={{ padding: '0.5rem' }}>
                                                <input
                                                    type="number"
                                                    className="form-input"
                                                    style={{ width: '60px', padding: '0.25rem' }}
                                                    value={segment.duration || 15}
                                                    onChange={e => updateSegment(segment.id, 'duration', parseInt(e.target.value))}
                                                    disabled={isLocked}
                                                />
                                            </td>
                                            <td style={{ padding: '0.5rem', fontWeight: 'bold', color: 'var(--accent)' }}>
                                                {calculateTMinus(segment.startTime)}
                                            </td>
                                            <td style={{ padding: '0.5rem' }}>
                                                <input
                                                    type="text"
                                                    className="form-input"
                                                    value={segment.activity}
                                                    onChange={e => updateSegment(segment.id, 'activity', e.target.value)}
                                                    disabled={isLocked}
                                                />
                                            </td>
                                            <td style={{ padding: '0.5rem' }}>
                                                <input
                                                    type="text"
                                                    className="form-input"
                                                    value={segment.location}
                                                    onChange={e => updateSegment(segment.id, 'location', e.target.value)}
                                                    disabled={isLocked}
                                                />
                                            </td>
                                            <td style={{ padding: '0.5rem' }}>
                                                {(() => {
                                                    const migrated = migrateSegmentNotes(segment);
                                                    const allNotes = migrated.notes['ALL_COACHES'];
                                                    const hasAnyNotes = Object.keys(migrated.notes).some(key => migrated.notes[key]);
                                                    const displayNote = selectedNotesCoach === 'ALL_COACHES'
                                                        ? (allNotes || (hasAnyNotes ? 'View Notes...' : ''))
                                                        : (migrated.notes[selectedNotesCoach] || '');

                                                    return (
                                                        <button
                                                            className="form-input"
                                                            style={{
                                                                padding: '0.25rem 0.5rem',
                                                                textAlign: 'left',
                                                                cursor: 'pointer',
                                                                width: '100%',
                                                                backgroundColor: hasAnyNotes ? 'var(--bg-input)' : 'transparent',
                                                                border: hasAnyNotes ? '1px solid var(--accent)' : '1px solid var(--border)',
                                                                color: hasAnyNotes ? 'var(--text-primary)' : 'var(--text-secondary)',
                                                                fontStyle: hasAnyNotes ? 'normal' : 'italic',
                                                                overflow: 'hidden',
                                                                textOverflow: 'ellipsis',
                                                                whiteSpace: 'nowrap'
                                                            }}
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                setNotesModalSegmentId(segment.id);
                                                            }}
                                                        >
                                                            {hasAnyNotes
                                                                ? (displayNote || 'Click to view notes...')
                                                                : 'Click to add notes...'
                                                            }
                                                        </button>
                                                    );
                                                })()}
                                            </td>
                                            <td style={{ padding: '0.5rem', textAlign: 'right' }}>
                                                {!isLocked && (
                                                    <button className="btn" style={{ color: '#ef4444' }} onClick={() => deleteSegment(segment.id)}>
                                                        <Icon name="PlusCircle" style={{ transform: 'rotate(45deg)' }} />
                                                    </button>
                                                )}

                                                {!isLocked && (
                                                    <button
                                                        className="btn btn-secondary no-print"
                                                        style={{ marginLeft: '4px', padding: '0.25rem 0.5rem', fontSize: '0.8rem' }}
                                                        title="Insert new item below"
                                                        onClick={(e) => {
                                                            e.stopPropagation();

                                                            let nextTime = '';
                                                            if (segment.startTime) {
                                                                const [hours, minutes] = segment.startTime.split(':').map(Number);
                                                                const date = new Date();
                                                                date.setHours(hours);
                                                                date.setMinutes(minutes + (segment.duration || 15));
                                                                nextTime = date.toTimeString().slice(0, 5);
                                                            }

                                                            const newSegment = {
                                                                id: Date.now().toString(),
                                                                type: 'Pregame',
                                                                duration: 15,
                                                                startTime: nextTime,
                                                                activity: '',
                                                                location: '',
                                                                staffId: user?.id,
                                                                notes: user?.role === 'HC' ? { 'ALL_COACHES': '' } : {}
                                                            };

                                                            const newSegments = [...(plan.segments || []), newSegment];
                                                            onUpdatePlan({ ...plan, segments: newSegments });
                                                        }}
                                                    >
                                                        + Below
                                                    </button>
                                                )}
                                            </td>
                                        </tr>
                                    ))}
                            </tbody>
                        </table>

                        {!isLocked && (
                            <div style={{ marginTop: '1rem' }}>
                                <button className="btn btn-primary" onClick={addSegment}>+ Add Segment</button>
                            </div>
                        )}

                        {/* Hidden Print Container */}
                        <div className="pregame-print-container" style={{ display: 'none' }}>
                            <div className="practice-print-header">
                                <h1>Pre-game Timeline</h1>
                                <div className="practice-print-meta">
                                    <span>Kickoff: {kickoffTime}</span>
                                </div>
                            </div>

                            <table className="practice-schedule-table">
                                <thead>
                                    <tr>
                                        <th>Real Time</th>
                                        <th>Dur</th>
                                        <th>Clock</th>
                                        <th>Activity</th>
                                        <th>Location</th>
                                        <th>Staff</th>
                                        <th>Notes</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {(plan.segments || [])
                                        .sort((a, b) => (a?.startTime || '').localeCompare(b?.startTime || ''))
                                        .map(seg => (
                                            <tr key={seg.id}>
                                                <td>{seg.startTime}</td>
                                                <td>{seg.duration || 15}</td>
                                                <td style={{ fontWeight: 'bold' }}>{calculateTMinus(seg.startTime)}</td>
                                                <td>{seg.activity}</td>
                                                <td>{seg.location}</td>
                                                <td>{staff && staff.find(s => s.id === seg.staffId)?.name || ''}</td>
                                                <td>{(() => {
                                                    const migrated = migrateSegmentNotes(seg);
                                                    const notes = migrated.notes;
                                                    const allCoachesNotes = notes['ALL_COACHES'] || '';
                                                    const coachNotes = selectedCoachFilter !== 'ALL' ? (notes[selectedCoachFilter] || '') : '';

                                                    // Combine notes: All Coaches first, then coach-specific
                                                    const combined = [];
                                                    if (allCoachesNotes) combined.push(`[All] ${allCoachesNotes}`);
                                                    if (coachNotes) combined.push(coachNotes);
                                                    return combined.join(' | ');
                                                })()}</td>
                                            </tr>
                                        ))}
                                </tbody>
                            </table>
                        </div>
                    </div>

                </div>
            );
        };


        // REMOVED: PlayerProfileView and PlayerProfileGallery (~1,148 lines)
        // Available in git history for restoration

        const RosterManager = ({ roster, onUpdateRoster, depthChart }) => {
            const { isFree } = useSchoolPlan(); // School Plan Hook
            const [newPlayer, setNewPlayer] = useState({
                number: '', name: '', position: 'QB/LB', offPosition: 'QB', defPosition: 'LB', year: 'Fr', height: '', weight: '',
                helmetSize: '', shoulderPadSize: '', pantSize: '',
                injured: false, traveling: true, captain: false,
                offenseRoles: [], defenseRoles: [], specialRoles: [],
                varsity: true, jv: false, jv2: false
            });
            const [isEditing, setIsEditing] = useState(null);
            const [viewProfileId, setViewProfileId] = useState(null);
            const [showArchived, setShowArchived] = useState(false);
            const [showImportHelp, setShowImportHelp] = useState(false);
            const fileInputRef = useRef(null);

            const downloadTemplate = () => {
                const template = `Number,Name,OffPos,DefPos,Year,Height,Weight
1,John Smith,QB,LB,Sr,6'2",185
2,Mike Johnson,RB,LB,Jr,5'11",175
3,Chris Davis,WR,DB,So,6'0",170`;

                const blob = new Blob([template], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'roster_template.csv';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            };

            const handleImportClick = () => {
                if (fileInputRef.current) fileInputRef.current.click();
            };

            const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const text = event.target.result;
                    processCSV(text);
                };
                reader.readAsText(file);
                // Reset input
                e.target.value = '';
            };

            const processCSV = (csvText) => {
                // detailed parser to handle quotes
                const rows = [];
                let currentRow = [];
                let currentCell = '';
                let inQuotes = false;

                for (let i = 0; i < csvText.length; i++) {
                    const char = csvText[i];
                    const nextChar = csvText[i + 1];

                    if (char === '"') {
                        if (inQuotes && nextChar === '"') {
                            currentCell += '"';
                            i++; // skip escaped quote
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (char === ',' && !inQuotes) {
                        currentRow.push(currentCell.trim());
                        currentCell = '';
                    } else if ((char === '\r' || char === '\n') && !inQuotes) {
                        if (currentCell || currentRow.length > 0) {
                            currentRow.push(currentCell.trim());
                            rows.push(currentRow);
                        }
                        currentRow = [];
                        currentCell = '';
                        if (char === '\r' && nextChar === '\n') i++;
                    } else {
                        currentCell += char;
                    }
                }
                if (currentCell || currentRow.length > 0) {
                    currentRow.push(currentCell.trim());
                    rows.push(currentRow);
                }

                if (rows.length < 2) {
                    alert("Invalid CSV format or empty file.");
                    return;
                }

                const headers = rows[0].map(h => h.toLowerCase().replace(/[^a-z0-9]/g, ''));
                const map = {};

                // Smart Mapping
                headers.forEach((h, i) => {
                    if (['number', 'jersey', 'no', '#'].includes(h)) map.number = i;
                    if (['name', 'fullname', 'player'].includes(h)) map.name = i;
                    if (['firstname', 'first'].includes(h)) map.firstName = i;
                    if (['lastname', 'last'].includes(h)) map.lastName = i;
                    if (['position', 'pos'].includes(h)) map.pos = i;
                    if (['offpos', 'offense'].includes(h)) map.offPos = i;
                    if (['defpos', 'defense'].includes(h)) map.defPos = i;
                    if (['year', 'grade', 'class', 'yr', 'gr'].includes(h)) map.year = i;
                    if (['height', 'ht'].includes(h)) map.height = i;
                    if (['weight', 'wt'].includes(h)) map.weight = i;
                });

                if (map.name === undefined && (map.firstName === undefined || map.lastName === undefined)) {
                    alert("Could not detect Name column. Please ensure header contains 'Name' or 'First Name'/'Last Name'.");
                    return;
                }

                const newPlayers = rows.slice(1).map(row => {
                    const p = {};

                    // Number
                    p.number = map.number !== undefined ? row[map.number] : '';

                    // Name
                    if (map.name !== undefined) p.name = row[map.name];
                    else if (map.firstName !== undefined && map.lastName !== undefined) {
                        p.name = `${row[map.firstName]} ${row[map.lastName]}`;
                    }

                    // Parse Name if strictly Last, First? (Simple check)
                    if (p.name && p.name.includes(',')) {
                        const parts = p.name.split(',');
                        if (parts.length === 2) p.name = `${parts[1].trim()} ${parts[0].trim()}`;
                    }

                    // Position
                    let offPos = 'NA';
                    let defPos = 'NA';

                    if (map.offPos !== undefined) offPos = row[map.offPos] || 'NA';
                    if (map.defPos !== undefined) defPos = row[map.defPos] || 'NA';

                    if (map.pos !== undefined) {
                        // Try to split generic 'QB/LB'
                        const rawPos = row[map.pos] || '';
                        if (rawPos.includes('/')) {
                            const parts = rawPos.split('/');
                            offPos = parts[0].trim();
                            defPos = parts[1].trim();
                        } else {
                            // Assign to Offense by default if known offense pos, else defense
                            if (['QB', 'RB', 'WR', 'TE', 'OL', 'T', 'G', 'C'].includes(rawPos)) offPos = rawPos;
                            else if (['DL', 'DE', 'DT', 'LB', 'CB', 'S', 'DB', 'SS', 'FS'].includes(rawPos)) defPos = rawPos;
                            else offPos = rawPos; // Fallback
                        }
                    }

                    p.offPosition = offPos;
                    p.defPosition = defPos;
                    p.position = `${offPos}/${defPos}`;

                    // Year
                    let rawYear = map.year !== undefined ? row[map.year] : 'Fr';
                    // Normalize Year
                    if (rawYear.toUpperCase() === 'SR' || rawYear === '12') p.year = 'Sr';
                    else if (rawYear.toUpperCase() === 'JR' || rawYear === '11') p.year = 'Jr';
                    else if (rawYear.toUpperCase() === 'SO' || rawYear === '10') p.year = 'So';
                    else if (rawYear.toUpperCase() === 'FR' || rawYear === '9') p.year = 'Fr';
                    else p.year = rawYear;

                    // Height/Weight
                    p.height = map.height !== undefined ? row[map.height] : '';
                    p.weight = map.weight !== undefined ? row[map.weight] : '';

                    // Defaults
                    p.id = 'import_' + Date.now() + Math.random().toString(36).substr(2, 9);
                    p.active = true;
                    p.archived = false;

                    // Init structures
                    p.profile = { favorites: {}, goals: {} };
                    p.metrics = { attendanceStreak: 0, awards: [] };

                    return p;
                }).filter(p => p.name); // valid players only

                if (confirm(`Found ${newPlayers.length} players. Import them to roster?`)) {
                    // Check for existing numbers to avoid total duplicates? 
                    // For now, simple append or maybe filter by existing number?
                    // Let's Append but warn logic is typically preferred.
                    // The user usually wants to bulk add.
                    onUpdateRoster([...roster, ...newPlayers]);
                    alert("Import successful!");
                }
            };



            const positions = ['QB', 'RB', 'WR', 'TE', 'OL', 'OT', 'OG', 'C', 'DE', 'DT', 'LB', 'CB', 'S', 'K', 'P', 'LS']; // Expanded primary list
            // Filter by Staff ID / Current User Roles
            // In Person-Centric view, we show tasks assigned to ANY of the user's roles.
            // const [selectedRole, setSelectedRole] = useState('ALL'); // Deprecated role selector
            const years = ['Fr', 'So', 'Jr', 'Sr'];

            const OFFENSE_TAGS = ['QB', 'RB', 'WR', 'TE', 'OL'];
            const DEFENSE_TAGS = ['DL', 'LB', 'DB'];
            const SPECIAL_TAGS = ['K', 'P', 'LS', 'H', 'KR', 'PR'];

            const toggleTag = (category, tag) => {
                setNewPlayer(prev => {
                    const current = prev[category];
                    if (current.includes(tag)) {
                        return { ...prev, [category]: current.filter(t => t !== tag) };
                    } else {
                        return { ...prev, [category]: [...current, tag] };
                    }
                });
            };

            const addPlayer = () => {
                // Free Plan Guardrail
                if (isFree && roster.length >= 50) {
                    alert("Free Plan Limit Reached (50 Players). Upgrade to Premium to add more players.");
                    return;
                }

                if (!newPlayer.number || !newPlayer.name) return;
                const position = `${newPlayer.offPosition}/${newPlayer.defPosition}`;
                onUpdateRoster([...roster, { ...newPlayer, position, id: Date.now().toString() }]);
                setNewPlayer({
                    number: '', name: '', position: 'QB/LB', offPosition: 'QB', defPosition: 'LB', year: 'Fr', height: '', weight: '',
                    helmetSize: '', shoulderPadSize: '', pantSize: '',
                    injured: false, traveling: true, captain: false,
                    offenseRoles: [], defenseRoles: [], specialRoles: [],
                    varsity: true, jv: false, jv2: false
                });
            };

            const updatePlayer = (id, field, value) => {
                // If updating off/def pos, also update the combined string for compat
                let updatedPlayer = roster.find(p => p.id === id);
                if (field === 'offPosition') {
                    const newPos = `${value}/${updatedPlayer.defPosition || 'NA'}`;
                    onUpdateRoster(roster.map(p => p.id === id ? { ...p, [field]: value, position: newPos } : p));
                } else if (field === 'defPosition') {
                    const newPos = `${updatedPlayer.offPosition || 'NA'}/${value}`;
                    onUpdateRoster(roster.map(p => p.id === id ? { ...p, [field]: value, position: newPos } : p));
                } else {
                    onUpdateRoster(roster.map(p => p.id === id ? { ...p, [field]: value } : p));
                }
            };

            const archivePlayer = (id) => {
                if (window.confirm("Are you sure you want to archive this player? They will be hidden from the active roster but can be restored.")) {
                    onUpdateRoster(roster.map(p => p.id === id ? { ...p, archived: true } : p));
                }
            };

            const restorePlayer = (id) => {
                onUpdateRoster(roster.map(p => p.id === id ? { ...p, archived: false } : p));
            };

            const deletePlayer = (id) => {
                if (window.confirm("PERMANENT DELETE: This cannot be undone. Are you sure?")) {
                    onUpdateRoster(roster.filter(p => p.id !== id));
                }
            };





            // Sort by number
            // Sort by number and filter
            const visibleRoster = roster.filter(p => showArchived ? p.archived : !p.archived);
            const sortedRoster = [...visibleRoster].sort((a, b) => parseInt(a.number) - parseInt(b.number));

            return (
                <div style={{ height: 'calc(100vh - 100px)', display: 'flex', flexDirection: 'column' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '2rem' }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                            <h2>Roster Management</h2>
                        </div>
                        <div style={{ display: 'flex', gap: '1rem' }}>

                            <button className={`btn ${showArchived ? 'btn-danger' : 'btn-secondary'}`} onClick={() => setShowArchived(!showArchived)}>
                                {showArchived ? 'Back to Active Roster' : 'View Archive'}
                            </button>
                            <button className="btn btn-secondary" onClick={downloadTemplate} title="Download CSV Template">
                                <Icon name="Download" size={16} /> Download Template
                            </button>
                            <button className="btn btn-secondary" onClick={handleImportClick}>
                                <Icon name="Upload" size={16} /> Import CSV
                            </button>
                            <button className="btn btn-secondary" onClick={() => setShowImportHelp(true)} title="How to import roster">
                                <Icon name="HelpCircle" size={16} />
                            </button>
                            <input
                                type="file"
                                ref={fileInputRef}
                                style={{ display: 'none' }}
                                accept=".csv"
                                onChange={handleFileChange}
                            />
                            <button className="btn btn-secondary" onClick={() => window.print()}>🖨️ Print Attendance</button>
                        </div>
                    </div>

                    <div className="card" style={{ marginBottom: '2rem', border: showArchived ? '2px dashed #f59e0b' : '1px solid var(--border)' }}>
                        {showArchived && <div style={{ marginBottom: '1rem', color: '#f59e0b', fontWeight: 'bold' }}>⚠️ VIEWING ARCHIVED PLAYERS</div>}
                        {!showArchived && (
                            <>
                                <h4 style={{ marginBottom: '1rem', borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem' }}>Add New Athlete</h4>

                                {/* Row 1: Basic Info */}
                                <div style={{ display: 'flex', gap: '1rem', marginBottom: '1rem' }}>
                                    <div style={{ width: '80px' }}>
                                        <label className="form-label">#</label>
                                        <input type="number" className="form-input" value={newPlayer.number} onChange={e => setNewPlayer({ ...newPlayer, number: e.target.value })} placeholder="#" />
                                    </div>
                                    <div style={{ flex: 2 }}>
                                        <label className="form-label">Name</label>
                                        <input type="text" className="form-input" value={newPlayer.name} onChange={e => setNewPlayer({ ...newPlayer, name: e.target.value })} placeholder="Player Name" />
                                    </div>
                                    <div style={{ flex: 1 }}>
                                        <label className="form-label">Off Pos</label>
                                        <select className="form-select" value={newPlayer.offPosition} onChange={e => setNewPlayer({ ...newPlayer, offPosition: e.target.value })}>
                                            <option value="NA">--</option>
                                            {positions.map(p => <option key={p}>{p}</option>)}
                                        </select>
                                    </div>
                                    <div style={{ flex: 1 }}>
                                        <label className="form-label">Def Pos</label>
                                        <select className="form-select" value={newPlayer.defPosition} onChange={e => setNewPlayer({ ...newPlayer, defPosition: e.target.value })}>
                                            <option value="NA">--</option>
                                            {positions.map(p => <option key={p}>{p}</option>)}
                                        </select>
                                    </div>
                                    <div style={{ flex: 1 }}>
                                        <label className="form-label">Year</label>
                                        <select className="form-select" value={newPlayer.year} onChange={e => setNewPlayer({ ...newPlayer, year: e.target.value })}>
                                            {years.map(y => <option key={y}>{y}</option>)}
                                        </select>
                                    </div>
                                    <div style={{ width: '80px' }}>
                                        <label className="form-label">Ht</label>
                                        <input type="text" className="form-input" value={newPlayer.height} onChange={e => setNewPlayer({ ...newPlayer, height: e.target.value })} placeholder="6'2" />
                                    </div>
                                    <div style={{ width: '80px' }}>
                                        <label className="form-label">Wt</label>
                                        <input type="text" className="form-input" value={newPlayer.weight} onChange={e => setNewPlayer({ ...newPlayer, weight: e.target.value })} placeholder="210" />
                                    </div>
                                </div>

                                {/* Row 1.5: Equipment Sizes */}
                                <div style={{ display: 'flex', gap: '1rem', marginBottom: '1rem' }}>
                                    <div style={{ flex: 1 }}>
                                        <label className="form-label">Helmet Size</label>
                                        <select className="form-select" value={newPlayer.helmetSize} onChange={e => setNewPlayer({ ...newPlayer, helmetSize: e.target.value })}>
                                            <option value="">Select...</option>
                                            {['S', 'M', 'L', 'XL', '2XL'].map(s => <option key={s}>{s}</option>)}
                                        </select>
                                    </div>
                                    <div style={{ flex: 1 }}>
                                        <label className="form-label">Shoulder Pad</label>
                                        <select className="form-select" value={newPlayer.shoulderPadSize} onChange={e => setNewPlayer({ ...newPlayer, shoulderPadSize: e.target.value })}>
                                            <option value="">Select...</option>
                                            {['S', 'M', 'L', 'XL', '2XL', '3XL'].map(s => <option key={s}>{s}</option>)}
                                        </select>
                                    </div>
                                    <div style={{ flex: 1 }}>
                                        <label className="form-label">Pant Size</label>
                                        <select className="form-select" value={newPlayer.pantSize} onChange={e => setNewPlayer({ ...newPlayer, pantSize: e.target.value })}>
                                            <option value="">Select...</option>
                                            {['S', 'M', 'L', 'XL', '2XL', '3XL'].map(s => <option key={s}>{s}</option>)}
                                        </select>
                                    </div>
                                </div>

                                {/* Row 2: Tagging */}
                                <div style={{ display: 'flex', gap: '2rem', marginBottom: '1rem', flexWrap: 'wrap' }}>
                                    <div style={{ flex: 1, minWidth: '200px' }}>
                                        <label className="form-label" style={{ color: 'var(--accent)' }}>Offense Roles</label>
                                        <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                                            {OFFENSE_TAGS.map(tag => (
                                                <label key={tag} style={{ display: 'flex', alignItems: 'center', gap: '4px', fontSize: '0.85rem', cursor: 'pointer', background: newPlayer.offenseRoles.includes(tag) ? 'var(--highlight)' : 'rgba(255,255,255,0.05)', padding: '4px 8px', borderRadius: '4px', border: newPlayer.offenseRoles.includes(tag) ? '1px solid var(--accent)' : '1px solid transparent' }}>
                                                    <input type="checkbox" checked={newPlayer.offenseRoles.includes(tag)} onChange={() => toggleTag('offenseRoles', tag)} style={{ display: 'none' }} />
                                                    {tag}
                                                </label>
                                            ))}
                                        </div>
                                    </div>
                                    <div style={{ flex: 1, minWidth: '200px' }}>
                                        <label className="form-label" style={{ color: 'var(--accent)' }}>Defense Roles</label>
                                        <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                                            {DEFENSE_TAGS.map(tag => (
                                                <label key={tag} style={{ display: 'flex', alignItems: 'center', gap: '4px', fontSize: '0.85rem', cursor: 'pointer', background: newPlayer.defenseRoles.includes(tag) ? 'var(--highlight)' : 'rgba(255,255,255,0.05)', padding: '4px 8px', borderRadius: '4px', border: newPlayer.defenseRoles.includes(tag) ? '1px solid var(--accent)' : '1px solid transparent' }}>
                                                    <input type="checkbox" checked={newPlayer.defenseRoles.includes(tag)} onChange={() => toggleTag('defenseRoles', tag)} style={{ display: 'none' }} />
                                                    {tag}
                                                </label>
                                            ))}
                                        </div>
                                    </div>
                                    <div style={{ flex: 1, minWidth: '200px' }}>
                                        <label className="form-label" style={{ color: 'var(--accent)' }}>Special Teams</label>
                                        <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                                            {SPECIAL_TAGS.map(tag => (
                                                <label key={tag} style={{ display: 'flex', alignItems: 'center', gap: '4px', fontSize: '0.85rem', cursor: 'pointer', background: newPlayer.specialRoles.includes(tag) ? 'var(--highlight)' : 'rgba(255,255,255,0.05)', padding: '4px 8px', borderRadius: '4px', border: newPlayer.specialRoles.includes(tag) ? '1px solid var(--accent)' : '1px solid transparent' }}>
                                                    <input type="checkbox" checked={newPlayer.specialRoles.includes(tag)} onChange={() => toggleTag('specialRoles', tag)} style={{ display: 'none' }} />
                                                    {tag}
                                                </label>
                                            ))}
                                        </div>
                                    </div>
                                </div>

                                {/* Row 3: Actions */}
                                <div style={{ display: 'flex', justifyContent: 'flex-end', alignItems: 'center', gap: '1rem', borderTop: '1px solid var(--border)', paddingTop: '1rem' }}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '1rem', marginRight: 'auto' }}>
                                        <label style={{ fontWeight: 'bold', color: 'var(--text-secondary)' }}>Squads:</label>
                                        <label style={{ display: 'flex', alignItems: 'center', gap: '4px', cursor: 'pointer' }}>
                                            <input type="checkbox" checked={newPlayer.varsity} onChange={e => setNewPlayer({ ...newPlayer, varsity: e.target.checked })} style={{ width: '16px', height: '16px', accentColor: 'var(--accent)' }} /> Var
                                        </label>
                                        <label style={{ display: 'flex', alignItems: 'center', gap: '4px', cursor: 'pointer' }}>
                                            <input type="checkbox" checked={newPlayer.jv} onChange={e => setNewPlayer({ ...newPlayer, jv: e.target.checked })} style={{ width: '16px', height: '16px', accentColor: 'var(--accent)' }} /> JV
                                        </label>
                                        <label style={{ display: 'flex', alignItems: 'center', gap: '4px', cursor: 'pointer' }}>
                                            <input type="checkbox" checked={newPlayer.jv2} onChange={e => setNewPlayer({ ...newPlayer, jv2: e.target.checked })} style={{ width: '16px', height: '16px', accentColor: 'var(--accent)' }} /> JV2
                                        </label>
                                    </div>

                                    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                        <input type="checkbox" checked={newPlayer.captain} onChange={e => setNewPlayer({ ...newPlayer, captain: e.target.checked })} style={{ width: '18px', height: '18px', accentColor: 'var(--accent)' }} />
                                        <label>Team Captain</label>
                                    </div>
                                    <button className="btn btn-primary" onClick={addPlayer}>
                                        <Icon name="PlusCircle" /> Add Athlete
                                    </button>
                                </div>
                            </>
                        )}
                    </div>

                    <div style={{ flex: 1, overflowY: 'auto' }}>
                        <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                            <thead>
                                <tr style={{ borderBottom: '2px solid var(--border)', textAlign: 'left', color: 'var(--text-secondary)', fontSize: '0.9rem' }}>
                                    <th style={{ padding: '0.5rem' }}>#</th>
                                    <th style={{ padding: '0.5rem' }}>Name</th>
                                    <th style={{ padding: '0.5rem' }}>Pos (Off/Def)</th>
                                    <th style={{ padding: '0.5rem' }}>Roles / Tags</th>
                                    <th style={{ padding: '0.5rem' }}>Year</th>
                                    <th style={{ padding: '0.5rem' }}>Ht</th>
                                    <th style={{ padding: '0.5rem' }}>Ht</th>
                                    <th style={{ padding: '0.5rem' }}>Wt</th>
                                    <th style={{ padding: '0.5rem' }}>Equipment</th>
                                    <th style={{ padding: '0.5rem', textAlign: 'center' }}>V</th>
                                    <th style={{ padding: '0.5rem', textAlign: 'center' }}>JV</th>
                                    <th style={{ padding: '0.5rem', textAlign: 'center' }}>J2</th>
                                    <th style={{ padding: '0.5rem', textAlign: 'center' }}>Cpt</th>
                                    <th style={{ padding: '0.5rem', textAlign: 'center' }}>Traveling</th>
                                    <th style={{ padding: '0.5rem', textAlign: 'center' }}>Load</th>
                                    <th style={{ padding: '0.5rem', textAlign: 'right' }}>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {sortedRoster.map(player => (
                                    <tr key={player.id} style={{ borderBottom: '1px solid var(--border)' }}>
                                        <td style={{ padding: '0.75rem 0.5rem', fontWeight: 'bold', color: 'var(--accent)' }}>
                                            {isEditing === player.id ? (
                                                <input
                                                    type="number"
                                                    className="form-input"
                                                    style={{ width: '50px' }}
                                                    value={player.number}
                                                    onChange={e => updatePlayer(player.id, 'number', e.target.value)}
                                                />
                                            ) : `#${player.number}`}
                                        </td>
                                        <td style={{ padding: '0.75rem 0.5rem', fontWeight: 'bold' }}>
                                            {isEditing === player.id ? (
                                                <input
                                                    type="text"
                                                    className="form-input"
                                                    value={player.name}
                                                    onChange={e => updatePlayer(player.id, 'name', e.target.value)}
                                                />
                                            ) : (
                                                <span>
                                                    {player.name}
                                                    {player.captain && <span style={{ marginLeft: '0.5rem', fontSize: '0.8rem' }}>©️</span>}
                                                </span>
                                            )}
                                        </td>
                                        <td style={{ padding: '0.75rem 0.5rem' }}>
                                            {isEditing === player.id ? (
                                                <div style={{ display: 'flex', gap: '4px', flexDirection: 'column' }}>
                                                    <select
                                                        className="form-select"
                                                        style={{ padding: '2px', fontSize: '0.8rem' }}
                                                        value={player.offPosition || 'NA'}
                                                        onChange={e => updatePlayer(player.id, 'offPosition', e.target.value)}
                                                    >
                                                        <option value="NA">--</option>
                                                        {positions.map(p => <option key={p}>{p}</option>)}
                                                    </select>
                                                    <select
                                                        className="form-select"
                                                        style={{ padding: '2px', fontSize: '0.8rem' }}
                                                        value={player.defPosition || 'NA'}
                                                        onChange={e => updatePlayer(player.id, 'defPosition', e.target.value)}
                                                    >
                                                        <option value="NA">--</option>
                                                        {positions.map(p => <option key={p}>{p}</option>)}
                                                    </select>
                                                </div>
                                            ) : (
                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '2px' }}>
                                                    <span style={{ fontWeight: 'bold', color: 'var(--text-primary)' }}>{player.offPosition}</span>
                                                    <span style={{ color: 'var(--text-secondary)', fontSize: '0.85rem' }}>{player.defPosition}</span>
                                                </div>
                                            )}
                                        </td>
                                        <td style={{ padding: '0.75rem 0.5rem' }}>
                                            <div style={{ display: 'flex', gap: '4px', flexWrap: 'wrap' }}>
                                                {(player.offenseRoles || []).map(t => (
                                                    <span key={t} style={{ fontSize: '0.7rem', background: 'rgba(255,255,255,0.1)', padding: '2px 6px', borderRadius: '4px' }}>{t}</span>
                                                ))}
                                                {(player.defenseRoles || []).map(t => (
                                                    <span key={t} style={{ fontSize: '0.7rem', background: 'rgba(239, 68, 68, 0.2)', padding: '2px 6px', borderRadius: '4px', color: '#fca5a5' }}>{t}</span>
                                                ))}
                                                {(player.specialRoles || []).map(t => (
                                                    <span key={t} style={{ fontSize: '0.7rem', background: 'rgba(59, 130, 246, 0.2)', padding: '2px 6px', borderRadius: '4px', color: '#93c5fd' }}>{t}</span>
                                                ))}
                                            </div>
                                        </td>
                                        <td style={{ padding: '0.75rem 0.5rem' }}>
                                            {isEditing === player.id ? (
                                                <select
                                                    className="form-select"
                                                    value={player.year}
                                                    onChange={e => updatePlayer(player.id, 'year', e.target.value)}
                                                >
                                                    {years.map(y => <option key={y}>{y}</option>)}
                                                </select>
                                            ) : player.year}
                                        </td>
                                        <td style={{ padding: '0.75rem 0.5rem' }}>
                                            {isEditing === player.id ? (
                                                <input
                                                    type="text"
                                                    className="form-input"
                                                    style={{ width: '60px' }}
                                                    value={player.height || ''}
                                                    onChange={e => updatePlayer(player.id, 'height', e.target.value)}
                                                />
                                            ) : player.height}
                                        </td>
                                        <td style={{ padding: '0.75rem 0.5rem' }}>
                                            {isEditing === player.id ? (
                                                <input
                                                    type="text"
                                                    className="form-input"
                                                    style={{ width: '60px' }}
                                                    value={player.weight || ''}
                                                    onChange={e => updatePlayer(player.id, 'weight', e.target.value)}
                                                />
                                            ) : player.weight}
                                        </td>
                                        <td style={{ padding: '0.75rem 0.5rem', fontSize: '0.85rem' }}>
                                            {isEditing === player.id ? (
                                                <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center' }}>
                                                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
                                                        <span style={{ fontSize: '0.6rem', color: 'var(--text-secondary)' }}>H</span>
                                                        <select className="form-select" style={{ padding: '2px', width: '50px' }} value={player.helmetSize || ''} onChange={e => updatePlayer(player.id, 'helmetSize', e.target.value)}>
                                                            <option value="">-</option>
                                                            {['S', 'M', 'L', 'XL', '2XL'].map(s => <option key={s} value={s}>{s}</option>)}
                                                        </select>
                                                    </div>
                                                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
                                                        <span style={{ fontSize: '0.6rem', color: 'var(--text-secondary)' }}>Pd</span>
                                                        <select className="form-select" style={{ padding: '2px', width: '50px' }} value={player.shoulderPadSize || ''} onChange={e => updatePlayer(player.id, 'shoulderPadSize', e.target.value)}>
                                                            <option value="">-</option>
                                                            {['S', 'M', 'L', 'XL', '2XL', '3XL'].map(s => <option key={s} value={s}>{s}</option>)}
                                                        </select>
                                                    </div>
                                                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
                                                        <span style={{ fontSize: '0.6rem', color: 'var(--text-secondary)' }}>Pt</span>
                                                        <select className="form-select" style={{ padding: '2px', width: '50px' }} value={player.pantSize || ''} onChange={e => updatePlayer(player.id, 'pantSize', e.target.value)}>
                                                            <option value="">-</option>
                                                            {['S', 'M', 'L', 'XL', '2XL', '3XL'].map(s => <option key={s} value={s}>{s}</option>)}
                                                        </select>
                                                    </div>
                                                </div>
                                            ) : (
                                                <div style={{ color: 'var(--text-secondary)', display: 'flex', gap: '0.5rem', fontSize: '0.8rem' }}>
                                                    <div title="Helmet">H: <span style={{ color: 'var(--text-primary)', fontWeight: 'bold' }}>{player.helmetSize || '-'}</span></div>
                                                    <div title="Pads">P: <span style={{ color: 'var(--text-primary)', fontWeight: 'bold' }}>{player.shoulderPadSize || '-'}</span></div>
                                                    <div title="Pants">Pa: <span style={{ color: 'var(--text-primary)', fontWeight: 'bold' }}>{player.pantSize || '-'}</span></div>
                                                </div>
                                            )}
                                        </td>
                                        <td style={{ padding: '0.75rem 0.5rem', textAlign: 'center' }}>
                                            <input type="checkbox" checked={player.varsity || false} onChange={e => updatePlayer(player.id, 'varsity', e.target.checked)} style={{ width: '16px', height: '16px', accentColor: 'var(--accent)' }} />
                                        </td>
                                        <td style={{ padding: '0.75rem 0.5rem', textAlign: 'center' }}>
                                            <input type="checkbox" checked={player.jv || false} onChange={e => updatePlayer(player.id, 'jv', e.target.checked)} style={{ width: '16px', height: '16px', accentColor: 'var(--accent)' }} />
                                        </td>
                                        <td style={{ padding: '0.75rem 0.5rem', textAlign: 'center' }}>
                                            <input type="checkbox" checked={player.jv2 || false} onChange={e => updatePlayer(player.id, 'jv2', e.target.checked)} style={{ width: '16px', height: '16px', accentColor: 'var(--accent)' }} />
                                        </td>
                                        <td style={{ padding: '0.75rem 0.5rem', textAlign: 'center' }}>
                                            <input
                                                type="checkbox"
                                                checked={player.captain || false}
                                                onChange={e => updatePlayer(player.id, 'captain', e.target.checked)}
                                                style={{ width: '18px', height: '18px', accentColor: 'var(--accent)' }}
                                            />
                                        </td>
                                        <td style={{ padding: '0.75rem 0.5rem', textAlign: 'center' }}>
                                            <input
                                                type="checkbox"
                                                checked={player.traveling}
                                                onChange={e => updatePlayer(player.id, 'traveling', e.target.checked)}
                                            />
                                        </td>

                                        {/* Load Column */}
                                        <td style={{ padding: '0.75rem 0.5rem', textAlign: 'center' }}>
                                            {(() => {
                                                const { totalScore } = calculatePlayerLoad(player.id, depthChart);
                                                let color = '#10b981'; // Green
                                                if (totalScore >= 9) color = '#ef4444'; // Red
                                                else if (totalScore >= 6) color = '#eab308'; // Yellow

                                                return (
                                                    <span style={{
                                                        background: color,
                                                        color: '#fff',
                                                        padding: '2px 8px',
                                                        borderRadius: '12px',
                                                        fontSize: '0.8rem',
                                                        fontWeight: 'bold'
                                                    }}>
                                                        {totalScore}
                                                    </span>
                                                );
                                            })()}
                                        </td>
                                        <td style={{ padding: '0.75rem 1rem', textAlign: 'right' }}>
                                            {isEditing === player.id ? (
                                                <button className="btn btn-primary" style={{ padding: '0.25rem 0.75rem', fontSize: '0.8rem' }} onClick={() => setIsEditing(null)}>Done</button>
                                            ) : (
                                                <div style={{ display: 'flex', gap: '0.5rem', justifyContent: 'flex-end' }}>
                                                    <button className="btn btn-secondary" style={{ padding: '0.25rem 0.5rem', fontSize: '0.8rem' }} onClick={() => setIsEditing(player.id)}>Edit</button>
                                                    {showArchived ? (
                                                        <>
                                                            <button className="btn" style={{ padding: '0.25rem 0.5rem', fontSize: '0.8rem', backgroundColor: '#10b981', color: '#fff', border: 'none' }} onClick={() => restorePlayer(player.id)}>Restore</button>
                                                            <button className="btn" style={{ padding: '0.25rem 0.5rem', fontSize: '0.8rem', color: '#ef4444' }} onClick={() => deletePlayer(player.id)}>Delete</button>
                                                        </>
                                                    ) : (
                                                        <button className="btn" style={{ padding: '0.25rem 0.5rem', fontSize: '0.8rem', backgroundColor: 'transparent', border: '1px solid #f59e0b', color: '#f59e0b' }} onClick={() => archivePlayer(player.id)}>Archive</button>
                                                    )}
                                                </div>
                                            )}
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>

                    {/* Import Help Modal */}
                    {showImportHelp && (
                        <div className="modal-overlay" onClick={() => setShowImportHelp(false)}>
                            <div className="modal-content" onClick={e => e.stopPropagation()} style={{ maxWidth: '700px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                                    <h3 style={{ margin: 0 }}>📋 How to Import Your Roster</h3>
                                    <button onClick={() => setShowImportHelp(false)} style={{ background: 'none', border: 'none', fontSize: '1.5rem', cursor: 'pointer', color: 'var(--text-secondary)' }}>×</button>
                                </div>

                                <div style={{ marginBottom: '1.5rem' }}>
                                    <h4 style={{ color: 'var(--accent)', marginBottom: '0.75rem' }}>Step 1: Download the Template</h4>
                                    <p style={{ marginBottom: '0.5rem' }}>Click the <strong>"Download Template"</strong> button to get a sample CSV file with the correct format.</p>
                                </div>

                                <div style={{ marginBottom: '1.5rem' }}>
                                    <h4 style={{ color: 'var(--accent)', marginBottom: '0.75rem' }}>Step 2: Fill in Your Data</h4>
                                    <p style={{ marginBottom: '0.5rem' }}>Open the template in Excel, Google Sheets, or any spreadsheet program and fill in your roster data.</p>

                                    <div style={{ marginTop: '1rem' }}>
                                        <div style={{ marginBottom: '0.5rem', fontWeight: 'bold' }}>Expected Spreadsheet Columns:</div>
                                        <div style={{
                                            display: 'flex',
                                            overflowX: 'auto',
                                            border: '1px solid var(--border)',
                                            borderRadius: '6px',
                                            background: 'white',
                                            boxShadow: 'inset 0 2px 4px rgba(0,0,0,0.05)'
                                        }}>
                                            {[
                                                { header: 'Number', alias: 'Jersey, #, No', example: '12' },
                                                { header: 'Name', alias: 'Full Name, Player', example: 'John Doe' },
                                                { header: 'OffPos', alias: 'Offense', example: 'QB' },
                                                { header: 'DefPos', alias: 'Defense', example: 'LB' },
                                                { header: 'Year', alias: 'Grade, Class, Yr', example: 'Fr, 9' },
                                                { header: 'Height', alias: 'Ht', example: '6\'2"' },
                                                { header: 'Weight', alias: 'Wt', example: '185' },
                                            ].map((col, idx) => (
                                                <div key={idx} style={{
                                                    minWidth: '130px',
                                                    flexShrink: 0,
                                                    borderRight: '1px solid var(--border)',
                                                    display: 'flex',
                                                    flexDirection: 'column'
                                                }}>
                                                    {/* Header Cell */}
                                                    <div style={{
                                                        background: '#f8fafc',
                                                        padding: '8px',
                                                        borderBottom: '1px solid var(--border)',
                                                        fontWeight: 'bold',
                                                        textAlign: 'center',
                                                        color: '#334155',
                                                        fontSize: '0.9rem'
                                                    }}>
                                                        {col.header}
                                                    </div>
                                                    {/* Body Cell */}
                                                    <div style={{ padding: '8px', fontSize: '0.8rem', flex: 1, display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                                        <div style={{ color: 'var(--text-secondary)' }}>
                                                            <span style={{ fontSize: '0.7rem', textTransform: 'uppercase', opacity: 0.7 }}>Accepts:</span><br />
                                                            {col.alias}
                                                        </div>
                                                        <div style={{ marginTop: 'auto', paddingTop: '4px', borderTop: '1px dashed var(--border)', color: 'var(--accent)', fontFamily: 'monospace' }}>
                                                            Ex: {col.example}
                                                        </div>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                        <div style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', marginTop: '4px', textAlign: 'right', fontStyle: 'italic' }}>
                                            Scroll horizontally to see more labels &rarr;
                                        </div>
                                    </div>
                                </div>

                                <div style={{ marginBottom: '1.5rem' }}>
                                    <h4 style={{ color: 'var(--accent)', marginBottom: '0.75rem' }}>Step 3: Save as CSV</h4>
                                    <p style={{ marginBottom: '0.5rem' }}>Save your file as a <strong>.csv</strong> (Comma Separated Values) file.</p>
                                    <p style={{ fontSize: '0.9rem', color: 'var(--text-secondary)' }}>In Excel: File → Save As → Choose "CSV (Comma delimited)"</p>
                                </div>

                                <div style={{ marginBottom: '1.5rem' }}>
                                    <h4 style={{ color: 'var(--accent)', marginBottom: '0.75rem' }}>Step 4: Import</h4>
                                    <p style={{ marginBottom: '0.5rem' }}>Click <strong>"Import CSV"</strong> and select your file. The system will automatically map the columns and import your players!</p>
                                </div>

                                <div style={{ background: '#dbeafe', border: '1px solid #3b82f6', borderRadius: '8px', padding: '1rem', marginTop: '1.5rem' }}>
                                    <strong style={{ color: '#1e40af' }}>💡 Pro Tip:</strong>
                                    <p style={{ margin: '0.5rem 0 0 0', color: '#1e3a8a' }}>The importer is smart! It will recognize common column names even if they don't match exactly. Just make sure you have at least a Name column (or First Name + Last Name).</p>
                                </div>

                                <div style={{ marginTop: '1.5rem', textAlign: 'right' }}>
                                    <button className="btn btn-primary" onClick={() => setShowImportHelp(false)}>Got it!</button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };





        const DUTY_CATEGORIES = {
            "Leadership": [
                "Assistant Head Coach", "Director of Football Operations", "Strength & Cond Coordinator",
                "Defensive Coordinator", "Offensive Coordinator", "Special Teams Coordinator",
                "Technology Coordinator", "Recruiting Coordinator", "Middle School Head Coach", "Director of Youth Football"
            ],
            "General": [
                "Technology/Video", "Equipment", "Player Equipment", "Field Equipment", "Footballs",
                "Discipline", "Lockers", "Player Files", "Support Staff", "Academics",
                "Program Promotion", "Awards/Appreciations", "Social Media/Marketing", "Recruiting", "Sponsorships"
            ],
            "Scouting": [
                "Self-Scouting", "Statistics", "Goal Chart", "Each Position Graded",
                "Off Self-Scout Report", "Def Self-Scout Report", "Specialty Self-Scout",
                "Upcoming Opponent Scouting", "Personnel (O/D/K)", "Off. Scouting Report",
                "Def. Scouting Report", "Specialty Scout Report", "Practice/Game Planning",
                "Practice Plans", "Practice Scripts (O/D/K)", "Draw Cards", "Game Call Sheet"
            ],
            "Offense": {
                "Varsity": [
                    "Offensive Coordinator", "Quarterbacks", "Running Backs", "Receivers",
                    "Tight Ends", "Offensive Line (x2)", "Scout Defense", "Scout Defensive Skill", "Scout Defensive Front"
                ],
                "JV/Freshman": [
                    "JV Off. Coordinator", "9th Off. Coordinator", "JV/9th Off. Backs",
                    "JV/9th Receivers", "JV/9th Off. Line/TE (x2)"
                ]
            },
            "Defense": {
                "Varsity": [
                    "Defensive Coordinator", "Defensive Line", "Inside Backers", "Outside Backers",
                    "Cornerbacks", "Safeties", "Scout Offense", "Scout Offensive Line", "Scout Offensive Skill"
                ],
                "JV/Freshman": [
                    "JV Def. Coordinator", "9th Def. Coordinator", "JV/9th Def. Line",
                    "JV/9th Inside Backers", "JV/9th Outside Backers", "JV/9th Def. Backs"
                ]
            },
            "Medical": [
                "Athletic Trainer", "Team Doctors", "Athletic Trainers"
            ],
            "Special Teams": {
                "General": ["Special Teams Coordinator"],
                "Kickoff": ["Kickers", "Right Contain", "Right Coverage", "Left Contain", "Left Coverage", "Scout Kick Return"],
                "Kick Return": ["Kick Return", "Right Edge", "Left Edge", "Middle", "Up-Backs", "Returners", "Scout Kickoff"],
                "Punt": ["Punters", "Shooters", "Long Snappers", "Right Protection", "Left Protection", "Scout Punt Return"],
                "Punt Return": ["Punt Return", "Defensive Line", "Inside Backers", "Blockers", "Corners", "Returners", "Scout Punt"],
                "Xpt/FG": ["Kickers", "Hold/Snap", "Right Edge", "Interior OL", "Left Edge", "Scout Kick Block"],
                "Kick Block": ["Kick Block", "Interior Push", "Blockers", "Check Fake", "Scout Xpt/FG"],
                "Sub-Varsity": ["JV Specialty Coordinator", "Fresh. Specialty Coordinator"]
            },
            "Practice": {
                "Before Practice": [
                    "Supervision", "Equipment", "Field Set Up", "Footballs", "Press Box Set Up",
                    "Video Set Up", "Taping/Injury Maint", "Managers"
                ],
                "After Practice": [
                    "Distraction List", "Video", "Player Issues", "Footballs", "Press Box Clean Up",
                    "Field Clean Up", "Injury Maint", "Supervision"
                ]
            },
            "Games": {
                "During the Day": ["Water/Powerade", "Officials Room (home)", "Visitors’ Room (home)", "Load Truck (away)", "Equipment"],
                "Pre-Game": ["Headsets", "Video", "Field Set Up", "Monitor Players"],
                "In-Game": [
                    "Call Offense/Defense", "Signal Offense/Defense", "Position Groups",
                    "Press Box Off/Def", "Specialty Organization", "Equipment", "Sideline Control",
                    "Hype Man", "Time Management", "Kickers", "Injuries"
                ],
                "Post-Game": [
                    "Field Clean Up", "Water Clean Up", "Headsets", "Video", "Player Supervision",
                    "Collect Cloth", "Officials Room (home)", "Visitor’s Room (home)", "Load Trailer (away)",
                    "Attendance (away)", "Injuries", "Media"
                ],
                "Sub-Varsity Games": ["Medical Kit", "Video", "Equipment Box", "Water", "Field Set Up/Clean Up"]
            },
            "Extra": [
                "Fundraising Team", "Feeder Team", "Program Promotion",
                "Misc. Responsibilities", "Program Evaluation & Meetings with Head Coach"
            ]
        };

        // --- VALHALLA UI COMPONENTS ---

        // --- VALHALLA 2.0 CONSTANTS & HELPERS ---
        // Colors
        const PRESET_COLORS = ['#38bdf8', '#3b82f6', '#ef4444', '#f97316', '#f59e0b', '#10b981', '#06b6d4', '#6366f1', '#8b5cf6', '#d946ef', '#ec4899', '#000000', '#4b5563'];

        const CALENDAR_CONSTANTS = {
            PRACTICE_TEMPO_PROTOCOLS: [
                { id: 'thud', code: 'THUD', label: 'Thud' },
                { id: 'tag', code: 'TAG', label: 'Tag' },
                { id: 'live', code: 'LIVE', label: 'Live' },
                { id: 'wrap', code: 'WRAP', label: 'Wrap' },
                { id: 'air', code: 'AIR', label: 'Air' }
            ],
            PRACTICE_TEMPLATES: [],
            SEGMENT_TYPE_SETTINGS: {
                'Take-Off': { showHash: false, showDefense: false },
                'Conditioning': { showHash: false, showDefense: false },
                'On-Air': { showHash: true, showDefense: false },
                'Air': { showHash: true, showDefense: false },
                'Routes on Air': { showHash: true, showDefense: false },
                'Pat-n-Go': { showHash: true, showDefense: false },
                'Walkthrough': { showHash: true, showDefense: false }
            }
        };


        // --- SUMMER COMPETITION MANAGER ---
        const SummerCompetitionManager = ({ roster, compData, onUpdateComp }) => {
            const [activeTab, setActiveTab] = useState('draft'); // draft, attendance, challenges, standings

            // Helper to get defaults if data is empty
            const data = compData || {
                config: { numTeams: 4 },
                teams: [
                    { id: 't1', name: 'Team 1', color: '#EF4444', captainIds: [], rosterIds: [] },
                    { id: 't2', name: 'Team 2', color: '#3B82F6', captainIds: [], rosterIds: [] },
                    { id: 't3', name: 'Team 3', color: '#10B981', captainIds: [], rosterIds: [] },
                    { id: 't4', name: 'Team 4', color: '#F59E0B', captainIds: [], rosterIds: [] }
                ], // Default 4 teams
                attendance: [],
                challenges: []
            };

            const updateData = (newData) => {
                onUpdateComp({ ...data, ...newData });
            };

            // Calculate Standings
            const getTeamStats = (teamId) => {
                let attendancePoints = 0;
                let challengePoints = 0;

                // Attendance: 1 pt per player per day (example logic)
                data.attendance.forEach(entry => {
                    const presentCount = entry.records[teamId]?.length || 0;
                    attendancePoints += presentCount;
                });

                // Challenges: Points logged in challenges
                data.challenges.forEach(challenge => {
                    challenge.matchups.forEach(m => {
                        if (m.winnerId === teamId) challengePoints += (m.points || 50); // Default 50 for a win?
                    });
                });

                return { attendancePoints, challengePoints, total: attendancePoints + challengePoints };
            };

            // DRAFT COMPONENTS
            const DraftTab = () => {
                const [draftPoolSearch, setDraftPoolSearch] = useState('');

                // Players already on a team
                const assignedPlayerIds = new Set(data.teams.flatMap(t => [...t.captainIds, ...t.rosterIds]));

                // Available players
                const draftPool = roster.filter(p => !assignedPlayerIds.has(p.id))
                    .filter(p => p.name.toLowerCase().includes(draftPoolSearch.toLowerCase()))
                    .filter(Boolean).sort((a, b) => (a?.name || '').localeCompare(b?.name || ''));

                const assignPlayer = (playerId, teamId, isCaptain = false) => {
                    const newTeams = data.teams.map(t => {
                        if (t.id === teamId) {
                            return isCaptain
                                ? { ...t, captainIds: [...t.captainIds, playerId] }
                                : { ...t, rosterIds: [...t.rosterIds, playerId] };
                        }
                        return t;
                    });
                    updateData({ teams: newTeams });
                };

                const removePlayer = (playerId, teamId) => {
                    const newTeams = data.teams.map(t => {
                        if (t.id === teamId) {
                            return {
                                ...t,
                                captainIds: t.captainIds.filter(id => id !== playerId),
                                rosterIds: t.rosterIds.filter(id => id !== playerId)
                            };
                        }
                        return t;
                    });
                    updateData({ teams: newTeams });
                };

                const updateTeamName = (teamId, newName) => {
                    updateData({ teams: data.teams.map(t => t.id === teamId ? { ...t, name: newName } : t) });
                };

                // Config: Add/Remove Teams
                const setTeamCount = (count) => {
                    let newTeams = [...data.teams];
                    if (count > newTeams.length) {
                        // Add teams
                        for (let i = newTeams.length + 1; i <= count; i++) {
                            newTeams.push({ id: `t${Date.now()}_${i}`, name: `Team ${i}`, color: '#6B7280', captainIds: [], rosterIds: [] });
                        }
                    } else if (count < newTeams.length) {
                        // Remove teams (warn if players assigned?)
                        // simplified: just slice, players return to pool automatically because assignedPlayerIds is calc'd from existing teams
                        newTeams = newTeams.slice(0, count);
                    }
                    updateData({ config: { ...data.config, numTeams: count }, teams: newTeams });
                };

                return (
                    <div style={{ display: 'grid', gridTemplateColumns: '300px 1fr', gap: '1rem', height: '100%' }}>
                        {/* Draft Pool */}
                        <div className="card" style={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
                            <div style={{ padding: '1rem', borderBottom: '1px solid var(--border)' }}>
                                <h3 style={{ margin: '0 0 0.5rem 0' }}>Draft Pool</h3>
                                <input
                                    type="text" placeholder="Search..."
                                    value={draftPoolSearch} onChange={e => setDraftPoolSearch(e.target.value)}
                                    style={{ width: '100%', padding: '0.5rem' }}
                                />
                                <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginTop: '0.5rem' }}>
                                    {draftPool.length} Remaining
                                </div>
                            </div>
                            <div style={{ flex: 1, overflowY: 'auto', padding: '0.5rem' }}>
                                {draftPool.map(p => (
                                    <div key={p.id} style={{ padding: '0.5rem', borderBottom: '1px solid var(--border)', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                        <span>{p.name} <span style={{ fontSize: '0.7em', color: 'var(--text-secondary)' }}>{p.position}</span></span>
                                        <div className="dropdown" style={{ position: 'relative', display: 'inline-block' }}>
                                            <button style={{ fontSize: '0.8rem', padding: '2px 6px' }}>Assign</button>
                                            <div className="dropdown-content" style={{ right: 0 }}>
                                                {data.teams.map(t => (
                                                    <div key={t.id} onClick={() => assignPlayer(p.id, t.id)} style={{ padding: '4px 8px', cursor: 'pointer', hover: { background: '#eee' } }}>
                                                        To {t.name}
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>

                        {/* Teams Grid */}
                        <div style={{ overflowY: 'auto', display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                            <div style={{ padding: '1rem', background: 'var(--surface)', borderRadius: '8px', display: 'flex', alignItems: 'center', gap: '1rem' }}>
                                <label>Number of Teams (1-8):</label>
                                <input
                                    type="number" min="1" max="8"
                                    value={data.teams.length}
                                    onChange={e => setTeamCount(Math.min(8, Math.max(1, parseInt(e.target.value) || 1)))}
                                    style={{ width: '60px', padding: '0.25rem' }}
                                />
                            </div>

                            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', gap: '1rem' }}>
                                {data.teams.map(team => (
                                    <div key={team.id} className="card" style={{ padding: '1rem', borderTop: `4px solid ${team.color}` }}>
                                        <input
                                            value={team.name}
                                            onChange={e => updateTeamName(team.id, e.target.value)}
                                            style={{ fontSize: '1.1rem', fontWeight: 'bold', width: '100%', border: 'none', background: 'transparent', marginBottom: '0.5rem' }}
                                        />

                                        {/* Captains */}
                                        <div style={{ marginBottom: '0.5rem' }}>
                                            <div style={{ fontSize: '0.75rem', textTransform: 'uppercase', color: 'var(--text-secondary)', marginBottom: '4px' }}>Captains</div>
                                            {team.captainIds.length === 0 && <div style={{ fontSize: '0.8rem', fontStyle: 'italic', opacity: 0.6 }}>No Captains</div>}
                                            {team.captainIds.map(pid => {
                                                const p = roster.find(x => x.id === pid);
                                                return (
                                                    <div key={pid} style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.9rem', marginBottom: '2px' }}>
                                                        <span>👑 {p?.name || 'Unknown'}</span>
                                                        <button onClick={() => removePlayer(pid, team.id)} style={{ border: 'none', background: 'none', color: 'red', cursor: 'pointer' }}>×</button>
                                                    </div>
                                                );
                                            })}
                                            <button
                                                style={{ fontSize: '0.75rem', marginTop: '4px', background: 'none', border: '1px dashed var(--text-secondary)', width: '100%' }}
                                                onClick={() => {
                                                    const pid = prompt("Enter Player Name to search correctly? actually drag drop is better. For now use the drafted pool.");
                                                    // Simplified: user promotes from roster
                                                }}
                                            >
                                                (Assign via Pool)
                                            </button>
                                        </div>

                                        {/* Roster */}
                                        <div>
                                            <div style={{ fontSize: '0.75rem', textTransform: 'uppercase', color: 'var(--text-secondary)', marginBottom: '4px' }}>Roster ({team.rosterIds.length})</div>
                                            {team.rosterIds.map(pid => {
                                                const p = roster.find(x => x.id === pid);
                                                return (
                                                    <div key={pid} style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.9rem', marginBottom: '2px' }}>
                                                        <span>{p?.name || 'Unknown'}</span>
                                                        <div style={{ display: 'flex', gap: '4px' }}>
                                                            <button onClick={() => { removePlayer(pid, team.id); assignPlayer(pid, team.id, true); }} title="Promote to Captain" style={{ border: 'none', background: 'none', cursor: 'pointer' }}>👑</button>
                                                            <button onClick={() => removePlayer(pid, team.id)} style={{ border: 'none', background: 'none', color: 'red', cursor: 'pointer' }}>×</button>
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>
                );
            };

            // ATTENDANCE COMPONENT
            const AttendanceTab = () => {
                const [date, setDate] = useState(new Date().toISOString().split('T')[0]);

                // Get existing record for this date
                const todayRecord = data.attendance.find(r => r.date === date) || { date, records: {} };

                const togglePresence = (teamId, playerId) => {
                    const currentTeamRecord = todayRecord.records[teamId] || [];
                    const newTeamRecord = currentTeamRecord.includes(playerId)
                        ? currentTeamRecord.filter(id => id !== playerId)
                        : [...currentTeamRecord, playerId];

                    const newRecords = { ...todayRecord.records, [teamId]: newTeamRecord };

                    // Update main data
                    const otherDates = data.attendance.filter(r => r.date !== date);
                    updateData({ attendance: [...otherDates, { date, records: newRecords }] });
                };

                return (
                    <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                        <div style={{ padding: '1rem', background: 'var(--surface)', marginBottom: '1rem', display: 'flex', alignItems: 'center', gap: '1rem' }}>
                            <label>Attendance Date:</label>
                            <input
                                type="date" value={date} onChange={e => setDate(e.target.value)}
                                style={{ padding: '0.5rem' }}
                            />
                        </div>

                        <div style={{ display: 'flex', gap: '1rem', overflowX: 'auto', paddingBottom: '1rem', flex: 1 }}>
                            {data.teams.map(team => {
                                const presentIds = todayRecord.records[team.id] || [];
                                const allTeamPlayers = [...team.captainIds, ...team.rosterIds];

                                return (
                                    <div key={team.id} className="card" style={{ minWidth: '250px', display: 'flex', flexDirection: 'column', borderTop: `4px solid ${team.color}` }}>
                                        <div style={{ padding: '0.75rem', borderBottom: '1px solid var(--border)', display: 'flex', justifyContent: 'space-between' }}>
                                            <span style={{ fontWeight: 'bold' }}>{team.name}</span>
                                            <span>{presentIds.length} / {allTeamPlayers.length}</span>
                                        </div>
                                        <div style={{ flex: 1, overflowY: 'auto', padding: '0.5rem' }}>
                                            {allTeamPlayers.map(pid => {
                                                const p = roster.find(x => x.id === pid);
                                                return (
                                                    <div
                                                        key={pid}
                                                        onClick={() => togglePresence(team.id, pid)}
                                                        style={{
                                                            padding: '0.5rem', marginBottom: '2px', cursor: 'pointer', borderRadius: '4px',
                                                            background: presentIds.includes(pid) ? 'rgba(16, 185, 129, 0.2)' : 'transparent',
                                                            display: 'flex', justifyContent: 'space-between'
                                                        }}
                                                    >
                                                        <span>{p?.name}</span>
                                                        {presentIds.includes(pid) && <Icon name="Check" size={14} />}
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                );
            };

            // STANDINGS COMPONENT
            const StandingsTab = () => {
                const stats = data.teams.map(t => ({ ...t, stats: getTeamStats(t.id) }))
                    .sort((a, b) => b.stats.total - a.stats.total);

                return (
                    <div className="card" style={{ padding: '2rem' }}>
                        <h2>Summer Championship Standings</h2>
                        <table style={{ width: '100%', borderCollapse: 'collapse', marginTop: '1rem' }}>
                            <thead>
                                <tr style={{ borderBottom: '2px solid var(--border)', textAlign: 'left' }}>
                                    <th style={{ padding: '1rem' }}>Rank</th>
                                    <th style={{ padding: '1rem' }}>Team</th>
                                    <th style={{ padding: '1rem', textAlign: 'center' }}>Attendance Pts</th>
                                    <th style={{ padding: '1rem', textAlign: 'center' }}>Challenge Pts</th>
                                    <th style={{ padding: '1rem', textAlign: 'right' }}>Total Score</th>
                                </tr>
                            </thead>
                            <tbody>
                                {stats.map((t, i) => (
                                    <tr key={t.id} style={{ borderBottom: '1px solid var(--border)' }}>
                                        <td style={{ padding: '1rem', fontSize: '1.2rem', fontWeight: 'bold' }}>{i + 1}</td>
                                        <td style={{ padding: '1rem' }}>
                                            <div style={{ fontWeight: 'bold', fontSize: '1.1rem', color: t.color }}>{t.name}</div>
                                            <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>
                                                {t.captainIds.length} C, {t.rosterIds.length} Players
                                            </div>
                                        </td>
                                        <td style={{ padding: '1rem', textAlign: 'center' }}>{t.stats.attendancePoints}</td>
                                        <td style={{ padding: '1rem', textAlign: 'center' }}>{t.stats.challengePoints}</td>
                                        <td style={{ padding: '1rem', textAlign: 'right', fontWeight: 'bold', fontSize: '1.5rem' }}>{t.stats.total}</td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                );
            };

            return (
                <div style={{ height: '100%', display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                    <header style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                        <h2 style={{ margin: 0 }}>Summer Competition</h2>
                        <div style={{ display: 'flex', gap: '0.5rem', background: 'var(--surface)', padding: '4px', borderRadius: '8px' }}>
                            {['draft', 'attendance', 'challenges', 'standings'].map(tab => (
                                <button
                                    key={tab}
                                    onClick={() => setActiveTab(tab)}
                                    style={{
                                        padding: '0.5rem 1rem', border: 'none', borderRadius: '6px',
                                        background: activeTab === tab ? 'var(--accent)' : 'transparent',
                                        color: activeTab === tab ? 'white' : 'var(--text-secondary)',
                                        cursor: 'pointer', fontWeight: 'bold', textTransform: 'capitalize'
                                    }}
                                >
                                    {tab}
                                </button>
                            ))}
                        </div>
                    </header>

                    <div style={{ flex: 1, overflow: 'hidden' }}>
                        {activeTab === 'draft' && <DraftTab />}
                        {activeTab === 'attendance' && <AttendanceTab />}
                        {activeTab === 'standings' && <StandingsTab />}
                        {activeTab === 'challenges' && <div className="card" style={{ padding: '2rem', textAlign: 'center' }}>Challenges Logic Coming Soon (Use Attendance/Standings for now)</div>}
                    </div>
                </div>
            );
        };


        const MobileAttendanceApp = ({ roster, attendance, setAttendance }) => {
            const [scheduledEvents] = useLocalStorage('oc-dashboard-scheduled-events', []);
            const [injuries] = useLocalStorage('oc-dashboard-injuries', []);

            const [viewMode, setViewMode] = useState('events'); // 'events' | 'roster'
            const [selectedEvent, setSelectedEvent] = useState(null);
            const [playerFilter, setPlayerFilter] = useState('ALL'); // ALL, Varsity, JV, JV2
            const [sortBy, setSortBy] = useState('ALPHA'); // ALPHA, NUMBER

            const today = new Date().toISOString().split('T')[0];

            // --- Event Selection ---
            const todaysEvents = scheduledEvents.filter(e => e.date === today);
            const DEFAULT_EVENTS = ['Weights', 'Practice', 'Film', 'Bus', 'Game', 'Install', 'Speed', 'Meeting'];

            const handleSelectEvent = (evtType) => {
                setSelectedEvent(evtType);
                setViewMode('roster');
            };

            // --- Attendance Logic ---
            const getRecord = (pid) => {
                return attendance.find(a =>
                    a.date === today &&
                    a.eventType === selectedEvent &&
                    a.playerId === pid
                );
            };

            const getStatus = (pid) => {
                const record = getRecord(pid);
                return record?.status || 'Present';
            };

            const toggleStatus = (pid) => {
                const current = getStatus(pid);
                // Cycle: Present -> Tardy -> Tardy Excused -> Absent -> Excused -> Present
                const nextStatus = {
                    'Present': 'Tardy',
                    'Tardy': 'Tardy Excused',
                    'Tardy Excused': 'Absent', // Formerly Late
                    'Absent': 'Excused',
                    'Excused': 'Present'
                }[current] || 'Present';

                const player = roster.find(p => p.id === pid);
                const existing = getRecord(pid);

                if (existing) {
                    setAttendance(attendance.map(a => a.id === existing.id ? { ...a, status: nextStatus } : a));
                } else {
                    const newRecord = {
                        id: Date.now() + Math.random(),
                        date: today,
                        eventType: selectedEvent,
                        playerId: pid,
                        playerName: player ? player.name : 'Unknown',
                        status: nextStatus,
                        missedTime: '',
                        notes: ''
                    };
                    setAttendance([newRecord, ...attendance]);
                }
            };

            const updateMissedTime = (pid, time) => {
                const existing = getRecord(pid);
                if (existing) {
                    setAttendance(attendance.map(a => a.id === existing.id ? { ...a, missedTime: time } : a));
                }
            };

            // --- Filtering & Sorting ---
            const getFilteredRoster = () => {
                let filtered = [...roster];
                if (playerFilter !== 'ALL') {
                    filtered = filtered.filter(p => {
                        const team = p.team || p.level || 'Varsity';
                        if (Array.isArray(team)) return team.includes(playerFilter);
                        return team === playerFilter;
                    });
                }

                return filtered.sort((a, b) => {
                    if (sortBy === 'ALPHA') {
                        // Sort by Last Name
                        const nameA = a.lastName || a.name.split(' ').slice(-1)[0] || a.name;
                        const nameB = b.lastName || b.name.split(' ').slice(-1)[0] || b.name;
                        return (nameA || '').localeCompare(nameB || '');
                    }
                    if (sortBy === 'NUMBER') return (parseInt(a.number || a.jersey || 0) || 999) - (parseInt(b.number || b.jersey || 0) || 999);
                    return 0;
                });
            };

            const getInjuryStatus = (pid) => {
                return injuries.find(i => i.playerId === pid && i.status === 'Active');
            };

            // --- RENDER ---
            if (viewMode === 'events') {
                return (
                    <div className="card" style={{ height: '100%', display: 'flex', flexDirection: 'column', padding: '1.5rem' }}>
                        <h2 style={{ marginBottom: '1.5rem' }}>Select Event</h2>
                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))', gap: '1rem' }}>
                            {todaysEvents.map(evt => (
                                <button key={evt.id} onClick={() => handleSelectEvent(evt.eventType)} className="btn btn-primary" style={{ padding: '2rem', fontSize: '1.2rem', display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '0.5rem' }}>
                                    <Icon name="Calendar" size={24} />
                                    <span>{evt.eventType}</span>
                                    {evt.time && <span style={{ fontSize: '0.8rem', opacity: 0.8 }}>{evt.time}</span>}
                                </button>
                            ))}
                            {todaysEvents.length === 0 && DEFAULT_EVENTS.map(evt => (
                                <button key={evt} onClick={() => handleSelectEvent(evt)} className="btn btn-secondary" style={{ padding: '2rem', fontSize: '1.2rem', display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '0.5rem' }}>
                                    <span>{evt}</span>
                                </button>
                            ))}
                        </div>
                        {todaysEvents.length === 0 && (
                            <div style={{ marginTop: '2rem', color: 'var(--text-secondary)', textAlign: 'center' }}>
                                No specific events scheduled for today. Select a standard event above.
                            </div>
                        )}
                    </div>
                );
            }

            const activeRoster = getFilteredRoster();
            const counts = activeRoster.reduce((acc, p) => {
                const s = getStatus(p.id);
                acc[s] = (acc[s] || 0) + 1;
                return acc;
            }, {});

            return (
                <div style={{ height: '100%', display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
                    {/* Header */}
                    <div style={{ padding: '1rem', background: 'var(--surface)', borderBottom: '1px solid var(--border)', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                            <button onClick={() => setViewMode('events')} className="btn" style={{ padding: '0.5rem' }}><Icon name="ArrowLeft" /></button>
                            <div>
                                <h2 style={{ margin: 0 }}>{selectedEvent}</h2>
                                <span style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>{today}</span>
                            </div>
                        </div>
                        <div style={{ display: 'flex', gap: '1rem', fontSize: '0.9rem' }}>
                            <span style={{ color: '#ef4444' }}>Absent: {counts['Absent'] || 0}</span>
                            <span style={{ color: '#eab308' }}>Tardy: {(counts['Tardy'] || 0) + (counts['Tardy Excused'] || 0)}</span>
                            <span style={{ color: 'var(--text-secondary)' }}>Total: {activeRoster.length}</span>
                        </div>
                    </div>

                    {/* Filter Bar */}
                    <div style={{ padding: '0.5rem 1rem', background: 'var(--bg-panel)', display: 'flex', gap: '0.5rem', overflowX: 'auto', alignItems: 'center' }}>
                        {['ALL', 'Varsity', 'JV', 'JV2'].map(f => (
                            <button
                                key={f}
                                onClick={() => setPlayerFilter(f)}
                                className={`btn-sm ${playerFilter === f ? 'btn-primary' : 'btn-secondary'}`}
                            >
                                {f}
                            </button>
                        ))}
                        <div style={{ flex: 1 }} />
                        <button onClick={() => setSortBy(sortBy === 'ALPHA' ? 'NUMBER' : 'ALPHA')} className="btn-sm btn-secondary" style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                            <Icon name="ArrowUpDown" size={12} /> {sortBy === 'ALPHA' ? 'Last Name' : 'Jersey'}
                        </button>
                    </div>

                    {/* Roster List */}
                    <div style={{ flex: 1, overflowY: 'auto', padding: '0.5rem' }}>
                        {activeRoster.map(p => {
                            const record = getRecord(p.id);
                            const status = record?.status || 'Present';
                            const injury = getInjuryStatus(p.id);

                            let statusColor = 'var(--surface)'; // Present default
                            if (status === 'Absent') statusColor = '#fee2e2';
                            if (status.includes('Tardy')) statusColor = '#fef3c7'; // Lighter amber for better text contrast
                            if (status === 'Excused') statusColor = '#e0f2fe';

                            return (
                                <div key={p.id} onClick={() => toggleStatus(p.id)} style={{
                                    display: 'flex', alignItems: 'center', justifyContent: 'space-between',
                                    padding: '0.75rem 1rem', marginBottom: '8px', borderRadius: '8px',
                                    background: statusColor,
                                    border: '1px solid var(--border)',
                                    cursor: 'pointer',
                                    userSelect: 'none',
                                    color: status === 'Absent' ? '#7f1d1d' : // Dark red for absent
                                        status.includes('Tardy') ? '#78350f' : // Dark brown for tardy
                                            status === 'Excused' ? '#0c4a6e' : // Dark blue for excused
                                                'inherit'
                                }}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '1rem', flex: 1 }}>
                                        <span style={{ width: '30px', fontWeight: 'bold', color: 'var(--text-secondary)' }}>{p.number || p.jersey || '#'}</span>
                                        <div style={{ display: 'flex', flexDirection: 'column' }}>
                                            <span style={{ fontWeight: '600', fontSize: '1rem' }}>{p.lastName ? `${p.lastName}, ${p.firstName}` : p.name} {injury && <span title={injury.description} style={{ fontSize: '0.8rem', marginLeft: '4px' }}>🤕</span>}</span>
                                            <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)' }}>{p.position} • {p.level || p.team || '-'}</span>
                                        </div>
                                    </div>

                                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-end', gap: '4px' }}>
                                        <div style={{ fontWeight: 'bold', textTransform: 'uppercase', fontSize: '0.85rem', color: status === 'Present' ? 'var(--text-secondary)' : 'inherit', textAlign: 'right' }}>
                                            {status}
                                        </div>
                                        {status.includes('Tardy') && (
                                            <div onClick={e => e.stopPropagation()} style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                                                <input
                                                    type="text"
                                                    placeholder="Missed time..."
                                                    value={record?.missedTime || ''}
                                                    onChange={(e) => updateMissedTime(p.id, e.target.value)}
                                                    style={{
                                                        fontSize: '0.75rem', padding: '2px 4px',
                                                        width: '80px', borderRadius: '4px', border: '1px solid #ccc'
                                                    }}
                                                />
                                            </div>
                                        )}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        const getDeadlineStatus = (deadline, deadlineTime) => {
            if (!deadline) return 'normal';
            const now = new Date();
            const deadlineDate = new Date(deadline);
            if (deadlineTime) {
                const [hours, minutes] = deadlineTime.split(':');
                deadlineDate.setHours(parseInt(hours), parseInt(minutes));
            }
            const diffMs = deadlineDate - now;
            const diffHours = diffMs / (1000 * 60 * 60);

            if (diffMs < 0) return 'overdue';
            if (diffHours < 24 && diffHours >= 0) return 'urgent';
            return 'normal';
        };

        const StaffTasksView = ({ tasks, onUpdateTasks, staff, currentUserRole = 'Head Coach', currentUserName = 'Coach Finn' }) => {
            const [viewContext, setViewContext] = useState('MY_TASKS'); // MY_TASKS, ROLE, STAFF, ALL
            const [filterRole, setFilterRole] = useState('ALL');
            const [filterStaffId, setFilterStaffId] = useState('ALL');

            // Quick Filters
            const quickFilters = [
                { id: 'MY_TASKS', label: 'My Tasks', icon: 'User' },
                { id: 'ROLE', label: 'By Role', icon: 'Users' },
                { id: 'STAFF', label: 'By Staff Member', icon: 'Search' },
                { id: 'ALL', label: 'All Tasks', icon: 'List' }
            ];

            // Helper to check if a task belongs to "My Tasks"
            // Simulating "My Tasks" based on matching role or name for now
            const isMyTask = (task) => {
                const assigned = task.assignTo || [];
                return assigned.includes(currentUserRole) || assigned.includes(currentUserName);
            };

            const getFilteredTasks = () => {
                let filtered = tasks;

                if (viewContext === 'MY_TASKS') {
                    filtered = tasks.filter(isMyTask);
                } else if (viewContext === 'ROLE') {
                    if (filterRole !== 'ALL') {
                        filtered = tasks.filter(t => t.assignTo && t.assignTo.includes(filterRole));
                    }
                } else if (viewContext === 'STAFF') {
                    if (filterStaffId !== 'ALL') {
                        // Assuming staff ID or Name is used in assignTo. Currently it seems to be mixed Names/Roles.
                        // We will match against Staff Name for now as that's what TaskAssigner used
                        const staffMember = staff.find(s => s.id === filterStaffId);
                        if (staffMember) {
                            filtered = tasks.filter(t => t.assignTo && t.assignTo.includes(staffMember.name));
                        }
                    }
                }

                // Sort by deadline (urgent first) or priority
                return filtered.sort((a, b) => {
                    const statusA = getDeadlineStatus(a.deadline, a.deadlineTime);
                    const statusB = getDeadlineStatus(b.deadline, b.deadlineTime);
                    const prioScore = { 'High': 3, 'Medium': 2, 'Low': 1 };

                    // Overdue/Urgent on top
                    if (statusA === 'overdue' && statusB !== 'overdue') return -1;
                    if (statusB === 'overdue' && statusA !== 'overdue') return 1;

                    if (statusA === 'urgent' && statusB !== 'urgent') return -1;
                    if (statusB === 'urgent' && statusA !== 'urgent') return 1;

                    // Then Priority
                    if (prioScore[a.priority] !== prioScore[b.priority]) {
                        return prioScore[b.priority] - prioScore[a.priority];
                    }
                    return 0;
                });
            };

            const toggleTaskComplete = (taskId) => {
                const newTasks = tasks.map(t =>
                    t.id === taskId ? { ...t, completed: !t.completed, completedAt: !t.completed ? new Date().toISOString() : null } : t
                );
                onUpdateTasks(newTasks);
            };

            const visibleTasks = getFilteredTasks();



            return (
                <div style={{ height: '100%', display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                    {/* Header & Context Switcher */}
                    <div className="card" style={{ padding: '1rem', display: 'flex', alignItems: 'center', justifyContent: 'space-between', flexWrap: 'wrap', gap: '1rem' }}>
                        <div style={{ display: 'flex', gap: '0.5rem' }}>
                            {quickFilters.map(filter => (
                                <button
                                    key={filter.id}
                                    className={`btn ${viewContext === filter.id ? 'btn-primary' : 'btn-secondary'}`}
                                    onClick={() => setViewContext(filter.id)}
                                >
                                    <Icon name={filter.icon} size={16} /> {filter.label}
                                </button>
                            ))}
                        </div>

                        {/* Secondary Filters based on Context */}
                        {viewContext === 'ROLE' && (
                            <select className="form-select" style={{ width: '200px' }} value={filterRole} onChange={e => setFilterRole(e.target.value)}>
                                <option value="ALL">All Roles</option>
                                <option value="Head Coach">Head Coach</option>
                                <option value="OC">Offensive Coord</option>
                                <option value="DC">Defensive Coord</option>
                                <option value="STC">Special Teams</option>
                                <option value="Position Coach">Position Coaches</option>
                            </select>
                        )}
                        {viewContext === 'STAFF' && (
                            <select className="form-select" style={{ width: '200px' }} value={filterStaffId} onChange={e => setFilterStaffId(e.target.value)}>
                                <option value="ALL">All Staff</option>
                                {staff.map(s => <option key={s.id} value={s.id}>{s.name}</option>)}
                            </select>
                        )}
                    </div>

                    {/* Task List */}
                    <div className="card" style={{ flex: 1, overflowY: 'auto', padding: '0' }}>
                        {visibleTasks.length === 0 ? (
                            <div style={{ padding: '3rem', textAlign: 'center', color: 'var(--text-secondary)' }}>
                                <Icon name="Check" size={48} color="var(--success)" style={{ opacity: 0.5, marginBottom: '1rem' }} />
                                <h3>All Caught Up!</h3>
                                <p>No tasks found for this view.</p>
                            </div>
                        ) : (
                            <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                                <thead style={{ background: 'var(--surface)', position: 'sticky', top: 0 }}>
                                    <tr>
                                        <th style={{ padding: '1rem', textAlign: 'left', width: '50px' }}></th>
                                        <th style={{ padding: '1rem', textAlign: 'left' }}>Task</th>
                                        <th style={{ padding: '1rem', textAlign: 'left' }}>Assigned To</th>
                                        <th style={{ padding: '1rem', textAlign: 'right' }}>Deadline</th>
                                        <th style={{ padding: '1rem', textAlign: 'center' }}>Status</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {visibleTasks.map(task => {
                                        const status = getDeadlineStatus(task.deadline, task.deadlineTime);
                                        const isOverdue = status === 'overdue' && !task.completed;
                                        const isUrgent = status === 'urgent' && !task.completed;

                                        return (
                                            <tr key={task.id} style={{ borderBottom: '1px solid var(--border)', opacity: task.completed ? 0.6 : 1, background: isOverdue ? 'rgba(239, 68, 68, 0.05)' : 'transparent' }}>
                                                <td style={{ padding: '1rem' }}>
                                                    <input
                                                        type="checkbox"
                                                        checked={task.completed || false}
                                                        onChange={() => toggleTaskComplete(task.id)}
                                                        style={{ width: '20px', height: '20px', cursor: 'pointer', accentColor: 'var(--success)' }}
                                                    />
                                                </td>
                                                <td style={{ padding: '1rem' }}>
                                                    <div style={{ fontWeight: 'bold', textDecoration: task.completed ? 'line-through' : 'none' }}>
                                                        {task.task}
                                                    </div>
                                                    <div style={{ display: 'flex', gap: '0.5rem', fontSize: '0.8rem', marginTop: '0.25rem' }}>
                                                        <span style={{
                                                            background: task.priority === 'High' ? '#fee2e2' : 'var(--bg-body)',
                                                            color: task.priority === 'High' ? '#991b1b' : 'var(--text-secondary)',
                                                            padding: '2px 6px', borderRadius: '4px'
                                                        }}>
                                                            {task.priority}
                                                        </span>
                                                        <span style={{ color: 'var(--text-secondary)' }}>{task.category}</span>
                                                        {task.estimatedTime && <span style={{ color: 'var(--text-secondary)' }}>⏱ {task.estimatedTime}</span>}
                                                    </div>
                                                    {task.notes && (
                                                        <div style={{ marginTop: '0.5rem', fontSize: '0.85rem', color: 'var(--text-secondary)', fontStyle: 'italic', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                            <Icon name="FileText" size={12} /> {task.notes.substring(0, 50)}{task.notes.length > 50 ? '...' : ''}
                                                        </div>
                                                    )}
                                                </td>
                                                <td style={{ padding: '1rem' }}>
                                                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.25rem' }}>
                                                        {task.assignTo && task.assignTo.map((a, idx) => (
                                                            <span key={idx} style={{ fontSize: '0.8rem', background: 'var(--bg-body)', padding: '2px 6px', borderRadius: '4px', border: '1px solid var(--border)' }}>
                                                                {a}
                                                            </span>
                                                        ))}
                                                    </div>
                                                </td>
                                                <td style={{ padding: '1rem', textAlign: 'right' }}>
                                                    {task.deadline ? (
                                                        <div style={{
                                                            color: isOverdue ? '#ef4444' : isUrgent ? '#f97316' : 'var(--text-primary)',
                                                            fontWeight: (isOverdue || isUrgent) ? 'bold' : 'normal'
                                                        }}>
                                                            {new Date(task.deadline).toLocaleDateString(undefined, { month: 'short', day: 'numeric' })}
                                                            {task.deadlineTime && <div style={{ fontSize: '0.8rem' }}>{task.deadlineTime}</div>}
                                                        </div>
                                                    ) : <span style={{ color: 'var(--text-secondary)' }}>-</span>}
                                                </td>
                                                <td style={{ padding: '1rem', textAlign: 'center' }}>
                                                    {task.completed ? (
                                                        <span style={{ color: 'var(--success)', fontWeight: 'bold', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '0.25rem' }}>
                                                            <Icon name="Check" size={14} /> Done
                                                        </span>
                                                    ) : isOverdue ? (
                                                        <span style={{ color: '#ef4444', fontWeight: 'bold' }}>Overdue</span>
                                                    ) : (
                                                        <span style={{ color: 'var(--text-secondary)' }}>Active</span>
                                                    )}
                                                </td>
                                            </tr>
                                        );
                                    })}
                                </tbody>
                            </table>
                        )}
                    </div>
                </div>
            );
        };

        const TaskAssigner = ({ tasks, onUpdateTasks, staff }) => {
            const [filterCategory, setFilterCategory] = useState('ALL');
            const [filterRole, setFilterRole] = useState('ALL');
            const [newTask, setNewTask] = useState({ category: 'Daily', task: '', recurrence: 'Daily', assignDate: '', deadline: '', deadlineTime: '', assignTo: [], priority: 'Medium', estimatedTime: '15m' });
            const [globalTaskTemplates, setGlobalTaskTemplates] = useState([]);

            // Fetch global task list templates
            useEffect(() => {
                const fetchGlobalTemplates = async () => {
                    try {
                        const snapshot = await window.db.collection('global_templates')
                            .where('type', '==', 'task_list')
                            .get();
                        const templates = snapshot.docs.map(doc => ({
                            id: doc.id,
                            name: doc.data().name,
                            category: doc.data().category,
                            description: doc.data().description,
                            data: doc.data().data || {}
                        }));
                        setGlobalTaskTemplates(templates);
                    } catch (err) {
                        console.error("Error fetching global task templates:", err);
                    }
                };
                fetchGlobalTemplates();
            }, []);

            // Expanded Categories - Merge with any unique categories found in tasks
            const DEFAULT_CATEGORIES = [
                'Year-Round',
                'Game Week - Monday', 'Game Week - Tuesday', 'Game Week - Wednesday', 'Game Week - Thursday', 'Game Week - Friday', 'Game Week - Saturday', 'Game Week - Sunday',
                'Saturday', 'Weekly',
                'Pre-Game', 'In-Game', 'Post-Game', 'Travel', 'Arrival', 'Day Before Game',
                'In-Season Weekday', 'Out-of-Season Weekday',
                'Postseason', 'Summer', 'Offseason', 'Administrative'
            ];
            // Ensure we don't miss categories that were manually typed or imported
            const existingCategories = [...new Set((tasks || []).map(t => t.category).filter(Boolean))];
            const CATEGORIES = [...new Set([...DEFAULT_CATEGORIES, ...existingCategories])];

            const RECURRENCE_OPTIONS = ['Daily', 'Daily In-Season', 'Weekly: Monday', 'Weekly: Tuesday', 'Weekly: Wednesday', 'Weekly: Thursday', 'Weekly: Friday', 'Weekly: Saturday', 'Monthly', 'Seasonal', 'Annual', 'None'];

            const handleCollaborationChange = (taskId, type) => {
                handleTaskChange(taskId, 'collaborationType', type);
            };

            const addTask = () => {
                if (!newTask.task.trim()) return;
                const id = 'task_' + Date.now();
                onUpdateTasks([...tasks, { ...newTask, id, collaborationType: 'Individual' }]);
                setNewTask({ ...newTask, task: '' }); // Reset task only
            };

            const toggleAssignee = (taskId, assignee) => {
                const taskIndex = tasks.findIndex(t => t.id === taskId);
                if (taskIndex === -1) return;
                const task = tasks[taskIndex];
                const currentAssignees = task.assignTo || [];
                const newAssignees = currentAssignees.includes(assignee)
                    ? currentAssignees.filter(a => a !== assignee)
                    : [...currentAssignees, assignee];

                const newTasks = [...tasks];
                // Default to Individual if adding 2nd person, user can change it
                const newCollab = newAssignees.length > 1 ? (task.collaborationType || 'Individual') : 'Individual';

                newTasks[taskIndex] = { ...task, assignTo: newAssignees, collaborationType: newCollab };
                onUpdateTasks(newTasks);
            };

            const deleteTask = (taskId) => {
                if (confirm('Delete this task?')) {
                    onUpdateTasks(tasks.filter(t => t.id !== taskId));
                }
            };

            const handleTaskChange = (taskId, field, value) => {
                const newTasks = tasks.map(t => t.id === taskId ? { ...t, [field]: value } : t);
                onUpdateTasks(newTasks);
            };

            // Load Global Task Template
            const loadTaskTemplate = (templateId) => {
                if (!templateId) return;
                const template = globalTaskTemplates.find(t => t.id === templateId);
                if (!template) return;

                if (confirm(`Load template "${template.name}"? This will add tasks from the template to your task list.`)) {
                    const templateTasks = template.data.tasks || [];
                    const newTasks = templateTasks.map(task => ({
                        id: `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                        task: task.task || task.title || 'New Task',
                        category: task.category || 'Daily',
                        recurrence: task.recurrence || 'Daily',
                        assignDate: task.assignDate || '',
                        deadline: task.deadline || '',
                        deadlineTime: task.deadlineTime || '',
                        assignTo: task.assignTo || [],
                        priority: task.priority || 'Medium',
                        estimatedTime: task.estimatedTime || '15m',
                        collaborationType: task.collaborationType || 'Individual'
                    }));
                    onUpdateTasks([...tasks, ...newTasks]);
                    alert(`Template "${template.name}" loaded successfully! ${newTasks.length} tasks added.`);
                }
            };

            const safeTasks = tasks || [];

            // Assignment Options
            const ROLE_GROUPS = ['All Staff', 'Coordinators', 'Position Coaches', 'Managers', 'Training Staff'];
            const ROLES = ['Head Coach', 'OC', 'DC', 'STC', 'Tech Coord', 'Video Coord', 'Equipment Mgr'];
            const STAFF_NAMES = staff.map(s => s.name).filter(Boolean);
            const ASSIGNMENT_OPTIONS = [...ROLE_GROUPS, ...ROLES, ...STAFF_NAMES];

            // Grouping Logic
            const visibleCategories = filterCategory === 'ALL' ? CATEGORIES : [filterCategory];

            // Note Editing State
            const [editingNoteId, setEditingNoteId] = useState(null);

            // Helper function to check if deadline is approaching or overdue
            const getDeadlineStatus = (deadline, deadlineTime) => {
                if (!deadline) return null;
                const now = new Date();
                const deadlineDate = new Date(deadline);
                if (deadlineTime) {
                    const [hours, minutes] = deadlineTime.split(':');
                    deadlineDate.setHours(parseInt(hours), parseInt(minutes));
                }
                const diffMs = deadlineDate - now;
                const diffHours = diffMs / (1000 * 60 * 60);

                if (diffMs < 0) return 'overdue';
                if (diffHours < 24) return 'urgent';
                if (diffHours < 72) return 'approaching';
                return 'normal';
            };

            const getDeadlineColor = (status) => {
                if (status === 'overdue') return '#ef4444';
                if (status === 'urgent') return '#f97316';
                if (status === 'approaching') return '#eab308';
                return 'var(--text-secondary)';
            };

            return (
                <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                    {/* NOTE EDITOR MODAL */}
                    {editingNoteId && (
                        <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000 }}>
                            <div className="card" style={{ width: '500px', height: '400px', display: 'flex', flexDirection: 'column', padding: '1.5rem', boxShadow: '0 4px 20px rgba(0,0,0,0.3)' }}>
                                <h3 style={{ marginTop: 0 }}>Task Notes / Attachments</h3>
                                <p style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>Add packing lists, detailed instructions, or links here.</p>
                                <textarea
                                    className="form-input"
                                    style={{ flex: 1, resize: 'none', fontFamily: 'monospace', fontSize: '0.9rem' }}
                                    value={safeTasks.find(t => t.id === editingNoteId)?.notes || ''}
                                    onChange={e => handleTaskChange(editingNoteId, 'notes', e.target.value)}
                                    placeholder="- Item 1\n- Item 2\n- Link: ..."
                                />
                                <div style={{ display: 'flex', justifyContent: 'flex-end', marginTop: '1rem' }}>
                                    <button className="btn btn-primary" onClick={() => setEditingNoteId(null)}>Done</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Load Global Template Button */}
                    {globalTaskTemplates.length > 0 && (
                        <div style={{ marginBottom: '1rem' }}>
                            <div style={{ position: 'relative', maxWidth: '300px' }}>
                                <select
                                    onChange={(e) => {
                                        loadTaskTemplate(e.target.value);
                                        e.target.value = ''; // Reset selection
                                    }}
                                    value=""
                                    style={{
                                        width: '100%', padding: '0.5rem', borderRadius: '6px',
                                        border: '1px solid var(--border)', fontSize: '0.85rem',
                                        background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                                        color: 'white', appearance: 'none', cursor: 'pointer',
                                        fontWeight: '500'
                                    }}
                                >
                                    <option value="" disabled>🌐 Load Global Task Template...</option>
                                    {globalTaskTemplates.map(t => (
                                        <option key={t.id} value={t.id} style={{ background: 'white', color: 'black' }}>
                                            {t.name}{t.category ? ` (${t.category})` : ''}
                                        </option>
                                    ))}
                                </select>
                                <Icon name="ChevronDown" size={14} style={{ position: 'absolute', right: '10px', top: '50%', transform: 'translateY(-50%)', pointerEvents: 'none', color: 'white' }} />
                            </div>
                        </div>
                    )}

                    <div style={{ display: 'flex', gap: '1rem', marginBottom: '1rem', alignItems: 'center', flexWrap: 'wrap' }}>
                        <div style={{ display: 'flex', flexDirection: 'column' }}>
                            <label style={{ fontSize: '0.7rem', color: 'var(--text-secondary)' }}>Event / Category</label>
                            <select className="form-select" value={filterCategory} onChange={e => setFilterCategory(e.target.value)} style={{ width: '200px' }}>
                                <option value="ALL">All Events</option>
                                {CATEGORIES.map(c => <option key={c} value={c}>{c}</option>)}
                            </select>
                        </div>
                        <div style={{ display: 'flex', flexDirection: 'column' }}>
                            <label style={{ fontSize: '0.7rem', color: 'var(--text-secondary)' }}>Assigned Role</label>
                            <select className="form-select" value={filterRole} onChange={e => setFilterRole(e.target.value)} style={{ width: '200px' }}>
                                <option value="ALL">All Roles</option>
                                {ASSIGNMENT_OPTIONS.map(r => <option key={r} value={r}>{r}</option>)}
                            </select>
                        </div>
                        <div style={{ flex: 1 }}></div>

                        {/* New Task Form */}
                        <div className="card" style={{ padding: '0.5rem', display: 'flex', gap: '0.5rem', alignItems: 'center', background: 'var(--bg-body)', flexWrap: 'wrap' }}>
                            <span style={{ fontWeight: 'bold', fontSize: '0.8rem' }}>NEW TASK:</span>
                            <select className="form-select" style={{ width: '140px', fontSize: '0.8rem' }} value={newTask.category} onChange={e => setNewTask({ ...newTask, category: e.target.value })}>
                                {CATEGORIES.map(c => <option key={c} value={c}>{c}</option>)}
                            </select>
                            <input className="form-input" style={{ width: '250px', fontSize: '0.8rem' }} placeholder="Task Description" value={newTask.task} onChange={e => setNewTask({ ...newTask, task: e.target.value })} />

                            <select className="form-select" style={{ width: '100px', fontSize: '0.8rem' }} value={newTask.priority} onChange={e => setNewTask({ ...newTask, priority: e.target.value })}>
                                <option value="High">High</option>
                                <option value="Medium">Medium</option>
                                <option value="Low">Low</option>
                            </select>
                            <input className="form-input" style={{ width: '80px', fontSize: '0.8rem' }} placeholder="Time (15m)" value={newTask.estimatedTime} onChange={e => setNewTask({ ...newTask, estimatedTime: e.target.value })} />

                            <select className="form-select" style={{ width: '120px', fontSize: '0.8rem' }} value={newTask.recurrence} onChange={e => setNewTask({ ...newTask, recurrence: e.target.value })}>
                                {RECURRENCE_OPTIONS.map(r => <option key={r} value={r}>{r}</option>)}
                            </select>


                            <div style={{ display: 'flex', flexDirection: 'column', gap: '0.25rem' }}>
                                <label style={{ fontSize: '0.7rem', color: 'var(--text-secondary)', fontWeight: '500' }}>Assign Date</label>
                                <input type="date" className="form-input" style={{ width: '130px', fontSize: '0.8rem' }} value={newTask.assignDate} onChange={e => setNewTask({ ...newTask, assignDate: e.target.value })} placeholder="Assign Date" />
                            </div>

                            <div style={{ display: 'flex', flexDirection: 'column', gap: '0.25rem' }}>
                                <label style={{ fontSize: '0.7rem', color: 'var(--text-secondary)', fontWeight: '500' }}>Deadline</label>
                                <div style={{ display: 'flex', gap: '0.25rem' }}>
                                    <input type="date" className="form-input" style={{ width: '130px', fontSize: '0.8rem' }} value={newTask.deadline} onChange={e => setNewTask({ ...newTask, deadline: e.target.value })} placeholder="Deadline" />
                                    <input type="time" className="form-input" style={{ width: '90px', fontSize: '0.8rem' }} value={newTask.deadlineTime} onChange={e => setNewTask({ ...newTask, deadlineTime: e.target.value })} placeholder="Time" />
                                </div>
                            </div>

                            <button className="btn-sm btn-primary" onClick={addTask}><Icon name="Plus" size={14} /></button>
                        </div>
                    </div>

                    <div style={{ flex: 1, overflowY: 'auto' }}>
                        <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '0.9rem' }}>
                            <thead>
                                <tr style={{ background: 'var(--bg-panel)', textAlign: 'left', position: 'sticky', top: 0, zIndex: 10 }}>
                                    <th style={{ padding: '0.75rem' }}>Task</th>
                                    <th style={{ padding: '0.75rem' }}>Details (Time/Pri)</th>
                                    <th style={{ padding: '0.75rem' }}>Recurrence / Deadline</th>
                                    <th style={{ padding: '0.75rem' }}>Assigned To</th>
                                    <th style={{ padding: '0.75rem', width: '50px' }}></th>
                                </tr>
                            </thead>
                            <tbody>
                                {visibleCategories.map(cat => {
                                    // Filter by Role as well
                                    const catTasks = safeTasks.filter(t =>
                                        t.category === cat &&
                                        (filterRole === 'ALL' || (t.assignTo && t.assignTo.includes(filterRole)))
                                    );

                                    if (catTasks.length === 0) return null;

                                    return (
                                        <React.Fragment key={cat}>
                                            {/* Category Header */}
                                            {filterCategory === 'ALL' && (
                                                <tr style={{ background: 'var(--bg-body)', borderBottom: '2px solid var(--border)' }}>
                                                    <td colSpan="5" style={{ padding: '0.5rem 0.75rem', fontWeight: 'bold', color: 'var(--accent)', fontSize: '0.9rem' }}>
                                                        {cat.toUpperCase()}
                                                    </td>
                                                </tr>
                                            )}

                                            {catTasks.map(task => (
                                                <tr key={task.id} style={{ borderBottom: '1px solid var(--border)' }}>
                                                    <td style={{ padding: '0.75rem', fontWeight: '500' }}>
                                                        <select
                                                            className="form-select"
                                                            style={{
                                                                width: '100%', fontSize: '0.7rem', padding: '0.1rem', marginBottom: '0.25rem',
                                                                border: 'none', background: 'var(--surface)', color: 'var(--text-secondary)'
                                                            }}
                                                            value={task.category}
                                                            onChange={e => handleTaskChange(task.id, 'category', e.target.value)}
                                                        >
                                                            {CATEGORIES.map(c => <option key={c} value={c}>{c}</option>)}
                                                        </select>
                                                        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                                            <input
                                                                className="form-input"
                                                                value={task.task}
                                                                onChange={e => handleTaskChange(task.id, 'task', e.target.value)}
                                                                style={{ width: '100%', border: 'none', background: 'transparent' }}
                                                            />
                                                            <button
                                                                onClick={() => setEditingNoteId(task.id)}
                                                                style={{
                                                                    border: 'none', background: 'none', cursor: 'pointer',
                                                                    opacity: task.notes ? 1 : 0.3,
                                                                    color: task.notes ? 'var(--accent)' : 'var(--text-secondary)'
                                                                }}
                                                                title="Add/Edit Notes"
                                                            >
                                                                <Icon name="FileText" size={16} />
                                                            </button>
                                                        </div>
                                                    </td>
                                                    <td style={{ padding: '0.75rem', display: 'flex', gap: '0.5rem' }}>
                                                        <select
                                                            className="form-select"
                                                            style={{ width: '90px', fontSize: '0.8rem', padding: '0.2rem' }}
                                                            value={task.priority || 'Medium'}
                                                            onChange={e => handleTaskChange(task.id, 'priority', e.target.value)}
                                                        >
                                                            <option value="High">🔥 High</option>
                                                            <option value="Medium">Medium</option>
                                                            <option value="Low">Low</option>
                                                        </select>
                                                        <input
                                                            className="form-input"
                                                            style={{ width: '60px', fontSize: '0.8rem', padding: '0.2rem' }}
                                                            placeholder="Time"
                                                            value={task.estimatedTime || ''}
                                                            onChange={e => handleTaskChange(task.id, 'estimatedTime', e.target.value)}
                                                        />
                                                    </td>
                                                    <td style={{ padding: '0.75rem' }}>
                                                        <select
                                                            className="form-select"
                                                            style={{ width: '100%', fontSize: '0.8rem', border: 'none', background: 'transparent' }}
                                                            value={task.recurrence}
                                                            onChange={e => handleTaskChange(task.id, 'recurrence', e.target.value)}
                                                        >
                                                            {RECURRENCE_OPTIONS.map(r => <option key={r} value={r}>{r}</option>)}
                                                        </select>
                                                        <div style={{ display: 'flex', gap: '0.5rem', marginTop: '0.5rem' }}>
                                                            <div style={{ flex: 1 }}>
                                                                <label style={{ fontSize: '0.7rem', color: 'var(--text-secondary)', fontWeight: '500', display: 'block', marginBottom: '0.25rem' }}>Assign Date</label>
                                                                <input
                                                                    type="date"
                                                                    className="form-input"
                                                                    style={{ fontSize: '0.8rem', width: '100%' }}
                                                                    value={task.assignDate || ''}
                                                                    onChange={e => handleTaskChange(task.id, 'assignDate', e.target.value)}
                                                                    placeholder="Assign Date"
                                                                />
                                                            </div>
                                                            <div style={{ flex: 1 }}>
                                                                <label style={{ fontSize: '0.7rem', color: 'var(--text-secondary)', fontWeight: '500', display: 'block', marginBottom: '0.25rem' }}>Deadline</label>
                                                                <div style={{ display: 'flex', gap: '0.25rem' }}>
                                                                    <input
                                                                        type="date"
                                                                        className="form-input"
                                                                        style={{ fontSize: '0.8rem', flex: 1 }}
                                                                        value={task.deadline || ''}
                                                                        onChange={e => handleTaskChange(task.id, 'deadline', e.target.value)}
                                                                        placeholder="Deadline"
                                                                    />
                                                                    <input
                                                                        type="time"
                                                                        className="form-input"
                                                                        style={{ fontSize: '0.8rem', width: '90px' }}
                                                                        value={task.deadlineTime || ''}
                                                                        onChange={e => handleTaskChange(task.id, 'deadlineTime', e.target.value)}
                                                                        placeholder="Time"
                                                                    />
                                                                    {task.deadline && (() => {
                                                                        const status = getDeadlineStatus(task.deadline, task.deadlineTime);
                                                                        if (!status || status === 'normal') return null;
                                                                        return (
                                                                            <span style={{
                                                                                fontSize: '1.2rem',
                                                                                color: getDeadlineColor(status),
                                                                                marginLeft: '0.25rem'
                                                                            }} title={status === 'overdue' ? 'Overdue!' : status === 'urgent' ? 'Due within 24 hours' : 'Due within 3 days'}>
                                                                                {status === 'overdue' ? '🔴' : status === 'urgent' ? '🟠' : '🟡'}
                                                                            </span>
                                                                        );
                                                                    })()}
                                                                </div>
                                                            </div>
                                                        </div>
                                                    </td>
                                                    <td style={{ padding: '0.75rem' }}>
                                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '0.25rem' }}>
                                                            {/* Collaboration Toggle (Visible if > 1 assignee) */}
                                                            {(task.assignTo && task.assignTo.length > 1) && (
                                                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '0.25rem', fontSize: '0.75rem', background: 'var(--surface)', padding: '2px 6px', borderRadius: '4px', width: 'fit-content' }}>
                                                                    <span style={{ color: 'var(--text-secondary)' }}>Type:</span>
                                                                    <label style={{ display: 'flex', alignItems: 'center', gap: '2px', cursor: 'pointer' }}>
                                                                        <input
                                                                            type="radio"
                                                                            name={`collab_${task.id}`}
                                                                            checked={task.collaborationType === 'Individual' || !task.collaborationType}
                                                                            onChange={() => handleCollaborationChange(task.id, 'Individual')}
                                                                        /> Solo
                                                                    </label>
                                                                    <label style={{ display: 'flex', alignItems: 'center', gap: '2px', cursor: 'pointer' }}>
                                                                        <input
                                                                            type="radio"
                                                                            name={`collab_${task.id}`}
                                                                            checked={task.collaborationType === 'Collaborative'}
                                                                            onChange={() => handleCollaborationChange(task.id, 'Collaborative')}
                                                                        /> Team
                                                                    </label>
                                                                </div>
                                                            )}

                                                            <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.25rem' }}>
                                                                {/* Display assigned pills */}
                                                                {(task.assignTo || []).map(a => (
                                                                    <span key={a} style={{
                                                                        fontSize: '0.75rem', padding: '2px 6px', borderRadius: '4px',
                                                                        background: 'var(--primary)', color: 'white', display: 'flex', alignItems: 'center', gap: '4px'
                                                                    }}>
                                                                        {a}
                                                                        <span
                                                                            onClick={() => toggleAssignee(task.id, a)}
                                                                            style={{ cursor: 'pointer', opacity: 0.8 }}
                                                                        >×</span>
                                                                    </span>
                                                                ))}

                                                                {/* Dropdown for adding */}
                                                                <div style={{ position: 'relative', display: 'inline-block' }}>
                                                                    <select
                                                                        className="form-select"
                                                                        style={{ width: '20px', padding: 0, height: '20px', opacity: 0 }}
                                                                        value=""
                                                                        onChange={e => {
                                                                            if (e.target.value) toggleAssignee(task.id, e.target.value);
                                                                        }}
                                                                    >
                                                                        <option value="">+</option>
                                                                        {ASSIGNMENT_OPTIONS.filter(o => !task.assignTo?.includes(o)).map(o => (
                                                                            <option key={o} value={o}>{o}</option>
                                                                        ))}
                                                                    </select>
                                                                    <Icon name="PlusCircle" size={18} color="var(--accent)" style={{ position: 'absolute', left: 0, top: 0, pointerEvents: 'none' }} />
                                                                </div>
                                                            </div>
                                                        </div>
                                                    </td>
                                                    <td style={{ padding: '0.75rem', textAlign: 'right' }}>
                                                        <button
                                                            onClick={() => deleteTask(task.id)}
                                                            style={{ border: 'none', background: 'none', color: '#ef4444', cursor: 'pointer', opacity: 0.6 }}
                                                            title="Delete Task"
                                                        >
                                                            <Icon name="X" size={16} />
                                                        </button>
                                                    </td>
                                                </tr>
                                            ))}
                                        </React.Fragment>
                                    );
                                })}
                            </tbody>
                        </table>
                    </div>
                </div>
            );
        };

        const ArchiveManager = ({ roster, staff, onUpdateRoster, onUpdateStaff }) => {
            const [tab, setTab] = useState('players'); // players | staff
            const archivedPlayers = roster.filter(p => p.archived);
            const archivedStaff = staff.filter(s => s.archived);

            const restorePlayer = (id) => {
                onUpdateRoster(roster.map(p => p.id === id ? { ...p, archived: false } : p));
            };

            const deletePlayerForever = (id) => {
                if (confirm("PERMANENT DELETE: This cannot be undone. Are you sure?")) {
                    onUpdateRoster(roster.filter(p => p.id !== id));
                }
            };

            const restoreStaff = (id) => {
                onUpdateStaff(staff.map(s => s.id === id ? { ...s, archived: false } : s));
            };

            const deleteStaffForever = (id) => {
                if (confirm("PERMANENT DELETE: This cannot be undone. Are you sure?")) {
                    onUpdateStaff(staff.filter(s => s.id !== id));
                }
            };

            return (
                <div style={{ height: 'calc(100vh - 100px)', display: 'flex', flexDirection: 'column' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '2rem' }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                            <h2>Archive Management</h2>
                        </div>
                        <div style={{ display: 'flex', gap: '1rem' }}>
                            <button className={`btn ${tab === 'players' ? 'btn-primary' : 'btn-secondary'}`} onClick={() => setTab('players')}>
                                Players ({archivedPlayers.length})
                            </button>
                            <button className={`btn ${tab === 'staff' ? 'btn-primary' : 'btn-secondary'}`} onClick={() => setTab('staff')}>
                                Staff ({archivedStaff.length})
                            </button>
                        </div>
                    </div>

                    <div className="card">
                        {tab === 'players' && (
                            <table className="table" style={{ width: '100%', borderCollapse: 'collapse' }}>
                                <thead>
                                    <tr style={{ borderBottom: '2px solid var(--border)' }}>
                                        <th style={{ textAlign: 'left', padding: '1rem' }}>Name</th>
                                        <th style={{ textAlign: 'left', padding: '1rem' }}>Position</th>
                                        <th style={{ textAlign: 'left', padding: '1rem' }}>Year</th>
                                        <th style={{ textAlign: 'right', padding: '1rem' }}>Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {archivedPlayers.map(p => (
                                        <tr key={p.id} style={{ borderBottom: '1px solid var(--border)' }}>
                                            <td style={{ padding: '1rem' }}>
                                                <div style={{ fontWeight: 'bold' }}>{p.name}</div>
                                                <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>#{p.number}</div>
                                            </td>
                                            <td style={{ padding: '1rem' }}>{p.position}</td>
                                            <td style={{ padding: '1rem' }}>{p.year}</td>
                                            <td style={{ padding: '1rem', textAlign: 'right', display: 'flex', gap: '0.5rem', justifyContent: 'flex-end' }}>
                                                <button className="btn btn-secondary" onClick={() => restorePlayer(p.id)} title="Restore to Roster">
                                                    <Icon name="Undo" size={16} /> Restore
                                                </button>
                                                <button className="btn btn-danger" onClick={() => deletePlayerForever(p.id)} title="Delete Permanently">
                                                    <Icon name="Trash" size={16} />
                                                </button>
                                            </td>
                                        </tr>
                                    ))}
                                    {archivedPlayers.length === 0 && (
                                        <tr>
                                            <td colSpan="4" style={{ textAlign: 'center', padding: '3rem', color: 'var(--text-secondary)' }}>
                                                No archived players found.
                                            </td>
                                        </tr>
                                    )}
                                </tbody>
                            </table>
                        )}

                        {tab === 'staff' && (
                            <table className="table" style={{ width: '100%', borderCollapse: 'collapse' }}>
                                <thead>
                                    <tr style={{ borderBottom: '2px solid var(--border)' }}>
                                        <th style={{ textAlign: 'left', padding: '1rem' }}>Name</th>
                                        <th style={{ textAlign: 'left', padding: '1rem' }}>Role</th>
                                        <th style={{ textAlign: 'left', padding: '1rem' }}>Email</th>
                                        <th style={{ textAlign: 'right', padding: '1rem' }}>Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {archivedStaff.map(s => (
                                        <tr key={s.id} style={{ borderBottom: '1px solid var(--border)' }}>
                                            <td style={{ padding: '1rem' }}>
                                                <div style={{ fontWeight: 'bold' }}>{s.name}</div>
                                            </td>
                                            <td style={{ padding: '1rem' }}>{s.role}</td>
                                            <td style={{ padding: '1rem' }}>{s.email}</td>
                                            <td style={{ padding: '1rem', textAlign: 'right', display: 'flex', gap: '0.5rem', justifyContent: 'flex-end' }}>
                                                <button className="btn btn-secondary" onClick={() => restoreStaff(s.id)} title="Restore to Staff">
                                                    <Icon name="Undo" size={16} /> Restore
                                                </button>
                                                <button className="btn btn-danger" onClick={() => deleteStaffForever(s.id)} title="Delete Permanently">
                                                    <Icon name="Trash" size={16} />
                                                </button>
                                            </td>
                                        </tr>
                                    ))}
                                    {archivedStaff.length === 0 && (
                                        <tr>
                                            <td colSpan="4" style={{ textAlign: 'center', padding: '3rem', color: 'var(--text-secondary)' }}>
                                                No archived staff found.
                                            </td>
                                        </tr>
                                    )}
                                </tbody>
                            </table>
                        )}
                    </div>
                </div>
            );
        };

        // -- Archive Manager --

        const StaffManager = ({ currentUser, staff, onUpdateStaff, dutyAssignments, onUpdateDuties, view = 'roster', masterTasks, onUpdateMasterTasks }) => {
            // view: 'roster' | 'duties'
            const [newMember, setNewMember] = useState({
                name: '', role: '', level: ['Varsity'], shirtSize: '',
                positions: { offense: '', offenseCoordinator: false, defense: '', defenseCoordinator: false, specials: { ko: '', kr: '', punt: '', pr: '', fg: '', block: '' }, specialsCoordinator: false },
                name: '', role: '', level: ['Varsity'], shirtSize: '', phone: '', email: '',
                positions: { offense: '', defense: '', specials: { ko: '', kr: '', punt: '', pr: '', fg: '', block: '' } },
                otherDuties: ''
            });

            const [isEditing, setIsEditing] = useState(null);
            const [selectedCoach, setSelectedCoach] = useState(null);

            // Drag and Drop Logic
            const handleDragStart = (e, id) => {
                e.dataTransfer.setData('staffId', id);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            };

            const handleDrop = (e, targetId) => {
                e.preventDefault();
                const draggedId = e.dataTransfer.getData('staffId');

                if (draggedId === targetId) return;

                const draggedIndex = staff.findIndex(m => m.id === draggedId);
                const targetIndex = staff.findIndex(m => m.id === targetId);

                if (draggedIndex === -1 || targetIndex === -1) return;

                const newStaff = [...staff];
                const [draggedItem] = newStaff.splice(draggedIndex, 1);
                newStaff.splice(targetIndex, 0, draggedItem);

                onUpdateStaff(newStaff);
            };

            const addMember = () => {
                // Email Invitation Logic
                if (newMember.email) {
                    const schoolId = localStorage.getItem('hc_school_id') || 'UNKNOWN';
                    const schoolName = localStorage.getItem('hc_school_name') || 'the team';
                    const coachName = currentUser?.displayName || 'Head Coach';

                    const subjectRaw = `Join the coaching staff at ${schoolName}`;
                    const bodyRaw = `Coach ${coachName} has added you to the staff.\n\n` +
                        `Please join the team using the following School ID:\n` +
                        `${schoolId}\n\n` +
                        `1. Log in to Digital DoFO\n` +
                        `2. Select "Join Existing School"\n` +
                        `3. Enter School ID: ${schoolId}`;

                    if (window.db) {
                        // Automated Email via Firebase Extension
                        window.db.collection('mail').add({
                            to: newMember.email,
                            message: {
                                subject: subjectRaw,
                                text: bodyRaw,
                                html: `<div style="font-family: sans-serif; padding: 20px;">
                                    <h2>Join ${schoolName}</h2>
                                    <p>Coach ${coachName} has added you to the staff.</p>
                                    <div style="background: #f3f4f6; padding: 15px; border-radius: 8px; margin: 20px 0;">
                                        <strong>School ID:</strong> <span style="font-family: monospace; font-size: 1.2em;">${schoolId}</span>
                                    </div>
                                    <ol>
                                        <li>Log in to <a href="https://digitaldofo.com">Digital DoFO</a></li>
                                        <li>Select "Join Existing School"</li>
                                        <li>Enter the School ID above</li>
                                    </ol>
                                </div>`
                            }
                        }).then(() => {
                            alert(`Invitation queued for ${newMember.email}. It should arrive shortly.`);
                        }).catch(err => {
                            console.error("Auto-email failed:", err);
                            // Fallback to mailto
                            window.location.href = `mailto:${newMember.email}?subject=${encodeURIComponent(subjectRaw)}&body=${encodeURIComponent(bodyRaw)}`;
                        });

                        // Auto-add to Access Control List
                        window.db.collection('config').doc('access').update({
                            allowedEmails: firebase.firestore.FieldValue.arrayUnion(newMember.email)
                        }).catch(err => console.warn("Could not update access list:", err));

                        // Create Invite Ticket (For Auto-Join)
                        window.db.collection('invites').doc(newMember.email.toLowerCase()).set({
                            schoolId: schoolId,
                            schoolName: schoolName,
                            role: newMember.role,
                            invitedBy: coachName,
                            invitedAt: new Date().toISOString(),
                            status: 'pending'
                        }).catch(err => console.error("Could not create invite ticket:", err));

                    } else {
                        window.location.href = `mailto:${newMember.email}?subject=${encodeURIComponent(subjectRaw)}&body=${encodeURIComponent(bodyRaw)}`;
                    }
                }

                const id = 'coach_' + Date.now();
                onUpdateStaff([...staff, { ...newMember, id }]);
                setNewMember({
                    name: '', role: '', level: ['Varsity'], shirtSize: '',
                    positions: { offense: '', offenseCoordinator: false, defense: '', defenseCoordinator: false, specials: { ko: '', kr: '', punt: '', pr: '', fg: '', block: '' }, specialsCoordinator: false },
                    name: '', role: '', level: ['Varsity'], shirtSize: '', phone: '', email: '',
                    positions: { offense: '', defense: '', specials: { ko: '', kr: '', punt: '', pr: '', fg: '', block: '' } },
                    otherDuties: ''
                });
            };

            const updateMember = (id, field, value) => {
                onUpdateStaff(staff.map(m => m.id === id ? { ...m, [field]: value } : m));
            };

            const updatePosition = (id, group, value) => {
                onUpdateStaff(staff.map(m => {
                    if (m.id !== id) return m;
                    return { ...m, positions: { ...m.positions, [group]: value } };
                }));
            };

            const updateSpecialsPosition = (id, unit, value) => {
                onUpdateStaff(staff.map(m => {
                    if (m.id !== id) return m;
                    return {
                        ...m,
                        positions: {
                            ...m.positions,
                            specials: { ...m.positions.specials, [unit]: value }
                        }
                    };
                }));
            };

            const deleteMember = (id) => {
                if (confirm('Are you sure you want to ARCHIVE this staff member? They can be restored from the Personnel > Archive menu.')) {
                    onUpdateStaff(staff.map(m => m.id === id ? { ...m, archived: true } : m));
                }
            };

            const formatSpecials = (specials) => {
                if (!specials) return '-';
                return Object.entries(specials)
                    .filter(([_, val]) => val)
                    .map(([key, val]) => `${key.toUpperCase()}: ${val}`)
                    .join(', ');
            };

            // Duty Draft Logic
            const [expandedCategories, setExpandedCategories] = useState({});
            const [dutyTab, setDutyTab] = useState('seasonal'); // 'seasonal' or 'recurring'

            if (view === 'duties') {
                return (
                    <TaskAssigner
                        tasks={masterTasks}
                        onUpdateTasks={onUpdateMasterTasks}
                        staff={staff}
                    />
                );
            }



            return (
                <div className="card" style={{ padding: '1.5rem', height: '100%', display: 'flex', flexDirection: 'column' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                        <h2 style={{ margin: 0 }}>Staff Manager</h2>
                    </div>

                    {selectedCoach ? (
                        <div style={{ flex: 1, overflowY: 'auto' }}>
                            <button className="btn btn-secondary" onClick={() => setSelectedCoach(null)} style={{ marginBottom: '1rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                <span>←</span> Back to Roster
                            </button>
                            <div className="card" style={{ marginBottom: '2rem', border: '1px solid var(--border)' }}>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '1rem', marginBottom: '1.5rem', borderBottom: '1px solid var(--border)', paddingBottom: '1rem' }}>
                                    <div style={{ width: '60px', height: '60px', borderRadius: '50%', background: 'var(--accent)', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '1.5rem', fontWeight: 'bold' }}>
                                        {selectedCoach.name.charAt(0)}
                                    </div>
                                    <div>
                                        <h2 style={{ margin: 0 }}>{selectedCoach.name}</h2>
                                        <div style={{ color: 'var(--text-secondary)' }}>
                                            {selectedCoach.role}
                                            {selectedCoach.type === 'Coach' && (
                                                <>
                                                    {(Array.isArray(selectedCoach.level) ? selectedCoach.level : [selectedCoach.level]).filter(Boolean).map(lvl => (
                                                        <span key={lvl} style={{
                                                            marginLeft: '0.5rem',
                                                            fontSize: '0.7rem',
                                                            padding: '2px 6px',
                                                            borderRadius: '4px',
                                                            background: 'var(--surface)',
                                                            border: '1px solid var(--border)',
                                                            verticalAlign: 'middle'
                                                        }}>
                                                            {lvl}
                                                        </span>
                                                    ))}
                                                </>
                                            )}
                                            {selectedCoach.type === 'Manager' && (
                                                <span style={{
                                                    marginLeft: '0.5rem',
                                                    fontSize: '0.7rem',
                                                    padding: '2px 6px',
                                                    borderRadius: '4px',
                                                    background: 'var(--surface)',
                                                    border: '1px solid var(--border)',
                                                    verticalAlign: 'middle'
                                                }}>
                                                    Manager
                                                </span>
                                            )}
                                        </div>
                                    </div>
                                </div>

                                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '3rem' }}>
                                    <div>
                                        <h4 style={{ color: 'var(--accent)', marginBottom: '1rem', textTransform: 'uppercase', fontSize: '0.85rem', letterSpacing: '1px' }}>Coaching Responsibilities</h4>
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                                            <div style={{ background: 'var(--surface)', padding: '0.75rem', borderRadius: '6px' }}>
                                                <div style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', marginBottom: '0.25rem' }}>Offense</div>
                                                <div>{selectedCoach.positions?.offense || '-'}</div>
                                            </div>
                                            <div style={{ background: 'var(--surface)', padding: '0.75rem', borderRadius: '6px' }}>
                                                <div style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', marginBottom: '0.25rem' }}>Defense</div>
                                                <div>{selectedCoach.positions?.defense || '-'}</div>
                                            </div>
                                        </div>
                                    </div>

                                    <div>
                                        <h4 style={{ color: 'var(--accent)', marginBottom: '1rem', textTransform: 'uppercase', fontSize: '0.85rem', letterSpacing: '1px' }}>Special Teams</h4>
                                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '0.5rem' }}>
                                            {Object.entries(selectedCoach.positions?.specials || {}).map(([unit, role]) => (
                                                role && (
                                                    <div key={unit} style={{ background: 'var(--surface)', padding: '0.5rem', borderRadius: '4px', fontSize: '0.9rem' }}>
                                                        <strong style={{ textTransform: 'uppercase', marginRight: '0.5rem' }}>{unit}:</strong> {role}
                                                    </div>
                                                )
                                            ))}
                                            {(!selectedCoach.positions?.specials || Object.values(selectedCoach.positions.specials).every(v => !v)) && (
                                                <div style={{ gridColumn: '1 / -1', color: 'var(--text-secondary)', fontStyle: 'italic' }}>No special teams assigned</div>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    ) : (
                        <div style={{ flex: 1, overflowY: 'auto' }}>
                            {(() => {
                                const coaches = staff.filter(m => !m.type || m.type === 'Coach');
                                const managers = staff.filter(m => m.type && m.type !== 'Coach');

                                const renderStaffTable = (list, title) => (
                                    <div style={{ marginBottom: '2rem' }}>
                                        <h3 style={{ borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem', marginBottom: '1rem', color: 'var(--accent)' }}>{title} ({list.length})</h3>
                                        <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                                            <thead>
                                                <tr style={{ textAlign: 'left', color: 'var(--text-secondary)', fontSize: '0.85rem', borderBottom: '1px solid var(--border)' }}>
                                                    <th style={{ padding: '0.5rem', width: '30px' }}></th>
                                                    <th style={{ padding: '0.5rem', width: '22%' }}>Name</th>
                                                    <th style={{ padding: '0.5rem', width: '13%' }}>Role</th>
                                                    <th style={{ padding: '0.5rem', width: '18%' }}>Contact</th>
                                                    <th style={{ padding: '0.5rem', width: '5%' }}>Size</th>
                                                    <th style={{ padding: '0.5rem', width: '22%' }}>Assignments</th>
                                                    <th style={{ padding: '0.5rem', width: '8%', textAlign: 'center' }} title="Admin can access Settings and View As menu">Admin</th>
                                                    <th style={{ padding: '0.5rem', width: '10%' }}></th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {list.map(member => (
                                                    <tr
                                                        key={member.id}
                                                        style={{ borderBottom: '1px solid var(--border)', cursor: 'move' }}
                                                        draggable
                                                        onDragStart={(e) => handleDragStart(e, member.id)}
                                                        onDragOver={handleDragOver}
                                                        onDrop={(e) => handleDrop(e, member.id)}
                                                    >
                                                        <td style={{ padding: '0.75rem 0.5rem', color: 'var(--text-secondary)' }}>
                                                            <div style={{ cursor: 'grab' }}>⋮⋮</div>
                                                        </td>
                                                        <td style={{ padding: '0.75rem 0.5rem' }}>
                                                            {isEditing === member.id ? (
                                                                <input
                                                                    className="form-input"
                                                                    value={member.name}
                                                                    onChange={e => updateMember(member.id, 'name', e.target.value)}
                                                                />
                                                            ) : (
                                                                <button
                                                                    onClick={() => setSelectedCoach(member)}
                                                                    style={{
                                                                        background: 'none', border: 'none',
                                                                        color: 'var(--text-primary)', fontWeight: 'bold',
                                                                        cursor: 'pointer', textAlign: 'left', padding: 0,
                                                                        fontSize: '1rem'
                                                                    }}
                                                                >
                                                                    {member.name}
                                                                </button>
                                                            )}
                                                        </td>
                                                        <td style={{ padding: '0.75rem 0.5rem' }}>
                                                            {isEditing === member.id ? (
                                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                                                    <input
                                                                        className="form-input"
                                                                        value={member.role || (member.roles ? member.roles.join(', ') : '')}
                                                                        onChange={e => updateMember(member.id, 'role', e.target.value)}
                                                                        placeholder="Role"
                                                                    />
                                                                    <select
                                                                        className="form-select"
                                                                        value={member.type || 'Coach'}
                                                                        onChange={e => updateMember(member.id, 'type', e.target.value)}
                                                                        style={{ fontSize: '0.8rem', padding: '0.2rem' }}
                                                                    >
                                                                        <option value="Coach">Coach</option>
                                                                        <option value="Student Manager">Student Manager</option>
                                                                        <option value="Stats">Stats</option>
                                                                        <option value="Trainer">Trainer</option>
                                                                    </select>
                                                                    {(!member.type || member.type === 'Coach') && (
                                                                        <div style={{ display: 'flex', gap: '0.25rem', flexWrap: 'wrap' }}>
                                                                            {['Varsity', 'JV', 'JV2'].map(lvl => {
                                                                                const currentLevels = Array.isArray(member.level) ? member.level : (member.level ? [member.level] : ['Varsity']);
                                                                                const isActive = currentLevels.includes(lvl);
                                                                                return (
                                                                                    <button
                                                                                        key={lvl}
                                                                                        onClick={() => {
                                                                                            const newLevels = isActive
                                                                                                ? currentLevels.filter(l => l !== lvl)
                                                                                                : [...currentLevels, lvl];
                                                                                            updateMember(member.id, 'level', newLevels);
                                                                                        }}
                                                                                        style={{
                                                                                            padding: '2px 6px',
                                                                                            fontSize: '0.7rem',
                                                                                            borderRadius: '4px',
                                                                                            border: `1px solid ${isActive ? 'var(--accent)' : 'var(--border)'}`,
                                                                                            background: isActive ? 'var(--accent-bg)' : 'transparent',
                                                                                            color: isActive ? 'var(--accent)' : 'var(--text-secondary)',
                                                                                            cursor: 'pointer'
                                                                                        }}
                                                                                    >
                                                                                        {lvl}
                                                                                    </button>
                                                                                );
                                                                            })}
                                                                        </div>
                                                                    )}
                                                                </div>
                                                            ) : (
                                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.25rem' }}>
                                                                    <div style={{ fontWeight: 500 }}>{member.role || (member.roles ? member.roles.join(', ') : '')}</div>
                                                                    {member.level && (
                                                                        <div style={{ display: 'flex', gap: '0.25rem', flexWrap: 'wrap' }}>
                                                                            {(Array.isArray(member.level) ? member.level : [member.level]).filter(Boolean).map((lvl, i) => (
                                                                                <span key={i} style={{
                                                                                    fontSize: '0.75rem',
                                                                                    padding: '0.1rem 0.4rem',
                                                                                    borderRadius: '4px',
                                                                                    background: 'var(--bg-tertiary)',
                                                                                    border: '1px solid var(--border)'
                                                                                }}>
                                                                                    {lvl}
                                                                                </span>
                                                                            ))}
                                                                        </div>
                                                                    )}
                                                                </div>
                                                            )}
                                                        </td>
                                                        <td style={{ padding: '0.75rem 0.5rem' }}>
                                                            {isEditing === member.id ? (
                                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                                                    <input
                                                                        className="form-input"
                                                                        value={member.phone || ''}
                                                                        onChange={e => updateMember(member.id, 'phone', e.target.value)}
                                                                        placeholder="Phone"
                                                                    />
                                                                    <input
                                                                        className="form-input"
                                                                        value={member.email || ''}
                                                                        onChange={e => updateMember(member.id, 'email', e.target.value)}
                                                                        placeholder="Email"
                                                                    />
                                                                </div>
                                                            ) : (
                                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.25rem', fontSize: '0.9rem' }}>
                                                                    {member.phone && (
                                                                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                                            <Icon name="Phone" size={14} style={{ color: 'var(--text-secondary)' }} />
                                                                            <span>{member.phone}</span>
                                                                        </div>
                                                                    )}
                                                                    {member.email && (
                                                                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                                            <Icon name="Mail" size={14} style={{ color: 'var(--text-secondary)' }} />
                                                                            <span>{member.email}</span>
                                                                        </div>
                                                                    )}
                                                                    {!member.phone && !member.email && <span style={{ opacity: 0.5 }}>-</span>}
                                                                </div>
                                                            )}
                                                        </td>
                                                        <td style={{ padding: '0.75rem 0.5rem' }}>
                                                            {isEditing === member.id ? (
                                                                <select
                                                                    className="form-select"
                                                                    value={member.shirtSize || ''}
                                                                    onChange={e => updateMember(member.id, 'shirtSize', e.target.value)}
                                                                >
                                                                    <option value="">-</option>
                                                                    {['XS', 'S', 'M', 'L', 'XL', '2XL', '3XL', '4XL'].map(sz => (
                                                                        <option key={sz} value={sz}>{sz}</option>
                                                                    ))}
                                                                </select>
                                                            ) : (
                                                                <span style={{
                                                                    padding: '0.2rem 0.5rem',
                                                                    background: 'var(--bg-tertiary)',
                                                                    borderRadius: '4px',
                                                                    fontSize: '0.85rem'
                                                                }}>
                                                                    {member.shirtSize || '-'}
                                                                </span>
                                                            )}
                                                        </td>
                                                        <td style={{ padding: '0.75rem 0.5rem', fontSize: '0.9rem' }}>
                                                            {isEditing === member.id ? (
                                                                <div style={{ display: 'grid', gridTemplateColumns: '30px 35px 1fr', gap: '0.5rem', alignItems: 'center' }}>
                                                                    {/* Header row */}
                                                                    <span style={{ color: 'var(--text-secondary)', fontSize: '0.8rem' }}>Off</span>
                                                                    <span style={{ color: 'var(--text-secondary)', fontSize: '0.7rem', textAlign: 'center' }}>Coord</span>
                                                                    <span></span>
                                                                    {/* Offense row */}
                                                                    <span></span>
                                                                    <input type="checkbox" checked={member.positions?.offenseCoordinator || false} onChange={e => updatePosition(member.id, 'offenseCoordinator', e.target.checked)} title="Coordinator" style={{ cursor: 'pointer', justifySelf: 'center' }} />
                                                                    <input
                                                                        className="form-input"
                                                                        value={member.positions?.offense || ''}
                                                                        onChange={e => updatePosition(member.id, 'offense', e.target.value)}
                                                                        placeholder="Position"
                                                                    />
                                                                    {/* Defense header */}
                                                                    <span style={{ color: 'var(--text-secondary)', fontSize: '0.8rem' }}>Def</span>
                                                                    <span style={{ color: 'var(--text-secondary)', fontSize: '0.7rem', textAlign: 'center' }}>Coord</span>
                                                                    <span></span>
                                                                    {/* Defense row */}
                                                                    <span></span>
                                                                    <input type="checkbox" checked={member.positions?.defenseCoordinator || false} onChange={e => updatePosition(member.id, 'defenseCoordinator', e.target.checked)} title="Coordinator" style={{ cursor: 'pointer', justifySelf: 'center' }} />
                                                                    <input
                                                                        className="form-input"
                                                                        value={member.positions?.defense || ''}
                                                                        onChange={e => updatePosition(member.id, 'defense', e.target.value)}
                                                                        placeholder="Position"
                                                                    />
                                                                    {/* Specials header */}
                                                                    <span style={{ color: 'var(--text-secondary)', fontSize: '0.8rem' }}>Spc</span>
                                                                    <span style={{ color: 'var(--text-secondary)', fontSize: '0.7rem', textAlign: 'center' }}>Coord</span>
                                                                    <span></span>
                                                                    {/* Specials row */}
                                                                    <span></span>
                                                                    <input type="checkbox" checked={member.positions?.specialsCoordinator || false} onChange={e => updatePosition(member.id, 'specialsCoordinator', e.target.checked)} title="Coordinator" style={{ cursor: 'pointer', justifySelf: 'center' }} />
                                                                    <input
                                                                        className="form-input"
                                                                        value={typeof member.positions?.specials === 'object' ? 'See Details' : (member.positions?.specials || '')}
                                                                        disabled={typeof member.positions?.specials === 'object'}
                                                                        onChange={e => updatePosition(member.id, 'specials', e.target.value)}
                                                                        title={typeof member.positions?.specials === 'object' ? "Edit in Detail View" : ""}
                                                                        placeholder="Position"
                                                                    />
                                                                </div>
                                                            ) : (
                                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.25rem' }}>
                                                                    {member.positions?.offense && <div><span style={{ color: 'var(--text-secondary)' }}>Off{member.positions.offenseCoordinator ? ' (C)' : ''}:</span> {member.positions.offense}</div>}
                                                                    {member.positions?.defense && <div><span style={{ color: 'var(--text-secondary)' }}>Def{member.positions.defenseCoordinator ? ' (C)' : ''}:</span> {member.positions.defense}</div>}
                                                                    {(member.positions?.specials && member.positions.specials !== ' - ') && (
                                                                        <div><span style={{ color: 'var(--text-secondary)' }}>Spc{member.positions.specialsCoordinator ? ' (C)' : ''}:</span> {typeof member.positions.specials === 'object' ? formatSpecials(member.positions.specials) : member.positions.specials}</div>
                                                                    )}
                                                                </div>
                                                            )}
                                                        </td>
                                                        <td style={{ padding: '0.75rem 0.5rem', textAlign: 'center' }}>
                                                            <input
                                                                type="checkbox"
                                                                checked={member.isAdmin || false}
                                                                onChange={e => updateMember(member.id, 'isAdmin', e.target.checked)}
                                                                style={{ cursor: 'pointer', width: '18px', height: '18px' }}
                                                                title="Grant admin access to Settings and View As menu"
                                                            />
                                                        </td>
                                                        <td style={{ padding: '0.75rem 0.5rem' }}>
                                                            <div style={{ display: 'flex', gap: '0.5rem', justifyContent: 'flex-end' }}>
                                                                {isEditing === member.id ? (
                                                                    <button className="btn btn-primary btn-sm" onClick={() => setIsEditing(null)}>Save</button>
                                                                ) : (
                                                                    <>
                                                                        <button
                                                                            onClick={() => setIsEditing(member.id)}
                                                                            style={{
                                                                                background: 'none',
                                                                                border: 'none',
                                                                                padding: '6px 10px',
                                                                                cursor: 'pointer',
                                                                                borderRadius: '6px',
                                                                                transition: 'all 0.2s',
                                                                                display: 'inline-flex',
                                                                                alignItems: 'center',
                                                                                justifyContent: 'center',
                                                                                color: 'var(--text-secondary)'
                                                                            }}
                                                                            onMouseEnter={e => e.currentTarget.style.background = 'var(--bg-tertiary)'}
                                                                            onMouseLeave={e => e.currentTarget.style.background = 'none'}
                                                                            title="Edit"
                                                                        >
                                                                            <Icon name="Edit2" size={16} />
                                                                        </button>
                                                                        <button
                                                                            onClick={() => deleteMember(member.id)}
                                                                            style={{
                                                                                background: 'none',
                                                                                border: 'none',
                                                                                padding: '6px 10px',
                                                                                cursor: 'pointer',
                                                                                borderRadius: '6px',
                                                                                transition: 'all 0.2s',
                                                                                display: 'inline-flex',
                                                                                alignItems: 'center',
                                                                                justifyContent: 'center',
                                                                                color: 'var(--text-secondary)'
                                                                            }}
                                                                            onMouseEnter={e => {
                                                                                e.currentTarget.style.background = 'rgba(239, 68, 68, 0.1)';
                                                                                e.currentTarget.style.color = '#ef4444';
                                                                            }}
                                                                            onMouseLeave={e => {
                                                                                e.currentTarget.style.background = 'none';
                                                                                e.currentTarget.style.color = 'var(--text-secondary)';
                                                                            }}
                                                                            title="Delete"
                                                                        >
                                                                            <Icon name="Trash2" size={16} />
                                                                        </button>
                                                                    </>
                                                                )}
                                                            </div>
                                                        </td>

                                                    </tr>
                                                ))}
                                            </tbody>
                                        </table>
                                    </div>
                                );

                                return (
                                    <>
                                        {renderStaffTable(coaches, "Coaching Staff")}
                                        {renderStaffTable(managers, "Managers & Support Staff")}
                                    </>
                                );
                            })()}

                            <div className="card" style={{ marginTop: '2rem', padding: '1.5rem', border: '1px solid var(--border)' }}>
                                <h3 style={{ marginTop: 0, marginBottom: '1.5rem' }}>Add New Staff Member</h3>
                                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1.5rem' }}>
                                    <div>
                                        <label className="form-label">Name</label>
                                        <input
                                            className="form-input"
                                            value={newMember.name}
                                            onChange={e => setNewMember({ ...newMember, name: e.target.value })}
                                            placeholder="Coach Name"
                                        />
                                    </div>
                                    <div>
                                        <label className="form-label">Role</label>
                                        <select
                                            className="form-select"
                                            value={newMember.role}
                                            onChange={e => setNewMember({ ...newMember, role: e.target.value })}
                                        >
                                            <option value="">Select Role...</option>
                                            <option value="Head Coach">Head Coach</option>
                                            <option value="Assistant">Assistant</option>
                                            <option value="Student Manager">Student Manager</option>
                                            <option value="Trainer">Trainer</option>
                                            <option value="Stats">Stats</option>
                                        </select>
                                    </div>

                                    <div>
                                        <label className="form-label" style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer', marginTop: '30px' }}>
                                            <input
                                                type="checkbox"
                                                checked={newMember.isAdmin || false}
                                                onChange={e => setNewMember({ ...newMember, isAdmin: e.target.checked })}
                                                style={{ width: '18px', height: '18px' }}
                                            />
                                            <span>Grant Admin Privileges</span>
                                        </label>
                                    </div>

                                    <div>
                                        <label className="form-label">Type</label>
                                        <select
                                            className="form-select"
                                            value={newMember.type || 'Coach'}
                                            onChange={e => setNewMember({ ...newMember, type: e.target.value })}
                                        >
                                            <option value="Coach">Coach</option>
                                            <option value="Student Manager">Student Manager</option>
                                            <option value="Stats">Stats</option>
                                            <option value="Trainer">Trainer</option>
                                        </select>
                                    </div>

                                    <div>
                                        <label className="form-label">Shirt Size</label>
                                        <select
                                            className="form-select"
                                            value={newMember.shirtSize || ''}
                                            onChange={e => setNewMember({ ...newMember, shirtSize: e.target.value })}
                                        >
                                            <option value="">Select Size</option>
                                            {['XS', 'S', 'M', 'L', 'XL', '2XL', '3XL', '4XL'].map(sz => (
                                                <option key={sz} value={sz}>{sz}</option>
                                            ))}
                                        </select>
                                    </div>

                                    <div>
                                        <label className="form-label">Phone</label>
                                        <input
                                            className="form-input"
                                            value={newMember.phone || ''}
                                            onChange={e => setNewMember({ ...newMember, phone: e.target.value })}
                                            placeholder="(555) 555-5555"
                                        />
                                    </div>
                                    <div>
                                        <label className="form-label">Email</label>
                                        <input
                                            className="form-input"
                                            value={newMember.email || ''}
                                            onChange={e => setNewMember({ ...newMember, email: e.target.value })}
                                            placeholder="coach@example.com"
                                        />
                                    </div>

                                    {(!newMember.type || newMember.type === 'Coach') && (
                                        <div>
                                            <label className="form-label">Level(s)</label>
                                            <div style={{ display: 'flex', gap: '0.5rem' }}>
                                                {['Varsity', 'JV', 'JV2'].map(lvl => {
                                                    const currentLevels = Array.isArray(newMember.level) ? newMember.level : (newMember.level ? [newMember.level] : ['Varsity']);
                                                    const isActive = currentLevels.includes(lvl);
                                                    return (
                                                        <button
                                                            key={lvl}
                                                            onClick={() => {
                                                                const newLevels = isActive
                                                                    ? currentLevels.filter(l => l !== lvl)
                                                                    : [...currentLevels, lvl];
                                                                setNewMember({ ...newMember, level: newLevels });
                                                            }}
                                                            style={{
                                                                flex: 1,
                                                                padding: '0.5rem',
                                                                borderRadius: '4px',
                                                                border: `1px solid ${isActive ? 'var(--accent)' : 'var(--border)'}`,
                                                                background: isActive ? 'var(--accent-bg)' : 'transparent',
                                                                color: isActive ? 'var(--accent)' : 'var(--text-secondary)',
                                                                cursor: 'pointer',
                                                                fontSize: '0.9rem',
                                                                transition: 'all 0.2s'
                                                            }}
                                                        >
                                                            {lvl}
                                                        </button>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                    )}

                                    <div>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem' }}>
                                            <label className="form-label" style={{ marginBottom: 0 }}>Offensive Assignment</label>
                                            <label style={{ display: 'flex', alignItems: 'center', gap: '5px', fontSize: '0.8rem', cursor: 'pointer' }}>
                                                <input
                                                    type="checkbox"
                                                    checked={newMember.positions.offenseCoordinator || false}
                                                    onChange={e => setNewMember({ ...newMember, positions: { ...newMember.positions, offenseCoordinator: e.target.checked } })}
                                                />
                                                Coordinator
                                            </label>
                                        </div>
                                        <input
                                            className="form-input"
                                            value={newMember.positions.offense}
                                            onChange={e => setNewMember({ ...newMember, positions: { ...newMember.positions, offense: e.target.value } })}
                                            placeholder="e.g. QBs"
                                        />
                                    </div>
                                    <div>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem' }}>
                                            <label className="form-label" style={{ marginBottom: 0 }}>Defensive Assignment</label>
                                            <label style={{ display: 'flex', alignItems: 'center', gap: '5px', fontSize: '0.8rem', cursor: 'pointer' }}>
                                                <input
                                                    type="checkbox"
                                                    checked={newMember.positions.defenseCoordinator || false}
                                                    onChange={e => setNewMember({ ...newMember, positions: { ...newMember.positions, defenseCoordinator: e.target.checked } })}
                                                />
                                                Coordinator
                                            </label>
                                        </div>
                                        <input
                                            className="form-input"
                                            value={newMember.positions.defense}
                                            onChange={e => setNewMember({ ...newMember, positions: { ...newMember.positions, defense: e.target.value } })}
                                            placeholder="e.g. LBs"
                                        />
                                    </div>
                                </div>
                                <div style={{ marginTop: '1.5rem', textAlign: 'right' }}>
                                    <button
                                        className="btn btn-primary"
                                        onClick={addMember}
                                        disabled={!newMember.name || !newMember.role}
                                    >
                                        Add Staff Member
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Special Teams Dashboard Component
        const SpecialTeamsDashboard = ({ roster, depthCharts, onUpdateDepthChart, savedLayouts, onUpdateLayout, onResetLayout, opponentData, onUpdateOpponentData, customPositions = {}, hiddenPositions = {}, positionNames = {} }) => {
            const [kickerDistance, setKickerDistance] = useState(opponentData?.kickerDistance || 50);
            const [punterDistance, setPunterDistance] = useState(opponentData?.punterDistance || 45);
            const [yardLine, setYardLine] = useState(35);
            const [searchQuery, setSearchQuery] = useState('');

            // Calculate returner placement
            const calculateReturnerPlacement = () => {
                // Simple calculation: where the ball will land minus a safety buffer
                const kickLandingZone = 100 - yardLine - kickerDistance;
                const puntLandingZone = 100 - yardLine - punterDistance;

                return {
                    kickReturn: Math.max(kickLandingZone - 5, 0), // 5 yard safety buffer
                    puntReturn: Math.max(puntLandingZone - 5, 0)
                };
            };

            const placement = calculateReturnerPlacement();

            // Update player status
            const updatePlayerStatus = (playerId, status) => {
                const currentAvailability = opponentData.playerAvailability || {};
                const updatedAvailability = {
                    ...currentAvailability,
                    [playerId]: {
                        status,
                        timestamp: new Date().toISOString()
                    }
                };
                onUpdateOpponentData({
                    ...opponentData,
                    playerAvailability: updatedAvailability
                });
            };

            // Update opponent data when values change
            useEffect(() => {
                if (onUpdateOpponentData) {
                    onUpdateOpponentData({ ...opponentData, kickerDistance, punterDistance });
                }
            }, [kickerDistance, punterDistance]);


            const stCharts = [
                { type: 'KICKOFF', title: 'Kickoff' },
                { type: 'KICK_RETURN', title: 'Kick Return' },
                { type: 'PUNT', title: 'Punt' },
                { type: 'PUNT_RETURN', title: 'Punt Return' },
                { type: 'FIELD_GOAL', title: 'Field Goal / PAT' },
                { type: 'HANDS_TEAM', title: 'Hands Team' },
                { type: 'ONSIDE_KICK', title: 'Onside Kick' },
                { type: 'PAT_BLOCK', title: 'PAT Block' }
            ];

            return (
                <div style={{ padding: '2rem' }}>
                    <h2 style={{ marginBottom: '2rem' }}>Special Teams Dashboard</h2>

                    {/* Player Availability Tracker */}
                    <div style={{
                        backgroundColor: 'rgba(255, 255, 255, 0.02)',
                        border: '1px solid var(--border)',
                        borderRadius: '8px',
                        padding: '1.5rem',
                        marginBottom: '2rem'
                    }}>
                        <h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Player Availability</h3>

                        <div style={{ marginBottom: '1rem', display: 'flex', gap: '1rem', alignItems: 'center' }}>
                            <input
                                type="text"
                                className="form-input"
                                placeholder="Search players..."
                                value={searchQuery}
                                onChange={e => setSearchQuery(e.target.value)}
                                style={{ maxWidth: '300px' }}
                            />
                            <div style={{ display: 'flex', gap: '0.5rem', fontSize: '0.9rem' }}>
                                <span>Legend:</span>
                                <span style={{ color: '#10b981' }}>🟢 Available</span>
                                <span style={{ color: '#f59e0b' }}>🟡 Questionable</span>
                                <span style={{ color: '#ef4444' }}>🔴 OUT</span>
                            </div>
                        </div>

                        <div style={{ maxHeight: '400px', overflowY: 'auto', border: '1px solid var(--border)', borderRadius: '4px' }}>
                            <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                                <thead style={{ position: 'sticky', top: 0, backgroundColor: 'var(--bg)', zIndex: 1 }}>
                                    <tr style={{ borderBottom: '2px solid var(--border)' }}>
                                        <th style={{ padding: '0.75rem', textAlign: 'left' }}>#</th>
                                        <th style={{ padding: '0.75rem', textAlign: 'left' }}>Name</th>
                                        <th style={{ padding: '0.75rem', textAlign: 'left' }}>Pos</th>
                                        <th style={{ padding: '0.75rem', textAlign: 'center' }}>Status</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {roster
                                        .filter(player =>
                                            !searchQuery ||
                                            player.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
                                            player.number.toString().includes(searchQuery) ||
                                            player.position.toLowerCase().includes(searchQuery.toLowerCase())
                                        )
                                        .filter(Boolean).sort((a, b) => (a?.name || '').localeCompare(b?.name || ''))
                                        .map(player => {
                                            const status = (opponentData.playerAvailability || {})[player.id]?.status || 'available';
                                            return (
                                                <tr key={player.id} style={{ borderBottom: '1px solid var(--border)' }}>
                                                    <td style={{ padding: '0.75rem' }}>{player.number}</td>
                                                    <td style={{ padding: '0.75rem', fontWeight: '500' }}>{player.name}</td>
                                                    <td style={{ padding: '0.75rem' }}>{player.position}</td>
                                                    <td style={{ padding: '0.75rem' }}>
                                                        <div style={{ display: 'flex', gap: '0.25rem', justifyContent: 'center' }}>
                                                            <button
                                                                onClick={() => updatePlayerStatus(player.id, 'available')}
                                                                style={{
                                                                    padding: '0.25rem 0.5rem',
                                                                    border: status === 'available' ? '2px solid #10b981' : '1px solid var(--border)',
                                                                    backgroundColor: status === 'available' ? 'rgba(16, 185, 129, 0.2)' : 'transparent',
                                                                    borderRadius: '4px',
                                                                    cursor: 'pointer',
                                                                    fontSize: '0.85rem'
                                                                }}
                                                            >
                                                                🟢
                                                            </button>
                                                            <button
                                                                onClick={() => updatePlayerStatus(player.id, 'questionable')}
                                                                style={{
                                                                    padding: '0.25rem 0.5rem',
                                                                    border: status === 'questionable' ? '2px solid #f59e0b' : '1px solid var(--border)',
                                                                    backgroundColor: status === 'questionable' ? 'rgba(245, 158, 11, 0.2)' : 'transparent',
                                                                    borderRadius: '4px',
                                                                    cursor: 'pointer',
                                                                    fontSize: '0.85rem'
                                                                }}
                                                            >
                                                                🟡
                                                            </button>
                                                            <button
                                                                onClick={() => updatePlayerStatus(player.id, 'out')}
                                                                style={{
                                                                    padding: '0.25rem 0.5rem',
                                                                    border: status === 'out' ? '2px solid #ef4444' : '1px solid var(--border)',
                                                                    backgroundColor: status === 'out' ? 'rgba(239, 68, 68, 0.2)' : 'transparent',
                                                                    borderRadius: '4px',
                                                                    cursor: 'pointer',
                                                                    fontSize: '0.85rem'
                                                                }}
                                                            >
                                                                🔴
                                                            </button>
                                                        </div>
                                                    </td>
                                                </tr>
                                            );
                                        })}
                                </tbody>
                            </table>
                        </div>
                    </div>

                    {/* Returner Placement Calculator */}
                    <div style={{
                        backgroundColor: 'rgba(56, 189, 248, 0.1)',
                        border: '1px solid var(--accent)',
                        borderRadius: '8px',
                        padding: '1.5rem',
                        marginBottom: '2rem'
                    }}>
                        <h3 style={{ marginTop: 0, marginBottom: '1rem', color: 'var(--accent)' }}>Returner Placement Calculator</h3>

                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1rem', marginBottom: '1.5rem' }}>
                            <div>
                                <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: 'bold' }}>
                                    Opponent Kicker Max Distance (yds)
                                </label>
                                <input
                                    type="number"
                                    className="form-input"
                                    value={kickerDistance}
                                    onChange={e => setKickerDistance(parseInt(e.target.value) || 0)}
                                    style={{ width: '100%' }}
                                />
                            </div>

                            <div>
                                <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: 'bold' }}>
                                    Opponent Punter Max Distance (yds)
                                </label>
                                <input
                                    type="number"
                                    className="form-input"
                                    value={punterDistance}
                                    onChange={e => setPunterDistance(parseInt(e.target.value) || 0)}
                                    style={{ width: '100%' }}
                                />
                            </div>

                            <div>
                                <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: 'bold' }}>
                                    Line of Scrimmage (yard line)
                                </label>
                                <input
                                    type="number"
                                    className="form-input"
                                    value={yardLine}
                                    onChange={e => setYardLine(parseInt(e.target.value) || 0)}
                                    min="0"
                                    max="100"
                                    style={{ width: '100%' }}
                                />
                            </div>
                        </div>

                        <div style={{
                            display: 'grid',
                            gridTemplateColumns: '1fr 1fr',
                            gap: '1rem',
                            padding: '1rem',
                            backgroundColor: 'rgba(0, 0, 0, 0.2)',
                            borderRadius: '4px'
                        }}>
                            <div>
                                <div style={{ fontSize: '0.9rem', color: 'var(--text-secondary)', marginBottom: '0.25rem' }}>
                                    Kick Return - Suggested Returner Depth:
                                </div>
                                <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: 'var(--accent)' }}>
                                    {placement.kickReturn} yards
                                </div>
                            </div>
                            <div>
                                <div style={{ fontSize: '0.9rem', color: 'var(--text-secondary)', marginBottom: '0.25rem' }}>
                                    Punt Return - Suggested Returner Depth:
                                </div>
                                <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: 'var(--accent)' }}>
                                    {placement.puntReturn} yards
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Special Teams Depth Charts */}
                    <h3 style={{ marginBottom: '1.5rem' }}>Special Teams Depth Charts</h3>
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '2rem' }}>
                        {stCharts.map(chart => (
                            <div key={chart.type} style={{
                                border: '1px solid var(--border)',
                                borderRadius: '8px',
                                padding: '1rem',
                                backgroundColor: 'rgba(255, 255, 255, 0.02)'
                            }}>
                                <DepthChart
                                    roster={roster}
                                    depthChart={depthCharts[chart.type] || {}}
                                    onUpdateDepthChart={(updated) => onUpdateDepthChart(chart.type, updated)}
                                    chartType={chart.type}
                                    savedLayout={savedLayouts[chart.type] || {}}
                                    onUpdateLayout={(layout) => onUpdateLayout(chart.type, layout)}
                                    onResetLayout={() => onResetLayout(chart.type)}
                                    customPositions={customPositions}
                                    hiddenPositions={hiddenPositions}
                                    positionNames={positionNames}
                                />
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        // Searchable Player Dropdown Component
        const SearchablePlayerDropdown = ({ roster, value, onChange, style, depthChart }) => {
            const [isOpen, setIsOpen] = useState(false);
            const [searchTerm, setSearchTerm] = useState('');
            const [highlightedIndex, setHighlightedIndex] = useState(0);
            const dropdownRef = useRef(null);
            const inputRef = useRef(null);

            // Filter roster based on search term
            const filteredRoster = useMemo(() => {
                if (!searchTerm.trim()) return roster;
                const term = searchTerm.toLowerCase();
                return roster.filter(p =>
                    p.name.toLowerCase().includes(term) ||
                    (p.number && p.number.toString().includes(term))
                );
            }, [roster, searchTerm]);

            // Get selected player
            const selectedPlayer = roster.find(p => p.id === value);

            // Close dropdown when clicking outside
            useEffect(() => {
                const handleClickOutside = (e) => {
                    if (dropdownRef.current && !dropdownRef.current.contains(e.target)) {
                        setIsOpen(false);
                        setSearchTerm('');
                    }
                };
                if (isOpen) {
                    document.addEventListener('mousedown', handleClickOutside);
                    return () => document.removeEventListener('mousedown', handleClickOutside);
                }
            }, [isOpen]);

            // Focus input when opened
            useEffect(() => {
                if (isOpen && inputRef.current) {
                    inputRef.current.focus();
                }
            }, [isOpen]);

            // Reset highlighted index when filtered list changes
            useEffect(() => {
                setHighlightedIndex(0);
            }, [filteredRoster]);

            const handleKeyDown = (e) => {
                if (!isOpen) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        setIsOpen(true);
                    }
                    return;
                }

                switch (e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        setHighlightedIndex(prev => Math.min(prev + 1, filteredRoster.length - 1));
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        setHighlightedIndex(prev => Math.max(prev - 1, 0));
                        break;
                    case 'Enter':
                        e.preventDefault();
                        if (filteredRoster[highlightedIndex]) {
                            onChange(filteredRoster[highlightedIndex].id);
                            setIsOpen(false);
                            setSearchTerm('');
                        }
                        break;
                    case 'Escape':
                        e.preventDefault();
                        setIsOpen(false);
                        setSearchTerm('');
                        break;
                }
            };

            const handleSelect = (playerId) => {
                onChange(playerId);
                setIsOpen(false);
                setSearchTerm('');
            };

            return (
                <div
                    ref={dropdownRef}
                    style={{ position: 'relative', width: '100%', ...style }}
                    onMouseDown={(e) => e.stopPropagation()} // Prevent drag handler
                >
                    {!isOpen ? (
                        <div
                            onClick={() => setIsOpen(true)}
                            onKeyDown={handleKeyDown}
                            tabIndex={0}
                            style={{
                                fontSize: '0.75rem',
                                padding: '2px 4px',
                                width: '100%',
                                background: 'var(--input-bg)',
                                border: '1px solid var(--border)',
                                borderRadius: '4px',
                                cursor: 'pointer',
                                color: 'var(--text)',
                                textAlign: 'left',
                                minHeight: '22px',
                                display: 'flex',
                                alignItems: 'center'
                            }}
                        >
                            {selectedPlayer ? (
                                <>
                                    <span style={{ color: depthChart ? getFatigueColor(calculatePlayerFatigue(selectedPlayer.id, depthChart).totalFatigue) : 'var(--text)' }}>
                                        #{selectedPlayer.number} {selectedPlayer.name}
                                    </span>
                                    {depthChart && (() => {
                                        const { totalFatigue } = calculatePlayerFatigue(selectedPlayer.id, depthChart);
                                        if (totalFatigue >= 5) {
                                            return <span style={{ marginLeft: '4px', fontSize: '0.65rem', fontWeight: 'bold', color: getFatigueColor(totalFatigue) }}>⚠️{totalFatigue}</span>;
                                        }
                                    })()}
                                </>
                            ) : '--'}
                        </div>
                    ) : (
                        <div style={{ position: 'relative' }}>
                            <input
                                ref={inputRef}
                                type="text"
                                value={searchTerm}
                                onChange={(e) => setSearchTerm(e.target.value)}
                                onKeyDown={handleKeyDown}
                                placeholder="Type name or #..."
                                style={{
                                    fontSize: '0.75rem',
                                    padding: '2px 4px',
                                    width: '100%',
                                    background: 'var(--input-bg)',
                                    border: '1px solid var(--accent)',
                                    borderRadius: '4px',
                                    color: 'var(--text)',
                                    outline: 'none'
                                }}
                            />
                            <div
                                style={{
                                    position: 'absolute',
                                    top: '100%',
                                    left: 0,
                                    right: 0,
                                    maxHeight: '200px',
                                    overflowY: 'auto',
                                    background: 'var(--bg-panel)',
                                    border: '1px solid var(--border)',
                                    borderRadius: '4px',
                                    marginTop: '2px',
                                    zIndex: 1000,
                                    boxShadow: '0 4px 6px rgba(0,0,0,0.3)'
                                }}
                            >
                                <div
                                    onClick={() => handleSelect('')}
                                    onMouseEnter={() => setHighlightedIndex(-1)}
                                    style={{
                                        padding: '4px 8px',
                                        fontSize: '0.75rem',
                                        cursor: 'pointer',
                                        background: highlightedIndex === -1 ? 'var(--accent)' : 'transparent',
                                        color: highlightedIndex === -1 ? 'white' : 'var(--text-secondary)'
                                    }}
                                >
                                    -- Clear --
                                </div>
                                {filteredRoster.length === 0 ? (
                                    <div style={{ padding: '8px', fontSize: '0.75rem', color: 'var(--text-secondary)', fontStyle: 'italic' }}>
                                        No players found
                                    </div>
                                ) : (
                                    filteredRoster.map((player, index) => {
                                        const { totalFatigue } = depthChart ? calculatePlayerFatigue(player.id, depthChart) : { totalFatigue: 0 };
                                        const fatigueColor = getFatigueColor(totalFatigue);
                                        const isHighlighted = highlightedIndex === index;

                                        return (
                                            <div
                                                key={player.id}
                                                onClick={() => handleSelect(player.id)}
                                                onMouseEnter={() => setHighlightedIndex(index)}
                                                style={{
                                                    padding: '4px 8px',
                                                    fontSize: '0.75rem',
                                                    cursor: 'pointer',
                                                    background: isHighlighted ? 'var(--accent)' : 'transparent',
                                                    display: 'flex',
                                                    justifyContent: 'space-between',
                                                    alignItems: 'center'
                                                }}
                                            >
                                                <span style={{ color: isHighlighted ? 'white' : (depthChart ? fatigueColor : 'var(--text)') }}>
                                                    #{player.number} {player.name}
                                                </span>
                                                {depthChart && totalFatigue >= 5 && (
                                                    <span style={{
                                                        fontSize: '0.65rem',
                                                        fontWeight: 'bold',
                                                        color: isHighlighted ? 'white' : fatigueColor,
                                                        marginLeft: '8px'
                                                    }}>
                                                        ⚠️{totalFatigue}
                                                    </span>
                                                )}
                                            </div>
                                        );
                                    })
                                )}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Fatigue Configuration Modal
        const FatigueConfigModal = ({ isOpen, onClose, thresholds, positionValues, onSave }) => {
            const [activeTab, setActiveTab] = useState('thresholds');
            const [localThresholds, setLocalThresholds] = useState(thresholds);
            const [localPositionValues, setLocalPositionValues] = useState(positionValues);
            const [expandedSections, setExpandedSections] = useState({ offense: true, defense: true, specialTeams: true });

            React.useEffect(() => {
                setLocalThresholds(thresholds);
                setLocalPositionValues(positionValues);
            }, [thresholds, positionValues]);

            if (!isOpen) return null;

            const toggleSection = (section) => {
                setExpandedSections(prev => ({ ...prev, [section]: !prev[section] }));
            };

            const updatePositionValue = (position, value) => {
                const numValue = parseInt(value) || 0;
                setLocalPositionValues(prev => ({ ...prev, [position]: Math.max(0, Math.min(10, numValue)) }));
            };

            const handleSave = () => {
                onSave(localThresholds, localPositionValues);
            };

            // Position groups
            const offensePositions = ['QB', 'RB', 'WR', 'TE', 'LT', 'LG', 'C', 'RG', 'RT', 'X', 'Y', 'Z', 'A'];
            const defensePositions = ['DE', 'DT', 'NT', 'LDE', 'RDE', 'LDT', 'RDT', 'Will', 'Mike', 'WLB', 'MLB', 'SLB', 'CB', 'LCB', 'RCB', 'FS', 'SS', 'Nickel', 'Nick'];
            const specialTeamsPositions = ['K', 'P', 'LS', 'PP', 'KR', 'Ret', 'R', 'Gunner', 'G1', 'G2', 'L1', 'L2', 'L3', 'L4', 'L5', 'R1', 'R2', 'R3', 'R4', 'R5', 'Rush', 'Jam', 'Front', 'Mid', 'Back', 'Deep', 'Wing', 'Off'];

            const renderPositionInputs = (positions, sectionKey, sectionTitle) => (
                <div key={sectionKey} style={{ marginBottom: '1.5rem', border: '1px solid var(--border)', borderRadius: '8px', overflow: 'hidden' }}>
                    <div
                        onClick={() => toggleSection(sectionKey)}
                        style={{
                            background: 'var(--accent)',
                            color: 'white',
                            padding: '0.75rem 1rem',
                            cursor: 'pointer',
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center',
                            fontWeight: 'bold'
                        }}
                    >
                        <span>{sectionTitle}</span>
                        <span>{expandedSections[sectionKey] ? '▼' : '▶'}</span>
                    </div>
                    {expandedSections[sectionKey] && (
                        <div style={{ padding: '1rem', display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(120px, 1fr))', gap: '1rem', background: 'var(--card-bg)' }}>
                            {positions.map(pos => (
                                <div key={pos} style={{ display: 'flex', flexDirection: 'column', gap: '0.25rem' }}>
                                    <label style={{ fontSize: '0.85rem', fontWeight: '500', color: 'var(--text)' }}>{pos}</label>
                                    <input
                                        type="number"
                                        value={localPositionValues[pos] || 1}
                                        onChange={e => updatePositionValue(pos, e.target.value)}
                                        min="0"
                                        max="10"
                                        className="form-input"
                                        style={{
                                            padding: '0.5rem',
                                            fontSize: '0.9rem',
                                            background: 'var(--input-bg)',
                                            color: 'var(--text)',
                                            border: '1px solid var(--border)',
                                            borderRadius: '4px'
                                        }}
                                    />
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            );

            return (
                <div className="modal-overlay" onClick={onClose} style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000 }}>
                    <div className="modal-content" onClick={e => e.stopPropagation()} style={{ background: 'var(--card-bg)', padding: '2rem', borderRadius: '12px', maxWidth: '900px', width: '90%', maxHeight: '90vh', overflow: 'auto' }}>
                        <h2 style={{ marginBottom: '1.5rem', color: 'var(--text)' }}>Configure Fatigue</h2>

                        {/* Tabs */}
                        <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '1.5rem', borderBottom: '2px solid var(--border)' }}>
                            <button
                                onClick={() => setActiveTab('thresholds')}
                                className={activeTab === 'thresholds' ? 'btn-primary' : 'btn-secondary'}
                                style={{
                                    padding: '0.75rem 1.5rem',
                                    borderRadius: '8px 8px 0 0',
                                    border: 'none',
                                    background: activeTab === 'thresholds' ? 'var(--accent)' : 'transparent',
                                    color: activeTab === 'thresholds' ? 'white' : 'var(--text)',
                                    fontWeight: activeTab === 'thresholds' ? 'bold' : 'normal'
                                }}
                            >
                                Thresholds
                            </button>
                            <button
                                onClick={() => setActiveTab('positions')}
                                className={activeTab === 'positions' ? 'btn-primary' : 'btn-secondary'}
                                style={{
                                    padding: '0.75rem 1.5rem',
                                    borderRadius: '8px 8px 0 0',
                                    border: 'none',
                                    background: activeTab === 'positions' ? 'var(--accent)' : 'transparent',
                                    color: activeTab === 'positions' ? 'white' : 'var(--text)',
                                    fontWeight: activeTab === 'positions' ? 'bold' : 'normal'
                                }}
                            >
                                Position Values
                            </button>
                        </div>

                        {/* Thresholds Tab Content */}
                        {activeTab === 'thresholds' && (
                            <>
                                {/* Color Preview */}
                                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '0.5rem', marginBottom: '2rem' }}>
                                    <div style={{ background: '#10b981', color: 'white', padding: '1rem', borderRadius: '8px', textAlign: 'center' }}>
                                        <div style={{ fontWeight: 'bold', marginBottom: '0.25rem' }}>Fresh</div>
                                        <div style={{ fontSize: '0.8rem' }}>0 - {localThresholds.moderate - 1}</div>
                                    </div>
                                    <div style={{ background: '#f97316', color: 'white', padding: '1rem', borderRadius: '8px', textAlign: 'center' }}>
                                        <div style={{ fontWeight: 'bold', marginBottom: '0.25rem' }}>Moderate</div>
                                        <div style={{ fontSize: '0.8rem' }}>{localThresholds.moderate} - {localThresholds.high - 1}</div>
                                    </div>
                                    <div style={{ background: '#eab308', color: 'white', padding: '1rem', borderRadius: '8px', textAlign: 'center' }}>
                                        <div style={{ fontWeight: 'bold', marginBottom: '0.25rem' }}>High</div>
                                        <div style={{ fontSize: '0.8rem' }}>{localThresholds.high} - {localThresholds.veryHigh - 1}</div>
                                    </div>
                                    <div style={{ background: '#ef4444', color: 'white', padding: '1rem', borderRadius: '8px', textAlign: 'center' }}>
                                        <div style={{ fontWeight: 'bold', marginBottom: '0.25rem' }}>Very High</div>
                                        <div style={{ fontSize: '0.8rem' }}>{localThresholds.veryHigh}+</div>
                                    </div>
                                </div>

                                {/* Threshold Inputs */}
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem', marginBottom: '2rem' }}>
                                    <div className="form-group">
                                        <label className="form-label" style={{ color: 'var(--text)', marginBottom: '0.5rem', display: 'block' }}>Moderate Threshold (Orange)</label>
                                        <input
                                            className="form-input"
                                            type="number"
                                            value={localThresholds.moderate}
                                            onChange={e => setLocalThresholds({ ...localThresholds, moderate: parseInt(e.target.value) || 1 })}
                                            min="1"
                                            style={{ width: '100%', background: 'var(--input-bg)', color: 'var(--text)', border: '1px solid var(--border)' }}
                                        />
                                    </div>
                                    <div className="form-group">
                                        <label className="form-label" style={{ color: 'var(--text)', marginBottom: '0.5rem', display: 'block' }}>High Threshold (Yellow)</label>
                                        <input
                                            className="form-input"
                                            type="number"
                                            value={localThresholds.high}
                                            onChange={e => setLocalThresholds({ ...localThresholds, high: parseInt(e.target.value) || localThresholds.moderate + 1 })}
                                            min={localThresholds.moderate + 1}
                                            style={{ width: '100%', background: 'var(--input-bg)', color: 'var(--text)', border: '1px solid var(--border)' }}
                                        />
                                    </div>
                                    <div className="form-group">
                                        <label className="form-label" style={{ color: 'var(--text)', marginBottom: '0.5rem', display: 'block' }}>Very High Threshold (Red)</label>
                                        <input
                                            className="form-input"
                                            type="number"
                                            value={localThresholds.veryHigh}
                                            onChange={e => setLocalThresholds({ ...localThresholds, veryHigh: parseInt(e.target.value) || localThresholds.high + 1 })}
                                            min={localThresholds.high + 1}
                                            style={{ width: '100%', background: 'var(--input-bg)', color: 'var(--text)', border: '1px solid var(--border)' }}
                                        />
                                    </div>
                                </div>
                            </>
                        )}

                        {/* Position Values Tab Content */}
                        {activeTab === 'positions' && (
                            <div style={{ marginBottom: '2rem' }}>
                                <p style={{ color: 'var(--text-secondary)', marginBottom: '1rem', fontSize: '0.9rem' }}>
                                    Set fatigue points (0-10) for each position. Higher values mean more fatigue per assignment.
                                </p>
                                {renderPositionInputs(offensePositions, 'offense', '⚡ Offense')}
                                {renderPositionInputs(defensePositions, 'defense', '🛡️ Defense')}
                                {renderPositionInputs(specialTeamsPositions, 'specialTeams', '🏈 Special Teams')}
                            </div>
                        )}

                        {/* Actions */}
                        <div style={{ display: 'flex', gap: '1rem', justifyContent: 'flex-end', borderTop: '1px solid var(--border)', paddingTop: '1rem' }}>
                            <button onClick={onClose} className="btn-secondary" style={{ padding: '0.5rem 1rem' }}>Cancel</button>
                            <button onClick={handleSave} className="btn-primary" style={{ padding: '0.5rem 1rem' }}>Save Configuration</button>
                        </div>
                    </div>
                </div>
            );
        };

        const DepthChart = ({ roster, depthChart, onUpdateDepthChart, chartType = 'OFFENSE', savedLayout = {}, onUpdateLayout, onResetLayout, positionNames = {}, onUpdatePositionNames, depthStrings = {}, onUpdateDepthStrings, depthRowCounts = {}, onUpdateDepthRowCounts, customPositions = {}, hiddenPositions = {}, forcePrintView = false }) => {
            // Derive base type and squad level
            const formattedType = chartType || 'OFFENSE';
            const baseChartType = formattedType.replace(/^(V|JV|J2|SCOUT)_/, '');
            const squadPrefix = formattedType.match(/^(V|JV|J2|SCOUT)_/)?.[1] || '';
            const squadName = { 'V': 'Varsity', 'JV': 'JV', 'J2': 'JV2', 'SCOUT': 'Scout Team' }[squadPrefix] || 'Varsity';

            // Map chart type to Setup Phase (OFFENSE, DEFENSE, SPECIAL_TEAMS)
            const getSetupPhase = (type) => {
                if (type === 'OFFENSE') return 'OFFENSE';
                if (type === 'DEFENSE') return 'DEFENSE';
                return 'SPECIAL_TEAMS'; // KICKOFF, PUNT, etc.
            };
            const setupPhase = getSetupPhase(baseChartType);

            // Standard coordinate mappings for different formations
            const FORMATIONS = {
                'OFFENSE': [
                    { id: 'OFF_LWR', key: 'X', defaultName: 'X', x: 100, y: 100 },
                    { id: 'OFF_LT', key: 'LT', defaultName: 'LT', x: 340, y: 100 },
                    { id: 'OFF_LG', key: 'LG', defaultName: 'LG', x: 520, y: 100 },
                    { id: 'OFF_C', key: 'C', defaultName: 'C', x: 700, y: 100 },
                    { id: 'OFF_RG', key: 'RG', defaultName: 'RG', x: 880, y: 100 },
                    { id: 'OFF_RT', key: 'RT', defaultName: 'RT', x: 1060, y: 100 },
                    { id: 'OFF_RWR', key: 'Z', defaultName: 'Z', x: 1240, y: 200 },
                    { id: 'OFF_QB', key: 'QB', defaultName: 'QB', x: 700, y: 300 },
                    { id: 'OFF_RB', key: 'RB', defaultName: 'RB', x: 700, y: 500 },
                    { id: 'OFF_SWR', key: 'A', defaultName: 'A', x: 170, y: 200 },
                    { id: 'OFF_TE', key: 'Y', defaultName: 'Y', x: 1420, y: 100 }
                ],
                'DEFENSE': [
                    { id: 'DEF_LDE', key: 'DE', defaultName: 'DE', x: 340, y: 100 },
                    { id: 'DEF_LDT', key: 'DT', defaultName: 'DT', x: 520, y: 100 },
                    { id: 'DEF_RDT', key: 'NT', defaultName: 'NT', x: 880, y: 100 },
                    { id: 'DEF_RDE', key: 'DE', defaultName: 'DE', x: 1060, y: 100 },
                    { id: 'DEF_WLB', key: 'Will', defaultName: 'Will', x: 520, y: 300 },
                    { id: 'DEF_MLB', key: 'Mike', defaultName: 'Mike', x: 880, y: 300 },
                    { id: 'DEF_LCB', key: 'CB', defaultName: 'CB', x: 100, y: 200 },
                    { id: 'DEF_RCB', key: 'CB', defaultName: 'CB', x: 1380, y: 200 },
                    { id: 'DEF_FS', key: 'FS', defaultName: 'FS', x: 520, y: 500 },
                    { id: 'DEF_SS', key: 'SS', defaultName: 'SS', x: 880, y: 500 },
                    { id: 'DEF_NICK', key: 'Nickel', defaultName: 'Nickel', x: 1100, y: 300 }
                ],
                'KICKOFF': [
                    { id: 'KO_K', key: 'K', defaultName: 'K', x: 700, y: 500 },
                    { id: 'KO_L1', key: 'L1', defaultName: 'L1', x: 600, y: 300 }, { id: 'KO_R1', key: 'R1', defaultName: 'R1', x: 800, y: 300 },
                    { id: 'KO_L2', key: 'L2', defaultName: 'L2', x: 500, y: 300 }, { id: 'KO_R2', key: 'R2', defaultName: 'R2', x: 900, y: 300 },
                    { id: 'KO_L3', key: 'L3', defaultName: 'L3', x: 400, y: 300 }, { id: 'KO_R3', key: 'R3', defaultName: 'R3', x: 1000, y: 300 },
                    { id: 'KO_L4', key: 'L4', defaultName: 'L4', x: 300, y: 300 }, { id: 'KO_R4', key: 'R4', defaultName: 'R4', x: 1100, y: 300 },
                    { id: 'KO_L5', key: 'L5', defaultName: 'L5', x: 200, y: 300 }, { id: 'KO_R5', key: 'R5', defaultName: 'R5', x: 1200, y: 300 }
                ],
                // ... other units if needed, adding key/defaultName to ensure consistency if renamed
                'KICK_RETURN': [
                    { id: 'KR_R1', defaultName: 'KR', x: 600, y: 600 }, { id: 'KR_R2', defaultName: 'KR', x: 800, y: 600 },
                    { id: 'KR_FL1', defaultName: 'Front', x: 200, y: 200 }, { id: 'KR_FL2', defaultName: 'Front', x: 1200, y: 200 },
                    { id: 'KR_M1', defaultName: 'Mid', x: 400, y: 300 }, { id: 'KR_M2', defaultName: 'Mid', x: 1000, y: 300 },
                    { id: 'KR_M3', defaultName: 'Mid', x: 600, y: 300 }, { id: 'KR_M4', defaultName: 'Mid', x: 800, y: 300 },
                    { id: 'KR_B1', defaultName: 'Back', x: 500, y: 450 }, { id: 'KR_B2', defaultName: 'Back', x: 900, y: 450 },
                    { id: 'KR_OFF', defaultName: 'Off', x: 700, y: 450 }
                ],
                'PUNT': [
                    { id: 'P_P', defaultName: 'P', x: 700, y: 600 },
                    { id: 'P_PP', defaultName: 'PP', x: 700, y: 400 },
                    { id: 'P_LS', defaultName: 'LS', x: 700, y: 100 },
                    { id: 'P_L1', defaultName: 'L1', x: 600, y: 100 }, { id: 'P_R1', defaultName: 'R1', x: 800, y: 100 },
                    { id: 'P_L2', defaultName: 'L2', x: 500, y: 100 }, { id: 'P_R2', defaultName: 'R2', x: 900, y: 100 },
                    { id: 'P_L3', defaultName: 'Wing', x: 400, y: 150 }, { id: 'P_R3', defaultName: 'Wing', x: 1000, y: 150 },
                    { id: 'P_G1', defaultName: 'Gunner', x: 100, y: 100 }, { id: 'P_G2', defaultName: 'Gunner', x: 1300, y: 100 }
                ],
                'PUNT_RETURN': [
                    { id: 'PR_R', defaultName: 'Ret', x: 700, y: 600 },
                    { id: 'PR_J1', defaultName: 'Jam', x: 100, y: 200 }, { id: 'PR_J2', defaultName: 'Jam', x: 1300, y: 200 },
                    { id: 'PR_L1', defaultName: 'Rush', x: 300, y: 150 }, { id: 'PR_R1', defaultName: 'Rush', x: 1100, y: 150 },
                    { id: 'PR_L2', defaultName: 'Rush', x: 400, y: 150 }, { id: 'PR_R2', defaultName: 'Rush', x: 1000, y: 150 },
                    { id: 'PR_L3', defaultName: 'Rush', x: 500, y: 150 }, { id: 'PR_R3', defaultName: 'Rush', x: 900, y: 150 },
                    { id: 'PR_L4', defaultName: 'Rush', x: 600, y: 150 }, { id: 'PR_R4', defaultName: 'Rush', x: 800, y: 150 }
                ],
                'HANDS_TEAM': [
                    { id: 'HT_FL1', defaultName: 'Front', x: 200, y: 100 }, { id: 'HT_FL2', defaultName: 'Front', x: 1200, y: 100 },
                    { id: 'HT_FL3', defaultName: 'Front', x: 400, y: 100 }, { id: 'HT_FL4', defaultName: 'Front', x: 1000, y: 100 },
                    { id: 'HT_FL5', defaultName: 'Front', x: 600, y: 100 }, { id: 'HT_FL6', defaultName: 'Front', x: 800, y: 100 },
                    { id: 'HT_M1', defaultName: 'Mid', x: 300, y: 300 }, { id: 'HT_M2', defaultName: 'Mid', x: 1100, y: 300 },
                    { id: 'HT_M3', defaultName: 'Mid', x: 700, y: 300 },
                    { id: 'HT_D1', defaultName: 'Deep', x: 500, y: 500 }, { id: 'HT_D2', defaultName: 'Deep', x: 900, y: 500 }
                ],
                'ONSIDE_KICK': [
                    { id: 'OS_K', defaultName: 'K', x: 700, y: 500 },
                    { id: 'OS_L1', defaultName: 'L1', x: 650, y: 300 }, { id: 'OS_R1', defaultName: 'R1', x: 750, y: 300 },
                    { id: 'OS_L2', defaultName: 'L2', x: 600, y: 300 }, { id: 'OS_R2', defaultName: 'R2', x: 800, y: 300 },
                    { id: 'OS_L3', defaultName: 'L3', x: 550, y: 300 }, { id: 'OS_R3', defaultName: 'R3', x: 850, y: 300 },
                    { id: 'OS_L4', defaultName: 'L4', x: 500, y: 300 }, { id: 'OS_R4', defaultName: 'R4', x: 900, y: 300 },
                    { id: 'OS_L5', defaultName: 'L5', x: 450, y: 300 }, { id: 'OS_R5', defaultName: 'R5', x: 950, y: 300 }
                ],
                'PAT_BLOCK': [
                    { id: 'PB_1', defaultName: 'Rush', x: 100, y: 100 }, { id: 'PB_11', defaultName: 'Rush', x: 1300, y: 100 },
                    { id: 'PB_2', defaultName: 'Rush', x: 220, y: 100 }, { id: 'PB_10', defaultName: 'Rush', x: 1180, y: 100 },
                    { id: 'PB_3', defaultName: 'Rush', x: 340, y: 100 }, { id: 'PB_9', defaultName: 'Rush', x: 1060, y: 100 },
                    { id: 'PB_4', defaultName: 'Rush', x: 460, y: 100 }, { id: 'PB_8', defaultName: 'Rush', x: 940, y: 100 },
                    { id: 'PB_5', defaultName: 'Rush', x: 580, y: 100 }, { id: 'PB_7', defaultName: 'Rush', x: 820, y: 100 },
                    { id: 'PB_6', defaultName: 'Safe', x: 700, y: 400 }
                ]
            };

            // Prepare Custom Positions for this phase
            const phaseCustomPositions = customPositions[setupPhase] || [];
            const formattedCustomPositions = phaseCustomPositions.map((cp, idx) => ({
                id: `CUSTOM_${baseChartType}_${cp.key}`, // Unique ID for depth chart assignment
                key: cp.key,
                defaultName: cp.key,
                x: 100 + (idx * 150) % 1200, // Staggered default placement
                y: 650 + Math.floor(idx / 8) * 150, // Below default positions
                isCustom: true
            }));

            // Get base defaults
            const baseDefaults = FORMATIONS[baseChartType] || FORMATIONS['OFFENSE'];

            // Filter out Hidden defaults
            const currentHidden = hiddenPositions[setupPhase] || [];
            const filteredDefaults = baseDefaults.filter(pos => !currentHidden.includes(pos.key));

            // Combine
            const availablePositions = [...filteredDefaults, ...formattedCustomPositions];

            // Merge with saved layout
            const positions = availablePositions.map(pos => {
                const saved = savedLayout[pos.id];
                // Determine name: user key override > default key override > default name
                const name = (pos.key ? positionNames[pos.key] : null) || pos.defaultName;
                return saved ? { ...pos, x: saved.x, y: saved.y, name } : { ...pos, name };
            });

            const getPlayer = (id) => roster.find(p => p.id === id);

            const handleSelectPlayer = (posId, depthIndex, playerId) => {
                const currentDepth = depthChart[posId] || [null, null, null];
                const newDepth = [...currentDepth];
                newDepth[depthIndex] = playerId;
                onUpdateDepthChart({ ...depthChart, [posId]: newDepth });
            };

            const chartTitles = {
                'OFFENSE': 'Offensive Depth Chart (Spread)',
                'DEFENSE': 'Defensive Depth Chart (4-2-5)',
                'KICKOFF': 'Kickoff Unit',
                'KICK_RETURN': 'Kick Return Unit',
                'PUNT': 'Punt Unit',
                'PUNT_RETURN': 'Punt Return / Block',
                'HANDS_TEAM': 'Hands Team',
                'ONSIDE_KICK': 'Onside Kick Unit',
                'PAT_BLOCK': 'PAT / FG Block'
            };

            // Draggable & Renaming Logic
            const [isLocked, setIsLocked] = useLocalStorage('depthChartLocked', false);
            const [draggingId, setDraggingId] = useState(null);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [tempPosition, setTempPosition] = useState(null); // { x, y } while dragging

            // Renaming State
            const [editingId, setEditingId] = useState(null);
            const [editName, setEditName] = useState("");

            // Fatigue Configuration State
            const [fatigueThresholds, setFatigueThresholds] = useLocalStorage('fatigue-thresholds', {
                moderate: 5,
                high: 8,
                veryHigh: 12
            });
            const [positionFatigueValues, setPositionFatigueValues] = useLocalStorage('position-fatigue-values', {});
            const [showFatigueConfig, setShowFatigueConfig] = useState(false);

            const handleSaveFatigueConfig = (newThresholds, newPositionValues) => {
                setFatigueThresholds(newThresholds);
                setPositionFatigueValues(newPositionValues);
                setShowFatigueConfig(false);
            };

            // Print Logic
            const [isPrinting, setIsPrinting] = useState(false);

            const handlePrint = () => {
                setIsPrinting(true);
                setTimeout(() => {
                    window.print();
                    setIsPrinting(false);
                }, 500);
            };

            const PrintView = () => (
                <div className="depth-chart-print-view" style={{ padding: '20px', fontFamily: 'Arial, sans-serif' }}>
                    <h1 style={{ textAlign: 'center', marginBottom: '20px' }}>{squadName} {chartTitles[baseChartType] || chartTitles['OFFENSE']} - Depth Chart</h1>
                    <div style={{ position: 'relative', height: '600px', border: '1px solid #ccc' }}>
                        {/* Field Lines */}
                        <div style={{ position: 'absolute', top: '50px', left: 0, right: 0, height: '2px', background: '#ccc' }}></div>

                        {positions.map(pos => (
                            <div
                                key={pos.id}
                                style={{
                                    position: 'absolute',
                                    left: `${pos.x}px`,
                                    top: `${pos.y}px`,
                                    width: '140px',
                                    transform: 'translateX(-50%)',
                                    border: '1px solid #000',
                                    padding: '5px',
                                    background: '#fff',
                                    borderRadius: '5px',
                                    textAlign: 'center'
                                }}
                            >
                                <div style={{ fontWeight: 'bold', borderBottom: '1px solid #ccc', marginBottom: '5px' }}>{pos.name}</div>
                                {Array.from({ length: (depthRowCounts[pos.id] || 3) }).map((_, depth) => {
                                    const playerId = depthChart[pos.id]?.[depth];
                                    const player = getPlayer(playerId);
                                    return (
                                        <div key={depth} style={{ fontSize: '12px', padding: '2px 0', borderBottom: '1px solid #eee' }}>
                                            {player ? `#${player.number} ${player.name}` : '-'}
                                        </div>
                                    );
                                })}
                            </div>
                        ))}
                    </div>
                </div>
            );

            const handleMouseDown = (e, pos) => {
                // Prevent drag if locked, clicking select, or editing
                if (isLocked) return;
                if (e.target.tagName === 'SELECT' || e.target.tagName === 'OPTION' || e.target.tagName === 'INPUT') return;
                if (editingId) return; // Don't drag while editing

                setDraggingId(pos.id);
                setDragOffset({
                    x: e.clientX - pos.x,
                    y: e.clientY - pos.y
                });
                setTempPosition({ x: pos.x, y: pos.y });
            };

            const handleDoubleClick = (pos) => {
                if (pos.key) {
                    setEditingId(pos.id);
                    setEditName(pos.name);
                }
            };

            const saveName = (pos) => {
                if (pos.key && onUpdatePositionNames) {
                    onUpdatePositionNames({ ...positionNames, [pos.key]: editName.toUpperCase().slice(0, 3) });
                }
                setEditingId(null);
            };

            const handleMouseMove = (e) => {
                if (!draggingId || !tempPosition) return;

                const SNAP_SIZE = 20;

                const rawX = e.clientX - dragOffset.x;
                const rawY = e.clientY - dragOffset.y;

                // Snap to grid
                const snappedX = Math.round(rawX / SNAP_SIZE) * SNAP_SIZE;
                const snappedY = Math.round(rawY / SNAP_SIZE) * SNAP_SIZE;

                setTempPosition({ x: snappedX, y: snappedY });
            };

            const handleMouseUp = () => {
                if (draggingId && tempPosition && onUpdateLayout) {
                    onUpdateLayout(draggingId, tempPosition.x, tempPosition.y);
                }
                setDraggingId(null);
                setTempPosition(null);
            };

            // Add listener to window for mouse up to catch drags that end outside container
            useEffect(() => {
                if (draggingId) {
                    window.addEventListener('mousemove', handleMouseMove);
                    window.addEventListener('mouseup', handleMouseUp);
                    return () => {
                        window.removeEventListener('mousemove', handleMouseMove);
                        window.removeEventListener('mouseup', handleMouseUp);
                    };
                }
            }, [draggingId, tempPosition]);

            // Direct Return for Forced Print View (Print All Mode)
            if (forcePrintView) {
                return (
                    <div style={{ height: 'auto', pageBreakInside: 'avoid' }}>
                        <PrintView />
                    </div>
                );
            }

            return (
                <>
                    {/* Fatigue Configuration Modal */}
                    <FatigueConfigModal
                        isOpen={showFatigueConfig}
                        onClose={() => setShowFatigueConfig(false)}
                        thresholds={fatigueThresholds}
                        positionValues={positionFatigueValues}
                        onSave={handleSaveFatigueConfig}
                    />

                    <div className="depth-chart-container" style={{ height: 'calc(100vh - 100px)', display: 'flex', flexDirection: 'column' }}>
                        <div className="depth-chart-controls" style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '2rem' }}>
                            <h2>{squadName} {chartTitles[baseChartType] || chartTitles['OFFENSE']}</h2>
                            <div style={{ display: 'flex', gap: '1rem' }}>
                                <button
                                    onClick={() => setShowFatigueConfig(true)}
                                    className="btn btn-secondary"
                                    title="Configure fatigue thresholds"
                                >
                                    ⚙️ Configure Fatigue
                                </button>
                                <button
                                    className={`btn ${isLocked ? 'btn-primary' : 'btn-secondary'}`}
                                    onClick={() => setIsLocked(!isLocked)}
                                    title={isLocked ? "Unlock positions to move them" : "Lock positions to prevent changes"}
                                >
                                    {isLocked ? '🔒 Layout Locked' : '🔓 Lock Layout'}
                                </button>
                                {!isLocked && (
                                    <button className="btn btn-secondary" onClick={onResetLayout} title="Reset positions to default">Reset Layout</button>
                                )}
                                <button className="btn btn-secondary" onClick={handlePrint}>🖨️ Print</button>
                            </div>
                        </div>

                        <div className="depth-chart-viewport" style={{
                            flex: 1,
                            overflowY: 'auto',
                            overflowX: 'auto',
                            position: 'relative',
                            minHeight: '600px',
                            border: '1px solid var(--border)',
                            borderRadius: '8px',
                            background: 'var(--surface)',
                            userSelect: 'none'
                        }}>
                            {/* Field Background Hint */}
                            <div style={{
                                position: 'absolute', top: '50px', left: '0', right: '0', height: '2px', background: 'var(--border)',
                                display: 'flex', justifyContent: 'space-between', padding: '0 50px', minWidth: '1500px', pointerEvents: 'none'
                            }}></div>

                            {positions.map(pos => {
                                const isDragging = draggingId === pos.id;
                                const x = isDragging ? tempPosition.x : pos.x;
                                const y = isDragging ? tempPosition.y : pos.y;
                                const isEditing = editingId === pos.id;

                                return (
                                    <div
                                        key={pos.id}
                                        onMouseDown={(e) => handleMouseDown(e, pos)}
                                        onDoubleClick={() => handleDoubleClick(pos)}
                                        style={{
                                            position: 'absolute',
                                            left: `${x}px`,
                                            top: `${y}px`,
                                            width: '140px',
                                            transform: 'translateX(-50%)', // Center align relative to coords
                                            display: 'flex',
                                            flexDirection: 'column',
                                            gap: '4px',
                                            background: isDragging ? 'var(--highlight)' : 'rgba(0,0,0,0.5)',
                                            padding: '8px',
                                            borderRadius: '8px',
                                            cursor: isDragging ? 'grabbing' : (pos.key ? 'pointer' : 'default'),
                                            border: isDragging ? '1px solid var(--accent)' : '1px solid transparent',
                                            zIndex: isDragging ? 10 : 1
                                        }}
                                    >
                                        {isEditing ? (
                                            <input
                                                autoFocus
                                                value={editName}
                                                onChange={(e) => setEditName(e.target.value)}
                                                onBlur={() => saveName(pos)}
                                                onKeyDown={(e) => {
                                                    if (e.key === 'Enter') saveName(pos);
                                                    if (e.key === 'Escape') setEditingId(null);
                                                }}
                                                maxLength={3}
                                                style={{
                                                    textAlign: 'center',
                                                    fontWeight: 'bold',
                                                    color: 'var(--text-primary)',
                                                    marginBottom: '4px',
                                                    background: 'var(--surface)',
                                                    border: '1px solid var(--accent)',
                                                    borderRadius: '4px',
                                                    padding: '2px',
                                                    width: '100%'
                                                }}
                                                onClick={(e) => e.stopPropagation()} // Prevent drag start
                                            />
                                        ) : (
                                            <div style={{ textAlign: 'center', fontWeight: 'bold', color: 'var(--accent)', marginBottom: '4px' }}>
                                                {pos.name}
                                            </div>
                                        )}

                                        {Array.from({ length: (depthRowCounts[pos.id] || 3) }).map((_, depth) => {
                                            const playerId = depthChart[pos.id]?.[depth];
                                            const label = depthStrings[pos.id]?.[depth] || (depth + 1).toString();

                                            return (
                                                <div key={depth} style={{ display: 'flex', gap: '4px', alignItems: 'center' }}>
                                                    <input
                                                        value={label}
                                                        onChange={(e) => {
                                                            if (!onUpdateDepthStrings) return;
                                                            const newPosStrings = [...(depthStrings[pos.id] || [])];
                                                            // Ensure array is padded if assigning to index > length
                                                            while (newPosStrings.length <= depth) newPosStrings.push('');
                                                            newPosStrings[depth] = e.target.value;
                                                            onUpdateDepthStrings({ ...depthStrings, [pos.id]: newPosStrings });
                                                        }}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                        placeholder={(depth + 1).toString()}
                                                        style={{
                                                            width: '24px',
                                                            textAlign: 'center',
                                                            padding: '2px',
                                                            border: '1px solid var(--border)',
                                                            borderRadius: '4px',
                                                            fontSize: '0.75rem',
                                                            background: 'rgba(255,255,255,0.1)',
                                                            color: 'var(--text-secondary)'
                                                        }}
                                                    />
                                                    <div style={{ flex: 1 }}>
                                                        <SearchablePlayerDropdown
                                                            roster={roster}
                                                            value={playerId || ''}
                                                            onChange={(newPlayerId) => handleSelectPlayer(pos.id, depth, newPlayerId)}
                                                            depthChart={depthChart}
                                                        />
                                                    </div>
                                                </div>
                                            );
                                        })}
                                        <div style={{ display: 'flex', justifyContent: 'center', marginTop: '4px' }}>
                                            <button
                                                className="btn-text"
                                                style={{ fontSize: '0.7rem', padding: '2px 4px', color: 'var(--text-secondary)' }}
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    if (onUpdateDepthRowCounts) {
                                                        const currentCount = depthRowCounts[pos.id] || 3;
                                                        onUpdateDepthRowCounts({ ...depthRowCounts, [pos.id]: currentCount + 1 });
                                                    }
                                                }}
                                            >
                                                + Add Row
                                            </button>
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                    {/* Print Portal */}
                    {isPrinting && ReactDOM.createPortal(
                        <div className="print-only-portal">
                            <PrintView />
                        </div>,
                        document.body
                    )}
                </>
            );
        };



        // --- Global Helper Functions for Metrics & Scoring ---
        const parseTime = (val) => {
            if (!val) return null;
            if (typeof val === 'number') return val;
            if (val.includes(':')) {
                const [m, s] = val.split(':').map(Number);
                return (m * 60) + s;
            }
            return parseFloat(val);
        };

        const calculateIronManScore = (id, value, weight) => {
            if (!value || !weight) return 0;
            const wt = parseFloat(weight);
            const val = parseTime(value);

            if (isNaN(wt) || isNaN(val)) return 0;

            // 40 Yard Dash (Linear Approximation)
            if (id === 'forty') {
                const standard1000 = 4.3 + (wt - 100) * 0.0056;
                const standard0 = standard1000 + 2.4;
                if (val <= standard1000) return 1000;
                if (val >= standard0) return 0;
                const range = standard0 - standard1000;
                const diff = standard0 - val;
                return Math.round((diff / range) * 1000);
            }

            // Bench Press & Squat
            if (id === 'bench' || id === 'squat') {
                const roundedWeight = Math.round(wt / 10) * 10;
                if (roundedWeight === 0) return 0;
                const rawScore = (val * 3 / roundedWeight) * 100;
                return Math.max(0, Math.min(1000, Math.round(rawScore)));
            }

            // Bag Jump (Board Jump)
            if (id === 'bagJump' || id === 'boardJump') {
                let threshold = 30;
                if (wt <= 150) threshold = 30;
                else if (wt < 160) threshold = 30;
                else if (wt < 170) threshold = 29;
                else if (wt < 180) threshold = 28;
                else if (wt < 190) threshold = 27;
                else if (wt < 200) threshold = 26;
                else if (wt < 210) threshold = 26;
                else if (wt < 220) threshold = 25;
                else if (wt < 230) threshold = 25;
                else if (wt < 240) threshold = 24;
                else if (wt < 250) threshold = 23;
                else if (wt < 260) threshold = 22;
                else if (wt < 270) threshold = 21;
                else if (wt < 280) threshold = 20;
                else if (wt < 290) threshold = 19;
                else if (wt < 300) threshold = 18;
                else if (wt < 310) threshold = 17;
                else if (wt < 320) threshold = 16;
                else threshold = 15;

                const rawScore = (val - threshold) * 20;
                return Math.max(0, Math.min(1000, Math.round(rawScore)));
            }

            // 800m Run
            if (id === 'run800') {
                const standard1000 = 125 + (wt - 100) * 0.15;
                const standard0 = standard1000 + 120;
                if (val <= standard1000) return 1000;
                if (val >= standard0) return 0;
                const range = standard0 - standard1000;
                const diff = standard0 - val;
                return Math.round((diff / range) * 1000);
            }

            // 30 Yard Shuttle
            if (id === 'shuttle30') {
                const rawScore = 4000 + (wt * 4) - (val * 80);
                return Math.max(0, Math.min(1000, Math.round(rawScore)));
            }

            return 0;
        };

        const MaddenRatings = ({ roster, ratings, onUpdateRatings, metrics }) => {
            const [selectedPlayerId, setSelectedPlayerId] = useState(null);

            // Full Attribute List from Image
            const ATTRIBUTES = [
                // Physical
                { id: 'SPD', name: 'Speed', group: 'Physical' },
                { id: 'ACC', name: 'Acceleration', group: 'Physical' },
                { id: 'STR', name: 'Strength', group: 'Physical' },
                { id: 'AGI', name: 'Agility', group: 'Physical' },
                { id: 'JMP', name: 'Jumping', group: 'Physical' },
                { id: 'STA', name: 'Stamina', group: 'Physical' },
                { id: 'TGH', name: 'Toughness', group: 'Physical' },
                { id: 'INJ', name: 'Injury', group: 'Physical' },
                // Mental
                { id: 'AWR', name: 'Awareness', group: 'Mental' },
                { id: 'PRC', name: 'Play Recognition', group: 'Mental' },
                { id: 'BCV', name: 'Ball Carrier Vision', group: 'Mental' },
                // Passing
                { id: 'THP', name: 'Throw Power', group: 'Passing' },
                { id: 'SAC', name: 'Short Accuracy', group: 'Passing' },
                { id: 'MAC', name: 'Med Accuracy', group: 'Passing' },
                { id: 'DAC', name: 'Deep Accuracy', group: 'Passing' },
                { id: 'RUN', name: 'Throw on Run', group: 'Passing' },
                { id: 'PAC', name: 'Play Action', group: 'Passing' },
                // Rushing
                { id: 'CAR', name: 'Carrying', group: 'Rushing' },
                { id: 'TRK', name: 'Trucking', group: 'Rushing' },
                { id: 'ELU', name: 'Elusiveness', group: 'Rushing' },
                { id: 'SFA', name: 'Stiff Arm', group: 'Rushing' },
                { id: 'SPM', name: 'Spin Move', group: 'Rushing' },
                { id: 'JKM', name: 'Juke Move', group: 'Rushing' },
                // Receiving
                { id: 'CTH', name: 'Catching', group: 'Receiving' },
                { id: 'SPC', name: 'Spectacular Catch', group: 'Receiving' },
                { id: 'CIT', name: 'Catch in Traffic', group: 'Receiving' },
                { id: 'RTE', name: 'Route Running', group: 'Receiving' },
                { id: 'RLS', name: 'Release', group: 'Receiving' },
                // Blocking
                { id: 'RBK', name: 'Run Block', group: 'Blocking' },
                { id: 'RBS', name: 'Run Block Power', group: 'Blocking' },
                { id: 'RBF', name: 'Run Block Finesse', group: 'Blocking' },
                { id: 'PBK', name: 'Pass Block', group: 'Blocking' },
                { id: 'PBS', name: 'Pass Block Power', group: 'Blocking' },
                { id: 'PBF', name: 'Pass Block Finesse', group: 'Blocking' },
                { id: 'IBL', name: 'Impact Blocking', group: 'Blocking' },
                // Defense
                { id: 'TAK', name: 'Tackle', group: 'Defense' },
                { id: 'POW', name: 'Hit Power', group: 'Defense' },
                { id: 'BSH', name: 'Block Shedding', group: 'Defense' },
                { id: 'PUR', name: 'Pursuit', group: 'Defense' },
                { id: 'PMV', name: 'Power Moves', group: 'Defense' },
                { id: 'FMV', name: 'Finesse Moves', group: 'Defense' },
                { id: 'MCV', name: 'Man Coverage', group: 'Defense' },
                { id: 'ZCV', name: 'Zone Coverage', group: 'Defense' },
                { id: 'PRS', name: 'Press', group: 'Defense' },
                // Special Teams
                { id: 'KPW', name: 'Kick Power', group: 'Special' },
                { id: 'KAC', name: 'Kick Accuracy', group: 'Special' },
                { id: 'RET', name: 'Return', group: 'Special' }
            ];

            // Weights from Image (Integers, Sum to 100)
            const MADDEN_WEIGHTS = {
                'QB': { weights: { THP: 18, SAC: 17, MAC: 16, DAC: 12, RUN: 10, AWR: 10, TGH: 5, PAC: 5, JKM: 4, BSH: 3 } }, // SHA->SAC
                'RB': { weights: { BCV: 21, CAR: 18, AWR: 13, ACC: 12, TRK: 6, SPD: 6, AGI: 5, SFA: 5, JKM: 5, CTH: 4, STR: 3, STA: 2 } },
                'FB': { weights: { RBK: 25, PBK: 20, STR: 15, CAR: 10, AWR: 10, CTH: 10, SPD: 5, ACC: 5 } }, // Default FB estimated
                'WR': { weights: { CTH: 20, AWR: 15, RTE: 15, RLS: 13, SPC: 10, SPD: 9, ACC: 5, CIT: 5, AGI: 5, JKM: 3 } }, // REL->RLS
                'TE': { weights: { CTH: 18, RTE: 17, AWR: 12, RBK: 10, SPD: 8, RLS: 7, CIT: 7, SPC: 6, PBK: 5, ACC: 4, IBL: 3, STR: 3 } }, // REL->RLS
                'OL': { weights: { PBK: 21, RBK: 21, IBL: 19, STR: 11, AWR: 11, STA: 10, AGI: 5, ACC: 2 } },
                'LT': { weights: { PBK: 21, RBK: 21, IBL: 19, STR: 11, AWR: 11, STA: 10, AGI: 5, ACC: 2 } },
                'LG': { weights: { PBK: 21, RBK: 21, IBL: 19, STR: 11, AWR: 11, STA: 10, AGI: 5, ACC: 2 } },
                'C': { weights: { PBK: 21, RBK: 21, IBL: 19, STR: 11, AWR: 11, STA: 10, AGI: 5, ACC: 2 } },
                'RG': { weights: { PBK: 21, RBK: 21, IBL: 19, STR: 11, AWR: 11, STA: 10, AGI: 5, ACC: 2 } },
                'RT': { weights: { PBK: 21, RBK: 21, IBL: 19, STR: 11, AWR: 11, STA: 10, AGI: 5, ACC: 2 } },
                'DE': { weights: { PMV: 17, FMV: 17, BSH: 15, PUR: 13, AWR: 10, STR: 8, ACC: 7, TAK: 7, SPD: 3, AGI: 3 } }, // PWM->PMV, FNM->FMV
                'DT': { weights: { BSH: 22, STR: 16, PMV: 14, PUR: 13, TAK: 11, AWR: 11, FMV: 7, ACC: 4, AGI: 1, SPD: 1 } },
                'MLB': { weights: { TAK: 17, PUR: 15, AWR: 14, PRC: 14, BSH: 12, ZCV: 9, POW: 7, SPD: 4, STR: 4, ACC: 2, AGI: 1, MCV: 1 } },
                'OLB': { weights: { PUR: 17, TAK: 16, AWR: 12, PRC: 12, BSH: 11, PMV: 11, FMV: 10, ZCV: 4, ACC: 2, SPD: 2, STR: 2, POW: 1 } },
                'CB': { weights: { MCV: 20, ZCV: 20, PRC: 17, AWR: 13, SPD: 11, ACC: 7, AGI: 4, JMP: 3, CTH: 2, TAK: 1 } },
                'S': { weights: { ZCV: 21, AWR: 16, PRC: 15, PUR: 13, TAK: 11, SPD: 10, POW: 5, ACC: 5, MCV: 2, BSH: 1, CTH: 1 } },
                'K': { weights: { KPW: 60, KAC: 40 } },
                'P': { weights: { KPW: 60, KAC: 40 } }
            };

            const getLatestStats = (playerId) => {
                const data = metrics[playerId];
                if (!data) return null;
                const results = Array.isArray(data) ? data : [{ date: 'Initial', ...data }];
                if (results.length === 0) return null;
                // Sort by date descending and get latest
                return results.sort((a, b) => new Date(b.date) - new Date(a.date))[0];
            };

            const safeRatings = ratings || {};

            const getPlayerRating = (playerId) => {
                return safeRatings[playerId] || ATTRIBUTES.reduce((acc, attr) => ({ ...acc, [attr.id]: 50 }), {});
            };

            const calculateArchetype = (pos, ratings) => {
                const r = ratings || {};

                // Simplified Logic mirroring Column D cues
                if (pos === 'QB') {
                    if ((ratings.SPD || 0) >= 85) return 'Scrambler';
                    if ((ratings.THP || 0) >= 90) return 'Strong Arm';
                    if ((ratings.SAC || 0) >= 90) return 'Field General';
                    return 'Balanced';
                }
                if (pos === 'RB') {
                    if ((ratings.TRK || 0) > (ratings.ELU || 0)) return 'Power Back';
                    if ((ratings.CTH || 0) > 75) return 'Receiving Back';
                    if ((ratings.SPD || 0) >= 90) return 'Elusive Back';
                    return 'Balanced';
                }
                if (pos === 'WR') {
                    if ((ratings.SPD || 0) >= 92) return 'Speedster';
                    if ((ratings.CTH || 0) >= 90) return 'Possession';
                    if ((ratings.SPC || 0) >= 85) return 'Deep Threat';
                    return 'Balanced';
                }
                if (['OL', 'LT', 'LG', 'C', 'RG', 'RT'].includes(pos)) {
                    if ((ratings.AGI || 0) >= 70) return 'Agile';
                    if ((ratings.STR || 0) >= 90) return 'Power';
                    return 'Balanced';
                }
                if (['DE', 'DT'].includes(pos)) {
                    if ((ratings.SPD || 0) >= 80) return 'Speed Rusher';
                    if ((ratings.STR || 0) >= 90) return 'Power Rusher';
                    return 'Balanced';
                }
                if (['MLB', 'OLB'].includes(pos)) {
                    if ((ratings.ZCV || 0) >= 75) return 'Pass Coverage';
                    if ((ratings.TAK || 0) >= 90) return 'Run Stopper';
                    return 'Field General';
                }
                if (['CB', 'S'].includes(pos)) {
                    if ((ratings.MCV || 0) > (ratings.ZCV || 0)) return 'Man to Man';
                    if ((ratings.ZCV || 0) > (ratings.MCV || 0)) return 'Zone';
                    return 'Balanced';
                }

                return 'Balanced';
            };

            const calculateOVR = (player, playerRatings) => {
                if (!player || !playerRatings) return 50;

                // Allow specific positions or generic groups (e.g. OLB)
                let pos = player.position;
                if (['LOLB', 'ROLB'].includes(pos)) pos = 'OLB';
                if (['LE', 'RE'].includes(pos)) pos = 'DE';
                if (['FS', 'SS'].includes(pos)) pos = 'S';

                const formula = MADDEN_WEIGHTS[pos] || MADDEN_WEIGHTS['QB']; // Fallback

                let weightedSum = 0;
                let totalWeight = 0;

                if (formula && formula.weights) {
                    for (const [attr, weight] of Object.entries(formula.weights)) {
                        weightedSum += (playerRatings[attr] || 50) * weight;
                        totalWeight += weight;
                    }
                }

                // If weights sum to 100, dividing by 1 gives the score.
                // If they sum to < 100 or > 100, dividing by totalWeight normalizes it.
                // User sheet used integers summing mostly to 100.
                if (totalWeight === 0) return 50;

                const ovr = weightedSum / totalWeight;
                return Math.max(0, Math.min(99, Math.round(ovr)));
            };

            const syncRatings = () => {
                const newRatings = { ...safeRatings };
                let updatedCount = 0;

                roster.forEach(player => {
                    const stats = getLatestStats(player.id);
                    if (!stats) return;

                    const playerWeight = parseFloat(player.weight) || 180;
                    const currentPlayerRatings = newRatings[player.id] || ATTRIBUTES.reduce((acc, attr) => ({ ...acc, [attr.id]: 50 }), {});

                    const updates = {};

                    // SPD (Speed) from 40 Yard Dash
                    if (stats.forty) {
                        const score = calculateIronManScore('forty', stats.forty, playerWeight);
                        // Map 0-1000 score to roughly 40-99 rating
                        updates['SPD'] = 50 + Math.round((score / 1000) * 49);
                        updates['ACC'] = updates['SPD']; // Base ACC off SPD for now
                    }

                    // STR (Strength) from Bench/Squat
                    const benchScore = stats.bench ? calculateIronManScore('bench', stats.bench, playerWeight) : 0;
                    const squatScore = stats.squat ? calculateIronManScore('squat', stats.squat, playerWeight) : 0;
                    const maxPowerScore = Math.max(benchScore, squatScore);
                    if (maxPowerScore > 0) {
                        updates['STR'] = 50 + Math.round((maxPowerScore / 1000) * 49);
                        updates['POW'] = updates['STR']; // Hit Power
                        updates['TRK'] = updates['STR']; // Trucking
                        updates['BSH'] = updates['STR']; // Block Shedding
                    }

                    // AGI (Agility) from Shuttle/Pro Agility/Bag Jump
                    const shuttleScore = stats.shuttle30 ? calculateIronManScore('shuttle30', stats.shuttle30, playerWeight) : 0;
                    const bagScore = stats.bagJump ? calculateIronManScore('bagJump', stats.bagJump, playerWeight) : 0;
                    const maxAgilityScore = Math.max(shuttleScore, bagScore);
                    if (maxAgilityScore > 0) {
                        updates['AGI'] = 50 + Math.round((maxAgilityScore / 1000) * 49);
                        updates['COD'] = updates['AGI']; // Change of Direction (using AGI field for now if COD not explicit)
                    }

                    // JMP (Jumping) from Vertical
                    if (stats.vertical) {
                        const vert = parseFloat(stats.vertical);
                        updates['JMP'] = Math.min(99, Math.max(40, 50 + Math.round((vert - 15) * 2)));
                    }

                    if (Object.keys(updates).length > 0) {
                        newRatings[player.id] = { ...currentPlayerRatings, ...updates };
                        updatedCount++;
                    }
                });

                if (updatedCount > 0) {
                    onUpdateRatings(newRatings);
                    alert(`Synced ratings for ${updatedCount} players based on latest testing data.`);
                } else {
                    alert("No testing data found to sync.");
                }
            };

            const handleAttributeChange = (attrId, value) => {
                if (!selectedPlayerId) return;
                const currentRatings = getPlayerRating(selectedPlayerId);
                const newRatings = { ...safeRatings, [selectedPlayerId]: { ...currentRatings, [attrId]: parseInt(value) } };
                onUpdateRatings(newRatings);
            };

            const sortedRoster = [...roster].sort((a, b) => {
                const ovrA = calculateOVR(a, safeRatings[a.id]);
                const ovrB = calculateOVR(b, safeRatings[b.id]);
                return ovrB - ovrA;
            });

            const selectedPlayer = roster.find(p => p.id === selectedPlayerId);
            const currentStats = selectedPlayerId ? getPlayerRating(selectedPlayerId) : null;
            const currentOVR = selectedPlayer ? calculateOVR(selectedPlayer, currentStats) : 0;

            // Group attributes for display
            const groupedAttributes = ATTRIBUTES.reduce((acc, attr) => {
                if (!acc[attr.group]) acc[attr.group] = [];
                acc[attr.group].push(attr);
                return acc;
            }, {});

            return (
                <div style={{ height: 'calc(100vh - 100px)', display: 'flex', gap: '2rem' }}>
                    {/* Player List */}
                    <div className="card" style={{ width: '300px', display: 'flex', flexDirection: 'column', padding: '0' }}>
                        <div style={{ padding: '1rem', borderBottom: '1px solid var(--border)', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <h3 style={{ margin: 0 }}>Roster</h3>
                            <button className="btn btn-secondary" style={{ fontSize: '0.7rem', padding: '2px 6px' }} onClick={syncRatings}>Sync Tests</button>
                        </div>
                        <div style={{ flex: 1, overflowY: 'auto' }}>
                            {sortedRoster.map(player => {
                                const ovr = calculateOVR(player, safeRatings[player.id]);
                                const archetype = calculateArchetype(player.position, safeRatings[player.id]);
                                let ovrColor = '#ef4444'; // < 70
                                if (ovr >= 90) ovrColor = '#10b981'; // Elite
                                else if (ovr >= 80) ovrColor = '#3b82f6'; // Star
                                else if (ovr >= 70) ovrColor = '#f59e0b'; // Starter

                                return (
                                    <div
                                        key={player.id}
                                        onClick={() => setSelectedPlayerId(player.id)}
                                        style={{
                                            padding: '0.75rem 1rem',
                                            borderBottom: '1px solid var(--border)',
                                            cursor: 'pointer',
                                            background: selectedPlayerId === player.id ? 'var(--bg-body)' : 'transparent',
                                            display: 'flex',
                                            justifyContent: 'space-between',
                                            alignItems: 'center'
                                        }}
                                    >
                                        <div>
                                            <div style={{ fontWeight: 'bold' }}>{player.name}</div>
                                            <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>
                                                #{player.number} • {player.position} <span style={{ color: 'var(--accent)', marginLeft: '4px' }}>• {archetype}</span>
                                            </div>
                                        </div>
                                        <div style={{
                                            background: ovrColor,
                                            color: '#fff',
                                            fontWeight: 'bold',
                                            borderRadius: '4px',
                                            width: '36px',
                                            height: '36px',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            fontSize: '1.1rem'
                                        }}>
                                            {ovr}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>

                    {/* Editor */}
                    <div className="card" style={{ flex: 1, display: 'flex', flexDirection: 'column' }}>
                        {selectedPlayer ? (
                            <>
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '2rem', borderBottom: '1px solid var(--border)', paddingBottom: '1rem' }}>
                                    <div>
                                        <h2 style={{ margin: 0 }}>{selectedPlayer.name}</h2>
                                        <div style={{ fontSize: '1.1rem', color: 'var(--text-secondary)', marginTop: '0.25rem' }}>
                                            #{selectedPlayer.number} • {selectedPlayer.position} <span style={{ color: 'var(--accent)', fontWeight: 'bold' }}>• {calculateArchetype(selectedPlayer.position, currentStats)}</span>
                                        </div>
                                        {(() => {
                                            const stats = getLatestStats(selectedPlayer.id);
                                            if (stats) {
                                                return (
                                                    <div style={{ display: 'flex', gap: '1rem', marginTop: '0.5rem', fontSize: '0.8rem', color: 'var(--text-secondary)' }}>
                                                        <span>40: <strong style={{ color: 'var(--text-primary)' }}>{stats.forty || '-'}</strong></span>
                                                        <span>Bench: <strong style={{ color: 'var(--text-primary)' }}>{stats.bench || '-'}</strong></span>
                                                        <span>Squat: <strong style={{ color: 'var(--text-primary)' }}>{stats.squat || '-'}</strong></span>
                                                        <span>Vert: <strong style={{ color: 'var(--text-primary)' }}>{stats.vertical || '-'}</strong></span>
                                                    </div>
                                                );
                                            }
                                            return null;
                                        })()}
                                    </div>
                                    <div style={{ textAlign: 'right' }}>
                                        <div style={{ fontSize: '0.9rem', color: 'var(--text-secondary)' }}>OVERALL</div>
                                        <div style={{ fontSize: '3rem', fontWeight: '900', lineHeight: 1, color: currentOVR >= 90 ? '#10b981' : currentOVR >= 80 ? '#3b82f6' : currentOVR >= 70 ? '#f59e0b' : '#ef4444' }}>
                                            {currentOVR}
                                        </div>
                                    </div>
                                </div>

                                <div style={{ overflowY: 'auto', paddingRight: '1rem' }}>
                                    {Object.entries(groupedAttributes).map(([group, attrs]) => (
                                        <div key={group} style={{ marginBottom: '2rem' }}>
                                            <h4 style={{ borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem', marginBottom: '1rem', color: 'var(--accent)' }}>{group}</h4>
                                            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))', gap: '1.5rem' }}>
                                                {attrs.map(attr => (
                                                    <div key={attr.id}>
                                                        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem' }}>
                                                            <label style={{ fontWeight: 'bold' }}>{attr.id}</label>
                                                            <span style={{ fontWeight: 'bold' }}>{currentStats[attr.id]}</span>
                                                        </div>
                                                        <input
                                                            type="range"
                                                            min="0"
                                                            max="99"
                                                            value={currentStats[attr.id]}
                                                            onChange={e => handleAttributeChange(attr.id, e.target.value)}
                                                            style={{
                                                                width: '100%',
                                                                accentColor: 'var(--accent)'
                                                            }}
                                                        />
                                                        <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginTop: '0.25rem' }}>{attr.name}</div>
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </>
                        ) : (
                            <div style={{ flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'var(--text-secondary)', flexDirection: 'column' }}>
                                <Icon name="User" />
                                <p style={{ marginTop: '1rem' }}>Select a player to edit ratings</p>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const PressboxTracker = ({ plays, gameLog, onUpdateGameLog, roster, depthChart, situation, onUpdateSituation, formations, activePlay, setActivePlay }) => {
            // Helper to convert User Format (-49 to -1, 50, 49 to 1) to Linear (1-99)
            // Linear: 1 (Own 1) -> 50 (Mid) -> 99 (Opp 1)
            const toLinearYard = (userVal) => {
                if (userVal === 50) return 50;
                if (userVal < 0) return Math.abs(userVal); // -20 -> 20
                return 100 - userVal; // 20 -> 80
            };

            // Helper to convert Linear (1-99) to User Format
            const toUserYard = (linearVal) => {
                if (linearVal === 50) return 50;
                if (linearVal < 50) return -linearVal; // 20 -> -20
                return 100 - linearVal; // 80 -> 20
            };

            const formatYardLine = (linearVal) => {
                const userVal = toUserYard(linearVal);
                if (userVal === 50) return '50';
                if (userVal < 0) return `Own ${Math.abs(userVal)}`;
                return `Opp ${userVal}`;
            };

            // Situation state is now lifted to App
            const setSituation = onUpdateSituation;
            const [selectedPlayId, setSelectedPlayId] = useState('');
            const [result, setResult] = useState({
                yards: 0,
                type: 'Run',
                outcome: 'Tackle'
            });
            const [isSelectingPlay, setIsSelectingPlay] = useState(false);
            const [injuredPlayerId, setInjuredPlayerId] = useState('');

            // Formation Window State
            const getDefaultDefenderPositions = () => [
                { id: 'DL1', label: 'DL', x: 35, y: 48 },
                { id: 'DL2', label: 'DL', x: 42, y: 50 },
                { id: 'DL3', label: 'DL', x: 58, y: 50 },
                { id: 'DL4', label: 'DL', x: 65, y: 48 },
                { id: 'LB1', label: 'LB', x: 30, y: 35 },
                { id: 'LB2', label: 'LB', x: 50, y: 38 },
                { id: 'LB3', label: 'LB', x: 70, y: 35 },
                { id: 'DB1', label: 'CB', x: 15, y: 20 },
                { id: 'DB2', label: 'CB', x: 85, y: 20 },
                { id: 'DB3', label: 'S', x: 35, y: 15 },
                { id: 'DB4', label: 'S', x: 65, y: 15 },
            ];
            const [defenders, setDefenders] = useState(getDefaultDefenderPositions());
            const [draggingDefender, setDraggingDefender] = useState(null);
            const fieldRef = useRef(null);

            // Reset defender positions when play changes
            // Reset defender positions when play changes
            useEffect(() => {
                setDefenders(getDefaultDefenderPositions());
            }, [selectedPlayId]);

            // Sync Active Play from OC
            useEffect(() => {
                if (activePlay) {
                    setSelectedPlayId(activePlay.id);
                }
            }, [activePlay]);

            // Special Teams Keys to Check
            const ST_KEYS = ['KICKOFF', 'KICK_RETURN', 'PUNT', 'PUNT_RETURN', 'FIELD_GOAL', 'HANDS_TEAM', 'ONSIDE_KICK', 'PAT_BLOCK'];

            const PENALTY_TYPES = [
                "Holding", "False Start", "Offsides", "Pass Interference", "Personal Foul",
                "Delay of Game", "Block in the Back", "Roughing the Passer", "Facemask", "Unsportsmanlike Conduct"
            ];

            const [penalty, setPenalty] = useState({
                active: false,
                playerId: '',
                type: ''
            });

            const reportInjury = () => {
                if (!injuredPlayerId) return;

                const player = roster.find(p => p.id === injuredPlayerId);
                const affectedUnits = [];

                ST_KEYS.forEach(key => {
                    const chart = depthChart[key] || {};
                    const isStarter = Object.values(chart).some(pid => pid === injuredPlayerId);
                    if (isStarter) affectedUnits.push(key.replace('_', ' '));
                });

                if (affectedUnits.length > 0) {
                    alert(`⚠️ ALERT: ${player.name} is a starter on: ${affectedUnits.join(', ')}.\n\nNotify Special Teams Coordinator immediately!`);
                } else {
                    alert(`Injury recorded for ${player.name}. No immediate Special Teams conflicts found.`);
                }

                // Reset
                setInjuredPlayerId('');
            };
            const handleLogPlay = () => {
                const play = plays.find(p => p.id === selectedPlayId);
                const newLogEntry = {
                    id: Date.now().toString(),
                    situation: { ...situation },
                    play: play ? { name: play.name, formation: play.formation } : { name: 'Unknown', formation: '' },
                    play: play ? { name: play.name, formation: play.formation } : { name: 'Unknown', formation: '' },
                    result: { ...result },
                    penalty: penalty.active ? { ...penalty } : null
                };

                // Calculate next situation
                let nextYardLine = situation.yardLine + result.yards;
                let nextDown = situation.down + 1;
                let nextDistance = situation.distance - result.yards;

                // Handle Touchdown
                if (result.type === 'Touchdown' || nextYardLine >= 100) {
                    nextYardLine = 100; // Endzone
                    // Reset for next drive (Kickoff? or PAT? Let's assume PAT/Kickoff sequence implies new drive starts at Own 25)
                    // For simplicity, let's just mark it. The user can manually reset or we can prompt.
                    // Let's auto-reset to Own 25 for next drive for now, or maybe just leave it at 100 to show TD.
                    // Better: Leave it, user changes drive number and yard line manually for next drive.
                }

                if (nextDistance <= 0 && nextYardLine < 100) {
                    nextDown = 1;
                    nextDistance = 10;
                }

                if (nextDown > 4) {
                    nextDown = 1;
                    nextDistance = 10;
                    // Turnover logic could go here
                }

                onUpdateGameLog([newLogEntry, ...gameLog]);

                // Update current situation
                setSituation({
                    ...situation,
                    down: nextDown,
                    distance: nextDistance,
                    yardLine: nextYardLine
                });

                // Reset result inputs
                setSelectedPlayId('');
                if (setActivePlay) setActivePlay(null); // Clear active play
                setResult({ yards: 0, type: 'Run', outcome: 'Tackle' });
                setPenalty({ active: false, playerId: '', type: '' });
            };

            return (
                <div style={{ height: 'calc(100vh - 100px)', display: 'flex', flexDirection: 'column', gap: '1.5rem' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                        <h2>Pressbox / Game Tracker</h2>
                        <div style={{ display: 'flex', gap: '1rem', alignItems: 'center' }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', background: 'var(--surface)', padding: '0.25rem 0.5rem', borderRadius: '8px', border: '1px solid var(--border)' }}>
                                <span style={{ fontSize: '0.9rem', fontWeight: 'bold' }}>Drive:</span>
                                <button className="btn" style={{ padding: '0.25rem 0.5rem' }} onClick={() => setSituation({ ...situation, driveNumber: Math.max(1, situation.driveNumber - 1) })}>-</button>
                                <span style={{ fontWeight: 'bold', minWidth: '20px', textAlign: 'center' }}>{situation.driveNumber}</span>
                                <button className="btn" style={{ padding: '0.25rem 0.5rem' }} onClick={() => setSituation({ ...situation, driveNumber: situation.driveNumber + 1 })}>+</button>
                            </div>
                            <button className="btn btn-secondary" onClick={() => window.print()}>🖨️ Print Log</button>
                        </div>
                    </div>

                    {/* Active Play Banner */}
                    {activePlay && (
                        <div style={{ background: 'linear-gradient(90deg, #f43f5e 0%, #ec4899 100%)', padding: '1rem', borderRadius: '8px', color: 'white', display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem', animation: 'pulse 2s infinite' }}>
                            <div>
                                <div style={{ fontSize: '0.8rem', opacity: 0.9, fontWeight: 'bold' }}>🚨 ACTIVE CALL IN FROM SIDELINE</div>
                                <div style={{ fontSize: '1.5rem', fontWeight: 'bold' }}>{activePlay.name}</div>
                                <div style={{ fontSize: '0.9rem' }}>{activePlay.formation}</div>
                            </div>
                            <Icon name="Radio" size={32} />
                        </div>
                    )}

                    {/* Situation Input */}
                    <div className="card" style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '1rem', alignItems: 'end' }}>
                        <div>
                            <label className="form-label">Down</label>
                            <div className="situation-toggle">
                                {[1, 2, 3, 4].map(d => (
                                    <button
                                        key={d}
                                        className={situation.down === d ? 'active' : ''}
                                        onClick={() => setSituation({ ...situation, down: d })}
                                    >
                                        {d}
                                    </button>
                                ))}
                            </div>
                        </div>
                        <div>
                            <label className="form-label">Distance</label>
                            <input
                                type="number"
                                className="form-input"
                                value={situation.distance}
                                onChange={e => setSituation({ ...situation, distance: parseInt(e.target.value) || 0 })}
                            />
                        </div>
                        <div>
                            <label className="form-label">Ball On (-49 to 49)</label>
                            <input
                                type="number"
                                className="form-input"
                                value={toUserYard(situation.yardLine)}
                                onChange={e => setSituation({ ...situation, yardLine: toLinearYard(parseInt(e.target.value) || 0) })}
                                placeholder="-25 = Own 25"
                            />
                            <div style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', marginTop: '0.25rem' }}>
                                {formatYardLine(situation.yardLine)}
                            </div>
                        </div>
                        <div>
                            <label className="form-label">Hash</label>
                            <div className="situation-toggle">
                                {['L', 'LM', 'M', 'RM', 'R'].map(h => (
                                    <button
                                        key={h}
                                        className={situation.hash === h ? 'active' : ''}
                                        onClick={() => setSituation({ ...situation, hash: h })}
                                    >
                                        {h}
                                    </button>
                                ))}
                            </div>
                        </div>
                    </div>

                    {/* Play Call & Result */}
                    <div className="card" style={{ display: 'flex', gap: '2rem', alignItems: 'flex-start' }}>
                        <div style={{ flex: 1 }}>
                            <label className="form-label">Call Play</label>
                            <div style={{ display: 'flex', gap: '0.5rem' }}>
                                <select
                                    className="form-select"
                                    value={selectedPlayId}
                                    onChange={e => setSelectedPlayId(e.target.value)}
                                >
                                    <option value="">-- Select Play --</option>
                                    {plays.map(p => (
                                        <option key={p.id} value={p.id}>{p.formation && !checkRedundantFormation(p.name, p.formation) ? `${p.formation} - ` : ''}{p.name}</option>
                                    ))}
                                </select>
                            </div>
                        </div>

                        <div style={{ flex: 1, display: 'flex', gap: '1rem' }}>
                            <div style={{ flex: 1 }}>
                                <label className="form-label">Yards Gained</label>
                                <input
                                    type="number"
                                    className="form-input"
                                    value={result.yards}
                                    onChange={e => setResult({ ...result, yards: parseInt(e.target.value) || 0 })}
                                />
                            </div>
                            <div style={{ flex: 1 }}>
                                <label className="form-label">Type</label>
                                <select
                                    className="form-select"
                                    value={result.type}
                                    onChange={e => setResult({ ...result, type: e.target.value })}
                                >
                                    <option>Run</option>
                                    <option>Pass</option>
                                    <option>Sack</option>
                                    <option>Special</option>
                                </select>
                            </div>
                            <div style={{ flex: 1 }}>
                                <label className="form-label">Result</label>
                                <select
                                    className="form-select"
                                    value={result.outcome}
                                    onChange={e => setResult({ ...result, outcome: e.target.value })}
                                >
                                    <option>Tackle</option>
                                    <option>Touchdown</option>
                                    <option>Fumble</option>
                                    <option>Interception</option>
                                    <option>Incomplete</option>
                                    <option>Out of Bounds</option>
                                    <option>Fair Catch</option>
                                    <option>Touchback</option>
                                    <option>Safety</option>
                                </select>
                            </div>
                        </div>

                        <div style={{ alignSelf: 'flex-end' }}>
                            <button
                                className="btn btn-primary"
                                style={{ height: '42px', padding: '0 2rem' }}
                                onClick={handleLogPlay}
                                disabled={!selectedPlayId}
                            >
                                Log Play
                            </button>
                        </div>
                    </div>

                    {/* Formation Window - Draggable Defenders */}
                    <div className="card" style={{ padding: '1rem', height: '500px', display: 'flex', flexDirection: 'column' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                            <div>
                                <h3 style={{ margin: 0, fontSize: '1.1rem' }}>Formation: {selectedPlayId ? plays.find(p => p.id === selectedPlayId)?.formation || 'Unknown' : 'No Play Selected'}</h3>
                                {selectedPlayId && plays.find(p => p.id === selectedPlayId) && (
                                    <div style={{ fontSize: '0.9rem', color: 'var(--text-secondary)', marginTop: '0.25rem' }}>
                                        {plays.find(p => p.id === selectedPlayId).name}
                                    </div>
                                )}
                            </div>
                            <button
                                className="btn btn-secondary"
                                onClick={() => setDefenders(getDefaultDefenderPositions())}
                                style={{ fontSize: '0.8rem', padding: '0.25rem 0.75rem' }}
                            >
                                Reset Defense
                            </button>
                        </div>

                        {/* Football Field */}
                        <div
                            ref={fieldRef}
                            style={{
                                flex: 1,
                                background: 'linear-gradient(180deg, #2d5016 0%, #1a3d0a 100%)',
                                borderRadius: '8px',
                                border: '3px solid #fff',
                                position: 'relative',
                                overflow: 'hidden',
                                cursor: draggingDefender ? 'grabbing' : 'default'
                            }}
                            onMouseMove={(e) => {
                                if (!draggingDefender || !fieldRef.current) return;
                                const rect = fieldRef.current.getBoundingClientRect();
                                const x = ((e.clientX - rect.left) / rect.width) * 100;
                                const y = ((e.clientY - rect.top) / rect.height) * 100;
                                const constrainedX = Math.max(2, Math.min(98, x));
                                const constrainedY = Math.max(2, Math.min(98, y));
                                setDefenders(prev => prev.map(d =>
                                    d.id === draggingDefender ? { ...d, x: constrainedX, y: constrainedY } : d
                                ));
                            }}
                            onMouseUp={() => setDraggingDefender(null)}
                            onMouseLeave={() => setDraggingDefender(null)}
                        >
                            {/* Hash Marks */}
                            <div style={{ position: 'absolute', left: '30%', top: 0, bottom: 0, width: '2px', borderLeft: '2px dashed rgba(255,255,255,0.3)' }} />
                            <div style={{ position: 'absolute', left: '70%', top: 0, bottom: 0, width: '2px', borderLeft: '2px dashed rgba(255,255,255,0.3)' }} />

                            {/* Line of Scrimmage */}
                            <div style={{ position: 'absolute', left: 0, right: 0, top: '50%', height: '3px', background: '#fff', opacity: 0.8 }} />
                            <div style={{ position: 'absolute', left: '50%', top: '50%', transform: 'translate(-50%, -50%)', color: '#fff', fontSize: '0.7rem', fontWeight: 'bold', background: 'rgba(0,0,0,0.5)', padding: '2px 6px', borderRadius: '4px' }}>
                                LOS
                            </div>

                            {/* Yard Line Markers */}
                            {[0, 25, 50, 75, 100].map(pct => (
                                <div key={pct} style={{ position: 'absolute', left: 0, right: 0, top: `${pct}%`, height: '1px', background: 'rgba(255,255,255,0.15)' }} />
                            ))}

                            {/* Offensive Players */}
                            {(() => {
                                const selectedPlay = selectedPlayId ? plays.find(p => p.id === selectedPlayId) : null;
                                if (!selectedPlay) return null;

                                // Find formation from database
                                let formationData = null;
                                if (selectedPlay.formation) {
                                    // Try exact match first
                                    formationData = formations.find(f =>
                                        f.name.toLowerCase() === selectedPlay.formation.toLowerCase()
                                    );

                                    // If no exact match, try fuzzy match
                                    if (!formationData) {
                                        const formationLower = selectedPlay.formation.toLowerCase();
                                        formationData = formations.find(f =>
                                            formationLower.includes(f.name.toLowerCase()) ||
                                            f.name.toLowerCase().includes(formationLower)
                                        );
                                    }
                                }

                                // Use formation positions if found, otherwise fallback to default
                                if (formationData && formationData.positions) {
                                    return formationData.positions.map((pos, idx) => (
                                        <div key={`off-${idx}`} style={{ position: 'absolute', left: `${pos.x}%`, top: `${pos.y}%`, transform: 'translate(-50%, -50%)', width: '24px', height: '24px', borderRadius: '50%', background: '#3b82f6', border: '2px solid #fff', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '0.6rem', fontWeight: 'bold', color: '#fff', pointerEvents: 'none', userSelect: 'none' }}>
                                            {pos.label}
                                        </div>
                                    ));
                                } else {
                                    // Fallback to default spread formation - aligned to LOS (y=50)
                                    const defaultPositions = [
                                        // OL on the LOS
                                        { label: 'LT', x: 35, y: 50 }, { label: 'LG', x: 42, y: 50 }, { label: 'C', x: 50, y: 50 },
                                        { label: 'RG', x: 58, y: 50 }, { label: 'RT', x: 65, y: 50 },
                                        // Receivers on the LOS
                                        { label: 'X', x: 10, y: 50 }, { label: 'Z', x: 90, y: 50 },
                                        { label: 'Y', x: 72, y: 50 }, { label: 'A', x: 28, y: 50 },
                                        // Backfield behind LOS
                                        { label: 'QB', x: 50, y: 56 }, { label: 'RB', x: 50, y: 64 }
                                    ];
                                    return defaultPositions.map((pos, idx) => (
                                        <div key={`off-${idx}`} style={{ position: 'absolute', left: `${pos.x}%`, top: `${pos.y}%`, transform: 'translate(-50%, -50%)', width: '24px', height: '24px', borderRadius: '50%', background: '#3b82f6', border: '2px solid #fff', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '0.6rem', fontWeight: 'bold', color: '#fff', pointerEvents: 'none', userSelect: 'none' }}>
                                            {pos.label}
                                        </div>
                                    ));
                                }
                            })()}

                            {/* Defensive Players (Draggable) */}
                            {defenders.map(defender => (
                                <div
                                    key={defender.id}
                                    style={{ position: 'absolute', left: `${defender.x}%`, top: `${defender.y}%`, transform: 'translate(-50%, -50%)', width: '28px', height: '28px', borderRadius: '50%', background: draggingDefender === defender.id ? '#ef4444' : '#dc2626', border: '3px solid #fff', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '0.65rem', fontWeight: 'bold', color: '#fff', cursor: 'grab', userSelect: 'none', boxShadow: draggingDefender === defender.id ? '0 4px 12px rgba(0,0,0,0.4)' : '0 2px 4px rgba(0,0,0,0.2)', transition: draggingDefender === defender.id ? 'none' : 'all 0.1s ease', zIndex: draggingDefender === defender.id ? 1000 : 10 }}
                                    onMouseDown={(e) => { e.preventDefault(); setDraggingDefender(defender.id); }}
                                >
                                    {defender.label}
                                </div>
                            ))}

                            {/* Legend */}
                            <div style={{ position: 'absolute', bottom: '8px', left: '8px', background: 'rgba(0,0,0,0.7)', borderRadius: '6px', padding: '6px 10px', display: 'flex', gap: '12px', fontSize: '0.7rem', color: '#fff' }}>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                                    <div style={{ width: '12px', height: '12px', borderRadius: '50%', background: '#3b82f6', border: '1px solid #fff' }} />
                                    <span>Offense</span>
                                </div>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                                    <div style={{ width: '12px', height: '12px', borderRadius: '50%', background: '#dc2626', border: '1px solid #fff' }} />
                                    <span>Defense (Drag to Move)</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Penalty Tracking */}
                    <div className="card">
                        <div style={{ display: 'flex', alignItems: 'center', gap: '2rem' }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                <input
                                    type="checkbox"
                                    id="penaltyActive"
                                    checked={penalty.active}
                                    onChange={e => setPenalty({ ...penalty, active: e.target.checked })}
                                    style={{ width: '20px', height: '20px', display: 'block' }}
                                />
                                <label htmlFor="penaltyActive" style={{ fontWeight: 'bold', color: penalty.active ? '#ef4444' : 'inherit' }}>
                                    FLAG ON PLAY?
                                </label>
                            </div>

                            {penalty.active && (
                                <>
                                    <div style={{ flex: 1 }}>
                                        <select
                                            className="form-select"
                                            value={penalty.playerId}
                                            onChange={e => setPenalty({ ...penalty, playerId: e.target.value })}
                                        >
                                            <option value="">-- Who Committed Penalty? --</option>
                                            {roster.filter(Boolean).sort((a, b) => (a?.name || '').localeCompare(b?.name || '')).map(p => (
                                                <option key={p.id} value={p.id}>#{p.number} {p.name}</option>
                                            ))}
                                        </select>
                                    </div>
                                    <div style={{ flex: 1 }}>
                                        <select
                                            className="form-select"
                                            value={penalty.type}
                                            onChange={e => setPenalty({ ...penalty, type: e.target.value })}
                                        >
                                            <option value="">-- Penalty Type --</option>
                                            {PENALTY_TYPES.map(t => (
                                                <option key={t} value={t}>{t}</option>
                                            ))}
                                        </select>
                                    </div>
                                </>
                            )}
                        </div>
                    </div>

                    {/* Injury Report */}
                    <div className="card" style={{ display: 'flex', gap: '1rem', alignItems: 'center', background: '#ffe4e6', border: '1px solid #f43f5e' }}>
                        <div style={{ fontWeight: 'bold', color: '#be123c', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                            <Icon name="Activity" size={20} />
                            Injury Report
                        </div>
                        <div style={{ flex: 1 }}>
                            <select
                                className="form-select"
                                value={injuredPlayerId}
                                onChange={e => setInjuredPlayerId(e.target.value)}
                                style={{ background: 'white', borderColor: '#fca5a5' }}
                            >
                                <option value="">-- Start Typing or Select Player --</option>
                                {roster.filter(Boolean).sort((a, b) => (a?.name || '').localeCompare(b?.name || '')).map(p => (
                                    <option key={p.id} value={p.id}>{p.name} #{p.number}</option>
                                ))}
                            </select>
                        </div>
                        <button
                            className="btn"
                            onClick={reportInjury}
                            disabled={!injuredPlayerId}
                            style={{
                                background: '#e11d48', color: 'white', border: 'none', fontWeight: 'bold'
                            }}
                        >
                            Mark & Check Depth
                        </button>
                    </div>

                    {/* Game Log */}
                    <div style={{ flex: 1, overflowY: 'auto' }}>
                        <h3>Game Log</h3>
                        <table style={{ width: '100%', borderCollapse: 'collapse', marginTop: '0.5rem' }}>
                            <thead>
                                <tr style={{ borderBottom: '2px solid var(--border)', textAlign: 'left', color: 'var(--text-secondary)', fontSize: '0.9rem' }}>
                                    <th style={{ padding: '0.5rem' }}>Drive</th>
                                    <th style={{ padding: '0.5rem' }}>Sit</th>
                                    <th style={{ padding: '0.5rem' }}>Ball</th>
                                    <th style={{ padding: '0.5rem' }}>Hash</th>
                                    <th style={{ padding: '0.5rem' }}>Play Call</th>
                                    <th style={{ padding: '0.5rem' }}>Result</th>
                                </tr>
                            </thead>
                            <tbody>
                                {/* This section seems to be part of a different component or context,
                                    as 'seg', 'coachFilter', 'currentTime', and 'roster.staff' are not defined here.
                                    Assuming it's intended for a different table or view.
                                    Inserting it as a comment block to maintain syntactical correctness.
                                */}

                                {gameLog.map(entry => (
                                    <tr key={entry.id} style={{ borderBottom: '1px solid var(--border)' }}>
                                        <td style={{ padding: '0.75rem 0.5rem', color: 'var(--text-secondary)' }}>#{entry.situation.driveNumber}</td>
                                        <td style={{ padding: '0.75rem 0.5rem' }}>
                                            <span className="tag">{entry.situation.down} & {entry.situation.distance}</span>
                                        </td>
                                        <td style={{ padding: '0.75rem 0.5rem' }}>{formatYardLine(entry.situation.yardLine)}</td>
                                        <td style={{ padding: '0.75rem 0.5rem' }}>{entry.situation.hash}</td>
                                        <td style={{ padding: '0.75rem 0.5rem', fontWeight: 'bold' }}>
                                            {entry.play.formation && !checkRedundantFormation(entry.play.name, entry.play.formation) ? `${entry.play.formation} - ` : ''}{entry.play.name}
                                        </td>
                                        <td style={{ padding: '0.75rem 0.5rem' }}>
                                            <span style={{ color: entry.result.yards >= 0 ? '#10b981' : '#ef4444', fontWeight: 'bold' }}>
                                                {entry.result.yards > 0 ? '+' : ''}{entry.result.yards}
                                            </span>
                                            <span style={{ marginLeft: '0.5rem', color: 'var(--text-secondary)', fontSize: '0.9rem' }}>
                                                {entry.result.type}
                                                {entry.result.outcome !== 'Tackle' && ` - ${entry.result.outcome}`}
                                            </span>
                                            {entry.penalty && (
                                                <div style={{ color: '#ef4444', fontSize: '0.8rem', fontWeight: 'bold' }}>
                                                    FLAG: {entry.penalty.type}
                                                    {(() => {
                                                        const p = roster.find(r => r.id === entry.penalty.playerId);
                                                        return p ? ` (#${p.number} ${p.name})` : '';
                                                    })()}
                                                </div>
                                            )}
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                </div>
            );
        };

        const FormationManager = ({ formations, onAddFormation, onUpdateFormation, onDeleteFormation, positionNames = {}, phase = 'OFFENSE' }) => {
            const [selectedFormationId, setSelectedFormationId] = useState(null);
            const [editingFormation, setEditingFormation] = useState(null);
            const [isCreatingNew, setIsCreatingNew] = useState(false);
            const fieldRef = useRef(null);
            const [draggingPlayer, setDraggingPlayer] = useState(null);
            const [selectedIndices, setSelectedIndices] = useState([]);
            const [selectionBox, setSelectionBox] = useState(null);
            const [lastMousePos, setLastMousePos] = useState(null);

            const displayedFormations = formations.filter(f => (f.phase || 'OFFENSE') === phase);

            const handleStartNew = () => {
                setIsCreatingNew(true);
                setSelectedFormationId(null);

                let defaultPositions = [];
                if (phase === 'DEFENSE') {
                    defaultPositions = [
                        { label: 'DE', x: 30, y: 48 }, { label: 'NT', x: 50, y: 48 }, { label: 'DE', x: 70, y: 48 },
                        { label: 'LB', x: 20, y: 40 }, { label: 'LB', x: 40, y: 35 }, { label: 'LB', x: 60, y: 35 }, { label: 'LB', x: 80, y: 40 },
                        { label: 'CB', x: 10, y: 25 }, { label: 'CB', x: 90, y: 25 },
                        { label: 'S', x: 35, y: 15 }, { label: 'S', x: 65, y: 15 }
                    ];
                } else if (phase === 'SPECIAL_TEAMS') {
                    defaultPositions = [
                        { label: 'L1', x: 10, y: 40 }, { label: 'L2', x: 20, y: 40 }, { label: 'L3', x: 30, y: 40 }, { label: 'L4', x: 40, y: 40 }, { label: 'L5', x: 45, y: 40 },
                        { label: 'K', x: 50, y: 50 },
                        { label: 'R5', x: 55, y: 40 }, { label: 'R4', x: 60, y: 40 }, { label: 'R3', x: 70, y: 40 }, { label: 'R2', x: 80, y: 40 }, { label: 'R1', x: 90, y: 40 }
                    ];
                } else {
                    // Align all players at or near the LOS (y=50) for easier positioning
                    defaultPositions = [
                        // OL on the LOS
                        { label: 'LT', x: 35, y: 50 }, { label: 'LG', x: 42, y: 50 }, { label: 'C', x: 50, y: 50 },
                        { label: 'RG', x: 58, y: 50 }, { label: 'RT', x: 65, y: 50 },
                        // Receivers on the LOS
                        { label: 'X', x: 10, y: 50 }, { label: 'Z', x: 90, y: 50 },
                        { label: 'Y', x: 72, y: 50 }, { label: 'A', x: 28, y: 50 },
                        // Backfield behind LOS
                        { label: 'QB', x: 50, y: 56 }, { label: 'RB', x: 50, y: 64 }
                    ];
                }

                setEditingFormation({
                    id: Date.now().toString(),
                    name: '',
                    description: '',
                    phase: phase,
                    positions: defaultPositions
                });
            };

            const handleSelectFormation = (formationId) => {
                const formation = formations.find(f => f.id === formationId);
                if (formation) {
                    setSelectedFormationId(formationId);
                    setEditingFormation(JSON.parse(JSON.stringify(formation)));
                    setIsCreatingNew(false);
                    setSelectedIndices([]);
                }
            };

            const handleSave = () => {
                if (!editingFormation.name.trim()) {
                    alert('Please enter a formation number/name');
                    return;
                }
                if (isCreatingNew) onAddFormation(editingFormation);
                else onUpdateFormation(editingFormation.id, editingFormation);
                setIsCreatingNew(false);
                setSelectedFormationId(editingFormation.id);
            };

            const handleDelete = () => {
                if (!selectedFormationId) return;
                onDeleteFormation(selectedFormationId);
                setSelectedFormationId(null);
                setEditingFormation(null);
            };

            return (
                <div style={{ height: 'calc(100vh - 100px)', display: 'flex', gap: '2rem' }}>
                    <div className="card" style={{ width: '300px', display: 'flex', flexDirection: 'column', padding: '0' }}>
                        <div style={{ padding: '1rem', borderBottom: '1px solid var(--border)', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <h3 style={{ margin: 0 }}>Formations</h3>
                            <button className="btn btn-primary" style={{ fontSize: '0.8rem', padding: '0.25rem 0.75rem' }} onClick={handleStartNew}>+ New</button>
                        </div>
                        <div style={{ flex: 1, overflowY: 'auto' }}>
                            {displayedFormations.map(formation => (
                                <div key={formation.id} onClick={() => handleSelectFormation(formation.id)} style={{ padding: '0.75rem 1rem', borderBottom: '1px solid var(--border)', cursor: 'pointer', background: selectedFormationId === formation.id ? 'var(--bg-body)' : 'transparent' }}>
                                    <div style={{ fontWeight: 'bold', fontSize: '1.1rem' }}>{formation.name}</div>
                                    {formation.description && <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginTop: '0.25rem' }}>{formation.description}</div>}
                                </div>
                            ))}
                        </div>
                    </div>
                    <div className="card" style={{ flex: 1, display: 'flex', flexDirection: 'column' }}>
                        {editingFormation ? (
                            <>
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem', paddingBottom: '1rem', borderBottom: '1px solid var(--border)' }}>
                                    <h2 style={{ margin: 0 }}>{isCreatingNew ? 'Create Formation' : 'Edit Formation'}</h2>
                                    <div style={{ display: 'flex', gap: '0.5rem' }}>
                                        <button className="btn btn-secondary" onClick={() => { setIsCreatingNew(false); setEditingFormation(null); setSelectedFormationId(null); }}>Cancel</button>
                                        {!isCreatingNew && <button className="btn" style={{ background: '#ef4444', color: 'white', border: 'none' }} onClick={handleDelete}>Delete</button>}
                                        <button className="btn btn-primary" onClick={handleSave}>Save</button>
                                    </div>
                                </div>
                                <div style={{ display: 'grid', gridTemplateColumns: '1fr 2fr', gap: '1rem', marginBottom: '1.5rem' }}>
                                    <div>
                                        <label className="form-label">Formation Number</label>
                                        <input type="text" className="form-input" value={editingFormation.name} onChange={e => setEditingFormation({ ...editingFormation, name: e.target.value })} placeholder="e.g., 887, 983" />
                                    </div>
                                    <div>
                                        <label className="form-label">Description</label>
                                        <input type="text" className="form-input" value={editingFormation.description} onChange={e => setEditingFormation({ ...editingFormation, description: e.target.value })} placeholder="e.g., Trips right" />
                                    </div>
                                </div>
                                <div style={{ flex: 1, minHeight: '400px' }}>
                                    <label className="form-label" style={{ marginBottom: '0.5rem', display: 'block' }}>Player Positions (Drag to Adjust)</label>
                                    <svg
                                        ref={fieldRef}
                                        width="100%"
                                        height="100%"
                                        viewBox="0 0 900 600"
                                        preserveAspectRatio="none"
                                        style={{ border: '2px solid #cbd5e1', borderRadius: '8px', cursor: (draggingPlayer !== null || selectionBox !== null) ? 'grabbing' : 'default' }}
                                        onMouseDown={(e) => {
                                            if (!fieldRef.current || !editingFormation) return;
                                            const rect = fieldRef.current.getBoundingClientRect();
                                            const x = ((e.clientX - rect.left) / rect.width) * 100;
                                            const y = ((e.clientY - rect.top) / rect.height) * 100;

                                            // If not Shift, clear other selections when clicking background
                                            if (!e.shiftKey) {
                                                setSelectedIndices([]);
                                            }

                                            setSelectionBox({ startX: x, startY: y, currentX: x, currentY: y });
                                        }}
                                        onMouseMove={(e) => {
                                            if (!fieldRef.current || !editingFormation) return;
                                            const rect = fieldRef.current.getBoundingClientRect();
                                            const x = ((e.clientX - rect.left) / rect.width) * 100;
                                            const y = ((e.clientY - rect.top) / rect.height) * 100;

                                            if (draggingPlayer !== null && lastMousePos) {
                                                // Handle Multi-Drag
                                                const dx = x - lastMousePos.x;
                                                const dy = y - lastMousePos.y;

                                                setEditingFormation(prev => ({
                                                    ...prev,
                                                    positions: prev.positions.map((p, idx) => {
                                                        if (selectedIndices.includes(idx)) {
                                                            return {
                                                                ...p,
                                                                x: Math.max(2, Math.min(98, p.x + dx)),
                                                                y: Math.max(2, Math.min(98, p.y + dy))
                                                            };
                                                        }
                                                        return p;
                                                    })
                                                }));
                                                setLastMousePos({ x, y });
                                            } else if (selectionBox) {
                                                // Handle Marquee Selection
                                                setSelectionBox(prev => ({ ...prev, currentX: x, currentY: y }));
                                            }
                                        }}
                                        onMouseUp={() => {
                                            if (selectionBox) {
                                                const x1 = Math.min(selectionBox.startX, selectionBox.currentX);
                                                const x2 = Math.max(selectionBox.startX, selectionBox.currentX);
                                                const y1 = Math.min(selectionBox.startY, selectionBox.currentY);
                                                const y2 = Math.max(selectionBox.startY, selectionBox.currentY);

                                                const newSelections = [];
                                                editingFormation.positions.forEach((p, idx) => {
                                                    if (p.x >= x1 && p.x <= x2 && p.y >= y1 && p.y <= y2) {
                                                        newSelections.push(idx);
                                                    }
                                                });

                                                if (newSelections.length > 0) {
                                                    setSelectedIndices(prev => {
                                                        const combined = Array.from(new Set([...prev, ...newSelections]));
                                                        return combined;
                                                    });
                                                }
                                            }
                                            setDraggingPlayer(null);
                                            setSelectionBox(null);
                                            setLastMousePos(null);
                                        }}
                                        onMouseLeave={() => {
                                            setDraggingPlayer(null);
                                            setSelectionBox(null);
                                            setLastMousePos(null);
                                        }}
                                    >
                                        <defs>
                                            {/* Grid Pattern */}
                                            <pattern id="formation-grid" width="100" height="100" patternUnits="userSpaceOnUse">
                                                <path d="M 100 0 L 0 0 0 100" fill="none" stroke="#f0f0f0" strokeWidth="1" />
                                            </pattern>
                                        </defs>

                                        {/* White Background */}
                                        <rect width="100%" height="100%" fill="white" />
                                        <rect width="100%" height="100%" fill="url(#formation-grid)" />

                                        {/* Yard Lines - Dynamic based on field position (default 50 = midfield) */}
                                        {(() => {
                                            const fieldPosition = 50; // Midfield for formation editor
                                            const yardLines = [];
                                            const startYard = Math.max(0, fieldPosition - 10);
                                            const endYard = Math.min(100, fieldPosition + 15);

                                            for (let yard = Math.ceil(startYard / 5) * 5; yard <= endYard; yard += 5) {
                                                const yardsFromLOS = yard - fieldPosition;
                                                const yPos = 340 - (yardsFromLOS * 20); // 20px per yard

                                                if (yPos < 0 || yPos > 480) continue;

                                                let label;
                                                if (yard === 0) label = 'GL';
                                                else if (yard === 100) label = 'GL';
                                                else if (yard === 50) label = `${yard}`;
                                                else if (yard < 50) label = `${yard}`;
                                                else label = `${100 - yard}`;

                                                const isLOS = yard === fieldPosition;
                                                const isMajor = yard % 10 === 0;
                                                const isGoalLine = yard === 0 || yard === 100;

                                                yardLines.push(
                                                    <g key={yard}>
                                                        <line
                                                            x1="0"
                                                            y1={yPos}
                                                            x2="100%"
                                                            y2={yPos}
                                                            stroke={isGoalLine ? '#dc2626' : isLOS ? '#000' : isMajor ? '#000' : '#ccc'}
                                                            strokeWidth={isLOS ? 3 : isGoalLine ? 2 : 1}
                                                            strokeDasharray={isMajor || isGoalLine || isLOS ? 'none' : '5,5'}
                                                        />
                                                        <text x="20" y={yPos - 5} fontSize="12" fill={isGoalLine ? '#dc2626' : '#666'}>
                                                            {isLOS ? `LOS (${label})` : label}
                                                        </text>
                                                        <text x="780" y={yPos - 5} fontSize="12" fill={isGoalLine ? '#dc2626' : '#666'} textAnchor="end">
                                                            {isLOS ? `LOS (${label})` : label}
                                                        </text>
                                                    </g>
                                                );
                                            }
                                            return yardLines;
                                        })()}

                                        {/* Hash Marks - High School Field (at thirds = 267px and 533px) */}
                                        {(() => {
                                            const fieldPosition = 50;
                                            const hashMarks = [];
                                            const startYard = Math.max(0, fieldPosition - 10);
                                            const endYard = Math.min(100, fieldPosition + 15);

                                            for (let yard = startYard; yard <= endYard; yard++) {
                                                const yardsFromLOS = yard - fieldPosition;
                                                const yPos = 340 - (yardsFromLOS * 20);

                                                if (yPos < 0 || yPos > 480) continue;

                                                hashMarks.push(
                                                    <g key={`hash-${yard}`}>
                                                        <line x1="267" y1={yPos - 5} x2="267" y2={yPos + 5} stroke="#000" strokeWidth="2" />
                                                        <line x1="533" y1={yPos - 5} x2="533" y2={yPos + 5} stroke="#000" strokeWidth="2" />
                                                    </g>
                                                );
                                            }
                                            return hashMarks;
                                        })()}

                                        {/* Player Markers */}
                                        {editingFormation.positions.map((pos, idx) => {
                                            const x = (pos.x / 100) * 800;
                                            const y = (pos.y / 100) * 500;
                                            const isSelected = selectedIndices.includes(idx);
                                            return (
                                                <g key={idx}
                                                    onMouseDown={(e) => {
                                                        e.preventDefault();
                                                        e.stopPropagation();

                                                        // Handle selection logic
                                                        if (e.shiftKey) {
                                                            setSelectedIndices(prev =>
                                                                prev.includes(idx) ? prev.filter(i => i !== idx) : [...prev, idx]
                                                            );
                                                        } else if (!isSelected) {
                                                            setSelectedIndices([idx]);
                                                        }

                                                        setDraggingPlayer(idx);
                                                        const rect = fieldRef.current.getBoundingClientRect();
                                                        const mx = ((e.clientX - rect.left) / rect.width) * 100;
                                                        const my = ((e.clientY - rect.top) / rect.height) * 100;
                                                        setLastMousePos({ x: mx, y: my });
                                                    }}
                                                    style={{ cursor: 'grab' }}
                                                >
                                                    <circle
                                                        cx={x}
                                                        cy={y}
                                                        r="16"
                                                        fill={isSelected ? '#60a5fa' : '#3b82f6'}
                                                        stroke={isSelected ? '#fbbf24' : '#fff'}
                                                        strokeWidth={isSelected ? '4' : '3'}
                                                        style={{ filter: isSelected ? 'drop-shadow(0 4px 12px rgba(0,0,0,0.4))' : 'drop-shadow(0 2px 4px rgba(0,0,0,0.2))' }}
                                                    />
                                                    <text
                                                        x={x}
                                                        y={y + 5}
                                                        fill="#fff"
                                                        fontSize="12"
                                                        fontWeight="bold"
                                                        textAnchor="middle"
                                                        style={{ pointerEvents: 'none', userSelect: 'none' }}
                                                    >
                                                        {positionNames[pos.label] || pos.label}
                                                    </text>
                                                </g>
                                            );
                                        })}

                                        {/* Selection Marquee */}
                                        {selectionBox && (
                                            <rect
                                                x={Math.min(selectionBox.startX, selectionBox.currentX) * 8}
                                                y={Math.min(selectionBox.startY, selectionBox.currentY) * 5}
                                                width={Math.abs(selectionBox.startX - selectionBox.currentX) * 8}
                                                height={Math.abs(selectionBox.startY - selectionBox.currentY) * 5}
                                                fill="rgba(59, 130, 246, 0.2)"
                                                stroke="#3b82f6"
                                                strokeWidth="1"
                                                strokeDasharray="4,2"
                                            />
                                        )}

                                        {/* Help Text */}
                                        <text x="10" y="490" fontSize="11" fill="#666">💡 Drag players to position</text>
                                    </svg>
                                </div>
                            </>
                        ) : (
                            <div style={{ flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'var(--text-secondary)', flexDirection: 'column' }}>
                                <Icon name="Grid" size={48} />
                                <p style={{ marginTop: '1rem', fontSize: '1.1rem' }}>Select a formation or create a new one</p>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const UserGuide = () => {
            return (
                <div className="card" style={{ padding: '2rem', maxWidth: '800px', margin: '0 auto' }}>
                    <h1 style={{ marginBottom: '2rem' }}><Icon name="HelpCircle" size={32} /> User Guide</h1>

                    <section style={{ marginBottom: '3rem' }}>
                        <h2 style={{ color: 'var(--accent)', borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem' }}>Head Coach Usage</h2>
                        <ul style={{ lineHeight: '1.6', fontSize: '1.1rem', color: 'var(--text-secondary)' }}>
                            <li><strong>Staff Management:</strong> Use "Task Assigner" and "Staff & Roles" to delegate responsibilities to your assistants.</li>
                            <li><strong>Weekly Schedule:</strong> Monitor the "Active Week" timeline to ensure the team is on track for the upcoming opponent.</li>
                            <li><strong>Travel & Logistics:</strong> Use the "Travel Roster" to manage personnel for away games.</li>
                            <li><strong>Oversight:</strong> View all depth charts and practice plans to ensure alignment with team goals.</li>
                        </ul>
                    </section>

                    <section style={{ marginBottom: '3rem' }}>
                        <h2 style={{ color: 'var(--accent)', borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem' }}>Offensive Coordinator Usage</h2>
                        <ul style={{ lineHeight: '1.6', fontSize: '1.1rem', color: 'var(--text-secondary)' }}>
                            <li><strong>Playbook:</strong> Add and organize plays with tags (Formation, Concept, Situation). Use batch delete to clean up old plays.</li>
                            <li><strong>Game Planning:</strong> Build your "Situations and Scripts" by tagging plays with specific situations (e.g., "3rd & Long").</li>
                            <li><strong>Practice Scripts:</strong> Generate scripts based on your installed playbook and daily focus.</li>
                            <li><strong>In-Game:</strong> Use the "OC Call Sheet" on the tablet app for real-time play calling and tracking.</li>
                        </ul>
                    </section>

                    <section style={{ marginBottom: '3rem' }}>
                        <h2 style={{ color: 'var(--accent)', borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem' }}>Position Coach Usage</h2>
                        <ul style={{ lineHeight: '1.6', fontSize: '1.1rem', color: 'var(--text-secondary)' }}>
                            <li><strong>Depth Charts:</strong> Manage rotation and depth for your specific unit (Varsity, JV, etc.).</li>
                            <li><strong>Player Development:</strong> Track "Iron Man" stats and "Testing" results for your position group.</li>
                            <li><strong>Equipment:</strong> Manage "Checkouts" and "Inventory" for your specific position needs.</li>
                        </ul>
                    </section>
                </div>
            );
        };


        // REMOVED: TestingRecords (~1,047 lines) - check git history

        const Settings = ({ teamLogo, onUpdateLogo, accentColor, onUpdateAccentColor, theme, onUpdateTheme, positionNames, onUpdatePositionNames, activeYear, onUpdateActiveYear, visibleFeatures, onUpdateVisibleFeatures, renderSyncManager, isSiteAdmin = false, currentSchoolId, programLevels, onUpdateProgramLevels }) => {


            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        onUpdateLogo(reader.result);
                    };
                    reader.readAsDataURL(file);
                }
            };
            const { currentUser, logout } = useAuth(); // Get current user from auth context

            // --- ADMIN SECURITY ---
            // Only these emails can see the "Access Control" tab
            const ADMIN_EMAILS = [
                'matthewfinn14@gmail.com'
            ];

            // Use prop if available (from global sync), otherwise fallback to hardcoded
            const isAdmin = isSiteAdmin || (currentUser && ADMIN_EMAILS.includes(currentUser.email.toLowerCase()));


            const [activeTab, setActiveTab] = useState('general'); // 'general' | 'access' | 'members' | 'billing'
            const [accessConfig, setAccessConfig] = useState({ inviteRequired: false, allowedEmails: [] });
            const [accessLoading, setAccessLoading] = useState(false);
            const [newEmail, setNewEmail] = useState('');

            // Global Templates State
            const [globalTemplates, setGlobalTemplates] = useState([]);
            const [templatesLoading, setTemplatesLoading] = useState(false);
            const [showTemplateModal, setShowTemplateModal] = useState(false);
            const [editingTemplate, setEditingTemplate] = useState(null);
            const [templateForm, setTemplateForm] = useState({
                type: 'practice_plan',
                name: '',
                description: '',
                category: '',
                data: {}
            });

            // Cloud Migration State REMOVED

            const handleMigrateToCloud = async () => {
                if (!currentUser) {
                    alert('You must be logged in to migrate data.');
                    return;
                }
                if (!window.confirm('Are you sure you want to migrate all local data to the cloud? This will overwrite any existing cloud data.')) {
                    return;
                }
                setMigrationStatus('loading');
                setMigrationError(null);
                try {
                    const getLocal = (key) => {
                        const saved = localStorage.getItem(key);
                        return saved ? JSON.parse(saved) : null;
                    };

                    // Core Data to Migrate
                    const itemsToSync = [
                        { id: 'roster', data: getLocal('oc-dashboard-roster') || [] },
                        { id: 'plays', data: getLocal('oc-dashboard-plays') || [] },
                        { id: 'staff', data: getLocal('oc-dashboard-staff') || [] },
                        { id: 'weeks', data: getLocal('oc-dashboard-weeks') || [] },
                        { id: 'masterTasks', data: getLocal('oc-dashboard-master-tasks') || [] },
                        {
                            id: 'settings', data: {
                                teamLogo: localStorage.getItem('oc-dashboard-logo'),
                                accentColor: localStorage.getItem('oc-dashboard-accent'),
                                theme: localStorage.getItem('oc-dashboard-theme'),
                                activeYear: localStorage.getItem('hc-active-year'),
                                visibleFeatures: getLocal('hc-visible-features')
                            }
                        }
                    ];

                    await Promise.all(itemsToSync.map(item =>
                        syncToFirestore(currentUser.uid, item.id, item.data)
                    ));

                    setMigrationStatus('success');
                    setTimeout(() => setMigrationStatus('idle'), 3000);
                } catch (err) {
                    console.error('Migration Error:', err);
                    setMigrationError(err.message);
                    setMigrationStatus('error');
                }
            };



            // Expanded Categories State for Access Control/Features
            const [expandedCategories, setExpandedCategories] = useState({
                gameWeek: true,
                programManagement: true,
                football101: true,
                playerDevelopment: true
            });

            const toggleCategory = (key) => {
                setExpandedCategories(prev => ({
                    ...prev,
                    [key]: !prev[key]
                }));
            };

            // Load Access Config when tab is opened
            useEffect(() => {
                if (activeTab === 'access') {
                    const loadAccess = async () => {
                        setAccessLoading(true);
                        try {
                            const doc = await window.db.collection('config').doc('access').get();
                            if (doc.exists) {
                                setAccessConfig(doc.data());
                            }
                        } catch (err) {
                            console.error("Error loading access config:", err);
                        }
                        setAccessLoading(false);
                    };
                    loadAccess();

                    // Also load global templates for Site Admin
                    const loadTemplates = async () => {
                        setTemplatesLoading(true);
                        try {
                            const snapshot = await window.db.collection('global_templates').get();
                            const templates = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                            setGlobalTemplates(templates);
                        } catch (err) {
                            console.error("Error loading templates:", err);
                        }
                        setTemplatesLoading(false);
                    };
                    loadTemplates();
                }
            }, [activeTab]);

            // Template CRUD Functions
            const handleCreateTemplate = () => {
                setEditingTemplate(null);
                setTemplateForm({
                    type: 'practice_plan',
                    name: '',
                    description: '',
                    category: '',
                    data: {}
                });
                setShowTemplateModal(true);
            };

            const handleEditTemplate = (template) => {
                setEditingTemplate(template);
                setTemplateForm({
                    type: template.type,
                    name: template.name,
                    description: template.description || '',
                    category: template.category || '',
                    data: template.data || {}
                });
                setShowTemplateModal(true);
            };

            const handleSaveTemplate = async () => {
                if (!templateForm.name.trim()) {
                    alert('Template name is required');
                    return;
                }

                setTemplatesLoading(true);
                try {
                    const templateData = {
                        ...templateForm,
                        updatedAt: new Date().toISOString(),
                        createdBy: currentUser.uid
                    };

                    if (editingTemplate) {
                        // Update existing
                        await window.db.collection('global_templates').doc(editingTemplate.id).update(templateData);
                    } else {
                        // Create new
                        templateData.createdAt = new Date().toISOString();
                        await window.db.collection('global_templates').add(templateData);
                    }

                    // Reload templates
                    setGlobalTemplates(templates);

                    setShowTemplateModal(false);
                } catch (err) {
                    console.error("Error saving template:", err);
                    alert("Failed to save template: " + err.message);
                }
                setTemplatesLoading(false);
            };

            const handleDeleteTemplate = async (templateId) => {
                if (!confirm('Are you sure you want to delete this template? This cannot be undone.')) return;

                setTemplatesLoading(true);
                try {
                    await window.db.collection('global_templates').doc(templateId).delete();
                    setGlobalTemplates(globalTemplates.filter(t => t.id !== templateId));
                } catch (err) {
                    console.error("Error deleting template:", err);
                    alert("Failed to delete template: " + err.message);
                }
                setTemplatesLoading(false);
            };

            const updateAccessConfig = async (newData) => {
                setAccessLoading(true);
                try {
                    await window.db.collection('config').doc('access').set(newData, { merge: true });
                    setAccessConfig(newData);
                } catch (err) {
                    console.error("Error saving access config:", err);
                    alert("Failed to save changes: " + err.message);
                }
                setAccessLoading(false);
            };

            const handleToggleInvite = () => {
                updateAccessConfig({ ...accessConfig, inviteRequired: !accessConfig.inviteRequired });
            };

            const handleAddEmail = () => {
                if (!newEmail || !newEmail.includes('@')) return;
                const current = accessConfig.allowedEmails || [];
                if (current.includes(newEmail)) return;
                updateAccessConfig({ ...accessConfig, allowedEmails: [...current, newEmail] });
                setNewEmail('');
            };

            const handleRemoveEmail = (emailToRemove) => {
                const current = accessConfig.allowedEmails || [];
                updateAccessConfig({ ...accessConfig, allowedEmails: current.filter(e => e !== emailToRemove) });
            };

            const handleTogglePayingAdmin = (email) => {
                const currentPaying = accessConfig.payingAdmins || [];
                let newPaying;
                if (currentPaying.includes(email)) {
                    newPaying = currentPaying.filter(e => e !== email);
                } else {
                    newPaying = [...currentPaying, email];
                }

                // If removing paying admin, also remove school association? Maybe keep it for history, 
                // but let's just update the list for now.
                updateAccessConfig({ ...accessConfig, payingAdmins: newPaying });
            };

            const handleTogglePersonalAccount = (email) => {
                const currentPersonal = accessConfig.personalAccounts || [];
                let newPersonal;
                if (currentPersonal.includes(email)) {
                    newPersonal = currentPersonal.filter(e => e !== email);
                } else {
                    newPersonal = [...currentPersonal, email];
                }
                // Determine mutual exclusivity? 
                // If Personal, remove from Paying (School) Admin?
                // Logic: A user could be both technically, but usually they are distinct.
                // Let's enforce exclusivity for clarity.
                let updates = { personalAccounts: newPersonal };
                if (newPersonal.includes(email)) {
                    // Remove from Paying Admins if added to Personal
                    const currentPaying = accessConfig.payingAdmins || [];
                    if (currentPaying.includes(email)) {
                        updates.payingAdmins = currentPaying.filter(e => e !== email);
                    }
                }

                updateAccessConfig({ ...accessConfig, ...updates });
            };

            const handleSchoolIdChange = (email, newSchoolId) => {
                const currentUserSchools = accessConfig.userSchools || {};
                const updatedSchools = { ...currentUserSchools, [email]: newSchoolId };
                updateAccessConfig({ ...accessConfig, userSchools: updatedSchools });
            };

            const handleToggleSiteAdmin = (email) => {
                const currentSiteAdmins = accessConfig.siteAdmins || [];
                let newSiteAdmins;
                if (currentSiteAdmins.includes(email)) {
                    newSiteAdmins = currentSiteAdmins.filter(e => e !== email);
                } else {
                    newSiteAdmins = [...currentSiteAdmins, email];
                }
                updateAccessConfig({ ...accessConfig, siteAdmins: newSiteAdmins });
            };

            // --- BILLING & LICENSING ---
            const [promoCode, setPromoCode] = useState('');
            const [redeeming, setRedeeming] = useState(false);
            const { billingInfo, updateBilling, planStatus: currentPlanStatus } = useSchoolPlan();

            const handleRedeemPromo = async () => {
                if (!promoCode) return;
                setRedeeming(true);
                try {
                    // 1. Validate Code
                    // NOTE: This assumes 'promo_codes' collection is readable by admins
                    const codeId = promoCode.trim();
                    const codeDoc = await window.db.collection('config').doc('billing').collection('promo_codes').doc(codeId).get();

                    if (!codeDoc.exists) throw new Error("Invalid Promo Code");
                    const codeData = codeDoc.data();

                    if (!codeData.active) throw new Error("Promo Code is inactive");
                    if (codeData.expiresAt && new Date(codeData.expiresAt) < new Date()) throw new Error("Promo Code expired");

                    // 2. Apply Code
                    const now = new Date();
                    let newSubEnd = now;

                    // If already premium/trial, extend from current expiry? 
                    // Let's simplify: Extend from NOW or Extend from Current Expiry if valid?
                    // Design: If 'extension', add days to max(now, currentExpiry).

                    let baseDate = now;
                    if (currentPlanStatus.includes('PREMIUM') && billingInfo.subscriptionEndsAt) {
                        const currentEnd = new Date(billingInfo.subscriptionEndsAt);
                        if (currentEnd > now) baseDate = currentEnd;
                    } else if (currentPlanStatus === 'PREMIUM_TRIAL' && billingInfo.trialEndsAt) {
                        const trialEnd = new Date(billingInfo.trialEndsAt);
                        if (trialEnd > now) baseDate = trialEnd;
                    }

                    if (codeData.durationDays) {
                        newSubEnd = new Date(baseDate.getTime() + (codeData.durationDays * 24 * 60 * 60 * 1000));
                    }

                    const newBilling = {
                        ...billingInfo,
                        plan: 'premium',
                        status: 'active',
                        subscriptionEndsAt: newSubEnd.toISOString(),
                        promoCode: codeId
                    };

                    // Update School
                    await window.db.collection('schools').doc(currentSchoolId).update({
                        billing: newBilling,
                        // Track redemption in school doc to prevent reuse? 
                        redeemedCodes: firebase.firestore.FieldValue.arrayUnion(codeId)
                    });

                    // Update Local State
                    updateBilling(newBilling);
                    setPromoCode('');
                    alert(`Success! Plan extended until ${newSubEnd.toLocaleDateString()}.\n\nReloading application...`);
                    window.location.reload();

                } catch (err) {
                    console.error("Redemption Error:", err);
                    alert("Redemption Failed: " + err.message);
                }
                setRedeeming(false);
            };

            // ... (existing code)

            // NEW: Members Logic
            const [loadingMembers, setLoadingMembers] = useState(false);
            const [members, setMembers] = useState([]);
            const [inviteEmail, setInviteEmail] = useState('');
            const [inviteRole, setInviteRole] = useState('coach');

            // Domain Management State
            const [claimedDomains, setClaimedDomains] = useState([]);
            const [newDomain, setNewDomain] = useState('');

            useEffect(() => {
                if (activeTab === 'members' && currentSchoolId) {
                    loadMembers();
                }
            }, [activeTab, currentSchoolId]);

            const loadMembers = async () => {
                setLoadingMembers(true);
                try {
                    const schoolDoc = await window.db.collection('schools').doc(currentSchoolId).get();
                    if (schoolDoc.exists) {
                        setMembers(schoolDoc.data().memberList || []);
                        setClaimedDomains(schoolDoc.data().domains || []);
                    }
                } catch (err) {
                    console.error("Error loading members:", err);
                }
                setLoadingMembers(false);
            };

            const handleAddDomain = async () => {
                if (!newDomain || !newDomain.includes('.')) return alert("Please enter a valid domain (e.g. myschool.edu)");
                const domain = newDomain.toLowerCase().trim().replace('@', ''); // specific cleanup

                try {
                    await window.db.collection('schools').doc(currentSchoolId).update({
                        domains: firebase.firestore.FieldValue.arrayUnion(domain)
                    });
                    setClaimedDomains(prev => [...prev, domain]);
                    setNewDomain('');
                } catch (err) {
                    console.error("Error adding domain:", err);
                    alert("Failed to add domain.");
                }
            };

            const handleRemoveDomain = async (domain) => {
                if (!window.confirm(`Stop auto-joining users from @${domain}?`)) return;
                try {
                    await window.db.collection('schools').doc(currentSchoolId).update({
                        domains: firebase.firestore.FieldValue.arrayRemove(domain)
                    });
                    setClaimedDomains(prev => prev.filter(d => d !== domain));
                } catch (err) {
                    console.error("Error removing domain:", err);
                    alert("Failed to remove domain.");
                }
            };

            const handleSendInvite = async () => {
                if (!inviteEmail || !inviteEmail.includes('@')) return;

                try {
                    // Create Invite Doc
                    const inviteToken = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
                    await window.db.collection('invites').add({
                        email: inviteEmail.toLowerCase(),
                        schoolId: currentSchoolId,
                        schoolName: localStorage.getItem('hc_school_name') || 'Football Program',
                        role: inviteRole,
                        token: inviteToken,
                        status: 'pending',
                        createdAt: new Date().toISOString(),
                        createdBy: window.auth.currentUser.uid
                    });

                    alert(`Invite Link Generated (Copy & Send):\n\n${window.location.origin}?invite=${inviteToken}`);
                    setInviteEmail('');
                } catch (err) {
                    console.error("Error sending invite:", err);
                }
            };

            const handleRemoveMember = async (member) => {
                const isSelf = member.uid === currentUser.uid;

                if (isSelf) {
                    if (member.role === 'admin') {
                        // Prompt for Admin Self-Removal choices
                        const choice = prompt("You are leaving as an Admin.\n\nType 'DELETE' to permanently delete this school (Wipe Data).\nType 'LEAVE' to just remove yourself.\nClick Cancel to stay.", "LEAVE");

                        if (choice === null) return; // Cancelled

                        const action = choice.toUpperCase().trim();

                        if (action === 'DELETE') {
                            if (!window.confirm("FINAL WARNING: This will wipe all school data. Are you sure?")) return;
                            setLoadingMembers(true);
                            try {
                                // 1. Delete School Doc
                                await window.db.collection('schools').doc(currentSchoolId).delete();

                                // 2. Delete Membership
                                await window.db.collection('users').doc(currentUser.uid).collection('memberships').doc(currentSchoolId).delete();

                                // 3. Update User Legacy Field & Local Storage
                                await window.db.collection('users').doc(currentUser.uid).update({ schoolId: firebase.firestore.FieldValue.delete() });
                                localStorage.removeItem('hc_school_id');

                                alert("School deleted. Reloading...");
                                window.location.reload();
                            } catch (err) {
                                console.error("Error deleting school:", err);
                                alert("Error: " + err.message);
                                setLoadingMembers(false);
                            }
                            return;
                        }

                        if (action !== 'LEAVE') return; // Invalid input or aborted
                        // Fallthrough to LEAVE logic
                    } else {
                        if (!window.confirm("Are you sure you want to leave this school?")) return;
                    }
                } else {
                    if (!window.confirm(`Are you sure you want to remove ${member.email}?`)) return;
                }

                // Standard Remove / Leave Logic
                try {
                    setLoadingMembers(true);

                    // 1. Remove from School's memberList
                    // 1. Remove from School's memberList AND staff list
                    await window.db.collection('schools').doc(currentSchoolId).update({
                        memberList: firebase.firestore.FieldValue.arrayRemove(member),
                        staff: firebase.firestore.FieldValue.arrayRemove(member) // Assuming member object is consistent/same ref.
                    });

                    // Note: arrayRemove only works if the object is IDENTICAL. 
                    // Members in 'staff' might have different fields than 'memberList'.
                    // So we might need to Read-Filter-Write for 'staff' array if the object structure differs.
                    // Given the 'member' passed here comes from the 'members' state which is `memberList`, 
                    // let's do a more robust Read-Modify-Write for the staff array to be safe.

                    const schoolDocRef = window.db.collection('schools').doc(currentSchoolId);
                    await window.db.runTransaction(async (transaction) => {
                        const sDoc = await transaction.get(schoolDocRef);
                        if (!sDoc.exists) return;

                        const sData = sDoc.data();
                        const currentStaff = sData.staff || [];
                        const currentMembers = sData.memberList || [];

                        const newStaff = currentStaff.filter(s => s.uid !== member.uid && s.id !== member.uid); // Check both UID and ID
                        const newMembers = currentMembers.filter(m => m.uid !== member.uid);

                        transaction.update(schoolDocRef, {
                            staff: newStaff,
                            memberList: newMembers
                        });
                    });

                    // 2. Delete Membership subdoc for the target user
                    // Note: This requires write permission to target user's subcollection. 
                    // If this fails (due to rules), the user is at least removed from the 'memberList'
                    // so they won't show in UI, but might retain access if rules check membership doc.
                    // Ideally Admin should have write access.
                    await window.db.collection('users').doc(member.uid).collection('memberships').doc(currentSchoolId).delete()
                        .catch(err => console.warn("Could not delete membership doc (perm issue?):", err));

                    // 3. [NEW] Clear Root User Legacy Fields
                    // This forces the user to be "orphaned" from this school in their personal view
                    await window.db.collection('users').doc(member.uid).update({
                        schoolId: firebase.firestore.FieldValue.delete(),
                        role: firebase.firestore.FieldValue.delete(),
                        activeYear: firebase.firestore.FieldValue.delete()
                    }).catch(err => console.warn("Could not clear root user fields (perm issue?):", err));

                    if (isSelf) {
                        // Also clear legacy field
                        await window.db.collection('users').doc(currentUser.uid).update({ schoolId: firebase.firestore.FieldValue.delete() });
                        localStorage.removeItem('hc_school_id');
                        window.location.reload();
                    } else {
                        // Refresh list
                        fetchMembers();
                    }

                } catch (err) {
                    console.error("Error removing member:", err);
                    alert("Failed to remove member. " + err.message);
                    setLoadingMembers(false);
                }
            };

            return (
                <div style={{ height: 'calc(100vh - 100px)', display: 'flex', flexDirection: 'column', gap: '2rem' }}>

                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                        <h2>Settings</h2>
                        <div style={{ display: 'flex', gap: '0.5rem', background: 'var(--bg-panel)', padding: '0.25rem', borderRadius: '8px' }}>
                            <button className="btn" style={{ backgroundColor: activeTab === 'general' ? 'var(--accent)' : 'transparent', color: activeTab === 'general' ? 'white' : 'var(--text-secondary)' }} onClick={() => setActiveTab('general')}>General</button>
                            {currentSchoolId && (
                                <button className="btn" style={{ backgroundColor: activeTab === 'members' ? 'var(--accent)' : 'transparent', color: activeTab === 'members' ? 'white' : 'var(--text-secondary)' }} onClick={() => setActiveTab('members')}>Members</button>
                            )}
                            {isAdmin && (
                                <button className="btn" style={{ backgroundColor: activeTab === 'access' ? 'var(--accent)' : 'transparent', color: activeTab === 'access' ? 'white' : 'var(--text-secondary)' }} onClick={() => setActiveTab('access')}>Site Admin</button>
                            )}
                            {(isAdmin || members.find(m => m.uid === currentUser.uid)?.role === 'admin') && (
                                <button className="btn" style={{ backgroundColor: activeTab === 'billing' ? 'var(--accent)' : 'transparent', color: activeTab === 'billing' ? 'white' : 'var(--text-secondary)' }} onClick={() => setActiveTab('billing')}>Billing</button>
                            )}
                        </div>
                    </div>

                    {activeTab === 'members' && currentSchoolId && (
                        <div className="animation-fade-in card">
                            {/* Domain Management UI */}
                            {(isAdmin || members.find(m => m.uid === currentUser.uid)?.role === 'admin') && (
                                <div style={{ borderTop: 'none', paddingTop: 0, marginTop: 0 }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '1rem', alignItems: 'center' }}>
                                        <div>
                                            <h3 style={{ margin: 0 }}>Approved Domains</h3>
                                            <p style={{ color: 'var(--text-secondary)', fontSize: '0.9rem', margin: '0.25rem 0 0 0' }}>
                                                Auto-join users with these email domains.
                                            </p>
                                        </div>
                                        <div style={{ display: 'flex', gap: '0.5rem' }}>
                                            <input
                                                placeholder="e.g. myschool.edu"
                                                className="form-input"
                                                value={newDomain}
                                                onChange={e => setNewDomain(e.target.value)}
                                                style={{ minWidth: '200px' }}
                                            />
                                            <button className="btn btn-primary" onClick={handleAddDomain}>Add</button>
                                        </div>
                                    </div>

                                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.5rem' }}>
                                        {claimedDomains.map((d, idx) => (
                                            <div key={idx} style={{
                                                background: 'var(--bg-main)', border: '1px solid var(--border)',
                                                padding: '0.5rem 1rem', borderRadius: '20px', display: 'flex', alignItems: 'center', gap: '0.5rem'
                                            }}>
                                                <span style={{ fontWeight: 500 }}>@{d}</span>
                                                <button
                                                    onClick={() => handleRemoveDomain(d)}
                                                    style={{ background: 'none', border: 'none', color: '#ef4444', cursor: 'pointer', padding: 0, display: 'flex', alignItems: 'center' }}
                                                    title="Remove Domain"
                                                >
                                                    <div style={{ fontSize: '1.2rem', lineHeight: 1 }}>&times;</div>
                                                </button>
                                            </div>
                                        ))}
                                        {claimedDomains.length === 0 && <span style={{ opacity: 0.5, fontSize: '0.9rem' }}>No domains claimed yet. Users must be invited manually.</span>}
                                    </div>
                                </div>
                            )}
                        </div>
                    )}

                    {activeTab === 'access' && isAdmin && (
                        <div className="animation-fade-in" style={{ display: 'flex', flexDirection: 'column', gap: '2rem' }}>
                            <div className="card">
                                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '1rem' }}>
                                    <div>
                                        <h3>Invite Only Mode</h3>
                                        <p style={{ color: 'var(--text-secondary)', fontSize: '0.9rem' }}>
                                            When enabled, only users with allowed emails can log in.
                                        </p>
                                    </div>
                                    <label className="switch" style={{ position: 'relative', display: 'inline-block', width: '60px', height: '34px' }}>
                                        <input
                                            type="checkbox"
                                            checked={accessConfig.inviteRequired || false}
                                            onChange={handleToggleInvite}
                                            style={{ opacity: 0, width: 0, height: 0 }}
                                        />
                                        <span style={{
                                            position: 'absolute', cursor: 'pointer',
                                            top: 0, left: 0, right: 0, bottom: 0,
                                            backgroundColor: accessConfig.inviteRequired ? '#22c55e' : '#ccc',
                                            transition: '.4s', borderRadius: '34px'
                                        }}></span>
                                        <span style={{
                                            position: 'absolute', content: '""',
                                            height: '26px', width: '26px',
                                            left: accessConfig.inviteRequired ? '30px' : '4px',
                                            bottom: '4px', backgroundColor: 'white',
                                            transition: '.4s', borderRadius: '50%'
                                        }}></span>
                                    </label>
                                </div>
                                {accessConfig.inviteRequired && (
                                    <div style={{ padding: '1rem', background: '#ecfdf5', color: '#065f46', borderRadius: '8px', fontSize: '0.9rem', border: '1px solid #a7f3d0' }}>
                                        ✅ <strong>Active:</strong> Security is strictly enforced. Unlisted users will be blocked.
                                    </div>
                                )}
                            </div>

                            <div className="card">
                                <h3>Allowed Users</h3>
                                <p style={{ color: 'var(--text-secondary)', marginBottom: '1rem' }}>Manage who can access the application.</p>

                                <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '1.5rem' }}>
                                    <input
                                        type="email"
                                        placeholder="Enter email address (e.g. coach@school.edu)"
                                        className="form-input"
                                        value={newEmail}
                                        onChange={(e) => setNewEmail(e.target.value)}
                                        style={{ flex: 1 }}
                                        onKeyDown={(e) => e.key === 'Enter' && handleAddEmail()}
                                    />
                                    <button
                                        className="btn btn-primary"
                                        onClick={handleAddEmail}
                                        disabled={!newEmail}
                                    >
                                        Add User
                                    </button>
                                </div>

                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                    {(!accessConfig.allowedEmails || accessConfig.allowedEmails.length === 0) && (
                                        <div style={{ color: 'var(--text-secondary)', fontStyle: 'italic', padding: '1rem', textAlign: 'center', background: 'var(--surface)', borderRadius: '8px' }}>
                                            No allowed emails found. Be careful not to lock yourself out!
                                        </div>
                                    )}
                                    {accessConfig.allowedEmails && accessConfig.allowedEmails.map((email, idx) => {
                                        const isPaying = accessConfig.payingAdmins && accessConfig.payingAdmins.includes(email);
                                        const isPersonal = accessConfig.personalAccounts && accessConfig.personalAccounts.includes(email);
                                        const schoolId = (accessConfig.userSchools && accessConfig.userSchools[email]) || '';

                                        return (
                                            <div key={idx} style={{
                                                display: 'flex', flexDirection: 'column',
                                                padding: '0.75rem', background: 'var(--surface)', borderRadius: '8px',
                                                borderLeft: '4px solid #3b82f6', gap: '0.5rem'
                                            }}>
                                                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                                                    <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                                                        <span style={{ fontWeight: 500 }}>{email}</span>
                                                        <button
                                                            onClick={() => handleRemoveEmail(email)}
                                                            style={{
                                                                background: 'none', border: 'none', cursor: 'pointer',
                                                                color: '#ef4444', fontSize: '1.2rem', padding: '0 0.5rem'
                                                            }}
                                                            title="Remove Access"
                                                        >
                                                            &times;
                                                        </button>
                                                    </div>
                                                </div>

                                                <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.5rem', marginTop: '0.25rem' }}>
                                                    {/* SCHOOL/PAYING ADMIN */}
                                                    <label style={{ display: 'flex', alignItems: 'center', gap: '0.25rem', fontSize: '0.8rem', cursor: 'pointer', userSelect: 'none', background: isPaying ? 'rgba(234, 179, 8, 0.2)' : 'rgba(234, 179, 8, 0.05)', padding: '4px 8px', borderRadius: '4px', border: '1px solid rgba(234, 179, 8, 0.3)' }} title="Toggle School Admin (Full Features)">
                                                        <input
                                                            type="checkbox"
                                                            checked={isPaying || false}
                                                            onChange={() => {
                                                                handleTogglePayingAdmin(email);
                                                                // If enabling paying, disable personal
                                                                if (!isPaying && isPersonal) {
                                                                    handleTogglePersonalAccount(email);
                                                                }
                                                            }}
                                                        />
                                                        👑 School Admin
                                                    </label>

                                                    {/* PERSONAL ACCOUNT */}
                                                    <label style={{ display: 'flex', alignItems: 'center', gap: '0.25rem', fontSize: '0.8rem', cursor: 'pointer', userSelect: 'none', background: isPersonal ? 'rgba(168, 85, 247, 0.2)' : 'rgba(168, 85, 247, 0.05)', padding: '4px 8px', borderRadius: '4px', border: '1px solid rgba(168, 85, 247, 0.3)' }} title="Toggle Personal Account (Individual)">
                                                        <input
                                                            type="checkbox"
                                                            checked={isPersonal || false}
                                                            onChange={() => {
                                                                handleTogglePersonalAccount(email);
                                                            }}
                                                        />
                                                        👤 Personal Account
                                                    </label>

                                                    {/* SITE ADMIN (SUPER) */}
                                                    {(isSiteAdmin) && (
                                                        <label style={{ display: 'flex', alignItems: 'center', gap: '0.25rem', fontSize: '0.8rem', cursor: 'pointer', userSelect: 'none', background: 'rgba(59, 130, 246, 0.1)', padding: '4px 8px', borderRadius: '4px', border: '1px solid rgba(59, 130, 246, 0.3)' }} title="Toggle Site Admin (Can manage other admins)">
                                                            <input
                                                                type="checkbox"
                                                                checked={accessConfig.siteAdmins && accessConfig.siteAdmins.includes(email)}
                                                                onChange={() => handleToggleSiteAdmin(email)}
                                                            />
                                                            🛡️ Site Admin
                                                        </label>
                                                    )}
                                                </div>

                                                {/* SCHOOL ID INPUT - Only show if School Admin is checked */}
                                                {isPaying && (
                                                    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginTop: '0.25rem' }}>
                                                        <span style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>School ID:</span>
                                                        <input
                                                            type="text"
                                                            value={schoolId}
                                                            onChange={(e) => handleSchoolIdChange(email, e.target.value)}
                                                            placeholder="e.g. central-high-2024"
                                                            style={{
                                                                background: 'rgba(0,0,0,0.2)',
                                                                border: '1px solid var(--border)',
                                                                borderRadius: '4px',
                                                                padding: '2px 6px',
                                                                fontSize: '0.8rem',
                                                                color: 'white',
                                                                width: '200px'
                                                            }}
                                                        />
                                                    </div>
                                                )}
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>

                            {/* GLOBAL TEMPLATES SECTION */}
                            <div className="card">
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                    <div>
                                        <h3>Global Templates</h3>
                                        <p style={{ color: 'var(--text-secondary)', fontSize: '0.9rem' }}>
                                            Create and manage templates available to all schools.
                                        </p>
                                    </div>
                                    <button className="btn btn-primary" onClick={handleCreateTemplate}>
                                        + Create Template
                                    </button>
                                </div>

                                {templatesLoading ? (
                                    <p>Loading templates...</p>
                                ) : globalTemplates.length === 0 ? (
                                    <div style={{ textAlign: 'center', padding: '2rem', color: 'var(--text-secondary)', fontStyle: 'italic' }}>
                                        No global templates yet. Create one to get started!
                                    </div>
                                ) : (
                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                        {globalTemplates.map(template => (
                                            <div key={template.id} style={{
                                                display: 'flex', justifyContent: 'space-between', alignItems: 'center',
                                                padding: '1rem', background: 'var(--surface)', borderRadius: '8px',
                                                borderLeft: `4px solid ${template.type === 'practice_plan' ? '#10b981' : template.type === 'calendar_event' ? '#3b82f6' : '#f59e0b'}`
                                            }}>
                                                <div style={{ flex: 1 }}>
                                                    <div style={{ fontWeight: 'bold', marginBottom: '0.25rem' }}>{template.name}</div>
                                                    <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>
                                                        {template.type === 'practice_plan' ? '🏈 Practice Plan' : template.type === 'calendar_event' ? '📅 Calendar Event' : '✅ Task List'}
                                                        {template.category && ` • ${template.category}`}
                                                        {template.description && ` • ${template.description}`}
                                                    </div>
                                                </div>
                                                <div style={{ display: 'flex', gap: '0.5rem' }}>
                                                    <button className="btn" onClick={() => handleEditTemplate(template)}>Edit</button>
                                                    <button className="btn" style={{ color: '#ef4444' }} onClick={() => handleDeleteTemplate(template.id)}>Delete</button>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>
                        </div>
                    )}

                    {activeTab === 'general' && (
                        <div className="animation-fade-in" style={{ display: 'flex', flexDirection: 'column', gap: '2rem' }}>

                            <div className="card">
                                <h3>Team Branding</h3>
                                <p style={{ color: 'var(--text-secondary)', marginBottom: '1rem' }}>Upload your team logo to appear on printed documents.</p>

                                <div style={{ display: 'flex', alignItems: 'center', gap: '2rem' }}>
                                    <div style={{
                                        width: '100px',
                                        height: '100px',
                                        border: '2px dashed var(--border)',
                                        borderRadius: '8px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        overflow: 'hidden',
                                        background: 'var(--surface)'
                                    }}>
                                        {teamLogo ? (
                                            <img src={teamLogo} alt="Team Logo" style={{ maxWidth: '100%', maxHeight: '100%' }} />
                                        ) : (
                                            <span style={{ fontSize: '2rem' }}>🛡️</span>
                                        )}
                                    </div>
                                    <div>
                                        <input
                                            type="file"
                                            accept="image/*"
                                            onChange={handleImageUpload}
                                            style={{ marginBottom: '0.5rem' }}
                                        />
                                        {teamLogo && (
                                            <button
                                                className="btn"
                                                style={{ color: '#ef4444', display: 'block' }}
                                                onClick={() => onUpdateLogo(null)}
                                            >
                                                Remove Logo
                                            </button>
                                        )}
                                    </div>
                                </div>
                            </div>



                            <div className="card">
                                <h3>Interface Theme</h3>
                                <p style={{ color: 'var(--text-secondary)', marginBottom: '1rem' }}>Select the overall look and feel of the application.</p>
                                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))', gap: '1rem' }}>
                                    {[
                                        { id: 'navy', name: 'Navy Night', color: '#0f172a', textColor: '#f8fafc' },
                                        { id: 'light', name: 'Clean Light', color: '#f1f5f9', textColor: '#0f172a' },
                                        { id: 'contrast', name: 'High Contrast', color: '#000000', textColor: '#ffffff' }
                                    ].map(t => (
                                        <button
                                            key={t.id}
                                            className="btn"
                                            onClick={() => onUpdateTheme(t.id)}
                                            style={{
                                                display: 'flex',
                                                flexDirection: 'column',
                                                alignItems: 'center',
                                                justifyContent: 'center',
                                                padding: '1.5rem',
                                                background: t.color,
                                                border: (theme || 'navy') === t.id ? `2px solid var(--accent)` : '1px solid var(--border)',
                                                borderRadius: '8px',
                                                cursor: 'pointer',
                                                boxShadow: (theme || 'navy') === t.id ? '0 0 0 2px var(--accent)' : 'none'
                                            }}
                                        >
                                            <span style={{ color: t.textColor, fontWeight: 'bold' }}>{t.name}</span>
                                            {(theme || 'navy') === t.id && (
                                                <div style={{ marginTop: '0.5rem', fontSize: '0.8rem', color: 'var(--accent)' }}>Active</div>
                                            )}
                                        </button>
                                    ))}
                                </div>
                            </div>

                            <div className="card">
                                <h3>Team Colors</h3>
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem', marginTop: '1rem' }}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                                        <input
                                            type="color"
                                            value={accentColor || '#38bdf8'}
                                            onChange={(e) => onUpdateAccentColor(e.target.value)}
                                            style={{ width: '50px', height: '50px', padding: '0', border: 'none', borderRadius: '4px', cursor: 'pointer', background: 'none' }}
                                        />
                                        <div>
                                            <div style={{ fontWeight: 'bold' }}>Accent Color</div>
                                            <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>Primary color for buttons, active states, and highlights.</div>
                                        </div>
                                    </div>

                                    <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                                        {PRESET_COLORS.map(color => (
                                            <button
                                                key={color}
                                                onClick={() => onUpdateAccentColor(color)}
                                                style={{
                                                    width: '32px',
                                                    height: '32px',
                                                    borderRadius: '50%',
                                                    backgroundColor: color,
                                                    border: accentColor === color ? '2px solid white' : '2px solid transparent',
                                                    boxShadow: accentColor === color ? '0 0 0 2px var(--accent)' : 'none',
                                                    cursor: 'pointer'
                                                }}
                                                title={color}
                                            />
                                        ))}
                                    </div>
                                </div>
                            </div>

                            <div className="card">
                                <h3>Account</h3>
                                <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                                    <button className="btn" style={{ background: '#ef4444', color: 'white' }} onClick={logout}>
                                        <Icon name="LogOut" size={16} /> Log Out
                                    </button>
                                </div>
                            </div>



                            <div className="card">
                                <h3>Active Season</h3>
                                <p style={{ color: 'var(--text-secondary)', marginBottom: '1rem' }}>Select the current active year for your program.</p>
                                <div>
                                    <label className="form-label">Season Year</label>
                                    <select
                                        className="form-select"
                                        value={activeYear}
                                        onChange={(e) => onUpdateActiveYear(e.target.value)}
                                        style={{ width: '200px' }}
                                    >
                                        <option value="2024">2024</option>
                                        <option value="2025">2025</option>
                                        <option value="2026">2026</option>
                                        <option value="2027">2027</option>
                                        <option value="2028">2028</option>
                                    </select>
                                </div>
                            </div>

                            <div className="card">
                                <h3>Menu Visibility</h3>
                                <p style={{ color: 'var(--text-secondary)', marginBottom: '1rem' }}>Toggle menu categories and individual items to simplify your sidebar.</p>
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                                    {[
                                        {
                                            key: 'staffMeeting', label: 'Staff Meeting', items: [

                                                { key: 'weekOverview', label: 'Week Overview' },
                                                { key: 'practice', label: 'Practice Plans' },
                                                { key: 'pregame', label: 'Pre-game Timeline' },

                                            ]
                                        },
                                        {
                                            key: 'gameWeek', label: 'Offense, Defense & Special Teams', items: [
                                                { key: 'offenseSetup', label: 'Offense Setup' },
                                                { key: 'defenseSetup', label: 'Defense Setup' },
                                                { key: 'stSetup', label: 'Special Teams Setup' },
                                                { key: 'depthCharts', label: 'Depth Charts' },
                                                { key: 'playbook', label: 'Playbook' },
                                                { key: 'formations', label: 'Formations' },
                                                { key: 'glossary', label: 'Glossary' },
                                                { key: 'drillLibrary', label: 'Drill Library' },
                                                { key: 'gamePlan', label: 'Game Plan' },
                                                { key: 'addPlay', label: 'Add a New Play' },
                                                { key: 'wristband', label: 'Wristband Builder' },
                                                { key: 'practiceScripts', label: 'Practice Scripts' },
                                                { key: 'dumbCallsheet', label: 'Dumb Call Sheet' },

                                            ]
                                        },
                                        {
                                            key: 'program', label: 'Program Management', items: [
                                                { key: 'culturalCalibration', label: 'Culture Calibration' },
                                                { key: 'onboarding', label: 'Onboarding' }
                                            ]
                                        },
                                        {
                                            key: 'apps', label: 'Mobile/Tablet Apps', items: [
                                                { key: 'playerApp', label: 'Player App Preview' },
                                                { key: 'attendanceApp', label: 'Attendance App' },
                                                { key: 'coachApp', label: 'Practice Coach App' },
                                                { key: 'callsheet', label: 'Situations and Scripts' },
                                                { key: 'smartCallsheet', label: 'Smart Call Sheet' },
                                                { key: 'simulator', label: 'Play-Calling Simulator' },
                                                { key: 'pressbox', label: 'Pressbox' },
                                                { key: 'specialTeams', label: 'Special Teams' }
                                            ]
                                        },
                                        {
                                            key: 'development', label: 'Player Development', items: [
                                                { key: 'summerComp', label: 'Summer Competition' },
                                                { key: 'selfAssessment', label: 'Self-Assessment' }
                                            ]
                                        }
                                    ].map(category => (
                                        <div key={category.key} style={{ borderLeft: '3px solid var(--primary)', paddingLeft: '1rem' }}>
                                            {/* Category Header - Clickable to expand/collapse */}
                                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '0.5rem' }}>
                                                {/* Category Checkbox */}
                                                <label style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', cursor: 'pointer', fontWeight: 'bold', flex: 1 }} onClick={(e) => e.stopPropagation()}>
                                                    <input
                                                        type="checkbox"
                                                        checked={visibleFeatures[category.key]?.enabled || false}
                                                        onChange={(e) => onUpdateVisibleFeatures({
                                                            ...visibleFeatures,
                                                            [category.key]: {
                                                                ...visibleFeatures[category.key],
                                                                enabled: e.target.checked
                                                            }
                                                        })}
                                                        style={{ cursor: 'pointer', width: '18px', height: '18px' }}
                                                    />
                                                    <span>{category.label}</span>
                                                </label>
                                                {/* Expand/Collapse Button */}
                                                <button
                                                    onClick={() => toggleCategory(category.key)}
                                                    style={{
                                                        background: 'none',
                                                        border: 'none',
                                                        cursor: 'pointer',
                                                        padding: '0.25rem',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        color: 'var(--text-secondary)',
                                                        transition: 'transform 0.2s'
                                                    }}
                                                >
                                                    <Icon name={expandedCategories[category.key] ? 'ChevronDown' : 'ChevronRight'} size={18} />
                                                </button>
                                            </div>
                                            {/* Item Checkboxes - Collapsible */}
                                            {expandedCategories[category.key] && (
                                                <div style={{ paddingLeft: '1.5rem', display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                                    {category.items.map(item => (
                                                        <label key={item.key} style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', cursor: 'pointer', opacity: visibleFeatures[category.key]?.enabled ? 1 : 0.5 }}>
                                                            <input
                                                                type="checkbox"
                                                                checked={visibleFeatures[category.key]?.items?.[item.key] || false}
                                                                disabled={!visibleFeatures[category.key]?.enabled}
                                                                onChange={(e) => onUpdateVisibleFeatures({
                                                                    ...visibleFeatures,
                                                                    [category.key]: {
                                                                        ...visibleFeatures[category.key],
                                                                        items: {
                                                                            ...visibleFeatures[category.key]?.items,
                                                                            [item.key]: e.target.checked
                                                                        }
                                                                    }
                                                                })}
                                                                style={{ cursor: visibleFeatures[category.key]?.enabled ? 'pointer' : 'not-allowed' }}
                                                            />
                                                            <span style={{ fontSize: '0.9rem' }}>{item.label}</span>
                                                        </label>
                                                    ))}
                                                </div>
                                            )}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    )}

                    {/* TEMPLATE MODAL */}
                    {showTemplateModal && (
                        <div style={{
                            position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
                            background: 'rgba(0,0,0,0.7)', display: 'flex', alignItems: 'center',
                            justifyContent: 'center', zIndex: 9999
                        }} onClick={() => setShowTemplateModal(false)}>
                            <div style={{
                                background: 'var(--bg-panel)', padding: '2rem', borderRadius: '12px',
                                maxWidth: '600px', width: '90%', maxHeight: '80vh', overflow: 'auto'
                            }} onClick={(e) => e.stopPropagation()}>
                                <h2>{editingTemplate ? 'Edit Template' : 'Create Template'}</h2>

                                <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem', marginTop: '1.5rem' }}>
                                    <div>
                                        <label className="form-label">Template Type</label>
                                        <select
                                            className="form-select"
                                            value={templateForm.type}
                                            onChange={(e) => setTemplateForm({ ...templateForm, type: e.target.value, data: {} })}
                                            disabled={!!editingTemplate}
                                        >
                                            <option value="practice_plan">🏈 Practice Plan</option>
                                            <option value="calendar_event">📅 Calendar Event</option>
                                            <option value="task_list">✅ Task List</option>
                                        </select>
                                    </div>

                                    <div>
                                        <label className="form-label">Template Name *</label>
                                        <input
                                            type="text"
                                            className="form-input"
                                            value={templateForm.name}
                                            onChange={(e) => setTemplateForm({ ...templateForm, name: e.target.value })}
                                            placeholder="e.g. Monday - Base Install"
                                        />
                                    </div>

                                    <div>
                                        <label className="form-label">Description</label>
                                        <input
                                            type="text"
                                            className="form-input"
                                            value={templateForm.description}
                                            onChange={(e) => setTemplateForm({ ...templateForm, description: e.target.value })}
                                            placeholder="Optional description"
                                        />
                                    </div>

                                    <div>
                                        <label className="form-label">Category</label>
                                        <input
                                            type="text"
                                            className="form-input"
                                            value={templateForm.category}
                                            onChange={(e) => setTemplateForm({ ...templateForm, category: e.target.value })}
                                            placeholder="e.g. Weekly, Game Week, Offseason"
                                        />
                                    </div>

                                    <div style={{ padding: '1rem', background: 'var(--surface)', borderRadius: '8px' }}>
                                        <p style={{ color: 'var(--text-secondary)', fontSize: '0.9rem', marginBottom: '0.5rem' }}>
                                            <strong>Template Data:</strong> {templateForm.type === 'practice_plan' ? 'Define practice segments in JSON format' : templateForm.type === 'calendar_event' ? 'Define program events and tasks' : 'Define task list items'}
                                        </p>
                                        <textarea
                                            className="form-input"
                                            value={JSON.stringify(templateForm.data, null, 2)}
                                            onChange={(e) => {
                                                try {
                                                    const parsed = JSON.parse(e.target.value);
                                                    setTemplateForm({ ...templateForm, data: parsed });
                                                } catch (err) {
                                                    // Invalid JSON, just update the raw value
                                                }
                                            }}
                                            rows={10}
                                            style={{ fontFamily: 'monospace', fontSize: '0.85rem' }}
                                            placeholder={templateForm.type === 'practice_plan'
                                                ? '{\n  "segments": [\n    {"type": "Team O", "duration": 15, "situation": "Base Downs", "hasScript": true}\n  ]\n}'
                                                : templateForm.type === 'calendar_event'
                                                    ? '{\n  "program": ["Event 1", "Event 2"],\n  "tasks": []\n}'
                                                    : '{\n  "tasks": [\n    {"task": "Task name", "assignTo": ["Role"]}\n  ]\n}'
                                            }
                                        />
                                    </div>

                                    <div style={{ display: 'flex', gap: '0.5rem', justifyContent: 'flex-end', marginTop: '1rem' }}>
                                        <button className="btn" onClick={() => setShowTemplateModal(false)}>Cancel</button>
                                        <button className="btn btn-primary" onClick={handleSaveTemplate}>
                                            {editingTemplate ? 'Update' : 'Create'} Template
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };


        const MetricGraph = ({ history, field }) => {
            if (!history || history.length < 2) return null;

            const sortedHistory = [...history].sort((a, b) => new Date(a.date) - new Date(b.date));
            const dataPoints = sortedHistory.filter(h => h[field.id]).map(h => ({
                date: h.date,
                value: parseFloat(h[field.id])
            }));

            if (dataPoints.length < 2) return null;

            const width = 600;
            const height = 300;
            const padding = 40;

            const minVal = Math.min(...dataPoints.map(d => d.value));
            const maxVal = Math.max(...dataPoints.map(d => d.value));
            const range = maxVal - minVal || 1; // Prevent div by zero

            // Calculate coordinates
            const points = dataPoints.map((d, i) => {
                const x = padding + (i / (dataPoints.length - 1)) * (width - 2 * padding);
                // Lower value is better for timed events (40yd), Higher is better for others
                const isTimed = ['forty', 'flying10', 'proAgility'].includes(field.id);

                let yRatio;
                if (isTimed) {
                    // Invert: Max value (slowest) at bottom (height-padding), Min value (fastest) at top (padding)
                    yRatio = (d.value - minVal) / range;
                    // actually for SVG y=0 is top. So we want Min (Fast) at Top (0+padding), Max (Slow) at Bottom.
                    // y = padding + yRatio * height -> if yRatio is 0 (min), y=padding. Correct.
                    // Wait, if d.value = minVal (Fastest), yRatio = 0. y = padding.
                    // If d.value = maxVal (Slowest), yRatio = 1. y = height-padding. 
                } else {
                    // Normal: Max value (Strongest) at Top, Min at Bottom
                    // yRatio = 1 is Max. We want Max at padding. 
                    yRatio = 1 - ((d.value - minVal) / range);
                }

                const y = padding + yRatio * (height - 2 * padding);
                return { x, y, value: d.value, date: d.date };
            });

            return (
                <div style={{ marginTop: '2rem', border: '1px solid var(--border)', borderRadius: '8px', padding: '1rem', background: 'var(--bg-body)' }}>
                    <h4 style={{ textAlign: 'center', marginBottom: '1rem' }}>Progress: {field.name}</h4>
                    <svg width="100%" height="100%" viewBox={`0 0 ${width} ${height} `} style={{ overflow: 'visible' }}>
                        {/* Grid Lines */}
                        {[0, 0.25, 0.5, 0.75, 1].map(r => (
                            <line
                                key={r}
                                x1={padding}
                                y1={padding + r * (height - 2 * padding)}
                                x2={width - padding}
                                y2={padding + r * (height - 2 * padding)}
                                stroke="var(--border)"
                                strokeWidth="1"
                            />
                        ))}

                        {/* Line */}
                        <polyline
                            points={points.map(p => `${p.x},${p.y} `).join(' ')}
                            fill="none"
                            stroke="var(--accent)"
                            strokeWidth="2"
                        />
                        {/* Points */}
                        {points.map((p, i) => (
                            <g key={i}>
                                <circle cx={p.x} cy={p.y} r="5" fill="var(--bg-body)" stroke="var(--accent)" strokeWidth="2" />
                                <text x={p.x} y={p.y - 10} textAnchor="middle" fill="var(--text-primary)" fontSize="12">{p.value}</text>
                                <text x={p.x} y={height - 10} textAnchor="middle" fill="var(--text-secondary)" fontSize="10">{p.date}</text>
                            </g>
                        ))}
                    </svg>
                </div>
            );
        };


        const SmartCallSheet = ({ weeks = [], currentWeek = {}, gamePlan = {}, situation, plays, onUpdateSituation, zonePhilosophies, onUpdatePhilosophy, onUpdateGamePlan, onQuickAddPlay, activePlay, setActivePlay, gamePlanLayouts = GAME_PLAN_LAYOUTS, practicePlans = {} }) => {
            const [selectedSection, setSelectedSection] = useState(null); // null = main menu, otherwise section key
            const [selectedHash, setSelectedHash] = useState('left'); // For opening script submenu
            const [selected2MinCategory, setSelected2MinCategory] = useState('oob_yac'); // For 2-minute submenu
            const [selectedOneWordCategory, setSelectedOneWordCategory] = useState('form_adj'); // For one-word submenu
            const [selected2ndXLHash, setSelected2ndXLHash] = useState('lh'); // For 1st/2nd & XL submenu
            const [selectedConvertShortMed, setSelectedConvertShortMed] = useState('short'); // For Convert Short/Med submenu
            const [selectedConvertLongXL, setSelectedConvertLongXL] = useState('long'); // For Convert L/XL submenu
            const [viewMode, setViewMode] = useState('situations'); // 'situations', 'matrix', or 'player_touches'

            // Game Plan 2.0 State
            const [gamePlanMode, setGamePlanMode] = useState('full'); // 'guided' or 'full'
            const [currentPhase, setCurrentPhase] = useState(1); // 1-5
            const [currentSituationInPhase, setCurrentSituationInPhase] = useState(0); // Index within phase

            // In-Game Script Builder State
            const [isBuildingScript, setIsBuildingScript] = useState(false);
            const [currentScriptPlays, setCurrentScriptPlays] = useState([]);
            const [scriptName, setScriptName] = useState('');

            // Helper to add play to current building script
            const addToScript = (play) => {
                if (!isBuildingScript) return false;
                setCurrentScriptPlays(prev => [...prev, play]);
                return true;
            };

            // Save in-game script
            const saveInGameScript = () => {
                if (!scriptName || currentScriptPlays.length === 0) return;
                const newScript = {
                    id: `ms_ig_${Date.now()} `,
                    name: scriptName,
                    playIds: currentScriptPlays.map(p => p.id),
                    color: '#f43f5e' // Rose color for in-game scripts
                };

                // Update game plan via prop
                const newGamePlan = {
                    ...gamePlan,
                    miniScripts: [...(gamePlan?.miniScripts || []), newScript]
                };
                // Assuming onUpdateSituation can propagate this up or we need onUpdateGamePlan passed down?
                // SmartCallSheet only has onUpdateSituation, we need onUpdateGamePlan or similar.
                // The prompt for SmartCallSheet props earlier showed it didn't have onUpdateGamePlan.
                // But we can check if it was added. If not, we might need to add it. 
                // Wait, I see gamePlan prop. But onUpdateGamePlan? 
                // Let's check props. 
                // Lines 11555 showed: <SmartCallSheet gamePlan=... onUpdateSituation=... zonePhilosophies=... onUpdatePhilosophy=... />
                // It does NOT have onUpdateGamePlan. I need to add that prop.
            };

            // Quick add play to a set
            const handleQuickAddToSet = (setId, playName) => {
                if (!playName.trim() || !onQuickAddPlay) return;

                // Create the incomplete play
                const newPlay = onQuickAddPlay(playName);

                // Add to the set
                const updatedSets = [...(gamePlan?.sets || [])];
                const setIndex = updatedSets.findIndex(s => s.id === setId);

                if (setIndex >= 0) {
                    updatedSets[setIndex] = {
                        ...updatedSets[setIndex],
                        playIds: [...(updatedSets[setIndex].playIds || []), newPlay.id]
                    };
                } else {
                    // Create new set if it doesn't exist
                    updatedSets.push({
                        id: setId,
                        playIds: [newPlay.id]
                    });
                }

                onUpdateGamePlan({
                    ...gamePlan,
                    sets: updatedSets
                });
            };

            // Define all game plan sections - DYNAMICALLY DERIVED from gamePlanLayouts
            const gamePlanSections = useMemo(() => {
                const layout = gamePlanLayouts.CALL_SHEET;
                const derivedSections = [];

                // Helper to find icon/submenu config from original static list or defaults
                const getMeta = (key) => {
                    // Fallback metadata map
                    const metaMap = {
                        'player_touches': { icon: 'Users' },
                        'mini_script_1': { icon: 'FileText' },
                        'mini_script_2': { icon: 'FileText' },
                        'opening_script': { icon: 'Play', hasSubmenu: true },
                        'second_half_openers': { icon: 'RefreshCw' },
                        'p_and_10': { icon: 'AlertCircle' },
                        'base_downs': { icon: 'BarChart2' },
                        '2nd_xl_lh': { icon: 'TrendingDown', hasSubmenu: true }, // Mapped from 2nd_xl in static list?
                        'eoh': { icon: 'Clock' },
                        'one_word': { icon: 'Hash', hasSubmenu: true }, // from Matrix?
                        'form_adj': { icon: 'Grid' },
                        'motion': { icon: 'Move' },
                        'tag': { icon: 'Tag' },
                        '3rd_short': { icon: 'CheckCircle' },
                        '3rd_med': { icon: 'CheckSquare' },
                        '3rd_long': { icon: 'AlertTriangle' },
                        '3rd_xl': { icon: 'XCircle' },
                        'backed_up': { icon: 'ArrowLeft' },
                        'coming_out': { icon: 'ArrowRight' },
                        'open_field': { icon: 'Maximize2' },
                        'fringe': { icon: 'Navigation' },
                        'high_red': { icon: 'Flag' },
                        'low_red': { icon: 'Flag' },
                        'goal_line': { icon: 'Award' },
                        '2-point': { icon: 'Star' },
                        'two_minute_oob_yac': { icon: 'Zap', hasSubmenu: true },
                        'four_minute': { icon: 'Timer' }
                    };
                    return metaMap[key] || { icon: 'Circle' };
                };

                // Iterate through layout sections and use their titles as headers
                // Safe navigation added to prevent crashes if layout data is missing
                (layout?.sections || []).forEach(section => {
                    // Add section header if title exists
                    if (section.title) {
                        derivedSections.push({ type: 'header', label: section.title });
                    }

                    // Add all cells from this section
                    (section.boxes || section.rows || []).forEach(cell => {
                        const meta = getMeta(cell.setId);

                        // Use the cell's header as the label
                        derivedSections.push({
                            key: cell.setId,
                            label: cell.header, // Use the customized header!
                            color: cell.color,
                            icon: meta.icon,
                            hasSubmenu: meta.hasSubmenu
                        });
                    });
                });

                return derivedSections;
            }, [gamePlanLayouts, gamePlan?.miniScripts]);

            // Formation groups for matrix view
            const formationGroups = [
                { id: 'one_word', label: '1 WORD', color: '#f59e0b', icon: 'Hash', hasSubmenu: true },
                { id: '887', label: '887', color: '#ef4444', icon: 'Grid' },
                { id: '888', label: '888', color: '#ef4444', icon: 'Grid' },
                { id: '687', label: '687', color: '#fbbf24', icon: 'Grid' },
                { id: '688', label: '688', color: '#fbbf24', icon: 'Grid' },
                { id: '881', label: '881', color: '#facc15', icon: 'Grid' },
                { id: '984', label: '984', color: '#4ade80', icon: 'Grid' },
                { id: '983', label: '983', color: '#4ade80', icon: 'Grid' },
                { id: '488', label: '488', color: '#60a5fa', icon: 'Grid' },
                { id: '487', label: '487', color: '#60a5fa', icon: 'Grid' }
            ];

            // Play Type groups
            const playTypeGroups = [
                { id: 'Tank Runs', label: 'TANK RUNS', color: '#16a34a', icon: 'ChevronsRight' },
                { id: 'Perimeter Runs', label: 'PERIMETER RUNS', color: '#0ea5e9', icon: 'CornerUpRight' },
                { id: 'FLOW RPOS', label: 'FLOW RPOS', color: '#eab308', icon: 'Shuffle' },
                { id: 'FIT RPOS', label: 'FIT RPOS', color: '#f59e0b', icon: 'Target' },
                { id: 'Quick', label: 'QUICK GAME', color: '#8b5cf6', icon: 'Zap' },
                { id: 'Intermediate', label: 'INTERMEDIATE', color: '#d946ef', icon: 'Activity' },
                { id: 'PAP', label: 'PAP', color: '#ec4899', icon: 'PlayCircle' },
                { id: 'MOVEMENT', label: 'MOVEMENT', color: '#f43f5e', icon: 'Move' },
                { id: 'Deep', label: 'DEEP SHOTS', color: '#ef4444', icon: 'ArrowUpCircle' },
                { id: 'GADGET', label: 'GADGET', color: '#64748b', icon: 'Star' }
            ];

            // Get plays for selected section
            // Helper to get all situations a play is assigned to
            const getPlaySituations = (playId) => {
                const situations = [];
                Object.values(gamePlan?.sets || {}).forEach(set => {
                    if (set.playIds && set.playIds.includes(playId)) {
                        // Find the section metadata for this set
                        const section = gamePlanSections.find(s => s.key === set.id);
                        if (section) {
                            situations.push({
                                id: set.id,
                                label: section.label,
                                color: section.color
                            });
                        }
                    }
                });
                return situations;
            };

            const getSectionPlays = () => {
                if (!selectedSection) return [];

                // Special handling for opening script with hash submenu
                if (selectedSection === 'opening_script') {
                    const setId = selectedHash === 'left' ? '1st_ten_lh' : '1st_ten_rh';
                    const sectionPlayIds = (gamePlan?.sets || {})[setId]?.playIds || [];
                    return sectionPlayIds.map(id => plays.find(p => p.id === id)).filter(Boolean);
                }

                // Special handling for 2-minute drill with category submenu
                if (selectedSection === 'two_minute') {
                    const setId = `two_minute_${selected2MinCategory} `;
                    const sectionPlayIds = (gamePlan?.sets || {})[setId]?.playIds || [];
                    return sectionPlayIds.map(id => plays.find(p => p.id === id)).filter(Boolean);
                }

                // Special handling for one_word in Strike 'Em Out view with category submenu
                if (selectedSection === 'one_word') {
                    const setId = selectedOneWordCategory; // 'form_adj', 'motion', or 'tag'
                    const sectionPlayIds = (gamePlan?.sets || []).find(s => s.id === setId)?.playIds || [];
                    return sectionPlayIds.map(id => plays.find(p => p.id === id)).filter(Boolean);
                }

                // Special handling for 2nd_xl with hash submenu
                if (selectedSection === '2nd_xl') {
                    const setId = selected2ndXLHash === 'lh' ? '2nd_xl_lh' : '2nd_xl_rh';
                    const sectionPlayIds = (gamePlan?.sets || []).find(s => s.id === setId)?.playIds || [];
                    return sectionPlayIds.map(id => plays.find(p => p.id === id)).filter(Boolean);
                }

                // Special handling for convert_short_med with distance submenu
                if (selectedSection === 'convert_short_med') {
                    const setId = selectedConvertShortMed === 'short' ? '3rd_short' : '3rd_med';
                    const sectionPlayIds = (gamePlan?.sets || []).find(s => s.id === setId)?.playIds || [];
                    return sectionPlayIds.map(id => plays.find(p => p.id === id)).filter(Boolean);
                }

                // Special handling for convert_long_xl with distance submenu
                if (selectedSection === 'convert_long_xl') {
                    const setId = selectedConvertLongXL === 'long' ? '3rd_long' : '3rd_xl';
                    const sectionPlayIds = (gamePlan?.sets || []).find(s => s.id === setId)?.playIds || [];
                    return sectionPlayIds.map(id => plays.find(p => p.id === id)).filter(Boolean);
                }

                // Check if this is a Play Type
                const isPlayType = playTypeGroups.some(pt => pt.id === selectedSection);
                if (isPlayType) {
                    return plays.filter(p => {
                        const allPlayTags = [...(p.tags || []), p.tag1, p.tag2].filter(Boolean);
                        return allPlayTags.includes(selectedSection);
                    });
                }

                // Check if this is a formation from Strike 'Em Out view
                const isFormation = formationGroups.some(f => f.id === selectedSection);
                if (isFormation) {
                    return plays.filter(p => p.formation && p.formation.includes(selectedSection));
                }

                const sectionPlayIds = (gamePlan?.sets || []).find(s => s.id === selectedSection)?.playIds || [];
                // Check mini scripts if not found in sets
                if (sectionPlayIds.length === 0 && selectedSection.startsWith('ms_')) {
                    const script = (gamePlan?.miniScripts || []).find(s => s.id === selectedSection);
                    if (script) {
                        return script.playIds.map(item => {
                            const id = typeof item === 'object' ? item.id : item;
                            const play = plays.find(p => p.id === id);
                            return play ? { ...play, ...(typeof item === 'object' ? item : {}), _raw: item } : null;
                        }).filter(Boolean);
                    }
                }
                return sectionPlayIds.map(item => {
                    const id = typeof item === 'object' ? item.id : item;
                    const play = plays.find(p => p.id === id);
                    return play ? { ...play, ...(typeof item === 'object' ? item : {}), _raw: item } : null;
                }).filter(Boolean);
            };

            const sectionPlays = getSectionPlays();

            // State for situation dropdown (track which play has dropdown open)
            const [situationDropdownPlayId, setSituationDropdownPlayId] = useState(null);

            // Main Menu View
            if (!selectedSection) {
                return (
                    <div style={{ height: 'calc(100vh - 100px)', display: 'flex', flexDirection: 'column', gap: '1.5rem', padding: '1rem', background: 'white', borderRadius: '8px', overflowY: 'auto' }}>
                        <div style={{ textAlign: 'center', marginBottom: '0.5rem' }}>
                            <h2 style={{ margin: 0, marginBottom: '0.5rem' }}>Situations and Scripts</h2>
                            <p style={{ color: 'var(--text-secondary)' }}>Select a situation to view plays</p>
                        </div>

                        {/* View Tabs and Statistics */}
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem', gap: '1rem' }}>
                            {/* View Tabs */}
                            <div style={{ display: 'flex', gap: '0.5rem' }}>
                                {[
                                    { id: 'situations', label: 'Situations & Scripts', icon: 'List' },
                                    { id: 'matrix', label: "Strike 'Em Out", icon: 'Grid' },
                                    { id: 'play_types', label: 'Play Type', icon: 'Layers' },
                                    { id: 'player_touches', label: 'Player Touches', icon: 'Users' }
                                ].map(tab => (
                                    <button
                                        key={tab.id}
                                        onClick={() => setViewMode(tab.id)}
                                        className={`btn ${viewMode === tab.id ? 'btn-primary' : 'btn-secondary'}`}
                                        style={{
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '0.5rem',
                                            padding: '0.75rem 1.5rem',
                                            borderRadius: '24px',
                                            border: viewMode === tab.id ? 'none' : '1px solid var(--border)',
                                            color: '#1f2937',
                                            background: viewMode === tab.id ? 'var(--primary)' : '#f3f4f6',
                                            fontWeight: viewMode === tab.id ? 'bold' : '500'
                                        }}
                                    >
                                        <Icon name={tab.icon} size={16} />
                                        {tab.label}
                                    </button>
                                ))}
                            </div>

                            {/* Game Plan Statistics Ticker */}
                            {(() => {
                                // Calculate unique plays in game plan
                                const allGamePlanPlayIds = new Set();
                                Object.values(gamePlan?.sets || {}).forEach(set => {
                                    (set.playIds || []).forEach(item => {
                                        const id = typeof item === 'object' ? item.id : item;
                                        if (id) allGamePlanPlayIds.add(id);
                                    });
                                });
                                Object.values(gamePlan?.miniScripts || {}).forEach(script => {
                                    (script.playIds || []).forEach(item => {
                                        const id = typeof item === 'object' ? item.id : item;
                                        if (id) allGamePlanPlayIds.add(id);
                                    });
                                });
                                const uniquePlaysCount = allGamePlanPlayIds.size;

                                // Calculate new plays (plays added this week that weren't in previous weeks)
                                const previousWeekPlayIds = new Set();
                                weeks.forEach(w => {
                                    if (w.weekNumber < currentWeek.weekNumber) {
                                        const prevGamePlan = w.gamePlan || {};
                                        Object.values(prevGamePlan.sets || {}).forEach(set => {
                                            (set.playIds || []).forEach(item => {
                                                const id = typeof item === 'object' ? item.id : item;
                                                if (id) previousWeekPlayIds.add(id);
                                            });
                                        });
                                        Object.values(prevGamePlan.miniScripts || {}).forEach(script => {
                                            (script.playIds || []).forEach(item => {
                                                const id = typeof item === 'object' ? item.id : item;
                                                if (id) previousWeekPlayIds.add(id);
                                            });
                                        });
                                    }
                                });
                                const newPlaysCount = Array.from(allGamePlanPlayIds).filter(id => !previousWeekPlayIds.has(id)).length;

                                // Calculate total practice script slots for the week
                                let totalScriptSlots = 0;
                                const plansList = Array.isArray(practicePlans) ? practicePlans : Object.values(practicePlans || {});
                                plansList.forEach(plan => {
                                    plan.segments.forEach(seg => {
                                        if (seg.hasScript && seg.script && seg.script.length > 0) {
                                            totalScriptSlots += seg.script.length;
                                        }
                                    });
                                });

                                return (
                                    <div style={{
                                        display: 'flex',
                                        gap: '1rem',
                                        padding: '0.5rem 1rem',
                                        background: 'linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%)',
                                        borderRadius: '24px',
                                        border: '1px solid var(--border)',
                                        alignItems: 'center'
                                    }}>
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.25rem' }}>
                                            <div style={{ fontSize: '1.25rem', fontWeight: 'bold', color: 'var(--primary)' }}>
                                                {uniquePlaysCount}
                                            </div>
                                            <div style={{ fontSize: '0.7rem', color: 'var(--text-secondary)', whiteSpace: 'nowrap' }}>
                                                Unique
                                            </div>
                                        </div>
                                        <div style={{ width: '1px', height: '24px', background: 'var(--border)' }}></div>
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.25rem' }}>
                                            <div style={{ fontSize: '1.25rem', fontWeight: 'bold', color: '#10b981' }}>
                                                {newPlaysCount}
                                            </div>
                                            <div style={{ fontSize: '0.7rem', color: 'var(--text-secondary)', whiteSpace: 'nowrap' }}>
                                                New
                                            </div>
                                        </div>
                                        <div style={{ width: '1px', height: '24px', background: 'var(--border)' }}></div>
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.25rem' }}>
                                            <div style={{ fontSize: '1.25rem', fontWeight: 'bold', color: '#6366f1' }}>
                                                {totalScriptSlots}
                                            </div>
                                            <div style={{ fontSize: '0.7rem', color: 'var(--text-secondary)', whiteSpace: 'nowrap' }}>
                                                Slots
                                            </div>
                                        </div>
                                    </div>
                                );
                            })()}
                        </div>

                        {/* Situations View */}
                        {viewMode === 'situations' && (gamePlanLayouts?.CALL_SHEET?.sections || []).map((section, sIdx) => (
                            <div key={section.id || sIdx} style={{ marginBottom: '1.5rem' }}>
                                {section.title && (
                                    <h3 style={{
                                        fontSize: '1rem',
                                        color: 'var(--text-secondary)',
                                        textTransform: 'uppercase',
                                        letterSpacing: '0.05em',
                                        borderBottom: '1px solid var(--border)',
                                        paddingBottom: '0.5rem',
                                        marginBottom: '1rem'
                                    }}>
                                        {section.title}
                                    </h3>
                                )}

                                <div style={{
                                    display: 'grid',
                                    gridTemplateColumns: 'repeat(4, 1fr)',
                                    gap: '1rem'
                                }}>
                                    {(section.boxes || section.rows || []).map(cell => {
                                        const meta = { icon: 'Circle', ...cell }; // Fallback
                                        const playCount = (gamePlan?.sets || []).find(s => s.id === cell.setId)?.playIds?.length || 0;

                                        return (
                                            <button
                                                key={cell.setId}
                                                onClick={() => setSelectedSection(cell.setId)}
                                                style={{
                                                    background: cell.color,
                                                    color: 'white',
                                                    border: 'none',
                                                    borderRadius: '12px',
                                                    padding: '1.5rem',
                                                    cursor: 'pointer',
                                                    transition: 'all 0.2s',
                                                    display: 'flex',
                                                    flexDirection: 'column',
                                                    alignItems: 'center',
                                                    gap: '0.75rem',
                                                    minHeight: '140px',
                                                    position: 'relative',
                                                    fontSize: '1rem',
                                                    fontWeight: 'bold',
                                                    textTransform: 'uppercase',
                                                    boxShadow: '0 2px 8px rgba(0,0,0,0.15)'
                                                }}
                                                onMouseEnter={(e) => {
                                                    e.currentTarget.style.transform = 'translateY(-4px)';
                                                    e.currentTarget.style.boxShadow = '0 4px 16px rgba(0,0,0,0.25)';
                                                }}
                                                onMouseLeave={(e) => {
                                                    e.currentTarget.style.transform = 'translateY(0)';
                                                    e.currentTarget.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
                                                }}
                                            >
                                                {/* Try to find icon from predefined list or use default */}
                                                <div style={{ textAlign: 'center' }}>{cell.header}</div>
                                                <div style={{
                                                    fontSize: '0.75rem',
                                                    opacity: 0.9,
                                                    position: 'absolute',
                                                    bottom: '0.5rem',
                                                    right: '0.5rem',
                                                    background: 'rgba(0,0,0,0.2)',
                                                    padding: '0.25rem 0.5rem',
                                                    borderRadius: '4px'
                                                }}>
                                                    {playCount} {playCount === 1 ? 'play' : 'plays'}
                                                </div>
                                            </button>
                                        );
                                    })}
                                </div>
                            </div>
                        ))}

                        {/* Matrix View (Strike 'Em Out) */}
                        {viewMode === 'matrix' && (
                            <div style={{
                                display: 'grid',
                                gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))',
                                gap: '1rem',
                                overflowY: 'auto',
                                flex: 1
                            }}>
                                {/* Use Matrix Formations */}
                                {(gamePlanLayouts?.MATRIX?.formations || formationGroups).map(group => {
                                    const formationPlays = plays.filter(p => p.formation && p.formation.includes(group.id));
                                    const playCount = formationPlays.length;

                                    // Special handling for legacy/static groups if needed, but prefer dynamic
                                    // If group comes from gamePlanLayouts it might miss 'icon', add fallback
                                    const icon = group.icon || 'Grid';

                                    return (
                                        <button
                                            key={group.id}
                                            onClick={() => setSelectedSection(group.id)}
                                            style={{
                                                background: group.color || '#ef4444',
                                                color: 'white',
                                                border: 'none',
                                                borderRadius: '12px',
                                                padding: '1.5rem',
                                                cursor: 'pointer',
                                                transition: 'all 0.2s',
                                                display: 'flex',
                                                flexDirection: 'column',
                                                alignItems: 'center',
                                                gap: '0.75rem',
                                                minHeight: '140px',
                                                position: 'relative',
                                                fontSize: '1.5rem',
                                                fontWeight: 'bold',
                                                boxShadow: '0 2px 8px rgba(0,0,0,0.15)'
                                            }}
                                            onMouseEnter={(e) => {
                                                e.currentTarget.style.transform = 'translateY(-4px)';
                                                e.currentTarget.style.boxShadow = '0 4px 16px rgba(0,0,0,0.25)';
                                            }}
                                            onMouseLeave={(e) => {
                                                e.currentTarget.style.transform = 'translateY(0)';
                                                e.currentTarget.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
                                            }}
                                        >
                                            <Icon name={icon} size={32} />
                                            <div style={{ textAlign: 'center' }}>{group.label}</div>
                                            <div style={{
                                                fontSize: '0.75rem',
                                                opacity: 0.9,
                                                position: 'absolute',
                                                bottom: '0.5rem',
                                                right: '0.5rem',
                                                background: 'rgba(0,0,0,0.2)',
                                                padding: '0.25rem 0.5rem',
                                                borderRadius: '4px'
                                            }}>
                                                {playCount} {playCount === 1 ? 'play' : 'plays'}
                                            </div>
                                        </button>
                                    );
                                })}
                            </div>
                        )}

                        {/* Play Types View */}
                        {viewMode === 'play_types' && (
                            <div style={{
                                display: 'grid',
                                gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))',
                                gap: '1rem',
                                overflowY: 'auto',
                                flex: 1
                            }}>
                                {playTypeGroups.map(group => {
                                    const playCount = plays.filter(p => {
                                        const allTags = [...(p.tags || []), p.tag1, p.tag2].filter(Boolean);
                                        return allTags.includes(group.id);
                                    }).length;

                                    return (
                                        <button
                                            key={group.id}
                                            onClick={() => setSelectedSection(group.id)}
                                            style={{
                                                background: group.color,
                                                color: 'white',
                                                border: 'none',
                                                borderRadius: '12px',
                                                padding: '1.5rem',
                                                cursor: 'pointer',
                                                transition: 'all 0.2s',
                                                display: 'flex',
                                                flexDirection: 'column',
                                                alignItems: 'center',
                                                gap: '0.75rem',
                                                minHeight: '140px',
                                                position: 'relative',
                                                fontSize: '1.25rem',
                                                fontWeight: 'bold',
                                                boxShadow: '0 2px 8px rgba(0,0,0,0.15)'
                                            }}
                                            onMouseEnter={(e) => {
                                                e.currentTarget.style.transform = 'translateY(-4px)';
                                                e.currentTarget.style.boxShadow = '0 4px 16px rgba(0,0,0,0.25)';
                                            }}
                                            onMouseLeave={(e) => {
                                                e.currentTarget.style.transform = 'translateY(0)';
                                                e.currentTarget.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
                                            }}
                                        >
                                            <Icon name={group.icon} size={32} />
                                            <div style={{ textAlign: 'center' }}>{group.label}</div>
                                            <div style={{
                                                fontSize: '0.75rem',
                                                opacity: 0.9,
                                                position: 'absolute',
                                                bottom: '0.5rem',
                                                right: '0.5rem',
                                                background: 'rgba(0,0,0,0.2)',
                                                padding: '0.25rem 0.5rem',
                                                borderRadius: '4px'
                                            }}>
                                                {playCount} {playCount === 1 ? 'play' : 'plays'}
                                            </div>
                                        </button>
                                    );
                                })}
                            </div>
                        )}

                        {/* Player Touches View */}
                        {viewMode === 'player_touches' && (
                            <div style={{
                                display: 'flex',
                                justifyContent: 'center',
                                alignItems: 'center',
                                overflowY: 'auto',
                                flex: 1,
                                padding: '2rem'
                            }}>
                                <button
                                    onClick={() => setSelectedSection('player_touches')}
                                    style={{
                                        background: '#8b5cf6',
                                        color: 'white',
                                        border: 'none',
                                        borderRadius: '16px',
                                        padding: '3rem',
                                        cursor: 'pointer',
                                        transition: 'all 0.2s',
                                        display: 'flex',
                                        flexDirection: 'column',
                                        alignItems: 'center',
                                        gap: '1rem',
                                        minWidth: '300px',
                                        minHeight: '200px',
                                        position: 'relative',
                                        fontSize: '2rem',
                                        fontWeight: 'bold',
                                        boxShadow: '0 4px 16px rgba(139, 92, 246, 0.3)'
                                    }}
                                    onMouseEnter={(e) => {
                                        e.currentTarget.style.transform = 'scale(1.05)';
                                        e.currentTarget.style.boxShadow = '0 8px 24px rgba(139, 92, 246, 0.4)';
                                    }}
                                    onMouseLeave={(e) => {
                                        e.currentTarget.style.transform = 'scale(1)';
                                        e.currentTarget.style.boxShadow = '0 4px 16px rgba(139, 92, 246, 0.3)';
                                    }}
                                >
                                    <Icon name="Users" size={48} />
                                    <div style={{ textAlign: 'center' }}>👐 PLAYER TOUCHES</div>
                                    <div style={{
                                        fontSize: '0.85rem',
                                        opacity: 0.9,
                                        position: 'absolute',
                                        bottom: '1rem',
                                        background: 'rgba(0,0,0,0.2)',
                                        padding: '0.5rem 1rem',
                                        borderRadius: '6px'
                                    }}>
                                        {((gamePlan?.sets || []).find(s => s.id === 'player_touches')?.playIds?.length || 0)} {((gamePlan?.sets || []).find(s => s.id === 'player_touches')?.playIds?.length || 0) === 1 ? 'play' : 'plays'}
                                    </div>
                                </button>
                            </div>
                        )}

                    </div>

                );
            }

            // Section Detail View
            const currentSection = gamePlanSections.find(s => s.key === selectedSection) ||
                formationGroups.find(f => f.id === selectedSection) ||
                playTypeGroups.find(pt => pt.id === selectedSection) ||
                (selectedSection === 'player_touches' ? { key: 'player_touches', label: '👐 PLAYER TOUCHES', color: '#8b5cf6', icon: 'Users' } : null);

            return (
                <div style={{ height: 'calc(100vh - 100px)', display: 'flex', flexDirection: 'column' }}>
                    {/* Header with Home Button */}
                    <div style={{
                        background: currentSection.color,
                        color: 'white',
                        padding: '1rem 1.5rem',
                        display: 'flex',
                        justifyContent: 'space-between',
                        alignItems: 'center',
                        boxShadow: '0 2px 8px rgba(0,0,0,0.15)'
                    }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                            <Icon name={currentSection.icon} size={24} />
                            <h2 style={{ margin: 0 }}>{currentSection.label}</h2>
                            <span style={{
                                fontSize: '0.9rem',
                                opacity: 0.9,
                                background: 'rgba(0,0,0,0.2)',
                                padding: '0.25rem 0.75rem',
                                borderRadius: '12px'
                            }}>
                                {sectionPlays.length} {sectionPlays.length === 1 ? 'play' : 'plays'}
                            </span>
                        </div>
                        <button
                            onClick={() => setSelectedSection(null)}
                            className="btn"
                            style={{
                                background: 'rgba(255,255,255,0.2)',
                                color: 'white',
                                border: '2px solid rgba(255,255,255,0.3)',
                                fontWeight: 'bold',
                                display: 'flex',
                                alignItems: 'center',
                                gap: '0.5rem'
                            }}
                        >
                            <Icon name="Home" size={18} />
                            HOME
                        </button>

                        {/* Build Script Toggle */}
                        <button
                            onClick={() => setIsBuildingScript(!isBuildingScript)}
                            className="btn"
                            style={{
                                background: isBuildingScript ? '#f43f5e' : 'rgba(255,255,255,0.2)',
                                color: 'white',
                                border: '2px solid rgba(255,255,255,0.3)',
                                fontWeight: 'bold',
                                display: 'flex',
                                alignItems: 'center',
                                gap: '0.5rem'
                            }}
                        >
                            <Icon name="Edit3" size={18} />
                            {isBuildingScript ? 'BUILDING...' : 'BUILD SCRIPT'}
                        </button>
                    </div>

                    {/* Script Builder Panel */}
                    {isBuildingScript && (
                        <div style={{
                            background: 'var(--bg-panel)',
                            padding: '1rem',
                            borderBottom: '2px solid var(--border)',
                            animation: 'slideDown 0.2s ease-out'
                        }}>
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.5rem' }}>
                                <div style={{ fontWeight: 'bold', color: '#f43f5e' }}>IN-GAME SCRIPT BUILDER</div>
                                <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>{currentScriptPlays.length} Plays Selected</div>
                            </div>

                            <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '1rem' }}>
                                <input
                                    type="text"
                                    placeholder="Script Name (e.g. 2nd Half Openers)"
                                    value={scriptName}
                                    onChange={(e) => setScriptName(e.target.value)}
                                    style={{
                                        flex: 1,
                                        padding: '0.5rem',
                                        borderRadius: '4px',
                                        border: '1px solid var(--border)',
                                        background: 'var(--bg-card)',
                                        color: 'var(--text-primary)'
                                    }}
                                />
                                <button
                                    className="btn btn-primary"
                                    onClick={saveInGameScript}
                                    style={{ backgroundColor: '#f43f5e', opacity: (!scriptName || currentScriptPlays.length === 0) ? 0.5 : 1 }}
                                    disabled={!scriptName || currentScriptPlays.length === 0}
                                >
                                    SAVE SCRIPT
                                </button>
                            </div>

                            {/* Current Plays List */}
                            {currentScriptPlays.length > 0 && (
                                <div style={{ maxHeight: '100px', overflowY: 'auto', background: 'var(--bg-card)', padding: '0.5rem', borderRadius: '4px', display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                    {currentScriptPlays.map((p, idx) => (
                                        <div key={`script - play - ${idx} `} style={{ fontSize: '0.8rem', display: 'flex', justifyContent: 'space-between' }}>
                                            <span>{idx + 1}. {getPlayDisplayName(p)}</span>
                                            <span style={{ cursor: 'pointer', color: '#ef4444' }} onClick={() => setCurrentScriptPlays(prev => prev.filter((_, i) => i !== idx))}>×</span>
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>
                    )}

                    {/* Quick Add Play Input */}
                    {onQuickAddPlay && selectedSection && !['play_type', 'player_touches'].includes(selectedSection) && (
                        <div style={{
                            marginTop: '2rem',
                            padding: '1.5rem',
                            background: 'var(--bg-panel)',
                            borderRadius: '8px',
                            border: '2px dashed var(--border)'
                        }}>
                            <div style={{ marginBottom: '0.75rem', fontWeight: 'bold', color: 'var(--text-secondary)', fontSize: '0.9rem' }}>
                                ➕ QUICK ADD PLAY
                            </div>
                            <input
                                type="text"
                                placeholder="Type play name and press Enter..."
                                style={{
                                    width: '100%',
                                    padding: '0.75rem',
                                    background: 'var(--bg-card)',
                                    border: '2px solid var(--border)',
                                    borderRadius: '6px',
                                    color: 'var(--text-primary)',
                                    fontSize: '1rem'
                                }}
                                onKeyDown={(e) => {
                                    if (e.key === 'Enter' && e.target.value.trim()) {
                                        // Determine the setId based on current section and submenus
                                        let setId = selectedSection;

                                        // Handle sections with submenus
                                        if (selectedSection === 'opening_script') {
                                            setId = `opening_script_${selectedHash} `;
                                        } else if (selectedSection === '2nd_xl') {
                                            setId = `2nd_xl_${selected2ndXLHash} `;
                                        } else if (selectedSection === '2_min') {
                                            setId = `2_min_${selected2MinCategory} `;
                                        } else if (selectedSection === 'one_word') {
                                            setId = `one_word_${selectedOneWordCategory} `;
                                        } else if (selectedSection === 'convert_short_med') {
                                            setId = selectedConvertShortMed === 'short' ? '3rd_short' : '3rd_med';
                                        } else if (selectedSection === 'convert_long_xl') {
                                            setId = selectedConvertLongXL === 'long' ? '3rd_long' : '3rd_xl';
                                        }

                                        handleQuickAddToSet(setId, e.target.value);
                                        e.target.value = '';
                                    }
                                }}
                            />
                            <div style={{ marginTop: '0.5rem', fontSize: '0.75rem', color: 'var(--text-secondary)' }}>
                                💡 Play will be created as incomplete - fill out details in the Playbook tab
                            </div>
                        </div>
                    )}

                    {/* Hash Toggle for Opening Script */}
                    {selectedSection === 'opening_script' && (
                        <div style={{
                            background: 'var(--bg-panel)',
                            padding: '1rem 1.5rem',
                            borderBottom: '2px solid var(--border)',
                            display: 'flex',
                            gap: '1rem'
                        }}>
                            <button
                                onClick={() => setSelectedHash('left')}
                                className="btn"
                                style={{
                                    background: selectedHash === 'left' ? currentSection.color : 'var(--bg-card)',
                                    color: selectedHash === 'left' ? 'white' : 'var(--text-primary)',
                                    border: selectedHash === 'left' ? 'none' : '2px solid var(--border)',
                                    fontWeight: 'bold',
                                    padding: '0.75rem 1.5rem',
                                    flex: 1
                                }}
                            >
                                ◀ LEFT HASH
                            </button>
                            <button
                                onClick={() => setSelectedHash('right')}
                                className="btn"
                                style={{
                                    background: selectedHash === 'right' ? currentSection.color : 'var(--bg-card)',
                                    color: selectedHash === 'right' ? 'white' : 'var(--text-primary)',
                                    border: selectedHash === 'right' ? 'none' : '2px solid var(--border)',
                                    fontWeight: 'bold',
                                    padding: '0.75rem 1.5rem',
                                    flex: 1
                                }}
                            >
                                RIGHT HASH ▶
                            </button>
                        </div>
                    )}

                    {/* Hash Toggle for 1st/2nd & XL */}
                    {selectedSection === '2nd_xl' && (
                        <div style={{
                            background: 'var(--bg-panel)',
                            padding: '1rem 1.5rem',
                            borderBottom: '2px solid var(--border)',
                            display: 'flex',
                            gap: '1rem'
                        }}>
                            <button
                                onClick={() => setSelected2ndXLHash('lh')}
                                className="btn"
                                style={{
                                    background: selected2ndXLHash === 'lh' ? currentSection.color : 'var(--bg-card)',
                                    color: selected2ndXLHash === 'lh' ? 'white' : 'var(--text-primary)',
                                    border: selected2ndXLHash === 'lh' ? 'none' : '2px solid var(--border)',
                                    fontWeight: 'bold',
                                    padding: '0.75rem 1.5rem',
                                    flex: 1
                                }}
                            >
                                ◀ LEFT HASH
                            </button>
                            <button
                                onClick={() => setSelected2ndXLHash('rh')}
                                className="btn"
                                style={{
                                    background: selected2ndXLHash === 'rh' ? currentSection.color : 'var(--bg-card)',
                                    color: selected2ndXLHash === 'rh' ? 'white' : 'var(--text-primary)',
                                    border: selected2ndXLHash === 'rh' ? 'none' : '2px solid var(--border)',
                                    fontWeight: 'bold',
                                    padding: '0.75rem 1.5rem',
                                    flex: 1
                                }}
                            >
                                RIGHT HASH ▶
                            </button>
                        </div>
                    )}

                    {/* Distance Toggle for Convert Short/Med */}
                    {selectedSection === 'convert_short_med' && (
                        <div style={{
                            background: 'var(--bg-panel)',
                            padding: '1rem 1.5rem',
                            borderBottom: '2px solid var(--border)',
                            display: 'flex',
                            gap: '1rem'
                        }}>
                            <button
                                onClick={() => setSelectedConvertShortMed('short')}
                                className="btn"
                                style={{
                                    background: selectedConvertShortMed === 'short' ? currentSection.color : 'var(--bg-card)',
                                    color: selectedConvertShortMed === 'short' ? 'white' : 'var(--text-primary)',
                                    border: selectedConvertShortMed === 'short' ? 'none' : '2px solid var(--border)',
                                    fontWeight: 'bold',
                                    padding: '0.75rem 1.5rem',
                                    flex: 1
                                }}
                            >
                                3RD & SHORT
                            </button>
                            <button
                                onClick={() => setSelectedConvertShortMed('med')}
                                className="btn"
                                style={{
                                    background: selectedConvertShortMed === 'med' ? currentSection.color : 'var(--bg-card)',
                                    color: selectedConvertShortMed === 'med' ? 'white' : 'var(--text-primary)',
                                    border: selectedConvertShortMed === 'med' ? 'none' : '2px solid var(--border)',
                                    fontWeight: 'bold',
                                    padding: '0.75rem 1.5rem',
                                    flex: 1
                                }}
                            >
                                3RD & MED
                            </button>
                        </div>
                    )}

                    {/* Distance Toggle for Convert L/XL */}
                    {selectedSection === 'convert_long_xl' && (
                        <div style={{
                            background: 'var(--bg-panel)',
                            padding: '1rem 1.5rem',
                            borderBottom: '2px solid var(--border)',
                            display: 'flex',
                            gap: '1rem'
                        }}>
                            <button
                                onClick={() => setSelectedConvertLongXL('long')}
                                className="btn"
                                style={{
                                    background: selectedConvertLongXL === 'long' ? currentSection.color : 'var(--bg-card)',
                                    color: selectedConvertLongXL === 'long' ? 'white' : 'var(--text-primary)',
                                    border: selectedConvertLongXL === 'long' ? 'none' : '2px solid var(--border)',
                                    fontWeight: 'bold',
                                    padding: '0.75rem 1.5rem',
                                    flex: 1
                                }}
                            >
                                3RD & LONG (7-12)
                            </button>
                            <button
                                onClick={() => setSelectedConvertLongXL('xl')}
                                className="btn"
                                style={{
                                    background: selectedConvertLongXL === 'xl' ? currentSection.color : 'var(--bg-card)',
                                    color: selectedConvertLongXL === 'xl' ? 'white' : 'var(--text-primary)',
                                    border: selectedConvertLongXL === 'xl' ? 'none' : '2px solid var(--border)',
                                    fontWeight: 'bold',
                                    padding: '0.75rem 1.5rem',
                                    flex: 1
                                }}
                            >
                                3RD & XL (12+)
                            </button>
                        </div>
                    )}

                    {/* 2-Minute Drill Category Toggle */}
                    {selectedSection === 'two_minute' && (
                        <div style={{
                            background: 'var(--bg-panel)',
                            padding: '1rem 1.5rem',
                            borderBottom: '2px solid var(--border)',
                            display: 'grid',
                            gridTemplateColumns: 'repeat(2, 1fr)',
                            gap: '0.75rem'
                        }}>
                            <button
                                onClick={() => setSelected2MinCategory('oob_yac')}
                                className="btn"
                                style={{
                                    background: selected2MinCategory === 'oob_yac' ? currentSection.color : 'var(--bg-card)',
                                    color: selected2MinCategory === 'oob_yac' ? 'white' : 'var(--text-primary)',
                                    border: selected2MinCategory === 'oob_yac' ? 'none' : '2px solid var(--border)',
                                    fontWeight: 'bold',
                                    padding: '0.75rem 1rem',
                                    fontSize: '0.85rem'
                                }}
                            >
                                🏃 OOB / YAC
                            </button>
                            <button
                                onClick={() => setSelected2MinCategory('first_down')}
                                className="btn"
                                style={{
                                    background: selected2MinCategory === 'first_down' ? currentSection.color : 'var(--bg-card)',
                                    color: selected2MinCategory === 'first_down' ? 'white' : 'var(--text-primary)',
                                    border: selected2MinCategory === 'first_down' ? 'none' : '2px solid var(--border)',
                                    fontWeight: 'bold',
                                    padding: '0.75rem 1rem',
                                    fontSize: '0.85rem'
                                }}
                            >
                                📍 FIRST DOWN
                            </button>
                            <button
                                onClick={() => setSelected2MinCategory('touchdown')}
                                className="btn"
                                style={{
                                    background: selected2MinCategory === 'touchdown' ? currentSection.color : 'var(--bg-card)',
                                    color: selected2MinCategory === 'touchdown' ? 'white' : 'var(--text-primary)',
                                    border: selected2MinCategory === 'touchdown' ? 'none' : '2px solid var(--border)',
                                    fontWeight: 'bold',
                                    padding: '0.75rem 1rem',
                                    fontSize: '0.85rem'
                                }}
                            >
                                🎯 TOUCHDOWN
                            </button>
                            <button
                                onClick={() => setSelected2MinCategory('final_play')}
                                className="btn"
                                style={{
                                    background: selected2MinCategory === 'final_play' ? currentSection.color : 'var(--bg-card)',
                                    color: selected2MinCategory === 'final_play' ? 'white' : 'var(--text-primary)',
                                    border: selected2MinCategory === 'final_play' ? 'none' : '2px solid var(--border)',
                                    fontWeight: 'bold',
                                    padding: '0.75rem 1rem',
                                    fontSize: '0.85rem'
                                }}
                            >
                                ⏱️ FINAL PLAY
                            </button>
                        </div>
                    )}

                    {/* One-Word Category Toggle */}
                    {selectedSection === 'one_word' && (
                        <div style={{
                            background: 'var(--bg-panel)',
                            padding: '1rem 1.5rem',
                            borderBottom: '2px solid var(--border)',
                            display: 'grid',
                            gridTemplateColumns: 'repeat(3, 1fr)',
                            gap: '0.75rem'
                        }}>
                            <button
                                onClick={() => setSelectedOneWordCategory('form_adj')}
                                className="btn"
                                style={{
                                    background: selectedOneWordCategory === 'form_adj' ? currentSection.color : 'var(--bg-card)',
                                    color: selectedOneWordCategory === 'form_adj' ? 'white' : 'var(--text-primary)',
                                    border: selectedOneWordCategory === 'form_adj' ? 'none' : '2px solid var(--border)',
                                    fontWeight: 'bold',
                                    padding: '0.75rem 1rem',
                                    fontSize: '0.85rem'
                                }}
                            >
                                📐 FORM ADJ
                            </button>
                            <button
                                onClick={() => setSelectedOneWordCategory('motion')}
                                className="btn"
                                style={{
                                    background: selectedOneWordCategory === 'motion' ? currentSection.color : 'var(--bg-card)',
                                    color: selectedOneWordCategory === 'motion' ? 'white' : 'var(--text-primary)',
                                    border: selectedOneWordCategory === 'motion' ? 'none' : '2px solid var(--border)',
                                    fontWeight: 'bold',
                                    padding: '0.75rem 1rem',
                                    fontSize: '0.85rem'
                                }}
                            >
                                🏃 MOTION
                            </button>
                            <button
                                onClick={() => setSelectedOneWordCategory('tag')}
                                className="btn"
                                style={{
                                    background: selectedOneWordCategory === 'tag' ? currentSection.color : 'var(--bg-card)',
                                    color: selectedOneWordCategory === 'tag' ? 'white' : 'var(--text-primary)',
                                    border: selectedOneWordCategory === 'tag' ? 'none' : '2px solid var(--border)',
                                    fontWeight: 'bold',
                                    padding: '0.75rem 1rem',
                                    fontSize: '0.85rem'
                                }}
                            >
                                🏷️ TAG
                            </button>
                        </div>
                    )}


                    {/* Zone Philosophy Editor (for field zones) */}
                    {['backed_up', 'coming_out', 'open_field', 'fringe', 'high_red', 'low_red', 'goal_line'].includes(selectedSection) && zonePhilosophies && (
                        <div style={{
                            background: 'var(--bg-panel)',
                            padding: '1.5rem',
                            borderBottom: '2px solid var(--border)'
                        }}>
                            <div style={{ marginBottom: '0.5rem', fontWeight: 'bold', fontSize: '0.9rem', color: 'var(--text-secondary)' }}>
                                💡 ZONE PHILOSOPHY
                            </div>
                            <textarea
                                value={zonePhilosophies[selectedSection] || ''}
                                onChange={(e) => onUpdatePhilosophy({
                                    ...zonePhilosophies,
                                    [selectedSection]: e.target.value
                                })}
                                placeholder="Enter your strategic philosophy for this field zone..."
                                style={{
                                    width: '100%',
                                    minHeight: '60px',
                                    padding: '0.75rem',
                                    borderRadius: '6px',
                                    border: '2px solid var(--border)',
                                    background: 'var(--bg-card)',
                                    color: 'var(--text-primary)',
                                    fontSize: '0.95rem',
                                    fontFamily: 'inherit',
                                    resize: 'vertical'
                                }}
                            />
                        </div>
                    )}

                    {/* Plays Grid */}
                    <div style={{ flex: 1, overflowY: 'auto', padding: '1.5rem' }}>
                        {sectionPlays.length === 0 ? (
                            <div style={{
                                height: '100%',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                color: 'var(--text-secondary)',
                                flexDirection: 'column',
                                gap: '1rem'
                            }}>
                                <Icon name="Clipboard" size={64} />
                                <div style={{ fontSize: '1.5rem', fontWeight: 'bold' }}>No plays in this section</div>
                                <p>Go to Game Plan → Call Sheet to add plays to "{currentSection.label}"</p>
                            </div>
                        ) : selectedSection === 'opening_script' ? (
                            // Special grouped display for opening script
                            <>
                                {/* Group plays by script category */}
                                {(() => {
                                    // Define opening script sections
                                    const scriptSections = [
                                        { id: 'base', label: '🎯 BASE PLAY', description: 'Your foundational play' },
                                        { id: 'formation', label: '🔄 FORMATION / MOTION / RULES', description: 'Formation adjustments and motion concepts' },
                                        { id: 'setup', label: '⚡ SETUP PLAYS', description: 'Complementary and setup plays' }
                                    ];

                                    // Categorize plays
                                    const categorizedPlays = {
                                        base: [],
                                        formation: [],
                                        setup: [],
                                        uncategorized: []
                                    };

                                    sectionPlays.forEach(play => {
                                        // Determine category based on play tags or index
                                        if (play.tags && play.tags.some(t => t.toLowerCase().includes('base'))) {
                                            categorizedPlays.base.push(play);
                                        } else if (play.tags && (
                                            play.tags.some(t => t.toLowerCase().includes('formation')) ||
                                            play.tags.some(t => t.toLowerCase().includes('motion')) ||
                                            play.tags.some(t => t.toLowerCase().includes('rule'))
                                        )) {
                                            categorizedPlays.formation.push(play);
                                        } else if (play.tags && play.tags.some(t => t.toLowerCase().includes('setup'))) {
                                            categorizedPlays.setup.push(play);
                                        } else {
                                            categorizedPlays.uncategorized.push(play);
                                        }
                                    });

                                    return (
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '2rem' }}>
                                            {scriptSections.map(section => {
                                                const sectionPlaysFiltered = categorizedPlays[section.id] || [];
                                                if (sectionPlaysFiltered.length === 0) return null;

                                                return (
                                                    <div key={section.id}>
                                                        <div style={{
                                                            marginBottom: '1rem',
                                                            paddingBottom: '0.5rem',
                                                            borderBottom: `3px solid ${currentSection.color} `
                                                        }}>
                                                            <h3 style={{ margin: 0, fontSize: '1.3rem', color: currentSection.color }}>{section.label}</h3>
                                                            <p style={{ margin: '0.25rem 0 0 0', fontSize: '0.85rem', color: 'var(--text-secondary)' }}>
                                                                {section.description}
                                                            </p>
                                                        </div>
                                                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '1.5rem' }}>
                                                            {sectionPlaysFiltered.map((play, idx) => (
                                                                <div
                                                                    key={play.id || idx}
                                                                    className="play-card"
                                                                    onClick={() => {
                                                                        if (isBuildingScript) addToScript(play);
                                                                        else if (setActivePlay) setActivePlay(play);
                                                                    }}
                                                                    style={{
                                                                        cursor: 'pointer',
                                                                        borderLeft: `4px solid ${currentSection.color} `,
                                                                        transition: 'all 0.2s',
                                                                        boxShadow: activePlay?.id === play.id ? '0 0 0 4px var(--accent)' : 'none',
                                                                        opacity: (activePlay && activePlay.id !== play.id) ? 0.7 : 1
                                                                    }}
                                                                    onMouseEnter={(e) => {
                                                                        e.currentTarget.style.transform = 'translateY(-4px)';
                                                                        if (activePlay?.id !== play.id) e.currentTarget.style.boxShadow = '0 8px 16px rgba(0,0,0,0.2)';
                                                                    }}
                                                                    onMouseLeave={(e) => {
                                                                        e.currentTarget.style.transform = 'translateY(0)';
                                                                        if (activePlay?.id !== play.id) e.currentTarget.style.boxShadow = '';
                                                                    }}
                                                                >
                                                                    <div style={{ padding: '1.5rem' }}>
                                                                        <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '0.5rem' }}>
                                                                            <div style={{ fontWeight: 'bold', fontSize: '1.3rem' }}>{getPlayDisplayName(play)}</div>
                                                                            {play.tempo && play.tempo !== 'REGULAR' && (
                                                                                <span style={{
                                                                                    fontSize: '0.75rem',
                                                                                    padding: '2px 6px',
                                                                                    borderRadius: '4px',
                                                                                    background: PLAY_PROTOCOLS.find(pp => pp.id === play.tempo)?.color || '#64748b',
                                                                                    color: 'white',
                                                                                    fontWeight: 'bold'
                                                                                }}>
                                                                                    {PLAY_PROTOCOLS.find(pp => pp.id === play.tempo)?.label || play.tempo}
                                                                                </span>
                                                                            )}
                                                                        </div>
                                                                        <div style={{ fontSize: '1rem', color: 'var(--text-secondary)', marginBottom: '1rem' }}>{play.formation}</div>
                                                                        {play.concept && <div style={{ fontSize: '0.9rem', marginBottom: '0.75rem' }}>Concept: {play.concept}</div>}
                                                                        {play.sequenceName && (
                                                                            <div style={{ marginTop: '0.5rem', marginBottom: '0.75rem', padding: '0.5rem', background: 'rgba(59, 130, 246, 0.1)', border: '1px solid #3b82f6', borderRadius: '4px' }}>
                                                                                <div style={{ fontSize: '0.8rem', fontWeight: 'bold', color: '#3b82f6', display: 'flex', alignItems: 'center', gap: '4px' }}>
                                                                                    <Icon name="Link" size={12} />
                                                                                    {play.sequenceName} #{play.sequenceOrder}
                                                                                </div>
                                                                                {(() => {
                                                                                    const nextPlay = plays.find(p => p.sequenceName === play.sequenceName && parseInt(p.sequenceOrder) === parseInt(play.sequenceOrder) + 1);
                                                                                    if (nextPlay) return (
                                                                                        <div style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                                                                            Next: <strong>{nextPlay.name}</strong>
                                                                                        </div>
                                                                                    );
                                                                                    return null;
                                                                                })()}
                                                                            </div>
                                                                        )}
                                                                        {play.mirrorPlay && (
                                                                            <div style={{
                                                                                fontSize: '0.85rem',
                                                                                color: 'var(--accent)',
                                                                                background: 'var(--surface)',
                                                                                padding: '0.5rem',
                                                                                borderRadius: '6px',
                                                                                marginTop: '0.75rem'
                                                                            }}>
                                                                                <Icon name="ArrowLeftRight" size={14} style={{ marginRight: '0.5rem' }} />
                                                                                Mirror: {play.mirrorPlay}
                                                                            </div>
                                                                        )}
                                                                        <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginTop: '1rem' }}>
                                                                            {play.hashPreference && (
                                                                                <span className="mini-tag" style={{ background: currentSection.color, color: 'white' }}>
                                                                                    {play.hashPreference}
                                                                                </span>
                                                                            )}
                                                                            {play.tags && play.tags.slice(0, 4).map(t => (
                                                                                <span key={t} className="mini-tag">{t}</span>
                                                                            ))}
                                                                        </div>
                                                                    </div>
                                                                </div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                );
                                            })}

                                            {/* Uncategorized plays */}
                                            {categorizedPlays.uncategorized.length > 0 && (
                                                <div>
                                                    <div style={{
                                                        marginBottom: '1rem',
                                                        paddingBottom: '0.5rem',
                                                        borderBottom: '3px solid var(--border)'
                                                    }}>
                                                        <h3 style={{ margin: 0, fontSize: '1.3rem', color: 'var(--text-secondary)' }}>📋 OTHER PLAYS</h3>
                                                        <p style={{ margin: '0.25rem 0 0 0', fontSize: '0.85rem', color: 'var(--text-secondary)' }}>
                                                            Add tags "base", "formation", "motion", or "setup" to organize these plays
                                                        </p>
                                                    </div>
                                                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '1.5rem' }}>
                                                        {categorizedPlays.uncategorized.map((play, idx) => (
                                                            <div
                                                                key={play.id || idx}
                                                                className="play-card"
                                                                onClick={() => isBuildingScript && addToScript(play)}
                                                                style={{
                                                                    cursor: 'pointer',
                                                                    borderLeft: `4px solid var(--border)`,
                                                                    transition: 'all 0.2s',
                                                                    opacity: 0.8
                                                                }}
                                                                onMouseEnter={(e) => {
                                                                    e.currentTarget.style.transform = 'translateY(-4px)';
                                                                    e.currentTarget.style.boxShadow = '0 8px 16px rgba(0,0,0,0.2)';
                                                                    e.currentTarget.style.opacity = '1';
                                                                }}
                                                                onMouseLeave={(e) => {
                                                                    e.currentTarget.style.transform = 'translateY(0)';
                                                                    e.currentTarget.style.boxShadow = '';
                                                                    e.currentTarget.style.opacity = '0.8';
                                                                }}
                                                            >
                                                                <div style={{ padding: '1.5rem' }}>
                                                                    <div style={{ fontWeight: 'bold', fontSize: '1.3rem', marginBottom: '0.5rem' }}>{play.name}</div>
                                                                    <div style={{ fontSize: '1rem', color: 'var(--text-secondary)', marginBottom: '1rem' }}>{play.formation}</div>
                                                                    {play.concept && <div style={{ fontSize: '0.9rem', marginBottom: '0.75rem' }}>Concept: {play.concept}</div>}
                                                                    {play.sequenceName && (
                                                                        <div style={{ marginTop: '0.5rem', marginBottom: '0.75rem', padding: '0.5rem', background: 'rgba(59, 130, 246, 0.1)', border: '1px solid #3b82f6', borderRadius: '4px' }}>
                                                                            <div style={{ fontSize: '0.8rem', fontWeight: 'bold', color: '#3b82f6', display: 'flex', alignItems: 'center', gap: '4px' }}>
                                                                                <Icon name="Link" size={12} />
                                                                                {play.sequenceName} #{play.sequenceOrder}
                                                                            </div>
                                                                            {(() => {
                                                                                const nextPlay = plays.find(p => p.sequenceName === play.sequenceName && parseInt(p.sequenceOrder) === parseInt(play.sequenceOrder) + 1);
                                                                                if (nextPlay) return (
                                                                                    <div style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                                                                        Next: <strong>{nextPlay.name}</strong>
                                                                                    </div>
                                                                                );
                                                                                return null;
                                                                            })()}
                                                                        </div>
                                                                    )}
                                                                    {play.mirrorPlay && (
                                                                        <div style={{
                                                                            fontSize: '0.85rem',
                                                                            color: 'var(--accent)',
                                                                            background: 'var(--surface)',
                                                                            padding: '0.5rem',
                                                                            borderRadius: '6px',
                                                                            marginTop: '0.75rem'
                                                                        }}>
                                                                            <Icon name="ArrowLeftRight" size={14} style={{ marginRight: '0.5rem' }} />
                                                                            Mirror: {play.mirrorPlay}
                                                                        </div>
                                                                    )}
                                                                    <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginTop: '1rem' }}>
                                                                        {play.hashPreference && (
                                                                            <span className="mini-tag" style={{ background: currentSection.color, color: 'white' }}>
                                                                                {play.hashPreference}
                                                                            </span>
                                                                        )}
                                                                        {play.tags && play.tags.slice(0, 4).map(t => (
                                                                            <span key={t} className="mini-tag">{t}</span>
                                                                        ))}
                                                                    </div>
                                                                </div>
                                                            </div>
                                                        ))}
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    );
                                })()}
                            </>
                        ) : ['fringe', 'high_red', 'low_red', 'goal_line'].includes(selectedSection) ? (
                            // Field zones with BASE / CONVERT / EXPLOSIVE matrix
                            <div style={{ overflowX: 'auto' }}>
                                <table style={{
                                    width: '100%',
                                    borderCollapse: 'separate',
                                    borderSpacing: '0.5rem',
                                    marginTop: '1rem'
                                }}>
                                    <thead>
                                        <tr>
                                            <th style={{
                                                background: 'var(--bg-panel)',
                                                padding: '1rem',
                                                borderRadius: '8px',
                                                textAlign: 'left',
                                                fontWeight: 'bold',
                                                color: 'var(--text-secondary)',
                                                minWidth: '120px'
                                            }}>DOWN</th>
                                            <th style={{
                                                background: '#10b981',
                                                color: 'white',
                                                padding: '1rem',
                                                borderRadius: '8px',
                                                textAlign: 'center',
                                                fontWeight: 'bold',
                                                minWidth: '250px'
                                            }}>BASE</th>
                                            <th style={{
                                                background: '#f59e0b',
                                                color: 'white',
                                                padding: '1rem',
                                                borderRadius: '8px',
                                                textAlign: 'center',
                                                fontWeight: 'bold',
                                                minWidth: '250px'
                                            }}>CONVERT</th>
                                            <th style={{
                                                background: '#ef4444',
                                                color: 'white',
                                                padding: '1rem',
                                                borderRadius: '8px',
                                                textAlign: 'center',
                                                fontWeight: 'bold',
                                                minWidth: '250px'
                                            }}>EXPLOSIVE</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {['1st', '2nd', '3rd', '4th'].map(down => (
                                            <tr key={down}>
                                                <td style={{
                                                    background: currentSection.color,
                                                    color: 'white',
                                                    padding: '1rem',
                                                    borderRadius: '8px',
                                                    fontWeight: 'bold',
                                                    fontSize: '1.1rem',
                                                    textAlign: 'center'
                                                }}>
                                                    {down}
                                                </td>
                                                {['base', 'convert', 'explosive'].map(category => {
                                                    const setId = `${selectedSection}_${down}_${category} `;
                                                    const cellPlays = (gamePlan?.sets || []).find(s => s.id === setId)?.playIds || [];
                                                    const cellPlayObjects = cellPlays.map(item => {
                                                        if (typeof item === 'string') {
                                                            const play = plays.find(p => p.id === item);
                                                            return play ? { ...play, type: 'play' } : null;
                                                        } else if (typeof item === 'object' && item.id) {
                                                            const play = plays.find(p => p.id === item.id);
                                                            return play ? { ...play, ...item, type: 'play' } : null;
                                                        }
                                                        return null;
                                                    }).filter(Boolean);

                                                    return (
                                                        <td key={category} style={{
                                                            background: 'var(--bg-panel)',
                                                            padding: '1rem',
                                                            borderRadius: '8px',
                                                            verticalAlign: 'top'
                                                        }}>
                                                            {cellPlayObjects.length > 0 ? (
                                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                                                    {cellPlayObjects.map(play => (
                                                                        <div
                                                                            key={play.id}
                                                                            style={{
                                                                                background: 'var(--bg-card)',
                                                                                padding: '0.75rem',
                                                                                borderRadius: '6px',
                                                                                cursor: 'pointer',
                                                                                border: '2px solid transparent',
                                                                                transition: 'all 0.2s',
                                                                                boxShadow: activePlay?.id === play.id ? '0 0 0 3px var(--accent)' : 'none',
                                                                                opacity: (activePlay && activePlay.id !== play.id) ? 0.7 : 1
                                                                            }}
                                                                            onClick={() => {
                                                                                if (isBuildingScript) addToScript(play);
                                                                                else if (setActivePlay) setActivePlay(play);
                                                                            }}
                                                                            onMouseEnter={(e) => {
                                                                                e.currentTarget.style.borderColor = currentSection.color;
                                                                                e.currentTarget.style.transform = 'translateY(-2px)';
                                                                            }}
                                                                            onMouseLeave={(e) => {
                                                                                e.currentTarget.style.borderColor = 'transparent';
                                                                                e.currentTarget.style.transform = 'translateY(0)';
                                                                            }}
                                                                        >
                                                                            <div style={{ fontWeight: 'bold', marginBottom: '0.25rem', color: 'var(--text-primary)', display: 'flex', alignItems: 'center', gap: '6px' }}>
                                                                                {play.priority && <Icon name="Star" size={14} fill="gold" color="gold" />}
                                                                                {getPlayDisplayName(play)} {play.wristbandSlot ? <span style={{ fontWeight: 'normal' }}>({play.wristbandSlot})</span> : ''} {play.staplesSlot ? <span style={{ fontWeight: 'normal', color: '#b45309', marginLeft: '4px' }}>[{play.staplesSlot}]</span> : ''}
                                                                                {play.tempo && play.tempo !== 'REGULAR' && (
                                                                                    <span style={{
                                                                                        fontSize: '0.65rem',
                                                                                        padding: '1px 4px',
                                                                                        borderRadius: '3px',
                                                                                        background: PLAY_PROTOCOLS.find(pp => pp.id === play.tempo)?.color || '#64748b',
                                                                                        color: 'white',
                                                                                        fontWeight: 'normal'
                                                                                    }}>
                                                                                        {PLAY_PROTOCOLS.find(pp => pp.id === play.tempo)?.code || play.tempo}
                                                                                    </span>
                                                                                )}
                                                                            </div>
                                                                            {play.formation && (
                                                                                <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>
                                                                                    {play.formation}
                                                                                </div>
                                                                            )}

                                                                            {/* Situation Assignment UI */}
                                                                            {(() => {
                                                                                const playSituations = getPlaySituations(play.id);
                                                                                const availableSituations = gamePlanSections.filter(section =>
                                                                                    !playSituations.some(ps => ps.id === section.key)
                                                                                );
                                                                                const showDropdown = situationDropdownPlayId === play.id;

                                                                                return (
                                                                                    <div
                                                                                        style={{
                                                                                            marginTop: '0.5rem',
                                                                                            display: 'flex',
                                                                                            flexWrap: 'wrap',
                                                                                            gap: '4px',
                                                                                            alignItems: 'center'
                                                                                        }}
                                                                                        onClick={(e) => e.stopPropagation()}
                                                                                    >
                                                                                        {/* Current situation tags */}
                                                                                        {playSituations.map(situation => (
                                                                                            <span
                                                                                                key={situation.id}
                                                                                                style={{
                                                                                                    display: 'inline-flex',
                                                                                                    alignItems: 'center',
                                                                                                    gap: '4px',
                                                                                                    padding: '2px 6px',
                                                                                                    borderRadius: '4px',
                                                                                                    fontSize: '0.7rem',
                                                                                                    fontWeight: '500',
                                                                                                    background: situation.color,
                                                                                                    color: 'white',
                                                                                                    cursor: 'default'
                                                                                                }}
                                                                                                onClick={(e) => e.stopPropagation()}
                                                                                            >
                                                                                                {situation.label}
                                                                                                <span
                                                                                                    style={{
                                                                                                        cursor: 'pointer',
                                                                                                        marginLeft: '2px',
                                                                                                        opacity: 0.8,
                                                                                                        fontWeight: 'bold'
                                                                                                    }}
                                                                                                    onClick={(e) => {
                                                                                                        e.stopPropagation();
                                                                                                        handleRemovePlayFromSet(situation.id, play.id);
                                                                                                    }}
                                                                                                    onMouseEnter={(e) => e.currentTarget.style.opacity = '1'}
                                                                                                    onMouseLeave={(e) => e.currentTarget.style.opacity = '0.8'}
                                                                                                >
                                                                                                    ×
                                                                                                </span>
                                                                                            </span>
                                                                                        ))}

                                                                                        {/* Add situation button */}
                                                                                        {availableSituations.length > 0 && (
                                                                                            <div style={{ position: 'relative' }} onClick={(e) => e.stopPropagation()}>
                                                                                                <button
                                                                                                    onClick={(e) => {
                                                                                                        e.stopPropagation();
                                                                                                        setSituationDropdownPlayId(showDropdown ? null : play.id);
                                                                                                    }}
                                                                                                    style={{
                                                                                                        padding: '2px 6px',
                                                                                                        fontSize: '0.7rem',
                                                                                                        background: 'var(--bg-panel)',
                                                                                                        border: '1px solid var(--border)',
                                                                                                        borderRadius: '4px',
                                                                                                        cursor: 'pointer',
                                                                                                        color: 'var(--text-secondary)',
                                                                                                        display: 'inline-flex',
                                                                                                        alignItems: 'center',
                                                                                                        gap: '2px'
                                                                                                    }}
                                                                                                    onMouseEnter={(e) => {
                                                                                                        e.currentTarget.style.background = 'var(--bg-card)';
                                                                                                        e.currentTarget.style.borderColor = 'var(--accent)';
                                                                                                    }}
                                                                                                    onMouseLeave={(e) => {
                                                                                                        e.currentTarget.style.background = 'var(--bg-panel)';
                                                                                                        e.currentTarget.style.borderColor = 'var(--border)';
                                                                                                    }}
                                                                                                >
                                                                                                    +
                                                                                                </button>

                                                                                                {/* Dropdown menu */}
                                                                                                {showDropdown && (
                                                                                                    <div
                                                                                                        style={{
                                                                                                            position: 'absolute',
                                                                                                            top: '100%',
                                                                                                            left: 0,
                                                                                                            marginTop: '4px',
                                                                                                            background: 'var(--bg-card)',
                                                                                                            border: '1px solid var(--border)',
                                                                                                            borderRadius: '6px',
                                                                                                            boxShadow: '0 4px 12px rgba(0,0,0,0.15)',
                                                                                                            zIndex: 1000,
                                                                                                            minWidth: '200px'
                                                                                                        }}
                                                                                                    >
                                                                                                        {availableSituations.map(situation => (
                                                                                                            <div
                                                                                                                key={situation.key}
                                                                                                                onClick={(e) => {
                                                                                                                    e.stopPropagation();
                                                                                                                    handleAddPlayToSet(situation.key, play.id);
                                                                                                                    setSituationDropdownPlayId(null);
                                                                                                                }}
                                                                                                                style={{
                                                                                                                    padding: '8px 12px',
                                                                                                                    cursor: 'pointer',
                                                                                                                    display: 'flex',
                                                                                                                    alignItems: 'center',
                                                                                                                    gap: '8px',
                                                                                                                    fontSize: '0.85rem',
                                                                                                                    borderBottom: '1px solid var(--border)'
                                                                                                                }}
                                                                                                                onMouseEnter={(e) => {
                                                                                                                    e.currentTarget.style.background = 'var(--bg-panel)';
                                                                                                                }}
                                                                                                                onMouseLeave={(e) => {
                                                                                                                    e.currentTarget.style.background = 'transparent';
                                                                                                                }}
                                                                                                            >
                                                                                                                <div
                                                                                                                    style={{
                                                                                                                        width: '12px',
                                                                                                                        height: '12px',
                                                                                                                        borderRadius: '3px',
                                                                                                                        background: situation.color
                                                                                                                    }}
                                                                                                                />
                                                                                                                {situation.label}
                                                                                                            </div>
                                                                                                        ))}
                                                                                                    </div>
                                                                                                )}
                                                                                            </div>
                                                                                        )}
                                                                                    </div>
                                                                                );
                                                                            })()}
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            ) : (
                                                                <div style={{
                                                                    color: 'var(--text-secondary)',
                                                                    fontSize: '0.85rem',
                                                                    fontStyle: 'italic',
                                                                    textAlign: 'center',
                                                                    padding: '1rem'
                                                                }}>
                                                                    No plays
                                                                </div>
                                                            )}

                                                            {/* Quick Add Input */}
                                                            {onQuickAddPlay && (
                                                                <div style={{ marginTop: '0.5rem' }}>
                                                                    <input
                                                                        type="text"
                                                                        placeholder="Add play..."
                                                                        style={{
                                                                            width: '100%',
                                                                            padding: '0.5rem',
                                                                            background: 'var(--bg-card)',
                                                                            border: '1px solid var(--border)',
                                                                            borderRadius: '4px',
                                                                            color: 'var(--text-primary)',
                                                                            fontSize: '0.85rem'
                                                                        }}
                                                                        onKeyDown={(e) => {
                                                                            if (e.key === 'Enter' && e.target.value.trim()) {
                                                                                handleQuickAddToSet(setId, e.target.value);
                                                                                e.target.value = '';
                                                                            }
                                                                        }}
                                                                    />
                                                                </div>
                                                            )}
                                                        </td>
                                                    );
                                                })}
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        ) : (
                            // Standard grid for other sections
                            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '1.5rem' }}>
                                {sectionPlays.map((play, idx) => (
                                    <div
                                        key={play.id || idx}
                                        className="play-card"
                                        onClick={() => {
                                            if (isBuildingScript) addToScript(play);
                                            else if (setActivePlay) setActivePlay(play);
                                        }}
                                        style={{
                                            cursor: 'pointer',
                                            borderLeft: `4px solid ${currentSection.color} `,
                                            transition: 'all 0.2s',
                                            boxShadow: activePlay?.id === play.id ? '0 0 0 4px var(--accent)' : 'none',
                                            opacity: (activePlay && activePlay.id !== play.id) ? 0.7 : 1
                                        }}
                                        onMouseEnter={(e) => {
                                            e.currentTarget.style.transform = 'translateY(-4px)';
                                            if (activePlay?.id !== play.id) e.currentTarget.style.boxShadow = '0 8px 16px rgba(0,0,0,0.2)';
                                        }}
                                        onMouseLeave={(e) => {
                                            e.currentTarget.style.transform = 'translateY(0)';
                                            if (activePlay?.id !== play.id) e.currentTarget.style.boxShadow = '';
                                        }}
                                    >
                                        <div style={{ padding: '1.5rem' }}>
                                            <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '0.5rem' }}>
                                                <div style={{ fontWeight: 'bold', fontSize: '1.3rem' }}>{getPlayDisplayName(play)}</div>
                                                {play.tempo && play.tempo !== 'REGULAR' && (
                                                    <span style={{
                                                        fontSize: '0.75rem',
                                                        padding: '2px 6px',
                                                        borderRadius: '4px',
                                                        background: PLAY_PROTOCOLS.find(pp => pp.id === play.tempo)?.color || '#64748b',
                                                        color: 'white',
                                                        fontWeight: 'bold'
                                                    }}>
                                                        {PLAY_PROTOCOLS.find(pp => pp.id === play.tempo)?.label || play.tempo}
                                                    </span>
                                                )}
                                            </div>
                                            <div style={{ fontSize: '1rem', color: 'var(--text-secondary)', marginBottom: '1rem' }}>{play.formation}</div>
                                            {play.concept && <div style={{ fontSize: '0.9rem', marginBottom: '0.75rem' }}>Concept: {play.concept}</div>}
                                            {play.sequenceName && (
                                                <div style={{ marginTop: '0.5rem', marginBottom: '0.75rem', padding: '0.5rem', background: 'rgba(59, 130, 246, 0.1)', border: '1px solid #3b82f6', borderRadius: '4px' }}>
                                                    <div style={{ fontSize: '0.8rem', fontWeight: 'bold', color: '#3b82f6', display: 'flex', alignItems: 'center', gap: '4px' }}>
                                                        <Icon name="Link" size={12} />
                                                        {play.sequenceName} #{play.sequenceOrder}
                                                    </div>
                                                    {(() => {
                                                        const nextPlay = plays.find(p => p.sequenceName === play.sequenceName && parseInt(p.sequenceOrder) === parseInt(play.sequenceOrder) + 1);
                                                        if (nextPlay) return (
                                                            <div style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', marginTop: '2px' }}>
                                                                Next: <strong>{nextPlay.name}</strong>
                                                            </div>
                                                        );
                                                        return null;
                                                    })()}
                                                </div>
                                            )}
                                            {play.mirrorPlay && (
                                                <div style={{
                                                    fontSize: '0.85rem',
                                                    color: 'var(--accent)',
                                                    background: 'var(--surface)',
                                                    padding: '0.5rem',
                                                    borderRadius: '6px',
                                                    marginTop: '0.75rem'
                                                }}>
                                                    <Icon name="ArrowLeftRight" size={14} style={{ marginRight: '0.5rem' }} />
                                                    Mirror: {play.mirrorPlay}
                                                </div>
                                            )}
                                            <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginTop: '1rem' }}>
                                                {play.hashPreference && (
                                                    <span className="mini-tag" style={{ background: currentSection.color, color: 'white' }}>
                                                        {play.hashPreference}
                                                    </span>
                                                )}
                                                {play.tag1 && (
                                                    <span className="mini-tag">
                                                        {(TAG_CATEGORIES["Motion"] || []).includes(play.tag1) ? `"${play.tag1}"` : play.tag1}
                                                    </span>
                                                )}
                                                {play.tag2 && <span className="mini-tag">({play.tag2})</span>}
                                                {play.tags && play.tags.slice(0, 4).map(t => {
                                                    if (t === play.tag1 || t === play.tag2) return null;
                                                    const isMotion = (TAG_CATEGORIES["Motion"] || []).includes(t);
                                                    return <span key={t} className="mini-tag">{isMotion ? `"${t}"` : t}</span>
                                                })}
                                            </div>

                                            {/* Situation Assignment UI */}
                                            {(() => {
                                                const playSituations = getPlaySituations(play.id);
                                                const showDropdown = situationDropdownPlayId === play.id;

                                                // Get available situations (not already assigned)
                                                const availableSituations = gamePlanSections.filter(s =>
                                                    s.key && !s.type && !playSituations.some(ps => ps.id === s.key)
                                                );

                                                return (
                                                    <div style={{ marginTop: '1rem', paddingTop: '1rem', borderTop: '1px solid var(--border)' }}>
                                                        <div style={{ fontSize: '0.75rem', fontWeight: 'bold', color: 'var(--text-secondary)', marginBottom: '0.5rem' }}>
                                                            SITUATIONS
                                                        </div>
                                                        <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', alignItems: 'center' }}>
                                                            {/* Current situation tags */}
                                                            {playSituations.map(situation => (
                                                                <span
                                                                    key={situation.id}
                                                                    style={{
                                                                        display: 'inline-flex',
                                                                        alignItems: 'center',
                                                                        gap: '4px',
                                                                        padding: '4px 8px',
                                                                        borderRadius: '4px',
                                                                        fontSize: '0.7rem',
                                                                        fontWeight: 'bold',
                                                                        background: situation.color,
                                                                        color: 'white',
                                                                        cursor: 'default'
                                                                    }}
                                                                    onClick={(e) => e.stopPropagation()}
                                                                >
                                                                    {situation.label}
                                                                    <span
                                                                        style={{
                                                                            cursor: 'pointer',
                                                                            marginLeft: '2px',
                                                                            opacity: 0.8,
                                                                            fontWeight: 'bold'
                                                                        }}
                                                                        onClick={(e) => {
                                                                            e.stopPropagation();
                                                                            handleRemovePlayFromSet(situation.id, play.id);
                                                                        }}
                                                                        onMouseEnter={(e) => e.currentTarget.style.opacity = '1'}
                                                                        onMouseLeave={(e) => e.currentTarget.style.opacity = '0.8'}
                                                                    >
                                                                        ×
                                                                    </span>
                                                                </span>
                                                            ))}

                                                            {/* Add situation button */}
                                                            {availableSituations.length > 0 && (
                                                                <div style={{ position: 'relative' }} onClick={(e) => e.stopPropagation()}>
                                                                    <button
                                                                        onClick={(e) => {
                                                                            e.stopPropagation();
                                                                            setSituationDropdownPlayId(showDropdown ? null : play.id);
                                                                        }}
                                                                        style={{
                                                                            padding: '4px 8px',
                                                                            borderRadius: '4px',
                                                                            border: '1px dashed var(--border)',
                                                                            background: 'var(--bg-card)',
                                                                            color: 'var(--text-secondary)',
                                                                            fontSize: '0.7rem',
                                                                            fontWeight: 'bold',
                                                                            cursor: 'pointer',
                                                                            transition: 'all 0.2s'
                                                                        }}
                                                                        onMouseEnter={(e) => {
                                                                            e.currentTarget.style.borderColor = 'var(--primary)';
                                                                            e.currentTarget.style.color = 'var(--primary)';
                                                                        }}
                                                                        onMouseLeave={(e) => {
                                                                            e.currentTarget.style.borderColor = 'var(--border)';
                                                                            e.currentTarget.style.color = 'var(--text-secondary)';
                                                                        }}
                                                                    >
                                                                        + ADD
                                                                    </button>

                                                                    {/* Dropdown menu */}
                                                                    {showDropdown && (
                                                                        <div
                                                                            style={{
                                                                                position: 'absolute',
                                                                                top: '100%',
                                                                                left: 0,
                                                                                marginTop: '4px',
                                                                                background: 'white',
                                                                                border: '1px solid var(--border)',
                                                                                borderRadius: '6px',
                                                                                boxShadow: '0 4px 12px rgba(0,0,0,0.15)',
                                                                                zIndex: 1000,
                                                                                maxHeight: '300px',
                                                                                overflowY: 'auto',
                                                                                minWidth: '200px'
                                                                            }}
                                                                        >
                                                                            {availableSituations.map(situation => (
                                                                                <div
                                                                                    key={situation.key}
                                                                                    onClick={(e) => {
                                                                                        e.stopPropagation();
                                                                                        handleAddPlayToSet(situation.key, play.id);
                                                                                        setSituationDropdownPlayId(null);
                                                                                    }}
                                                                                    style={{
                                                                                        padding: '8px 12px',
                                                                                        cursor: 'pointer',
                                                                                        fontSize: '0.85rem',
                                                                                        display: 'flex',
                                                                                        alignItems: 'center',
                                                                                        gap: '8px',
                                                                                        transition: 'background 0.15s'
                                                                                    }}
                                                                                    onMouseEnter={(e) => e.currentTarget.style.background = 'var(--bg-panel)'}
                                                                                    onMouseLeave={(e) => e.currentTarget.style.background = 'transparent'}
                                                                                >
                                                                                    <div
                                                                                        style={{
                                                                                            width: '12px',
                                                                                            height: '12px',
                                                                                            borderRadius: '2px',
                                                                                            background: situation.color
                                                                                        }}
                                                                                    />
                                                                                    {situation.label}
                                                                                </div>
                                                                            ))}
                                                                        </div>
                                                                    )}
                                                                </div>
                                                            )}

                                                            {playSituations.length === 0 && availableSituations.length === 0 && (
                                                                <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', fontStyle: 'italic' }}>
                                                                    No situations available
                                                                </span>
                                                            )}
                                                        </div>
                                                    </div>
                                                );
                                            })()}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            );
        };


        // REMOVED: PlayerMetrics and ImpactRatings (~481 lines) - check git history

        const CollapsibleCategory = ({ title, icon, children, defaultOpen = false, nested = false, onTitleClick }) => {
            const [isOpen, setIsOpen] = useState(defaultOpen);

            const handleClick = () => {
                if (onTitleClick) {
                    onTitleClick();
                }
                setIsOpen(!isOpen);
            };

            return (
                <div style={{ marginBottom: '0.5rem' }}>
                    <div
                        onClick={handleClick}
                        style={{
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'space-between',
                            padding: nested ? '0.5rem 0.5rem 0.5rem 2rem' : '0.75rem 0.5rem',
                            cursor: 'pointer',
                            color: 'var(--text-secondary)',
                            fontWeight: nested ? '500' : 'bold',
                            fontSize: '0.9rem',
                            borderRadius: '6px',
                            transition: 'background 0.2s',
                            userSelect: 'none'
                        }}
                        className="nav-category-header"
                        onMouseEnter={e => e.currentTarget.style.background = 'rgba(255,255,255,0.05)'}
                        onMouseLeave={e => e.currentTarget.style.background = 'transparent'}
                    >
                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                            {icon && <Icon name={icon} size={nested ? 16 : 18} />}
                            <span style={{
                                textTransform: nested ? 'none' : 'uppercase',
                                letterSpacing: nested ? 'normal' : '0.05em',
                                fontSize: nested ? '0.9rem' : '0.8rem'
                            }}>{title}</span>
                        </div>
                        <span style={{ fontSize: '0.8rem' }}>
                            <Icon name={isOpen ? "ChevronDown" : "ChevronRight"} />
                        </span>
                    </div>
                    {isOpen && (
                        <div key={isOpen} style={{ paddingLeft: '0.5rem', display: 'flex', flexDirection: 'column', gap: '0.25rem' }}>
                            {children}
                        </div>
                    )}
                </div>
            );
        };

        const useLocalStorage = (key, initialValue) => {
            const [storedValue, setStoredValue] = useState(() => {
                try {
                    const item = window.localStorage.getItem(key);
                    return item ? JSON.parse(item) : initialValue;
                } catch (error) {
                    console.error(error);
                    return initialValue;
                }
            });

            const setValue = React.useCallback((value) => {
                try {
                    const valueToStore = value instanceof Function ? value(storedValue) : value;
                    setStoredValue(valueToStore);
                    window.localStorage.setItem(key, JSON.stringify(valueToStore));
                } catch (error) {
                    console.error(error);
                }
            }, [key, storedValue]);

            return [storedValue, setValue];
        };


        const INITIAL_DRILL_DATA = [
            // OFFENSE
            { id: 'off_1', title: 'QB Drops & Footwork', type: 'offense', category: 'QB', videoUrl: 'https://www.youtube.com/embed/dQw4w9WgXcQ', description: 'Focus on 3-step, 5-step, and rollout mechanics. Maintain eye level.' },
            { id: 'off_2', title: 'RB Ball Security Gauntlet', type: 'offense', category: 'RB', videoUrl: '', description: 'High and tight. Rip attempts by defenders. Finish through the line.' },
            { id: 'off_3', title: 'WR Stalk Blocking', type: 'offense', category: 'WR', videoUrl: '', description: 'Break down in space. Mirror the defender. Hands inside.' },
            { id: 'off_4', title: 'OL Combo Blocks', type: 'offense', category: 'OL', videoUrl: '', description: 'Hip to hip. Overtake technique. Communication is key.' },
            { id: 'off_5', title: 'Route Tree Precision', type: 'offense', category: 'WR', videoUrl: '', description: 'Sharp cuts at correct depths. Speed out, Post, Dig, Comeback.' },
            { id: 'off_6', title: 'Mesh Point Drill', type: 'offense', category: 'QB', videoUrl: '', description: 'QB/RB exchange work. Read key defenders for RPO actions.' },

            // DEFENSE
            { id: 'def_1', title: 'Tackling: Profile & Drive', type: 'defense', category: 'LB', videoUrl: '', description: 'Heads up tackling. Near foot, near shoulder. Drive for 5.' },
            { id: 'def_2', title: 'DB Backpedal & Break', type: 'defense', category: 'DB', videoUrl: '', description: 'Smooth pedal. Low hips. Explode out of the break on receiver visual.' },
            { id: 'def_3', title: 'DL Get Off', type: 'defense', category: 'DL', videoUrl: '', description: 'React to ball movement. Low pad level. Hand violence.' },
            { id: 'def_4', title: 'Shed & Scrape', type: 'defense', category: 'LB', videoUrl: '', description: 'Disengage blocks. Lateral movement to gap. Flow to the ball.' },
            { id: 'def_5', title: 'Open Field Tackle', type: 'defense', category: 'DB', videoUrl: '', description: 'Closing space. Coming to balance. Angle preservation.' },

            // SPECIAL / CIRCUIT / GROUP
            { id: 'spec_1', title: 'Gunner Release', type: 'special', category: 'Punt', videoUrl: '', description: 'Beating the jam. Stack and restack. Speed to the ball.' },
            { id: 'grp_1', title: 'Inside Run (9-on-7)', type: 'group', category: 'Run', videoUrl: '', description: 'Physical run game work. Focus on double teams and LB fills.' },
            { id: 'circ_1', title: 'Agility Station', type: 'circuit', category: 'Agility', videoUrl: '', description: 'Cone drills. Pro agility. L-Drill. Ladder work.' },
            { id: 'circ_2', title: 'Turnover Circuit', type: 'circuit', category: 'Ball', videoUrl: '', description: 'Must have ball drills. Strip sacks. Interceptions. Fumble recovery.' },
            { id: 'grp_2', title: '7-on-7 Pass Skelly', type: 'group', category: 'Pass', videoUrl: '', description: 'Passing concepts vs coverage. No pass rush. Timing focus.' },
        ];

        const DrillLibraryView = ({ phase = 'OFFENSE', drills = [], onAddDrill }) => {
            const [selectedDrill, setSelectedDrill] = useState(null);
            const [activeFilter, setActiveFilter] = useState('ALL');
            const [showAddModal, setShowAddModal] = useState(false);
            const [newDrill, setNewDrill] = useState({ title: '', category: '', videoUrl: '', description: '' });

            const isOffense = phase === 'OFFENSE';
            const isDefense = phase === 'DEFENSE';
            const isST = phase === 'SPECIAL_TEAMS';

            const filters = isOffense
                ? ['ALL', 'QB', 'RB', 'WR', 'OL', 'TE']
                : isDefense
                    ? ['ALL', 'DL', 'LB', 'DB']
                    : ['ALL', 'K', 'P', 'R', 'COV'];

            const categoryOptions = filters.filter(f => f !== 'ALL');

            const saveNewDrill = () => {
                if (!newDrill.title || !newDrill.category) return alert('Title and Category are required');

                const drill = {
                    title: newDrill.title,
                    category: newDrill.category,
                    videoUrl: newDrill.videoUrl,
                    description: newDrill.description,
                    type: isOffense ? 'offense' : isDefense ? 'defense' : 'special' // Simplified for now
                };

                onAddDrill(drill);
                setShowAddModal(false);
                setNewDrill({ title: '', category: '', videoUrl: '', description: '' });
            };

            const filterDrills = (type, categoryFilter) => {
                return drills.filter(d => d.type === type && (categoryFilter === 'ALL' || d.category === categoryFilter));
            };

            const renderDrillList = (drills, title) => (
                <div style={{ background: 'rgba(255,255,255,0.02)', borderRadius: '8px', padding: '1rem', height: '100%' }}>
                    <h3 style={{ borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem', marginBottom: '1rem', color: 'var(--text-secondary)', fontSize: '1rem', textTransform: 'uppercase', letterSpacing: '0.05em' }}>
                        {title}
                    </h3>
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                        {drills.length === 0 && <div style={{ color: 'var(--text-secondary)', fontStyle: 'italic', fontSize: '0.9rem' }}>No drills found.</div>}
                        {drills.map(drill => (
                            <div
                                key={drill.id}
                                onClick={() => setSelectedDrill(drill)}
                                className="drill-card"
                                style={{
                                    padding: '0.75rem',
                                    background: 'rgba(255,255,255,0.05)',
                                    borderRadius: '6px',
                                    cursor: 'pointer',
                                    transition: 'all 0.2s',
                                    border: '1px solid transparent'
                                }}
                                onMouseEnter={e => {
                                    e.currentTarget.style.background = 'rgba(255,255,255,0.1)';
                                    e.currentTarget.style.transform = 'translateX(4px)';
                                }}
                                onMouseLeave={e => {
                                    e.currentTarget.style.background = 'rgba(255,255,255,0.05)';
                                    e.currentTarget.style.transform = 'translateX(0)';
                                }}
                            >
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.25rem' }}>
                                    <span style={{ fontWeight: '600', color: 'var(--text-primary)' }}>{drill.title}</span>
                                    <span style={{ fontSize: '0.7rem', background: 'var(--accent)', color: 'white', padding: '2px 6px', borderRadius: '4px' }}>{drill.category}</span>
                                </div>
                                <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                                    {drill.description}
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            );

            return (
                <div className="animate-fade-in" style={{ padding: '2rem', height: '100%', display: 'flex', flexDirection: 'column', gap: '2rem', overflowY: 'auto' }}>

                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                        <h1 style={{ fontSize: '2rem' }}>
                            {isOffense ? 'Offensive' : isDefense ? 'Defensive' : 'Special Teams'} <span style={{ color: 'var(--accent)' }}>Drill Library</span>
                        </h1>
                        <button className="btn btn-primary" onClick={() => setShowAddModal(true)} style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                            <Icon name="Plus" size={16} /> Add Drill
                        </button>
                        <div style={{ display: 'flex', gap: '0.5rem' }}>
                            {filters.map(cat => (
                                <button
                                    key={cat}
                                    onClick={() => setActiveFilter(cat)}
                                    style={{
                                        padding: '6px 12px',
                                        fontSize: '0.85rem',
                                        borderRadius: '6px',
                                        border: 'none',
                                        background: activeFilter === cat ? 'var(--accent)' : 'rgba(255,255,255,0.1)',
                                        color: activeFilter === cat ? 'white' : 'var(--text-secondary)',
                                        cursor: 'pointer'
                                    }}
                                >
                                    {cat}
                                </button>
                            ))}
                        </div>
                    </div>

                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', gap: '1.5rem' }}>
                        {isOffense && renderDrillList(filterDrills('offense', activeFilter), 'Position Drills')}
                        {isDefense && renderDrillList(filterDrills('defense', activeFilter), 'Position Drills')}
                        {isST && renderDrillList(filterDrills('special', activeFilter), 'Special Teams Drills')}

                        {/* Shared Drills potentially, or just keep them in a separate view? 
                            For now, let's include Group and Circuit if 'ALL' or specific categories align, 
                            or just append them at the bottom if requested.
                            Let's just show standard drills for now based on the refactor. 
                        */}
                    </div>

                    {(isOffense || isDefense) && (
                        <div style={{ marginTop: '2rem' }}>
                            <h2 style={{ fontSize: '1.25rem', marginBottom: '1rem', borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem', opacity: 0.8 }}>Team & Circuits</h2>
                            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', gap: '1.5rem' }}>
                                {renderDrillList(filterDrills('group', 'ALL'), 'Group / Team')}
                                {renderDrillList(filterDrills('circuit', 'ALL'), 'Circuits')}
                            </div>
                        </div>
                    )}


                    {/* VIDEO MODAL */}
                    {selectedDrill && (
                        <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.85)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000, backdropFilter: 'blur(5px)' }} onClick={() => setSelectedDrill(null)}>
                            <div style={{ width: '800px', maxWidth: '90%', background: '#1e1e1e', borderRadius: '12px', padding: '0', overflow: 'hidden', boxShadow: '0 20px 50px rgba(0,0,0,0.5)', border: '1px solid var(--border)' }} onClick={e => e.stopPropagation()}>
                                <div style={{ padding: '1.5rem', borderBottom: '1px solid var(--border)', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                    <h2 style={{ margin: 0, fontSize: '1.5rem' }}>{selectedDrill.title}</h2>
                                    <button onClick={() => setSelectedDrill(null)} style={{ background: 'none', border: 'none', color: 'var(--text-secondary)', fontSize: '1.5rem', cursor: 'pointer' }}>&times;</button>
                                </div>

                                <div style={{ padding: '2rem', display: 'flex', flexDirection: 'column', gap: '1.5rem' }}>
                                    <div style={{ width: '100%', aspectRatio: '16/9', background: 'black', display: 'flex', alignItems: 'center', justifyContent: 'center', borderRadius: '8px', overflow: 'hidden' }}>
                                        {selectedDrill.videoUrl ? (
                                            <iframe width="100%" height="100%" src={selectedDrill.videoUrl} frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen></iframe>
                                        ) : (
                                            <div style={{ textAlign: 'center', color: 'var(--text-secondary)' }}>
                                                <Icon name="Monitor" size={48} style={{ marginBottom: '1rem', opacity: 0.5 }} />
                                                <p>No video available for this drill.</p>
                                            </div>
                                        )}
                                    </div>

                                    <div>
                                        <h4 style={{ color: 'var(--accent)', marginBottom: '0.5rem', textTransform: 'uppercase', fontSize: '0.85rem' }}>Description / Key Coaching Points</h4>
                                        <p style={{ lineHeight: '1.6', color: 'var(--text-secondary)' }}>{selectedDrill.description}</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* ADD DRILL MODAL */}
                    {showAddModal && (
                        <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.85)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000, backdropFilter: 'blur(5px)' }}>
                            <div style={{ width: '500px', maxWidth: '90%', background: '#1e1e1e', borderRadius: '12px', padding: '1.5rem', boxShadow: '0 20px 50px rgba(0,0,0,0.5)', border: '1px solid var(--border)' }}>
                                <h2 style={{ marginBottom: '1.5rem' }}>Add New Drill</h2>
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                                    <div>
                                        <label className="form-label">Drill Title</label>
                                        <input className="form-input" value={newDrill.title} onChange={e => setNewDrill({ ...newDrill, title: e.target.value })} placeholder="e.g. QB Footwork" />
                                    </div>
                                    <div>
                                        <label className="form-label">Category</label>
                                        <select className="form-input" value={newDrill.category} onChange={e => setNewDrill({ ...newDrill, category: e.target.value })}>
                                            <option value="">Select Category...</option>
                                            {categoryOptions.map(c => <option key={c} value={c}>{c}</option>)}
                                        </select>
                                    </div>
                                    <div>
                                        <label className="form-label">Video URL (YouTube/Vimeo)</label>
                                        <input className="form-input" value={newDrill.videoUrl} onChange={e => setNewDrill({ ...newDrill, videoUrl: e.target.value })} placeholder="https://..." />
                                    </div>
                                    <div>
                                        <label className="form-label">Description / Key Points</label>
                                        <textarea className="form-input" rows={3} value={newDrill.description} onChange={e => setNewDrill({ ...newDrill, description: e.target.value })} placeholder="Coaching points..." />
                                    </div>
                                    <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '1rem', marginTop: '1rem' }}>
                                        <button className="btn btn-secondary" onClick={() => setShowAddModal(false)}>Cancel</button>
                                        <button className="btn btn-primary" onClick={saveNewDrill}>Save Drill</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                </div>
            );
        };







        // Master Playbook View Component
        const MasterPlaybookView = ({ plays, onUpdatePlay, onDeletePlay, onQuickAddPlay, playSyntax = [], week, onUpdateWeek }) => {
            const renderPlayThumbnail = (play, type = 'standard') => {
                if (!play) return null;

                let data = null;
                if (type === 'skill' && (play.wizSkillData || play.rooskiSkillData)) {
                    data = { elements: play.wizSkillData || play.rooskiSkillData };
                } else if (type === 'oline' && (play.wizOlineData || play.rooskiOlineData)) {
                    data = { elements: play.wizOlineData || play.rooskiOlineData };
                } else if (play.diagramData) {
                    data = play.diagramData;
                }

                if (!data || !data.elements || data.elements.length === 0) return null;

                return (
                    <svg viewBox="0 0 900 600" width="100%" height="100%" style={{ display: 'block' }} preserveAspectRatio="xMidYMid meet">
                        <g opacity="0.1">
                            <line x1="0" y1="10%" x2="100%" y2="10%" stroke="#000" strokeWidth="2" />
                            <line x1="0" y1="30%" x2="100%" y2="30%" stroke="#000" strokeWidth="2" />
                            <line x1="0" y1="50%" x2="100%" y2="50%" stroke="#000" strokeWidth="4" />
                            <line x1="0" y1="70%" x2="100%" y2="70%" stroke="#000" strokeWidth="2" />
                            <line x1="0" y1="90%" x2="100%" y2="90%" stroke="#000" strokeWidth="2" />
                        </g >
                        {
                            data.elements && data.elements.map(el => {
                                if (el.type === 'player') {
                                    const { x, y } = el.points[0];
                                    const size = 30;
                                    const isRect = el.shape === 'square';
                                    return (
                                        <g key={el.id}>
                                            {isRect ? (
                                                <rect x={x - size / 2} y={y - size / 2} width={size} height={size} fill="white" stroke={el.color} strokeWidth="2" />
                                            ) : (
                                                <circle cx={x} cy={y} r={size / 2} fill="white" stroke={el.color} strokeWidth="2" />
                                            )}
                                            <text x={x} y={y} dy="0.35em" textAnchor="middle" fontSize="16" fontWeight="bold" fill={el.color}>{el.label}</text>
                                        </g>
                                    );
                                }

                                let d = '';
                                if (el.style === 'zigzag') {
                                    d = getZigZagPath(el.points);
                                } else if (el.type === 'free' || el.points.length > 1) {
                                    d = `M ${el.points.map(p => `${p.x},${p.y}`).join(' L ')}`;
                                }

                                let markerEnd = undefined;
                                let tBlock = null;

                                if (el.endType === 'arrow' || (!el.endType && el.type !== 'free')) {
                                    markerEnd = `url(#arrowhead-${el.color})`;
                                } else if (el.endType === 't') {
                                    const points = el.points;
                                    const end = points[points.length - 1];
                                    const prev = points[points.length - 2] || points[0];
                                    const dx = end.x - prev.x;
                                    const dy = end.y - prev.y;
                                    const len = Math.hypot(dx, dy) || 1;
                                    const perpX = (-dy / len) * 15;
                                    const perpY = (dx / len) * 15;
                                    tBlock = <line x1={end.x - perpX} y1={end.y - perpY} x2={end.x + perpX} y2={end.y + perpY} stroke={el.color} strokeWidth="4" />;
                                } else if (el.endType === 'dot') {
                                    const end = el.points[el.points.length - 1];
                                    tBlock = <circle cx={end.x} cy={end.y} r="6" fill={el.color} />;
                                }

                                return (
                                    <g key={el.id}>
                                        <path d={d} stroke={el.color} strokeWidth="4" fill="none" strokeDasharray={el.style === 'dashed' ? "10,5" : "none"} markerEnd={markerEnd} />
                                        {tBlock}
                                    </g>
                                );
                            })
                        }
                    </svg >
                );
            };

            const [searchTerm, setSearchTerm] = useState('');
            const [isBatchImportOpen, setIsBatchImportOpen] = useState(false);
            const [importData, setImportData] = useState('');
            const [parsedImport, setParsedImport] = useState([]);
            const [columnMapping, setColumnMapping] = useState({});

            // Batch Import Logic
            const handleParseImport = () => {
                if (!importData.trim()) return;
                const rows = importData.split('\n').filter(r => r.trim());
                if (rows.length === 0) return;

                const firstRow = rows[0];
                const delimiter = firstRow.includes('\t') ? '\t' : (firstRow.includes(',') ? ',' : ' ');

                const parsed = rows.map(row => {
                    return row.split(delimiter).map(cell => cell.trim());
                });

                setParsedImport(parsed);
                setColumnMapping({});
            };

            const handleBatchCreate = (addToInstall = false) => {
                const newPlays = parsedImport.map(row => {
                    let playNameParts = [];
                    let formation = '';
                    let type = '';

                    Object.entries(columnMapping).forEach(([colIdx, fieldId]) => {
                        const value = row[parseInt(colIdx)];
                        if (!value) return;

                        if (fieldId === 'name_override') {
                            playNameParts = [value];
                        } else if (fieldId === 'formation') {
                            formation = value;
                        } else if (fieldId === 'type') {
                            type = value;
                        } else {
                            const field = playSyntax.find(f => f.id === fieldId);
                            if (field) {
                                playNameParts.push(value);
                            }
                        }
                    });

                    const finalName = playNameParts.join(' ').trim() || row[0];
                    return { name: finalName, formation, type: type || '' };
                });

                newPlays.forEach(playData => {
                    const newPlay = onQuickAddPlay(playData.name);
                    if (newPlay && playData.formation) {
                        onUpdatePlay(newPlay.id, { formation: playData.formation, type: playData.type });
                    }
                    if (addToInstall && newPlay && week) {
                        const installList = week.installList || [];
                        if (!installList.includes(newPlay.id)) {
                            onUpdateWeek(week.id, 'installList', [...installList, newPlay.id]);
                        }
                    }
                });

                setIsBatchImportOpen(false);
                setParsedImport([]);
                setImportData('');
                setColumnMapping({});
            };

            const COLORS = ['#000000', '#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#a855f7', '#22c55e', '#eab308'];
            const PREVIEW_DEFS = (
                <svg style={{ display: 'none' }}>
                    <defs>
                        {COLORS.map(c => (
                            <marker key={c} id={`arrowhead-${c}`} markerWidth="6" markerHeight="4" refX="5" refY="2" orient="auto">
                                <polygon points="0 0, 6 2, 0 4" fill={c} />
                            </marker>
                        ))}
                    </defs>
                </svg>
            );

            // Real-time search filtering
            const filteredPlays = plays.filter(p => {
                if (!searchTerm) return true;
                const search = searchTerm.toLowerCase();
                return p.name.toLowerCase().includes(search) ||
                    (p.formation && p.formation.toLowerCase().includes(search));
            });

            const handleAddToInstall = (playId) => {
                if (!week) return;
                const installList = week.installList || [];
                if (!installList.includes(playId)) {
                    onUpdateWeek(week.id, 'installList', [...installList, playId]);
                }
            };

            return (
                <>
                    {PREVIEW_DEFS}
                    <div style={{ height: 'calc(100vh - 100px)', display: 'flex', flexDirection: 'column' }}>
                        <div style={{ padding: '1.5rem', borderBottom: '1px solid var(--border)', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <div>
                                <h1 style={{ margin: 0 }}>Master Playbook</h1>
                                <p style={{ margin: '0.5rem 0 0 0', opacity: 0.7 }}>Manage all plays in your offensive system</p>
                            </div>
                            <button
                                className="btn btn-primary"
                                onClick={() => setIsBatchImportOpen(true)}
                                style={{ display: 'flex', alignItems: 'center', gap: '8px' }}
                            >
                                <Icon name="Download" size={16} /> Batch Add Plays
                            </button>
                        </div>

                        <div style={{ padding: '1rem', borderBottom: '1px solid var(--border)' }}>
                            <input
                                type="text"
                                className="form-input"
                                placeholder="Search plays as you type..."
                                value={searchTerm}
                                onChange={e => setSearchTerm(e.target.value)}
                                style={{ width: '100%', maxWidth: '500px' }}
                            />
                            {searchTerm && (
                                <p style={{ margin: '0.5rem 0 0 0', fontSize: '0.85rem', color: 'var(--text-secondary)' }}>
                                    Showing {filteredPlays.length} of {plays.length} plays
                                </p>
                            )}
                        </div>

                        <div style={{ flex: 1, overflowY: 'auto', padding: '1rem' }}>
                            {filteredPlays.length === 0 && searchTerm && (
                                <div style={{ textAlign: 'center', padding: '3rem', color: 'var(--text-secondary)' }}>
                                    <p style={{ fontSize: '1.1rem', marginBottom: '0.5rem' }}>No plays found matching "{searchTerm}"</p>
                                    <p style={{ fontSize: '0.9rem' }}>Try a different search term or create a new play</p>
                                </div>
                            )}
                            {filteredPlays.length === 0 && !searchTerm && (
                                <div style={{ textAlign: 'center', padding: '3rem', color: 'var(--text-secondary)' }}>
                                    <p style={{ fontSize: '1.1rem' }}>No plays in your playbook yet</p>
                                    <p style={{ fontSize: '0.9rem' }}>Click "Batch Add Plays" to get started</p>
                                </div>
                            )}
                            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '1.5rem' }}>
                                {filteredPlays.map(play => (
                                    <div key={play.id} className="card" style={{ padding: '0', display: 'flex', flexDirection: 'column', overflow: 'hidden', height: '100%', border: '1px solid var(--border)', borderRadius: '8px', boxShadow: 'var(--shadow-sm)' }}>
                                        {/* Diagram Preview Area */}
                                        <div style={{
                                            width: '100%',
                                            height: '220px',
                                            background: '#ffffff',
                                            borderBottom: '1px solid var(--border)',
                                            position: 'relative'
                                        }}>
                                            {renderPlayThumbnail(play, 'skill') || (
                                                <div style={{ width: '100%', height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', flexDirection: 'column', gap: '0.5rem', opacity: 0.3 }}>
                                                    <Icon name="Image" size={32} />
                                                    <span style={{ fontSize: '0.9rem', fontWeight: '500' }}>No Diagram</span>
                                                </div>
                                            )}
                                            {/* Priority Star Overlay */}
                                            {play.priority && (
                                                <div style={{ position: 'absolute', top: '10px', right: '10px', background: 'white', borderRadius: '50%', padding: '4px', boxShadow: '0 2px 4px rgba(0,0,0,0.1)' }}>
                                                    <Icon name="Star" size={16} style={{ fill: '#eab308', color: '#eab308' }} />
                                                </div>
                                            )}
                                        </div>

                                        {/* Card Content */}
                                        <div style={{ padding: '1rem', flex: 1, display: 'flex', flexDirection: 'column' }}>
                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '0.5rem' }}>
                                                <h3 style={{ margin: 0, fontSize: '1.1rem', fontWeight: '700', lineHeight: '1.3' }}>{getPlayDisplayName(play)}</h3>
                                                {play.type && (
                                                    <span style={{ fontSize: '0.75rem', fontWeight: 'bold', background: 'var(--bg-main)', padding: '2px 6px', borderRadius: '4px', border: '1px solid var(--border)', marginLeft: '0.5rem', whiteSpace: 'nowrap' }}>
                                                        {play.type}
                                                    </span>
                                                )}
                                            </div>

                                            <div style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginBottom: '1rem' }}>
                                                {play.formation || <span style={{ opacity: 0.5 }}>No formation</span>}
                                            </div>

                                            <div style={{ marginTop: 'auto', display: 'flex', justifyContent: 'space-between', alignItems: 'center', borderTop: '1px solid var(--border)', paddingTop: '0.75rem' }}>
                                                <div style={{ display: 'flex', gap: '0.5rem' }}>
                                                    {week && (
                                                        <button
                                                            className="btn btn-secondary"
                                                            style={{ padding: '0.4rem 0.8rem', fontSize: '0.85rem' }}
                                                            onClick={() => handleAddToInstall(play.id)}
                                                        >
                                                            <Icon name="Plus" size={14} /> Add to Install
                                                        </button>
                                                    )}
                                                    <button
                                                        className="btn-ghost"
                                                        style={{ padding: '0.4rem', color: '#ef4444' }}
                                                        onClick={() => onDeletePlay && onDeletePlay(play.id)}
                                                    >
                                                        <Icon name="Trash2" size={16} />
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>

                    {/* Batch Import Modal */}
                    {isBatchImportOpen && (
                        <div style={{ position: 'fixed', top: 0, left: 0, width: '100vw', height: '100vh', background: 'rgba(0,0,0,0.5)', zIndex: 1000, display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
                            <div style={{ background: 'white', borderRadius: '8px', width: '800px', maxWidth: '95vw', maxHeight: '90vh', display: 'flex', flexDirection: 'column', padding: '1.5rem', boxShadow: '0 4px 12px rgba(0,0,0,0.2)' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                    <h2>Batch Add Plays</h2>
                                    <button className="btn-ghost" onClick={() => { setIsBatchImportOpen(false); setParsedImport([]); setImportData(''); }}>
                                        <Icon name="X" />
                                    </button>
                                </div>

                                {!parsedImport.length ? (
                                    <div style={{ flex: 1, display: 'flex', flexDirection: 'column' }}>
                                        <p style={{ marginBottom: '1rem', color: '#666' }}>Paste your spreadsheet data below. We'll automatically detect columns (Name, Formation, etc.).</p>
                                        <textarea
                                            className="form-input"
                                            style={{ flex: 1, minHeight: '300px', fontFamily: 'monospace', fontSize: '0.9rem' }}
                                            placeholder={`Name\tFormation\tType\nPower Right\tI-Right\tRun\nSpider 2 Y Banana\tSingleback\tPass`}
                                            value={importData}
                                            onChange={e => setImportData(e.target.value)}
                                        />
                                        <div style={{ marginTop: '1rem', display: 'flex', justifyContent: 'flex-end', gap: '1rem' }}>
                                            <button className="btn btn-secondary" onClick={() => setIsBatchImportOpen(false)}>Cancel</button>
                                            <button className="btn btn-primary" disabled={!importData.trim()} onClick={handleParseImport}>
                                                Parse Data
                                            </button>
                                        </div>
                                    </div>
                                ) : (
                                    <div style={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
                                        <div style={{ marginBottom: '1rem', padding: '0.5rem', background: '#f0f9ff', border: '1px solid #bae6fd', borderRadius: '4px' }}>
                                            <strong>Map Columns:</strong> Assign each column to a Play Syntax field.
                                        </div>

                                        <div style={{ overflow: 'auto', flex: 1, border: '1px solid #ddd', borderRadius: '4px' }}>
                                            <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '0.9rem' }}>
                                                <thead style={{ position: 'sticky', top: 0, background: '#f8fafc', zIndex: 10 }}>
                                                    <tr>
                                                        {parsedImport[0].map((_, colIndex) => (
                                                            <th key={colIndex} style={{ padding: '0.5rem', borderBottom: '2px solid #ddd', textAlign: 'left', minWidth: '150px' }}>
                                                                <select
                                                                    className="form-select"
                                                                    style={{ width: '100%', fontSize: '0.8rem' }}
                                                                    value={columnMapping[String(colIndex)] || ''}
                                                                    onChange={(e) => {
                                                                        const val = e.target.value;
                                                                        if (!val) {
                                                                            const newMap = { ...columnMapping };
                                                                            delete newMap[String(colIndex)];
                                                                            setColumnMapping(newMap);
                                                                            return;
                                                                        }
                                                                        setColumnMapping(prev => ({ ...prev, [String(colIndex)]: val }));
                                                                    }}
                                                                >
                                                                    <option value="">- Ignore -</option>
                                                                    <optgroup label="Core Fields">
                                                                        <option value="name_override">Full Play Name</option>
                                                                        <option value="formation">Formation</option>
                                                                        <option value="type">Type (Run/Pass)</option>
                                                                    </optgroup>
                                                                    <optgroup label="Play Syntax">
                                                                        {playSyntax.map(field => (
                                                                            <option key={field.id} value={field.id}>{field.name}</option>
                                                                        ))}
                                                                    </optgroup>
                                                                </select>
                                                            </th>
                                                        ))}
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    {parsedImport.slice(0, 50).map((row, rIndex) => (
                                                        <tr key={rIndex} style={{ borderBottom: '1px solid #eee' }}>
                                                            {row.map((cell, cIndex) => (
                                                                <td key={cIndex} style={{ padding: '0.5rem' }}>{cell}</td>
                                                            ))}
                                                        </tr>
                                                    ))}
                                                </tbody>
                                            </table>
                                        </div>

                                        <div style={{ marginTop: '1rem', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                            <button className="btn btn-secondary" onClick={() => setParsedImport([])}>Back to Paste</button>
                                            <div style={{ display: 'flex', gap: '1rem' }}>
                                                <button className="btn btn-secondary" onClick={() => handleBatchCreate(false)}>
                                                    Import {parsedImport.length} Plays
                                                </button>
                                                {week && (
                                                    <button className="btn btn-primary" onClick={() => handleBatchCreate(true)}>
                                                        Import & Add to Install
                                                    </button>
                                                )}
                                            </div>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                    )}
                </>
            );
        };

        // 1. Install Manager Component
        const InstallManagerView = ({
            plays,
            week,
            weeks,
            currentWeekId,
            onUpdateWeek,
            gamePlan,
            practicePlans,
            wbSettings,
            drills = [],
            onQuickAddPlay,
            playSyntax = [],
            onUpdatePlay,
            gamePlanLayouts,
            defaultWbSettings,
            defaultDepthChart,
            defaultZonePhilosophies,
            playCategories = [],
            playBuckets = []
        }) => {
            // Helper to group categories for the 3 columns
            const getCategoryGroup = (type) => {
                if (!type) return 'NONE';
                // Check if type matches a known category
                const cat = playCategories.find(c => c.id === type || c.label === type) || { id: type, label: type };
                const str = (cat.label || cat.id).toLowerCase();

                if (str.includes('run') || str.includes('rpo')) return 'RUN';
                if (str.includes('pass') || str.includes('quick') || str.includes('inter') || str.includes('shot') || str.includes('pap')) return 'PASS';
                return 'OTHER';
            };
            const { ReactSortable } = window; // Destructure Sortable
            const [searchTerm, setSearchTerm] = useState('');
            const [isQuickAddOpen, setIsQuickAddOpen] = useState(false); // Modal state for parser
            const [showImportModal, setShowImportModal] = useState(false);
            const [importSourceWeekId, setImportSourceWeekId] = useState('');

            // Quick Parser State
            const [assignmentModalState, setAssignmentModalState] = useState(null); // { playId, x, y }
            const [rawPlayCall, setRawPlayCall] = useState('');
            const [tokens, setTokens] = useState([]);
            const [parsedFields, setParsedFields] = useState({});

            const handleAssignSituation = (playId, box) => {
                const setId = box.setId;
                if (!onUpdateWeek || !week || !week.id) return;

                // Clone current gamePlan (offensiveGamePlan)
                const currentGamePlan = week.offensiveGamePlan || {};

                let updatedGamePlan;

                if (setId.startsWith('ms_')) {
                    // Handle Mini Script Update
                    const newMiniScripts = (currentGamePlan.miniScripts || []).map(s =>
                        s.id === setId ? { ...s, playIds: [...(s.playIds || []), playId] } : s
                    );
                    updatedGamePlan = { ...currentGamePlan, miniScripts: newMiniScripts };
                } else {
                    // Handle Standard Set Update
                    const existingSet = currentGamePlan.sets?.find(s => s.id === setId);
                    let newSets;
                    if (existingSet) {
                        newSets = (currentGamePlan.sets || []).map(s => s.id === setId ? { ...s, playIds: [...(s.playIds || []), playId] } : s);
                    } else {
                        // Implicit creation
                        newSets = [...(currentGamePlan.sets || []), { id: setId, name: setId, playIds: [playId] }];
                    }
                    updatedGamePlan = { ...currentGamePlan, sets: newSets };
                }

                // Update Week
                onUpdateWeek(week.id, 'offensiveGamePlan', updatedGamePlan);
            };

            // Fallback Buckets (ensure Run/Pass/Screen always exist)
            const DEFAULT_DEFAULTS = [
                { id: 'run', label: 'Run', color: '#10b981', textColor: '#ffffff' },
                { id: 'pass', label: 'Pass', color: '#3b82f6', textColor: '#ffffff' },
                { id: 'screen', label: 'Screen', color: '#8b5cf6', textColor: '#ffffff' }
            ];

            // Calculate Effective Buckets
            const effectiveBuckets = useMemo(() => {
                // If user has defined categories (buckets), use them strictly.
                // This prevents legacy defaults (like 'screen') from reappearing if user created 'SCREENS'.
                if (playCategories && playCategories.length > 0) {
                    return playCategories;
                }

                // Fallback Layout if nothing is defined
                return DEFAULT_DEFAULTS;
            }, [playCategories]);

            // Helper for Game Plan Updates
            const onUpdateGamePlan = (newPlan) => {
                if (onUpdateWeek && week) {
                    onUpdateWeek(week.id, 'offensiveGamePlan', newPlan);
                }
            };

            // Current Install List (Array of play IDs)
            const installList = week.installList || [];

            // Hydrated Install List
            const hydratedInstall = installList.map(id => plays.find(p => p.id === id)).filter(Boolean);

            // AUTO-MIGRATION: Ensure plays with 'type' but no 'bucketId' are assigned to matching bucket
            useEffect(() => {
                if (!onUpdatePlay || !hydratedInstall.length || !playBuckets.length) return;

                hydratedInstall.forEach(play => {
                    if (!play.bucketId && play.type) {
                        const typeStr = play.type.toLowerCase();
                        // Find a bucket that matches this type
                        const matchingBucket = effectiveBuckets.find(b =>
                            !b.categoryId && (
                                b.id === typeStr ||
                                b.label.toLowerCase() === typeStr ||
                                (typeStr.includes('run') && (b.id === 'run' || b.id === 'run-root')) ||
                                (typeStr.includes('pass') && (b.id === 'pass' || b.id === 'pass-root')) ||
                                (typeStr.includes('screen') && (b.id === 'screen' || b.id === 'screen-root'))
                            )
                        );
                        if (matchingBucket) {
                            onUpdatePlay(play.id, { bucketId: matchingBucket.id });
                        }
                    }
                });
            }, [hydratedInstall.length, effectiveBuckets]);

            const handleAssignPlayToSituation = (playId, box) => {
                if (!playId || !box || !box.setId) return;

                const safeGamePlan = gamePlan || {};
                const isScript = box.type === 'script';
                const collectionKey = isScript ? 'miniScripts' : 'sets';
                const targetId = box.setId;

                const updatedGamePlan = { ...safeGamePlan };

                // Ensure collection array exists
                if (!Array.isArray(updatedGamePlan[collectionKey])) {
                    updatedGamePlan[collectionKey] = [];
                }

                // Find existing set/script in the array
                const existingItem = updatedGamePlan[collectionKey].find(item => item.id === targetId);

                // Get current assigned IDs
                const currentData = existingItem || { playIds: [], assignedPlayIds: [] };
                let currentAssigned = currentData.assignedPlayIds || currentData.playIds || [];

                const isAssigned = currentAssigned.includes(playId);
                let newAssignedIds;

                if (isAssigned) {
                    // Remove play (toggle off)
                    newAssignedIds = currentAssigned.filter(id => id !== playId);
                } else {
                    // Add play - use Set to prevent duplicates from rapid clicks
                    newAssignedIds = [...new Set([...currentAssigned, playId])];
                }

                if (existingItem) {
                    // Update existing item
                    updatedGamePlan[collectionKey] = updatedGamePlan[collectionKey].map(item =>
                        item.id === targetId
                            ? { ...item, assignedPlayIds: newAssignedIds }
                            : item
                    );
                } else {
                    // Create new item
                    updatedGamePlan[collectionKey] = [
                        ...updatedGamePlan[collectionKey],
                        { id: targetId, name: targetId, assignedPlayIds: newAssignedIds, playIds: [] }
                    ];
                }

                onUpdateGamePlan(updatedGamePlan);
            };

            const getPlaySituations = (playId) => {
                const layouts = gamePlanLayouts;
                if (!playId || !layouts?.CALL_SHEET?.sections) return [];

                const assignedSituations = [];

                layouts.CALL_SHEET.sections.forEach(section => {
                    if (!section.boxes) return;
                    section.boxes.forEach(box => {
                        if (!box.setId) return;

                        const safeGamePlan = gamePlan || {};
                        const isScript = box.type === 'script';
                        // Fix: Handle as Arrays
                        const collection = isScript ? (safeGamePlan.miniScripts || []) : (safeGamePlan.sets || []);

                        const data = Array.isArray(collection) ? collection.find(item => item.id === box.setId)
                            : null;

                        // Check if play is assigned
                        if (data?.assignedPlayIds?.includes(playId)) {
                            assignedSituations.push({
                                id: box.setId,
                                header: box.header,
                                color: box.color,
                                type: box.type
                            });
                        }
                    });
                });

                return assignedSituations;
            };

            // Initialize/Reset parsed fields when syntax changes or modal opens
            useEffect(() => {
                if (isQuickAddOpen) {
                    const initialFields = {};
                    playSyntax.forEach(s => {
                        initialFields[s.id] = [];
                    });
                    setParsedFields(initialFields);
                }
            }, [isQuickAddOpen, playSyntax]);

            // Tokenizer
            const handleTokenize = () => {
                const parts = rawPlayCall.trim().split(/\s+/).filter(t => t.length > 0);
                setTokens(parts.map((t, i) => ({ id: `token-${i}`, text: t })));
                // Reset bucket distribution
                const initialFields = {};
                playSyntax.forEach(s => {
                    initialFields[s.id] = [];
                });
                setParsedFields(initialFields);
            };

            // Drag and Drop Logic for Parser
            const handleDragStartToken = (e, token, source) => {
                e.dataTransfer.setData('token', JSON.stringify(token));
                e.dataTransfer.setData('source', source);
            };

            const handleDropToken = (e, targetField) => {
                e.preventDefault();
                const tokenData = JSON.parse(e.dataTransfer.getData('token'));
                const source = e.dataTransfer.getData('source');

                // Remove from source
                if (source === 'unassigned') {
                    setTokens(prev => prev.filter(t => t.id !== tokenData.id));
                } else {
                    setParsedFields(prev => ({
                        ...prev,
                        [source]: prev[source].filter(t => t.id !== tokenData.id)
                    }));
                }

                // Add to target
                if (targetField === 'unassigned') {
                    setTokens(prev => [...prev, tokenData]);
                } else {
                    setParsedFields(prev => ({
                        ...prev,
                        [targetField]: [...prev[targetField], tokenData]
                    }));
                }
            };

            const handleQuickAddSubmit = () => {
                // Construct Play Name from fields in Order of Syntax

                const buildPart = (fieldId, arr) => {
                    if (!arr || arr.length === 0) return '';
                    const coreText = arr.map(t => t.text).join(' ');
                    const syntaxItem = playSyntax.find(s => s.id === fieldId);
                    if (syntaxItem) {
                        const pre = syntaxItem.prefix || '';
                        const suf = syntaxItem.suffix || '';
                        return `${pre}${coreText}${suf}`;
                    }
                    return coreText;
                };

                const parts = playSyntax.map(s => buildPart(s.id, parsedFields[s.id])).filter(p => p.length > 0);

                // If no syntax defined, fallback (or if user just typed)
                let finalName = parts.join(' ');
                if (!finalName && rawPlayCall) finalName = rawPlayCall.trim();

                if (!finalName) return;

                // Check if exists
                const existing = plays.find(p => p.name.toLowerCase() === finalName.toLowerCase());

                if (existing) {
                    handleAddToInstall(existing.id);
                    alert("Play already exists in Master Playbook. Added to this week's install.");
                } else {
                    // Create New
                    // We need to pass structured data if handleQuickAddPlay supports it.
                    // The current App implementation just takes a name. 
                    // We can enhance App's handler or just pass a name and let App create a shell.

                    // We'll call onQuickAddPlay which returns the new play object
                    const newPlay = onQuickAddPlay(finalName);

                    // If we want to save specific fields (like 'formation' property), we might need to update the play immediately after.
                    // But for now, let's just assume the name is the key.
                    // If onQuickAddPlay returns the object, we can add it to install list.

                    if (newPlay && newPlay.id) {
                        handleAddToInstall(newPlay.id);
                    }
                }

                // Reset
                setRawPlayCall('');
                setTokens([]);
                setParsedFields({ formation: [], motion: [], concept: [], protection: [], tags: [] });
                setIsQuickAddOpen(false);
            };


            // Removed redundant installList declaration (moved to top)

            const handleAddToInstall = (playId) => {
                if (!installList.includes(playId)) {
                    // Get the play
                    const play = plays.find(p => p.id === playId);

                    // Prepare updates: Reset priority (always start unstarred)
                    const updates = { priority: false };
                    onUpdatePlay(playId, updates);

                    // Create new installList or append to existing
                    const newList = [...installList, playId];
                    onUpdateWeek(week.id, 'installList', newList);
                }
            };

            const handleRemoveFromInstall = (playId) => {
                const newList = installList.filter(id => id !== playId);
                onUpdateWeek(week.id, 'installList', newList);
            };

            const handleTogglePriority = (playId) => {
                const play = plays.find(p => p.id === playId);
                if (play) {
                    onUpdatePlay(playId, { priority: !play.priority });
                }
            };

            // Import Handler
            const handleImportInstalls = () => {
                if (!importSourceWeekId) return;
                const sourceWeek = weeks.find(w => w.id === importSourceWeekId);
                if (!sourceWeek) return;

                const confirm = window.confirm(`Importing week data from ${sourceWeek.name} will OVERWRITE the current week's Installs, Wristbands, Depth Chart, and Zone Philosophies. This cannot be undone. Continue?`);
                if (!confirm) return;

                // 1. Installs
                if (sourceWeek.installList) onUpdateWeek(week.id, 'installList', [...sourceWeek.installList]);
                if (sourceWeek.newInstallIds) onUpdateWeek(week.id, 'newInstallIds', [...sourceWeek.newInstallIds]);

                // 2. Wristbands
                const newWristbands = sourceWeek.wristbands ? JSON.parse(JSON.stringify(sourceWeek.wristbands)) : JSON.parse(JSON.stringify(defaultWbSettings));
                onUpdateWeek(week.id, 'wristbands', newWristbands);

                // 3. Depth Chart
                const newDepthChart = sourceWeek.depthChart ? JSON.parse(JSON.stringify(sourceWeek.depthChart)) : JSON.parse(JSON.stringify(defaultDepthChart));
                onUpdateWeek(week.id, 'depthChart', newDepthChart);

                // 4. Zone Philosophies
                const newZonePhi = sourceWeek.zonePhilosophies ? JSON.parse(JSON.stringify(sourceWeek.zonePhilosophies)) : JSON.parse(JSON.stringify(defaultZonePhilosophies));
                onUpdateWeek(week.id, 'zonePhilosophies', newZonePhi);

                setShowImportModal(false);
            };

            const handleClearWeek = () => {
                const confirm = window.prompt(`Are you sure you want to CLEAR ALL DATA for this week (Installs, Wristbands, Depth Chart, Zone Phi)? This cannot be undone.\n\nType "delete" to confirm.`);
                if (confirm !== 'delete') return;

                onUpdateWeek(week.id, 'installList', []);
                onUpdateWeek(week.id, 'newInstallIds', []);
                onUpdateWeek(week.id, 'wristbands', JSON.parse(JSON.stringify(defaultWbSettings)));
                onUpdateWeek(week.id, 'depthChart', JSON.parse(JSON.stringify(defaultDepthChart)));
                onUpdateWeek(week.id, 'zonePhilosophies', JSON.parse(JSON.stringify(defaultZonePhilosophies)));
            };

            // Analytics Helpers
            const getGamePlanStatus = (playId) => {
                if (!gamePlan) return false;
                let found = false;

                Object.values(gamePlan).forEach(section => {
                    if (Array.isArray(section)) {
                        if (section.some(p => p.id === playId)) found = true;
                    } else if (typeof section === 'object' && section !== null) {
                        // Check for nested sets/plays if applicable to data structure
                        Object.values(section).forEach(sub => {
                            if (Array.isArray(sub)) {
                                if (sub.some(p => p.id === playId)) found = true;
                            }
                        })
                    }
                });
                return found;
            };

            const getScriptCount = (playId) => {
                let count = 0;
                if (!practicePlans) return 0;

                Object.values(practicePlans).forEach(plan => {
                    if (plan.segments) {
                        plan.segments.forEach(seg => {
                            // Check unassigned cards
                            if (seg.unassignedCards) {
                                count += seg.unassignedCards.filter(c => c.playId === playId).length;
                            }
                            // Check script rows if they exist
                            if (seg.scriptRows) {
                                count += seg.scriptRows.filter(r => r.playId === playId).length;
                            }
                        });
                    }
                });
                return count;
            };



            const handleListChange = (newItems, bucketId, familyName) => {
                // Update the install list order
                const fullListIds = week.installList || [];
                const newIdsSet = new Set(newItems.map(p => p.id));

                // Get all items NOT in the current bucket
                const otherIds = fullListIds.filter(id => !newIdsSet.has(id));

                // Combine: other items + new items from this bucket
                const finalIds = [...otherIds, ...newItems.map(p => p.id)];

                // Update the week's install list
                onUpdateWeek(week.id, 'installList', finalIds);

                // Assign bucketId and conceptFamily to plays that were dragged
                newItems.forEach(p => {
                    const updates = {};
                    if (p.bucketId !== bucketId) updates.bucketId = bucketId;

                    // Only update conceptFamily if familyName is provided (which it is for family-specific columns)
                    // If familyName is 'No Concept', we set it to null or empty string
                    const targetFamily = familyName === 'No Concept' ? '' : familyName;
                    if (familyName !== undefined && p.conceptFamily !== targetFamily) {
                        updates.conceptFamily = targetFamily;
                    }

                    if (Object.keys(updates).length > 0) {
                        onUpdatePlay(p.id, updates);
                    }
                });
            };

            const getWristbandSlot = (playId) => {
                const play = plays.find(p => p.id === playId);
                if (play && play.wristbandSlot) return play.wristbandSlot;
                return null;
            };

            // Calculate Available Wristband Slots
            const availableSlots = React.useMemo(() => {
                if (!wbSettings) return [];
                const slots = [];
                Object.keys(wbSettings).filter(k => k.startsWith('card')).forEach(cardKey => {
                    const card = wbSettings[cardKey];
                    if (card.type === 'rooski') {
                        const series = cardKey.replace('card', '');
                        for (let i = 1; i <= 16; i++) slots.push(`${series}${String(i).padStart(2, '0')}`);
                    } else {
                        const start = (parseInt(cardKey.replace('card', '')) * 100) + 1;
                        for (let i = 0; i < 48; i++) slots.push(String(start + i));
                    }
                });
                const assigned = new Set(plays.filter(p => p.wristbandSlot).map(p => String(p.wristbandSlot)));
                return slots.filter(s => !assigned.has(s)).sort((a, b) => parseInt(a) - parseInt(b));
            }, [wbSettings, plays]);


            // Filtered Master List (Exclude already installed)
            const masterList = plays.filter(p => {
                if (installList.includes(p.id)) return false;
                if (searchTerm && !p.name.toLowerCase().includes(searchTerm.toLowerCase())) return false;
                return true;
            });

            // Removed redundant hydratedInstall declaration (moved to top)

            const handleToggleNewPlay = (playId) => {
                const currentNewIds = week.newInstallIds || [];
                let newIds;
                if (currentNewIds.includes(playId)) {
                    newIds = currentNewIds.filter(id => id !== playId);
                } else {
                    newIds = [...currentNewIds, playId];
                }
                onUpdateWeek(week.id, 'newInstallIds', newIds);
            };


            const handleDuplicatePlay = (playId) => {
                const playToClone = plays.find(p => p.id === playId);
                if (!playToClone) return;

                const newPlay = {
                    ...playToClone,
                    id: Date.now().toString() + Math.random().toString().slice(2, 5),
                    name: `${playToClone.name} (Copy)`,
                    wristbandSlot: null,
                    isWiz: false,
                    isMiniScript: false
                };

                // Add to library
                if (onQuickAddPlay) {
                    onQuickAddPlay(newPlay);

                    // Add to install
                    const currentList = week.installList || [];
                    onUpdateWeek(week.id, 'installList', [...currentList, newPlay.id]);
                }
            };

            return (
                <>
                    <div style={{ height: 'calc(100vh - 100px)', display: 'flex', flexDirection: 'column' }}>
                        <div style={{ padding: '1.5rem', borderBottom: '1px solid var(--border)', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <div>
                                <h1 style={{ margin: 0 }}>Week {week.weekNum} Install/Ready List</h1>
                                <p style={{ margin: '0.5rem 0 0 0', opacity: 0.7 }}>Manage the active plays for Week {week.weekNum}: {week.opponent}</p>
                            </div>

                            <div style={{ display: 'flex', gap: '12px', alignItems: 'center' }}>
                                <button
                                    className="btn"
                                    onClick={handleClearWeek}
                                    title="Clear Week"
                                    style={{
                                        height: '38px',
                                        padding: '0 16px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '8px',
                                        background: 'white',
                                        border: '1px solid #cbd5e1',
                                        color: '#ef4444',
                                        borderRadius: '6px',
                                        fontSize: '0.9rem',
                                        fontWeight: '500'
                                    }}
                                >
                                    <Icon name="Trash" size={16} /> Clear Week
                                </button>
                                <button
                                    className="btn"
                                    onClick={() => setShowImportModal(true)}
                                    style={{
                                        height: '38px',
                                        padding: '0 16px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '8px',
                                        background: 'white',
                                        border: '1px solid #cbd5e1',
                                        color: '#64748b',
                                        borderRadius: '6px',
                                        fontSize: '0.9rem',
                                        fontWeight: '500'
                                    }}
                                >
                                    <Icon name="Download" size={16} /> Import
                                </button>
                                <button
                                    className="btn btn-primary"
                                    onClick={() => setIsQuickAddOpen(true)}
                                    style={{
                                        height: '38px',
                                        padding: '0 16px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '8px',
                                        borderRadius: '6px',
                                        fontSize: '0.9rem',
                                        fontWeight: '600'
                                    }}
                                >
                                    <Icon name="Plus" size={16} /> Quick Add / Parse Play
                                </button>
                            </div>
                        </div>

                        {showImportModal && (
                            <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 10000 }}>
                                <div className="card" style={{ width: '400px', padding: '1.5rem', background: 'white', color: 'black' }}>
                                    <h3>Import Installs</h3>
                                    <p>Select a week to copy installs from. <strong>This will overwrite current data.</strong></p>
                                    <select
                                        className="form-select"
                                        value={importSourceWeekId}
                                        onChange={e => setImportSourceWeekId(e.target.value)}
                                        style={{ marginBottom: '1rem', width: '100%' }}
                                    >
                                        <option value="">Select Week...</option>
                                        {weeks.filter(w => w.id !== week.id).map(w => (
                                            <option key={w.id} value={w.id}>{w.name}</option>
                                        ))}
                                    </select>
                                    <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '8px' }}>
                                        <button className="btn" onClick={() => setShowImportModal(false)}>Cancel</button>
                                        <button className="btn btn-primary" onClick={handleImportInstalls} disabled={!importSourceWeekId}>Import</button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {isQuickAddOpen && (
                            <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 10000 }}>
                                <div className="card" style={{ width: '90%', maxWidth: '600px', padding: '1.5rem', background: '#f8fafc', border: '1px solid #e2e8f0', boxShadow: '0 10px 25px rgba(0,0,0,0.2)' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                        <h3 style={{ margin: 0 }}>Play Call Parser</h3>
                                        <button onClick={() => setIsQuickAddOpen(false)} style={{ background: 'none', border: 'none', cursor: 'pointer' }}>
                                            <Icon name="X" size={20} />
                                        </button>
                                    </div>

                                    <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '1rem' }}>
                                        <input
                                            className="form-input"
                                            value={rawPlayCall}
                                            onChange={e => setRawPlayCall(e.target.value.toUpperCase())}
                                            placeholder="Type play call here..."
                                            onKeyDown={e => e.key === 'Enter' && handleTokenize()}
                                        />
                                        <button className="btn btn-primary" onClick={handleTokenize}>Parse</button>
                                    </div>

                                    {/* Unassigned Tokens */}
                                    <div
                                        style={{ minHeight: '40px', padding: '0.5rem', background: 'white', border: '1px solid #ddd', borderRadius: '4px', marginBottom: '1rem', display: 'flex', flexWrap: 'wrap', gap: '0.5rem' }}
                                        onDragOver={e => e.preventDefault()}
                                        onDrop={e => handleDropToken(e, 'unassigned')}
                                    >
                                        {tokens.length === 0 && <span style={{ color: '#aaa', fontSize: '0.8rem' }}>Tokens will appear here...</span>}
                                        {tokens.map(t => (
                                            <span
                                                key={t.id}
                                                draggable
                                                onDragStart={e => handleDragStartToken(e, t, 'unassigned')}
                                                style={{ background: '#e2e8f0', color: '#0f172a', padding: '2px 8px', borderRadius: '12px', fontSize: '0.85rem', cursor: 'grab' }}
                                            >
                                                {t.text}
                                            </span>
                                        ))}
                                    </div>

                                    {/* Drop Zones Grid */}
                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '0.5rem' }}>
                                        {playSyntax.length === 0 && (
                                            <div style={{ gridColumn: '1 / -1', padding: '1rem', background: '#fef3c7', color: '#b45309', borderRadius: '4px', textAlign: 'center' }}>
                                                No Play Syntax defined. Go to Offense Setup to configure your play structure.
                                            </div>
                                        )}
                                        {playSyntax.map(field => (
                                            <div
                                                key={field.id}
                                                style={{ background: 'white', border: '1px solid #ddd', borderRadius: '4px', padding: '0.5rem', minHeight: '60px' }}
                                                onDragOver={e => e.preventDefault()}
                                                onDrop={e => handleDropToken(e, field.id)}
                                            >
                                                <div style={{ fontSize: '0.7rem', textTransform: 'uppercase', color: '#888', marginBottom: '0.25rem' }}>{field.label}</div>
                                                <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.25rem' }}>
                                                    {parsedFields[field.id] && parsedFields[field.id].map(t => (
                                                        <span
                                                            key={t.id}
                                                            draggable
                                                            onDragStart={e => handleDragStartToken(e, t, field.id)}
                                                            style={{ background: '#dbeafe', color: '#1e3a8a', padding: '2px 6px', borderRadius: '4px', fontSize: '0.8rem', cursor: 'grab' }}
                                                        >
                                                            {t.text}
                                                        </span>
                                                    ))}
                                                </div>
                                            </div>
                                        ))}
                                    </div>

                                    <div style={{ marginTop: '1rem', display: 'flex', justifyContent: 'flex-end', gap: '0.5rem' }}>
                                        <button className="btn" onClick={() => setIsQuickAddOpen(false)}>Cancel</button>
                                        <button className="btn btn-primary" onClick={handleQuickAddSubmit}>Create & Add</button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* FLEX LAYOUT: Sidebar + Main Content */}
                        <div style={{ flex: 1, display: 'flex', overflow: 'hidden', minHeight: 0 }}>

                            {/* LEFT COLUMN: MASTER PLAYBOOK SEARCH + INSTALL LIST */}
                            <div style={{ width: '300px', flexShrink: 0, display: 'flex', flexDirection: 'column', borderRight: '1px solid var(--border)', background: 'white', minHeight: 0 }}>
                                {/* Master Playbook Search Section */}
                                <div style={{ borderBottom: '1px solid var(--border)', background: '#f8fafc' }}>
                                    <div style={{ padding: '0.75rem', background: '#f1f5f9', borderBottom: '1px solid var(--border)' }}>
                                        <h4 style={{ margin: 0, fontSize: '0.9rem', fontWeight: 'bold', color: 'var(--text-secondary)' }}>Master Playbook</h4>
                                    </div>
                                    <div style={{ padding: '0.75rem' }}>
                                        <input
                                            type="text"
                                            className="form-input"
                                            placeholder="Search plays..."
                                            value={searchTerm}
                                            onChange={e => setSearchTerm(e.target.value)}
                                            style={{ fontSize: '0.85rem' }}
                                        />
                                    </div>
                                    <div style={{ maxHeight: '200px', overflowY: 'auto', padding: '0 0.75rem 0.75rem 0.75rem' }}>
                                        {masterList.slice(0, 20).map(play => (
                                            <div
                                                key={play.id}
                                                className="card"
                                                onClick={() => handleAddToInstall(play.id)}
                                                style={{
                                                    padding: '0.5rem 0.6rem',
                                                    marginBottom: '0.25rem',
                                                    display: 'flex',
                                                    justifyContent: 'space-between',
                                                    alignItems: 'center',
                                                    cursor: 'pointer',
                                                    transition: 'all 0.2s',
                                                    border: '1px solid #e2e8f0'
                                                }}
                                                onMouseEnter={(e) => {
                                                    e.currentTarget.style.background = '#f0f9ff';
                                                    e.currentTarget.style.borderColor = '#3b82f6';
                                                }}
                                                onMouseLeave={(e) => {
                                                    e.currentTarget.style.background = 'white';
                                                    e.currentTarget.style.borderColor = '#e2e8f0';
                                                }}
                                                title="Click to add to install list"
                                            >
                                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', flex: 1, overflow: 'hidden' }}>
                                                    {/* Plus Icon */}
                                                    <div style={{
                                                        background: '#3b82f6',
                                                        color: 'white',
                                                        borderRadius: '50%',
                                                        width: '20px',
                                                        height: '20px',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        flexShrink: 0
                                                    }}>
                                                        <Icon name="Plus" size={14} />
                                                    </div>

                                                    {/* Play Info */}
                                                    <div style={{ flex: 1, overflow: 'hidden' }}>
                                                        <div style={{ fontWeight: 'bold', fontSize: '0.8rem', color: '#1e293b', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                            {getPlayDisplayName(play)}
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        ))}
                                        {masterList.length === 0 && searchTerm && (
                                            <div style={{ padding: '0.75rem' }}>
                                                <div style={{ textAlign: 'center', padding: '0.5rem 0', color: 'var(--text-secondary)', fontSize: '0.8rem', marginBottom: '0.5rem' }}>
                                                    No plays found matching "{searchTerm}"
                                                </div>
                                                <button
                                                    className="btn btn-primary"
                                                    onClick={() => {
                                                        // Create a new play with the search term as the name
                                                        const newPlay = onQuickAddPlay(searchTerm.trim());
                                                        if (newPlay && newPlay.id) {
                                                            handleAddToInstall(newPlay.id);
                                                        }
                                                        setSearchTerm(''); // Clear search after creating
                                                    }}
                                                    style={{ width: '100%', fontSize: '0.85rem', padding: '0.6rem' }}
                                                >
                                                    <Icon name="Plus" size={14} /> Create "{searchTerm}"
                                                </button>
                                            </div>
                                        )}
                                        {masterList.length === 0 && !searchTerm && (
                                            <div style={{ textAlign: 'center', padding: '1rem', color: 'var(--text-secondary)', fontSize: '0.8rem' }}>
                                                No plays found to add.
                                            </div>
                                        )}
                                        {masterList.length > 20 && (
                                            <div style={{ textAlign: 'center', padding: '0.5rem', color: 'var(--text-secondary)', fontSize: '0.75rem', fontStyle: 'italic' }}>
                                                Showing first 20 results. Refine search to see more.
                                            </div>
                                        )}
                                    </div>
                                </div>

                                {/* Uncategorized Plays - Prompt to tag them */}
                                <div style={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden', minHeight: 0 }}>
                                    <div style={{ padding: '0.75rem', background: '#fef2f2', borderBottom: '1px solid var(--border)' }}>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                            <h4 style={{ margin: 0, fontSize: '0.9rem', fontWeight: 'bold', color: '#991b1b' }}>Uncategorized Plays</h4>
                                            <span style={{ fontSize: '0.7rem', padding: '2px 8px', background: '#fee2e2', color: '#991b1b', borderRadius: '12px', fontWeight: 'bold' }}>
                                                {hydratedInstall.filter(p =>
                                                    (p.bucketId && !effectiveBuckets.some(b => b.id === p.bucketId)) ||
                                                    (!p.bucketId && (!p.type || !effectiveBuckets.some(b => b.id === p.type)))
                                                ).length}
                                            </span>
                                        </div>
                                        <p style={{ margin: '0.25rem 0 0 0', fontSize: '0.7rem', color: '#b91c1c' }}>
                                            Tag these to move to Run/Pass/Screen columns.
                                        </p>
                                    </div>
                                    <div style={{ flex: 1, overflowY: 'auto', padding: '0.75rem', display: 'flex', flexDirection: 'column' }}>
                                        {(() => {
                                            const uncategorized = hydratedInstall.filter(p => (p.bucketId && !effectiveBuckets.some(b => b.id === p.bucketId)) || (!p.bucketId && (!p.type || !effectiveBuckets.some(b => b.id === p.type))));

                                            if (uncategorized.length === 0) {
                                                return (
                                                    <ReactSortable
                                                        list={[]}
                                                        setList={() => { }}
                                                        group="installColumns"
                                                        style={{
                                                            minHeight: '100px', display: 'flex', alignItems: 'center', justifyContent: 'center'
                                                        }}
                                                    >
                                                        <div style={{ textAlign: 'center', padding: '2rem', color: 'var(--text-secondary)', fontSize: '0.8rem', width: '100%' }}>
                                                            No unassigned                                                                  <br />Drag plays here to unassign.
                                                        </div>
                                                    </ReactSortable>
                                                );
                                            }

                                            return (
                                                <ReactSortable
                                                    list={uncategorized}
                                                    setList={(items) => handleListChange(items, null)}
                                                    group="installColumns"
                                                    animation={150}
                                                    style={{ minHeight: '50px' }}
                                                >
                                                    {uncategorized.map(play => (
                                                        <div
                                                            key={play.id}
                                                            data-id={play.id}
                                                            className="card"
                                                            style={{
                                                                padding: '0.5rem 0.6rem',
                                                                marginBottom: '0.25rem',
                                                                display: 'flex',
                                                                justifyContent: 'space-between',
                                                                alignItems: 'center',
                                                                borderLeft: '3px solid #64748b', // Grey for unassigned
                                                                cursor: 'grab',
                                                                background: 'white'
                                                            }}
                                                            onClick={(e) => setAssignmentModalState({ playId: play.id, x: e.clientX, y: e.clientY })}
                                                        >
                                                            <div style={{ flex: 1, overflow: 'hidden' }}>
                                                                <div style={{ fontWeight: 'bold', color: '#1e293b', fontSize: '0.8rem' }}>{getPlayDisplayName(play)}</div>
                                                            </div>
                                                            <div style={{ color: '#64748b' }}>
                                                                <Icon name="Tag" size={14} />
                                                            </div>
                                                        </div>
                                                    ))}
                                                </ReactSortable>
                                            );
                                        })()}
                                    </div>
                                </div>
                            </div>


                            {/* BUCKET GRID: Dynamic columns based on playBuckets from Offense Setup */}
                            {/* Bucket Grid - Full Width with Nested Concept Families */}

                            {/* NEW LAYOUT: Grid + Inbox */}
                            <div style={{ flex: 1, display: 'flex', height: 'calc(100vh - 250px)', overflow: 'hidden', gap: '1rem', padding: '1rem' }}>
                                <div style={{
                                    flex: 3,
                                    display: 'grid',
                                    gridTemplateColumns: 'repeat(auto-fill, minmax(280px, 1fr))',
                                    gridAutoRows: 'min-content',
                                    gap: '1rem',
                                    overflowY: 'auto',
                                    overflowX: 'hidden', // Prevent horizontal bleed
                                    paddingRight: '0.5rem',
                                    minWidth: 0 // Allow flex item to shrink
                                }}>
                                    {effectiveBuckets.filter(b => !b.categoryId).map(bucket => {
                                        const bucketPlays = hydratedInstall.filter(p => p.bucketId === bucket.id);

                                        // Group plays by concept family
                                        const playsByFamily = bucketPlays.reduce((acc, play) => {
                                            const family = play.conceptFamily || 'No Concept';
                                            if (!acc[family]) acc[family] = [];
                                            acc[family].push(play);
                                            return acc;
                                        }, {});

                                        const families = Object.keys(playsByFamily).sort();

                                        return (
                                            <div key={bucket.id} className="card" style={{
                                                display: 'flex',
                                                flexDirection: 'column',
                                                background: 'var(--bg-panel)',
                                                border: '1px solid var(--border)',
                                                height: 'fit-content'
                                            }}>
                                                {/* Bucket Header */}
                                                <div style={{
                                                    padding: '0.75rem 1rem',
                                                    borderBottom: `3px solid ${bucket.color || 'var(--accent)'}`,
                                                    background: 'var(--bg-main)',
                                                    fontWeight: 'bold',
                                                    display: 'flex',
                                                    justifyContent: 'space-between',
                                                    alignItems: 'center',
                                                    fontSize: '1rem',
                                                    color: 'var(--text-main)'
                                                }}>
                                                    <span style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                        <div style={{ width: '10px', height: '10px', borderRadius: '50%', background: bucket.color || 'var(--accent)' }}></div>
                                                        {bucket.label || bucket.id}
                                                    </span>
                                                    <span style={{
                                                        fontSize: '0.75rem',
                                                        padding: '2px 8px',
                                                        background: 'var(--bg-panel)',
                                                        border: '1px solid var(--border)',
                                                        borderRadius: '12px',
                                                        fontWeight: 'bold',
                                                        color: 'var(--text-secondary)'
                                                    }}>
                                                        {bucketPlays.length}
                                                    </span>
                                                </div>

                                                {/* Content */}
                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem', padding: '0.5rem' }}>
                                                    {families.length === 0 ? (
                                                        <div style={{ padding: '1.5rem', textAlign: 'center', color: 'var(--text-secondary)', fontSize: '0.8rem', fontStyle: 'italic', opacity: 0.7 }}>
                                                            No plays assigned
                                                        </div>
                                                    ) : (
                                                        families.map(family => (
                                                            <div key={family} style={{
                                                                border: '1px solid var(--border)',
                                                                borderRadius: '6px',
                                                                overflow: 'hidden'
                                                            }}>
                                                                {family !== 'No Concept' && (
                                                                    <div style={{
                                                                        padding: '0.25rem 0.5rem',
                                                                        background: 'var(--bg-item)',
                                                                        borderBottom: '1px solid var(--border)',
                                                                        fontSize: '0.75rem',
                                                                        fontWeight: 'bold',
                                                                        color: 'var(--text-secondary)',
                                                                        display: 'flex', justifyContent: 'space-between'
                                                                    }}>
                                                                        <span>{family}</span>
                                                                        <span>{playsByFamily[family].length}</span>
                                                                    </div>
                                                                )}
                                                                <div style={{ padding: '0.25rem' }}>
                                                                    <InstallSortableColumn
                                                                        items={playsByFamily[family]}
                                                                        type={`${bucket.label}-${family}`}
                                                                        onListChange={(newItems) => {
                                                                            handleListChange(newItems, bucket.id, family);
                                                                        }}
                                                                        onUpdatePlay={onUpdatePlay}
                                                                        handleRemoveFromInstall={handleRemoveFromInstall}
                                                                        handleTogglePriority={handleTogglePriority}
                                                                        getGamePlanStatus={getGamePlanStatus}
                                                                        getScriptCount={getScriptCount}
                                                                        handleToggleNewPlay={handleToggleNewPlay}
                                                                        newInstallIds={week.newInstallIds || []}
                                                                        onOpenAssignmentModal={(id, x, y) => setAssignmentModalState({ playId: id, x, y })}
                                                                        onDuplicatePlay={handleDuplicatePlay}
                                                                        playBuckets={effectiveBuckets}
                                                                    />
                                                                </div>
                                                            </div>
                                                        ))
                                                    )}
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>

                            </div>
                        </div>




                    </div >
                    {assignmentModalState && (() => {
                        const { playId, x, y } = assignmentModalState;
                        const play = plays.find(p => p.id === playId);
                        if (!play) return null;

                        const assignedSits = getPlaySituations(playId);
                        const assignedIds = new Set(assignedSits.map(s => s.id));

                        return (
                            <PlayDetailsModal
                                playId={playId}
                                plays={plays}
                                weekDate={week.id}
                                newInstallIds={week.newInstallIds || []}
                                gamePlanLayouts={gamePlanLayouts}
                                assignedIds={assignedIds}
                                onClose={() => setAssignmentModalState(null)}
                                onUpdateWeek={onUpdateWeek}
                                onUpdatePlay={onUpdatePlay}
                                onAssignSituation={handleAssignSituation}
                                position={{ x, y }}
                                playBuckets={playBuckets}
                                playCategories={playCategories}
                                currentWeek={week}
                            />
                        );
                    })()}
                </>
            );
        };

        const PrintHubView = ({ roster, staff, gamePlans, depthChart, practicePlans, attendance, wbSettings, setWbSettings, plays, drills = [] }) => {
            const [selectedCategory, setSelectedCategory] = useState('practice');
            const [selectedOption, setSelectedOption] = useState(null); // 'daily_plan', 'weekly_plan', 'wristbands', etc.
            const [selectedDay, setSelectedDay] = useState(null); // For daily plan selection
            const [selectedCardForPrint, setSelectedCardForPrint] = useState(null); // For wristband card selection
            const [scheduledEvents] = useLocalStorage('oc-dashboard-scheduled-events', []);

            const categories = [
                { id: 'practice', label: 'Practice', icon: 'Clipboard' },
                { id: 'game', label: 'Game Day', icon: 'Trophy' },
                { id: 'personnel', label: 'Personnel', icon: 'Users' }
            ];

            const printOptions = {
                practice: [
                    { id: 'daily_plan', label: 'Daily Practice Plan', desc: 'Print schedule and periods for a specific day', icon: 'Calendar' },
                    { id: 'weekly_plan', label: 'Weekly Practice Plan', desc: 'Print overview of the week\'s schedule', icon: 'Layout' },
                    { id: 'scripts', label: 'Practice Scripts', desc: 'Print scripts with optional scout cards', icon: 'FileText' },
                ],
                game: [
                    { id: 'call_sheet', label: 'Call Sheet', desc: 'Simplified, high-contrast call sheet', icon: 'Grid' },
                    { id: 'wristbands', label: 'Wristband Builder', desc: '3x5" Wristband Inserts', icon: 'Columns' },
                    { id: 'pregame', label: 'Pre-game Timeline', desc: 'Print game day itinerary', icon: 'Clock' },
                    { id: 'game_report', label: 'Game Report', desc: 'Post-game summary and stats', icon: 'BarChart' }
                ],
                personnel: [
                    { id: 'depth_chart', label: 'Depth Chart', desc: 'Offense, Defense, and Special Teams', icon: 'Layers' },
                    { id: 'attendance', label: 'Attendance Report', desc: 'Print attendance history', icon: 'CheckSquare' },
                    { id: 'profiles', label: 'Player Profiles', desc: 'Print player details and measurables', icon: 'User' }
                ]
            };

            const handlePrint = (optionId) => {
                if (optionId === 'daily_plan') {
                    setSelectedOption('daily_plan');
                    // Auto-select 'Monday' or current day if available, else require selection
                    setSelectedDay(null);
                } else if (optionId === 'wristbands') {
                    setSelectedOption('wristbands');
                    setSelectedCardForPrint(null);
                } else {
                    alert(`Print functionality for ${optionId} coming next!`);
                }
            };

            // Batch State
            const [batchSelection, setBatchSelection] = useState({
                Monday: { plan: false, script: false, cards: false },
                Tuesday: { plan: false, script: false, cards: false },
                Wednesday: { plan: false, script: false, cards: false },
                Thursday: { plan: false, script: false, cards: false },
                Friday: { plan: false, script: false, cards: false },
            });
            const [selectedPrintCoach, setSelectedPrintCoach] = useState('ALL');
            const [batchComponents, setBatchComponents] = useState(null);

            const handleToggleBatch = (day, type) => {
                setBatchSelection(prev => ({
                    ...prev,
                    [day]: { ...prev[day], [type]: !prev[day][type] }
                }));
            };

            const handleGenerateBatch = () => {
                const components = [];
                const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];

                days.forEach(day => {
                    const sel = batchSelection[day];
                    const plan = practicePlans[day];

                    // Order: Plan -> Script -> Cards (Ideal for Plan Front / Script Back if duplexing)
                    if (sel.plan) components.push(<PracticePlanPrintView key={`${day} -plan`} plan={plan} isBatchMode={true} coachFilter={selectedPrintCoach} roster={roster} staff={staff} drills={drills} />);
                    if (sel.script) components.push(<ScriptPrintView key={`${day} -script`} plan={plan} isBatchMode={true} />);
                    if (sel.cards) components.push(<ScoutCardPrintView key={`${day} -cards`} plan={plan} isBatchMode={true} />);
                });

                if (components.length === 0) {
                    alert('Please select at least one item to print.');
                    return;
                }
                setBatchComponents(components);
            };

            const handleBack = () => {
                setBatchComponents(null);
                setSelectedOption(null);
                setSelectedDay(null);
            };

            // Render Sub-Views
            if (batchComponents) {
                return <BatchPrintContainer components={batchComponents} onBack={() => setBatchComponents(null)} />;
            }

            if (selectedOption === 'daily_plan') {
                // Modified to show the Batch Matrix instead of just Day Buttons
                return (
                    <div style={{ padding: '2rem', maxWidth: '1000px', margin: '0 auto' }}>
                        <button onClick={handleBack} className="btn btn-secondary" style={{ marginBottom: '1rem' }}>
                            <Icon name="ArrowLeft" size={16} /> Back
                        </button>

                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                            <h2>Practice Print Batcher</h2>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                <label style={{ fontWeight: 'bold' }}>Filter by Coach:</label>
                                <select
                                    className="form-select"
                                    value={selectedPrintCoach}
                                    onChange={(e) => setSelectedPrintCoach(e.target.value)}
                                    style={{ width: '200px' }}
                                >
                                    <option value="ALL">All Coaches</option>
                                    {staff && staff.map(c => (
                                        <option key={c.id} value={c.id}>{c.name}</option>
                                    ))}
                                </select>
                            </div>
                        </div>

                        <div className="card" style={{ padding: '0', overflow: 'hidden' }}>
                            <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                                <thead style={{ background: 'rgba(255,255,255,0.05)' }}>
                                    <tr>
                                        <th style={{ padding: '1rem', textAlign: 'left' }}>Day</th>
                                        <th style={{ padding: '1rem', textAlign: 'center' }}>Daily Plan</th>
                                        <th style={{ padding: '1rem', textAlign: 'center' }}>Practice Script</th>
                                        <th style={{ padding: '1rem', textAlign: 'center' }}>Scout Cards</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {Object.keys(batchSelection).map(day => (
                                        <tr key={day} style={{ borderBottom: '1px solid var(--border)' }}>
                                            <td style={{ padding: '1rem', fontWeight: 'bold' }}>{day}</td>
                                            <td style={{ padding: '1rem', textAlign: 'center' }}>
                                                <input
                                                    type="checkbox"
                                                    checked={batchSelection[day].plan}
                                                    onChange={() => handleToggleBatch(day, 'plan')}
                                                    style={{ width: '20px', height: '20px', cursor: 'pointer' }}
                                                />
                                            </td>
                                            <td style={{ padding: '1rem', textAlign: 'center' }}>
                                                <input
                                                    type="checkbox"
                                                    checked={batchSelection[day].script}
                                                    onChange={() => handleToggleBatch(day, 'script')}
                                                    style={{ width: '20px', height: '20px', cursor: 'pointer' }}
                                                />
                                            </td>
                                            <td style={{ padding: '1rem', textAlign: 'center' }}>
                                                <input
                                                    type="checkbox"
                                                    checked={batchSelection[day].cards}
                                                    onChange={() => handleToggleBatch(day, 'cards')}
                                                    style={{ width: '20px', height: '20px', cursor: 'pointer' }}
                                                />
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                            <div style={{ padding: '1.5rem', background: 'rgba(255,255,255,0.02)', display: 'flex', justifyContent: 'flex-end', gap: '1rem' }}>
                                <button className="btn btn-secondary" onClick={() => setBatchSelection({
                                    Monday: { plan: false, script: false, cards: false },
                                    Tuesday: { plan: false, script: false, cards: false },
                                    Wednesday: { plan: false, script: false, cards: false },
                                    Thursday: { plan: false, script: false, cards: false },
                                    Friday: { plan: false, script: false, cards: false },
                                })}>Clear All</button>
                                <button className="btn btn-primary" onClick={handleGenerateBatch} style={{ padding: '0.75rem 2rem' }}>
                                    <Icon name="Printer" size={18} style={{ marginRight: '8px' }} />
                                    Generate Print Packet
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }
            // Wristband Print Preview
            if (selectedOption === 'wristbands') {
                if (!selectedCardForPrint) {
                    // Card Selector View
                    const availableCards = wbSettings ? Object.keys(wbSettings).filter(key => key.startsWith('card')) : [];

                    return (
                        <div style={{ padding: '2rem', maxWidth: '1000px', margin: '0 auto' }}>
                            <button onClick={handleBack} className="btn btn-secondary" style={{ marginBottom: '1rem' }}>
                                <Icon name="ArrowLeft" size={16} /> Back to Print Center
                            </button>

                            <div style={{ marginBottom: '2rem' }}>
                                <h2 style={{ fontSize: '2rem', marginBottom: '0.5rem' }}>Select Wristband Card</h2>
                                <p style={{ color: 'var(--text-secondary)' }}>Choose which wristband card to print (4 copies per page)</p>
                            </div>

                            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))', gap: '1.5rem' }}>
                                {availableCards.map(cardId => {
                                    const card = wbSettings[cardId];
                                    const cardNumber = cardId.replace('card', '');
                                    const cardTypeLabel = card && (card.type === 'wiz' || card.type === 'rooski') ? 'WIZ' : card && card.type === 'mini-scripts' ? 'SCRIPT' : 'TRADITIONAL';
                                    const opponent = card.opp || card.opponent || 'No Opponent';

                                    return (
                                        <div
                                            key={cardId}
                                            className="card"
                                            style={{
                                                padding: '1.5rem',
                                                cursor: 'pointer',
                                                transition: 'transform 0.2s, box-shadow 0.2s'
                                            }}
                                            onClick={() => setSelectedCardForPrint(cardId)}
                                            onMouseEnter={e => {
                                                e.currentTarget.style.transform = 'translateY(-4px)';
                                                e.currentTarget.style.boxShadow = '0 8px 16px rgba(0,0,0,0.2)';
                                            }}
                                            onMouseLeave={e => {
                                                e.currentTarget.style.transform = 'translateY(0)';
                                                e.currentTarget.style.boxShadow = '';
                                            }}>
                                            <div style={{ marginBottom: '1rem' }}>
                                                <h3 style={{ fontSize: '1.25rem', marginBottom: '0.5rem' }}>Card {cardNumber}</h3>
                                                <div style={{
                                                    background: 'black',
                                                    color: 'white',
                                                    padding: '4px 8px',
                                                    borderRadius: '4px',
                                                    fontSize: '0.75rem',
                                                    fontWeight: 'bold',
                                                    display: 'inline-block',
                                                    marginBottom: '0.5rem'
                                                }}>
                                                    {cardTypeLabel}
                                                </div>
                                                <p style={{ color: 'var(--text-secondary)', fontSize: '0.9rem', margin: 0 }}>
                                                    vs. {opponent}
                                                </p>
                                            </div>
                                            <button className="btn btn-primary" style={{ width: '100%' }}>
                                                <Icon name="Printer" size={16} /> Select Card
                                            </button>
                                        </div>
                                    );
                                })}
                            </div>

                            {availableCards.length === 0 && (
                                <div className="card" style={{ padding: '3rem', textAlign: 'center' }}>
                                    <p style={{ color: 'var(--text-secondary)', fontSize: '1.1rem' }}>
                                        No wristband cards available. Please create cards in the Wristband Builder first.
                                    </p>
                                </div>
                            )}
                        </div>
                    );
                } else {
                    // Print Layout View - 4 copies in 2x2 grid
                    const card = wbSettings[selectedCardForPrint];
                    const cardNumber = selectedCardForPrint.replace('card', '');

                    // Get slots for this card
                    const getSlotsForCard = (cardId) => {
                        const cardData = wbSettings[cardId];
                        if (cardData.type === 'wiz' || cardData.type === 'rooski') {
                            const series = cardId === 'card1' ? 1 : (cardId === 'card2' ? 2 : (cardId === 'card3' ? 3 : (cardId === 'card4' ? 4 : (cardId === 'card5' ? 5 : 6))));
                            const slots = [];
                            for (let i = 1; i <= 16; i++) {
                                slots.push(`${series}${String(i).padStart(2, '0')}`);
                            }
                            return slots;
                        }
                        const start = cardId === 'card1' ? 101 : (cardId === 'card2' ? 201 : (cardId === 'card3' ? 301 : (cardId === 'card4' ? 401 : (cardId === 'card5' ? 501 : 601))));
                        const slots = [];
                        for (let i = start; i <= start + 47; i++) slots.push(i);
                        return slots;
                    };

                    // Build slot map from plays
                    const slotMap = {};
                    if (plays) {
                        plays.forEach(play => {
                            if (play.wristbandSlot) slotMap[play.wristbandSlot] = play;
                        });
                    }

                    const slots = getSlotsForCard(selectedCardForPrint);
                    const opponent = card.opp || card.opponent || '';

                    // Helper: Render Play Thumbnail for Print (WIZ Grid style)
                    const renderPlayThumbnail = (play, type = 'standard') => {
                        if (!play) return null;

                        let data = null;
                        if (type === 'skill' && (play.wizSkillData || play.rooskiSkillData)) {
                            data = { elements: play.wizSkillData || play.rooskiSkillData };
                        } else if (type === 'oline' && (play.wizOlineData || play.rooskiOlineData)) {
                            data = { elements: play.wizOlineData || play.rooskiOlineData };
                        } else if (play.diagramData) {
                            data = play.diagramData;
                        }

                        if (!data || !data.elements || data.elements.length === 0) return null;

                        // Fixed viewBox matching WIZ grid cell proportions
                        const fieldWidth = 800;
                        const fieldHeight = 460;
                        const viewBoxX = 0;
                        const viewBoxY = 60;

                        const routeColors = ['#ef4444', '#3b82f6', '#22c55e', '#eab308', '#a855f7', '#f97316', '#06b6d4', '#ec4899'];

                        return (
                            <svg viewBox={`${viewBoxX} ${viewBoxY} ${fieldWidth} ${fieldHeight}`} width="100%" height="100%" style={{ display: 'block', background: 'white', flex: 1 }} preserveAspectRatio="xMidYMid meet">
                                {/* Arrow markers */}
                                <defs>
                                    {routeColors.map(color => (
                                        <marker key={color} id={`print-arrow-${color.replace('#', '')}`} markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                                            <path d="M0,0 L0,6 L9,3 z" fill={color} />
                                        </marker>
                                    ))}
                                    <marker id="print-arrow-000000" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                                        <path d="M0,0 L0,6 L9,3 z" fill="#000000" />
                                    </marker>
                                </defs>

                                {/* Field background */}
                                <rect x={viewBoxX} y={viewBoxY} width={fieldWidth} height={fieldHeight} fill="white" />

                                {/* Yard lines - LEFT side, 5/10/15 going UP from bottom */}
                                <g stroke="#c4a052" strokeWidth="2">
                                    <line x1="250" y1="40" x2="250" y2="65" />
                                    <line x1="550" y1="40" x2="550" y2="65" />
                                </g>
                                <g fill="#888" fontSize="12" fontWeight="bold">
                                    <text x="12" y="365">5</text>
                                    <text x="8" y="265">10</text>
                                    <text x="8" y="165">15</text>
                                </g>
                                <g stroke="#ddd" strokeWidth="1">
                                    <line x1="30" y1="350" x2={fieldWidth - 15} y2="350" />
                                    <line x1="30" y1="250" x2={fieldWidth - 15} y2="250" />
                                    <line x1="30" y1="150" x2={fieldWidth - 15} y2="150" />
                                </g>

                                {data.elements.map(el => {
                                    if (el.type === 'player') {
                                        const { x, y } = el.points[0];
                                        const size = el.shape === 'text-only' ? 0 : 28;
                                        const isRect = el.shape === 'square';
                                        const isTextOnly = el.shape === 'text-only';
                                        const fontSize = isTextOnly ? (el.fontSize ? Math.min(el.fontSize * 0.25, 40) : 24) : 14;

                                        return (
                                            <g key={el.id}>
                                                {!isTextOnly && (isRect ? (
                                                    <rect x={x - size / 2} y={y - size / 2} width={size} height={size} fill="white" stroke={el.color} strokeWidth="3" />
                                                ) : (
                                                    <circle cx={x} cy={y} r={size / 2} fill="white" stroke={el.color} strokeWidth="3" />
                                                ))}
                                                <text x={x} y={y} dy="0.35em" textAnchor="middle" fontSize={fontSize} fontWeight="bold" fill={el.color}>{el.label}</text>
                                            </g>
                                        );
                                    }

                                    let d = '';
                                    if (el.style === 'zigzag') {
                                        d = getZigZagPath(el.points);
                                    } else if (el.type === 'free' || el.points.length > 1) {
                                        d = `M ${el.points.map(p => `${p.x},${p.y}`).join(' L ')}`;
                                    }

                                    let markerEnd = undefined;
                                    let tBlock = null;
                                    const colorHex = (el.color || '#000000').replace('#', '');

                                    if (el.endType === 'arrow' || (!el.endType && el.type !== 'free')) {
                                        markerEnd = `url(#print-arrow-${colorHex})`;
                                    } else if (el.endType === 't') {
                                        const end = el.points[el.points.length - 1];
                                        const prev = el.points[el.points.length - 2] || el.points[0];
                                        const dx = end.x - prev.x;
                                        const dy = end.y - prev.y;
                                        const len = Math.hypot(dx, dy) || 1;
                                        const perpX = (-dy / len) * 12;
                                        const perpY = (dx / len) * 12;
                                        tBlock = <line x1={end.x - perpX} y1={end.y - perpY} x2={end.x + perpX} y2={end.y + perpY} stroke={el.color} strokeWidth="5" />;
                                    } else if (el.endType === 'dot') {
                                        const end = el.points[el.points.length - 1];
                                        tBlock = <circle cx={end.x} cy={end.y} r="5" fill={el.color} />;
                                    } else if (el.type === 'arrow') {
                                        markerEnd = `url(#print-arrow-${colorHex})`;
                                    }

                                    return (
                                        <g key={el.id}>
                                            <path d={d} stroke={el.color} strokeWidth="5" fill="none" strokeDasharray={el.style === 'dashed' ? "8,4" : "none"} markerEnd={markerEnd} />
                                            {tBlock}
                                        </g>
                                    );
                                })}
                            </svg>
                        );
                    };

                    // Render the appropriate card type
                    let cardContent = null;
                    if (card.type === 'wiz' || card.type === 'rooski') {
                        // Wiz Rendering Logic adapted for Print
                        // 4x4 Grid for 3x5 card
                        const rows = [];
                        for (let i = 0; i < slots.length; i += 4) {
                            rows.push(slots.slice(i, i + 4));
                        }
                        const viewType = card.viewType || 'standard';

                        cardContent = (
                            <div className="wiz-grid-container" style={{ width: '5in', height: '3in', display: 'flex', flexDirection: 'column', border: '2px solid black', background: 'white' }}>
                                {/* Header */}
                                <div style={{
                                    background: 'black',
                                    color: 'white',
                                    fontWeight: 'bold',
                                    fontSize: '10pt',
                                    padding: '2px 4px',
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center'
                                }}>
                                    <span style={{ textTransform: 'uppercase' }}>{card.customHeader || 'WIZ'}</span>
                                    <span>{opponent}</span>
                                </div>
                                {/* Grid */}
                                <div style={{ flex: 1, display: 'flex', flexDirection: 'column' }}>
                                    {rows.map((rowSlots, rIndex) => (
                                        <div key={rIndex} style={{ flex: 1, display: 'flex', borderBottom: rIndex < rows.length - 1 ? '1px solid black' : 'none' }}>
                                            {rowSlots.map((slot, cIndex) => {
                                                const play = slotMap[slot];

                                                // Filter plays based on view type logic
                                                let shouldShowPlay = false;
                                                if (play) {
                                                    if (viewType === 'skill') {
                                                        // Relaxed filtering to allow Standard plays
                                                        shouldShowPlay = !play.isOlineOnly;
                                                    } else if (viewType === 'oline') {
                                                        // Relaxed filtering for oline view
                                                        shouldShowPlay = true;
                                                    } else {
                                                        shouldShowPlay = true; // standard/diagram view
                                                    }
                                                }

                                                const displayPlay = shouldShowPlay ? play : null;

                                                return (
                                                    <div key={slot} style={{
                                                        width: '25%', // Fixed width for print
                                                        flexShrink: 0,
                                                        borderRight: cIndex < 3 ? '1px solid black' : 'none',
                                                        display: 'flex',
                                                        flexDirection: 'column',
                                                        overflow: 'hidden'
                                                    }}>
                                                        {/* Diagram Area - fill the cell */}
                                                        <div style={{ flex: 1, display: 'flex', alignItems: 'stretch', justifyContent: 'stretch', overflow: 'hidden', background: 'white' }}>
                                                            {displayPlay && renderPlayThumbnail(displayPlay, viewType)}
                                                        </div>
                                                        {/* Info Row - compact like the reference */}
                                                        <div style={{ display: 'flex', borderTop: '1px solid black', height: '12px', minHeight: '12px', maxHeight: '12px', fontSize: '7px', background: 'white' }}>
                                                            <div style={{ width: '22px', display: 'flex', alignItems: 'center', justifyContent: 'center', borderRight: '1px solid black', fontWeight: 'bold', color: '#000' }}>{slot}</div>
                                                            <div style={{ flex: 1, minWidth: 0, display: 'flex', alignItems: 'center', paddingLeft: '2px', overflow: 'hidden', whiteSpace: 'nowrap', fontWeight: 'bold', color: '#000' }}>
                                                                {displayPlay ? (displayPlay.wizName || displayPlay.name) : ''}
                                                            </div>
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        );
                    } else {
                        // Traditional and script cards - proper rendering matching WristbandBuilder
                        const isMiniScripts = card.type === 'mini-scripts';
                        const cardType = isMiniScripts ? 'SCRIPT' : 'TRADITIONAL';
                        const rowHeight = 11;
                        const fontSize = 0.55; // rem

                        // Prepare Data Rows
                        let displayRows = [];
                        if (isMiniScripts) {
                            displayRows = (card.rows || []).map((row, idx) => {
                                const slotNum = slots[0] + idx; // Calculate slot based on start
                                if (row.type === 'play') {
                                    const play = plays.find(p => p.id === row.playId);
                                    const playName = row.playName || play?.name || 'Unknown';
                                    const wsSlot = play?.wristbandSlot || '';
                                    const displayText = wsSlot ? `[${wsSlot}] ${playName}` : playName;
                                    return { slot: slotNum, text: displayText, type: row.type, color: row.color };
                                } else {
                                    return { slot: slotNum, text: row.label, type: row.type, color: row.color };
                                }
                            });
                        } else if (card.type === 'modular') {
                            const colorBase = card.color || 'white';
                            const colorMap = {
                                'green-light': '#d1fae5', 'green-medium': '#a7f3d0',
                                'orange-light': '#fed7aa', 'orange-medium': '#fdba74',
                                'red-light': '#fecaca', 'red-medium': '#fca5a5',
                                'blue-light': '#bfdbfe', 'blue-medium': '#93c5fd',
                                'yellow-light': '#fef08a', 'yellow-medium': '#fde047',
                                'purple-light': '#e9d5ff', 'purple-medium': '#d8b4fe',
                                'teal-light': '#99f6e4', 'teal-medium': '#5eead4',
                                'pink-light': '#fbcfe8', 'pink-medium': '#f9a8d4'
                            };

                            const startSlot = slots[0];
                            let logicalSlot = startSlot;
                            let displaySlotCounter = startSlot;

                            displayRows = [];
                            (card.rows || []).forEach((row, idx) => {
                                const isHeader = row.type === 'header' || row.type === 'tempo';

                                if (isHeader && logicalSlot % 2 === 0) {
                                    displayRows.push({
                                        slot: logicalSlot,
                                        type: 'spacer',
                                        text: ''
                                    });
                                    logicalSlot++;
                                }

                                const currentLogical = logicalSlot;

                                let rowColor = 'transparent';
                                if (colorBase && colorBase !== 'white' && colorBase !== 'gray') {
                                    const shade = Math.floor(idx / 2) % 2 === 0 ? 'light' : 'medium';
                                    rowColor = colorMap[`${colorBase}-${shade}`] || 'transparent';
                                }

                                if (isHeader) {
                                    let text = (row.type === 'header') ? (row.label || 'SECTION') : (row.label || row.tempoType || 'TEMPO');
                                    displayRows.push({
                                        slot: currentLogical,
                                        displaySlot: '',
                                        type: row.type,
                                        text: text,
                                        isHeader: isHeader,
                                        color: rowColor
                                    });
                                    displayRows.push({
                                        slot: currentLogical + 1,
                                        type: 'spacer',
                                        text: '',
                                        color: rowColor
                                    });
                                    logicalSlot += 2;
                                } else {
                                    let slotDisplay = displaySlotCounter;
                                    displaySlotCounter++;

                                    let text = '';
                                    const play = plays.find(p => p.id === row.playId);
                                    text = play ? (row.playName || play.name) : 'Unknown';
                                    if (play && play.formation && !play.name.toLowerCase().includes(play.formation.toLowerCase())) text += ' - ' + play.formation;

                                    displayRows.push({
                                        slot: currentLogical,
                                        displaySlot: slotDisplay,
                                        type: row.type,
                                        text: text,
                                        isHeader: false,
                                        color: rowColor
                                    });
                                    logicalSlot++;
                                }
                            });
                        } else {
                            // Traditional Card Color Logic
                            const colorBase = card.color || 'white';
                            // Define color map directly here since we can't easily access the one in WristbandBuilder
                            const colorMap = {
                                'green-light': '#d1fae5', 'green-medium': '#a7f3d0',
                                'orange-light': '#fed7aa', 'orange-medium': '#fdba74',
                                'red-light': '#fecaca', 'red-medium': '#fca5a5',
                                'blue-light': '#bfdbfe', 'blue-medium': '#93c5fd',
                                'yellow-light': '#fef08a', 'yellow-medium': '#fde047',
                                'purple-light': '#e9d5ff', 'purple-medium': '#d8b4fe',
                                'teal-light': '#99f6e4', 'teal-medium': '#5eead4',
                                'pink-light': '#fbcfe8', 'pink-medium': '#f9a8d4'
                            };

                            displayRows = slots.map((slot, idx) => {
                                const play = slotMap[slot];

                                // Calculate alternating row color
                                let rowColor = 'transparent';
                                if (colorBase && colorBase !== 'white' && colorBase !== 'gray') {
                                    // Alternating shades logic: light, medium
                                    // Use Math.floor(idx / 2) to ensure both columns in the same row get the same shade
                                    const shade = Math.floor(idx / 2) % 2 === 0 ? 'light' : 'medium';
                                    rowColor = colorMap[`${colorBase}-${shade}`] || 'transparent';
                                }

                                return {
                                    slot: slot,
                                    text: play ? `${play.name}${play.formation && !checkRedundantFormation(play.name, play.formation) ? ' - ' + play.formation : ''}` : '',
                                    type: 'play',
                                    color: rowColor
                                };
                            });
                        }

                        // Split into Odd/Even Columns
                        const col1 = [];
                        const col2 = [];
                        displayRows.forEach(row => {
                            if (parseInt(row.slot) % 2 === 1) col1.push(row);
                            else col2.push(row);
                        });

                        // Ensure equal length for table rendering
                        const rowCount = Math.max(col1.length, col2.length, 24);
                        const tableRows = [];
                        for (let i = 0; i < rowCount; i++) {
                            tableRows.push([col1[i] || null, col2[i] || null]);
                        }

                        cardContent = (
                            <div style={{ width: '5in', height: '3in', border: '2px solid black', background: 'white', display: 'flex', flexDirection: 'column' }}>
                                {/* Header */}
                                <div style={{
                                    background: 'black',
                                    color: 'white',
                                    fontWeight: 'bold',
                                    fontSize: '10pt',
                                    padding: '0 2px',
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center'
                                }}>
                                    <span style={{ textTransform: 'uppercase' }}>{card.customHeader || cardType}</span>
                                    <span>{opponent}</span>
                                </div>
                                {/* Table Grid */}
                                <table className="wristband-spreadsheet-table" style={{ borderCollapse: 'collapse', width: '100%', flex: 1 }}>
                                    <tbody>
                                        {tableRows.map((rowGroup, rowIndex) => (
                                            <tr key={rowIndex}>
                                                {rowGroup.map((cellData, colIndex) => {
                                                    const isTempo = cellData?.type === 'tempo';
                                                    const isLastRow = rowIndex === tableRows.length - 1;
                                                    const boBottom = isLastRow ? 'none' : '1px solid #333';

                                                    if (!cellData) return (
                                                        <React.Fragment key={colIndex}>
                                                            <td style={{
                                                                border: '1px solid #333',
                                                                borderLeft: colIndex === 0 ? 'none' : '1px solid #333',
                                                                borderRight: colIndex === 1 ? 'none' : '1px solid #333',
                                                                borderBottom: boBottom,
                                                                width: '30px'
                                                            }} />
                                                            <td style={{
                                                                border: '1px solid #333',
                                                                borderLeft: '1px solid #333',
                                                                borderRight: colIndex === 1 ? 'none' : '1px solid #333',
                                                                borderBottom: boBottom,
                                                            }} />
                                                        </React.Fragment>
                                                    );

                                                    // Header/Tempo Row Render
                                                    if (cellData.isHeader) {
                                                        const isTempo = cellData.type === 'tempo';
                                                        return (
                                                            <React.Fragment key={`${colIndex}-${cellData.slot}`}>
                                                                <td
                                                                    colSpan={4}
                                                                    style={{
                                                                        fontWeight: 'bold',
                                                                        background: isTempo ? '#ffedd5' : '#333',
                                                                        color: isTempo ? 'black' : 'white',
                                                                        textAlign: 'center',
                                                                        border: '1px solid #333',
                                                                        height: `${fontSize + 0.5}rem`, // Adjust height slightly for preview
                                                                        fontSize: `${fontSize}rem`,
                                                                        verticalAlign: 'middle',
                                                                        overflow: 'hidden',
                                                                        whiteSpace: 'nowrap',
                                                                        borderBottom: boBottom
                                                                    }}
                                                                >
                                                                    {cellData.text}
                                                                </td>
                                                            </React.Fragment>
                                                        );
                                                    }

                                                    if (cellData.type === 'spacer') {
                                                        return null;
                                                    }

                                                    return (
                                                        <React.Fragment key={`${colIndex}-${cellData.slot}`}>
                                                            {/* Slot Number */}
                                                            <td style={{
                                                                fontWeight: 'bold',
                                                                width: '30px',
                                                                padding: '0 2px',
                                                                border: '1px solid #333',
                                                                borderLeft: colIndex === 0 ? 'none' : '1px solid #333',
                                                                borderBottom: boBottom,
                                                                fontSize: `${fontSize}rem`,
                                                                textAlign: 'center',
                                                                verticalAlign: 'middle',
                                                                color: 'black'
                                                            }}>
                                                                {cellData.displaySlot !== undefined ? cellData.displaySlot : cellData.slot}
                                                            </td>
                                                            {/* Play Name / Text */}
                                                            <td style={{
                                                                padding: '0 2px',
                                                                border: '1px solid #333',
                                                                borderRight: colIndex === 1 ? 'none' : '1px solid #333',
                                                                borderBottom: boBottom,
                                                                fontSize: `${fontSize}rem`,
                                                                verticalAlign: 'middle',
                                                                fontWeight: isTempo ? 'bold' : 'normal',
                                                                background: cellData.color || (isTempo ? '#ffedd5' : 'transparent'),
                                                                WebkitPrintColorAdjust: 'exact',
                                                                printColorAdjust: 'exact',
                                                                color: 'black',
                                                                overflow: 'hidden',
                                                                whiteSpace: 'nowrap',
                                                                maxWidth: '0' // Force overflow
                                                            }}>
                                                                <div style={{ overflow: 'hidden', textOverflow: 'ellipsis' }}>
                                                                    {cellData.text}
                                                                </div>
                                                            </td>
                                                        </React.Fragment>
                                                    );
                                                })}
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        );
                    }

                    const printContent = (
                        <div className="wristband-print-container" style={{
                            display: 'grid',
                            gridTemplateColumns: '1fr 1fr',
                            gridTemplateRows: '1fr 1fr',
                            width: '10.5in',
                            height: '7.5in',
                            gap: '0.25in',
                            margin: '0.25in auto',
                            background: 'white',
                            boxSizing: 'border-box'
                        }}>
                            {[1, 2, 3, 4].map(i => (
                                <div key={i} style={{
                                    width: '100%',
                                    height: '100%',
                                    display: 'flex',
                                    justifyContent: 'center',
                                    alignItems: 'center',
                                    border: 'none'
                                }}>
                                    <div style={{ transform: 'scale(1)', transformOrigin: 'center' }}>
                                        {cardContent}
                                    </div>
                                </div>
                            ))}
                        </div>
                    );

                    return (
                        <div>
                            <div className="no-print" style={{ padding: '1rem', background: '#333', color: 'white', marginBottom: '1rem', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                <div>
                                    <div style={{ marginBottom: '0.5rem' }}>
                                        <strong>Wristband Print Preview</strong> - Card {cardNumber} (4 copies per page)
                                    </div>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                        <label style={{ fontSize: '0.9rem', opacity: 0.8 }}>Header Title:</label>
                                        <input
                                            type="text"
                                            value={card.customHeader !== undefined ? card.customHeader : ((card.type === 'wiz' || card.type === 'rooski') ? 'WIZ' : (card.type === 'mini-scripts' ? 'SCRIPT' : 'TRADITIONAL'))}
                                            onChange={(e) => {
                                                const newHeader = e.target.value;
                                                setWbSettings(prev => ({
                                                    ...prev,
                                                    [selectedCardForPrint]: { ...prev[selectedCardForPrint], customHeader: newHeader }
                                                }));
                                            }}
                                            style={{
                                                background: 'rgba(255,255,255,0.1)',
                                                border: '1px solid rgba(255,255,255,0.2)',
                                                color: 'white',
                                                padding: '2px 8px',
                                                borderRadius: '4px',
                                                width: '200px',
                                                fontSize: '0.9rem'
                                            }}
                                        />
                                    </div>
                                </div>
                                <div style={{ display: 'flex', gap: '1rem' }}>
                                    <button onClick={() => setSelectedCardForPrint(null)} className="btn btn-secondary">
                                        <Icon name="ChevronLeft" /> Change Card
                                    </button>
                                    <button onClick={() => window.print()} className="btn btn-primary">
                                        <Icon name="Printer" /> Print
                                    </button>
                                </div>
                            </div>

                            {/* On-Screen Preview */}
                            <div style={{ transform: 'scale(0.8)', transformOrigin: 'top center', marginBottom: '2rem' }}>
                                {printContent}
                            </div>

                            {/* Print Portal - Hidden on Screen, Visible on Print */}
                            {ReactDOM.createPortal(
                                <div className="print-only-portal">
                                    {printContent}
                                </div>,
                                document.body
                            )}
                        </div>
                    );
                }
            }

            return (
                <div style={{ padding: '2rem', maxWidth: '1200px', margin: '0 auto' }}>
                    <div style={{ marginBottom: '2rem' }}>
                        <h1 style={{ fontSize: '2.5rem', marginBottom: '0.5rem' }}>Print Center</h1>
                        <p style={{ color: 'var(--text-secondary)' }}>Central hub for printing all coaching documents.</p>
                    </div>

                    <div style={{ display: 'flex', flexDirection: 'column', gap: '3rem' }}>
                        {categories.map(cat => (
                            <div key={cat.id}>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.75rem', marginBottom: '1.5rem', borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem' }}>
                                    <div style={{ color: 'var(--accent)' }}>
                                        <Icon name={cat.icon} size={24} />
                                    </div>
                                    <h2 style={{ fontSize: '1.5rem', fontWeight: 'bold', margin: 0 }}>{cat.label}</h2>
                                </div>
                                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '1.5rem' }}>
                                    {printOptions[cat.id].map(option => (
                                        <div key={option.id} className="card" style={{ padding: '1.5rem', display: 'flex', flexDirection: 'column', gap: '1rem', transition: 'transform 0.2s', cursor: 'pointer' }}
                                            onClick={() => handlePrint(option.id)}
                                            onMouseEnter={e => e.currentTarget.style.transform = 'translateY(-4px)'}
                                            onMouseLeave={e => e.currentTarget.style.transform = 'translateY(0)'}
                                        >
                                            <div style={{ width: '48px', height: '48px', borderRadius: '12px', background: 'var(--bg-input)', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'var(--accent)' }}>
                                                <Icon name={option.icon} size={24} />
                                            </div>
                                            <div>
                                                <h3 style={{ fontSize: '1.25rem', marginBottom: '0.5rem' }}>{option.label}</h3>
                                                <p style={{ color: 'var(--text-secondary)', fontSize: '0.9rem', margin: 0 }}>{option.desc}</p>
                                            </div>
                                            <div style={{ marginTop: 'auto', paddingTop: '1rem' }}>
                                                <button className="btn btn-secondary" style={{ width: '100%' }}>
                                                    <Icon name="Printer" size={16} /> Print
                                                </button>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };


        const PlaybookSidebar = ({ plays, weekInstallIds = [] }) => {
            const [searchTerm, setSearchTerm] = useState('');
            // Store toggle state separately from search visibility
            const [userExpanded, setUserExpanded] = useState({
                'runs': true, 'passes': false, 'screens': false,
                'runs-week': true // Default open
            });

            // Toggle function handling user interactions
            const toggle = (id) => setUserExpanded(prev => ({ ...prev, [id]: !prev[id] }));

            // Memoize filtered plays to avoid recalculating on every render/keystroke
            const getFilteredPlays = (type, subFilter) => {
                let filtered = plays.filter(p => !p.archived);
                // 1. Basic Type Filter
                if (type === 'Run') filtered = filtered.filter(p => p.type === 'Run' || p.type === 'RPO');
                if (type === 'Pass') filtered = filtered.filter(p => p.type === 'Pass' || p.type === 'Play Action');
                if (type === 'Screen') filtered = filtered.filter(p => p.type === 'Screen');

                // 2. Search Filter (Global within type)
                if (searchTerm) {
                    const term = searchTerm.toLowerCase();
                    filtered = filtered.filter(p => p.name.toLowerCase().includes(term));
                }

                // 3. Sub-Filters
                if (subFilter === 'Inside') return filtered.filter(p => p.concept?.includes('Inside') || p.tags?.includes('Inside'));
                if (subFilter === 'Perimeter') return filtered.filter(p => p.concept?.includes('Outside') || p.concept?.includes('Perimeter') || p.tags?.includes('Outside'));
                if (subFilter === 'RPO') return filtered.filter(p => p.type === 'RPO' || p.name.includes('RPO'));
                if (subFilter === 'Week-Run') return filtered.filter(p => weekInstallIds.includes(p.id) && (p.type === 'Run' || p.type === 'RPO'));

                if (subFilter === 'Quick') return filtered.filter(p => p.concept?.includes('Quick') || p.tags?.includes('Quick'));
                if (subFilter === 'Intermediate') return filtered.filter(p => p.concept?.includes('Intermediate'));
                if (subFilter === 'Shot') return filtered.filter(p => p.concept?.includes('Shot') || p.tags?.includes('Shot'));
                if (subFilter === 'PA') return filtered.filter(p => p.type === 'Play Action' || p.name.includes('PA') || p.name.includes('Play Action'));
                if (subFilter === 'Week-Pass') return filtered.filter(p => weekInstallIds.includes(p.id) && (p.type === 'Pass' || p.type === 'Play Action'));

                if (subFilter === 'Week-Screen') return filtered.filter(p => weekInstallIds.includes(p.id) && p.type === 'Screen');

                return filtered;
            };

            const renderDraggablePlay = (play) => (
                <div
                    key={play.id}
                    draggable
                    onDragStart={(e) => {
                        e.dataTransfer.setData('application/react-dnd', JSON.stringify({ playId: play.id }));
                        e.dataTransfer.effectAllowed = 'copy';
                    }}
                    style={{
                        padding: '4px 8px', fontSize: '0.85rem', cursor: 'grab',
                        borderBottom: '1px solid #f1f5f9', background: 'white',
                        whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis',
                        color: 'black' // Explicit black for high contrast
                    }}
                    title={play.name}
                >
                    {play.priority && <span style={{ color: '#ca8a04', marginRight: '4px', fontWeight: 'bold' }}>★</span>}
                    {getPlayDisplayName(play)}
                </div>
            );

            const renderCategory = (id, label, items, level = 0) => {
                // If searching, always expand if there are items. If not searching, use user state.
                const isSearching = searchTerm.length > 0;
                const isOpen = isSearching ? items.length > 0 : userExpanded[id];

                // If searching and no items, hide the category entirely to reduce noise
                if (isSearching && items.length === 0) return null;

                return (
                    <div style={{ marginLeft: level * 8 }}>
                        <div
                            onClick={() => toggle(id)}
                            style={{
                                padding: '6px 8px', fontWeight: 'bold', fontSize: '0.9rem',
                                cursor: 'pointer', background: '#f1f5f9', borderBottom: '1px solid #cbd5e1',
                                display: 'flex', alignItems: 'center', justifyContent: 'space-between',
                                color: 'black' // High contrast
                            }}
                        >
                            <span>{label} <span style={{ fontWeight: 'normal', fontSize: '0.8em', color: '#64748b' }}>({items.length})</span></span>
                            <span style={{ color: '#64748b' }}>{isOpen ? '▼' : '▶'}</span>
                        </div>
                        {isOpen && (
                            <div style={{ borderLeft: '2px solid #e2e8f0' }}>
                                {items.length > 0 ? items.map(renderDraggablePlay) : <div style={{ padding: '4px 8px', color: '#64748b', fontSize: '0.8rem', fontStyle: 'italic' }}>No plays</div>}
                            </div>
                        )}
                    </div>
                );
            };

            const renderParentCategory = (id, label, children, hasResults) => {
                const isSearching = searchTerm.length > 0;
                // If searching, expand if any children have results (passed via prop or implied?)
                // For parents, we'll just check if they are toggled or if we are searching (expand all parents on search for simplicity)
                const isOpen = isSearching ? true : userExpanded[id];

                return (
                    <div>
                        <div
                            onClick={() => toggle(id)}
                            style={{
                                padding: '10px 8px', fontWeight: '900', fontSize: '1rem',
                                cursor: 'pointer', background: '#e2e8f0', borderBottom: '1px solid #94a3b8',
                                display: 'flex', alignItems: 'center', justifyContent: 'space-between',
                                color: 'black'
                            }}
                        >
                            {label}
                            <span style={{ color: '#475569' }}>{isOpen ? '▼' : '▶'}</span>
                        </div>
                        {isOpen && (
                            <div>{children}</div>
                        )}
                    </div>
                );
            };


            return (
                <div style={{ width: '280px', borderRight: '2px solid black', display: 'flex', flexDirection: 'column', background: '#fff' }}>
                    <div style={{ padding: '12px', borderBottom: '2px solid black', background: '#f8fafc' }}>
                        <input
                            placeholder={`Search ${plays.length} plays...`}
                            value={searchTerm}
                            onChange={(e) => setSearchTerm(e.target.value)}
                            style={{
                                width: '100%', padding: '8px', fontSize: '0.9rem',
                                border: '1px solid #64748b', borderRadius: '4px',
                                color: 'black'
                            }}
                        />
                    </div>
                    <div style={{ flex: 1, overflowY: 'auto' }}>
                        {/* RUNS / RPOS */}
                        {renderParentCategory('runs', 'RUNS / RPOs', (
                            <>
                                {renderCategory('runs-inside', 'Inside Runs', getFilteredPlays('Run', 'Inside'), 1)}
                                {renderCategory('runs-rpo', 'RPOs', getFilteredPlays('Run', 'RPO'), 1)}
                                {renderCategory('runs-perimeter', 'Perimeter', getFilteredPlays('Run', 'Perimeter'), 1)}
                                {renderCategory('runs-week', "This Week", getFilteredPlays('Run', 'Week-Run'), 1)}
                            </>
                        ))}

                        {/* PASSES */}
                        {renderParentCategory('passes', 'PASSES', (
                            <>
                                {renderCategory('passes-quick', 'Quick Game', getFilteredPlays('Pass', 'Quick'), 1)}
                                {renderCategory('passes-inter', 'Intermediate', getFilteredPlays('Pass', 'Intermediate'), 1)}
                                {renderCategory('passes-shot', 'Shots', getFilteredPlays('Pass', 'Shot'), 1)}
                                {renderCategory('passes-pa', 'Play Action', getFilteredPlays('Pass', 'PA'), 1)}
                                {renderCategory('passes-week', "This Week", getFilteredPlays('Pass', 'Week-Pass'), 1)}
                            </>
                        ))}

                        {/* SCREENS */}
                        {renderParentCategory('screens', 'SCREENS', (
                            <>
                                {renderCategory('screens-all', 'All Screens', getFilteredPlays('Screen'), 1)}
                                {renderCategory('screens-week', 'This Week', getFilteredPlays('Screen', 'Week-Screen'), 1)}
                            </>
                        ))}

                        {/* GLOBAL SEARCH RESULTS (Uncategorized / All) */}
                        {searchTerm.length > 1 && (
                            <div style={{ marginTop: '0', borderTop: '2px solid black' }}>
                                <div style={{
                                    padding: '10px 8px', fontWeight: '900', fontSize: '1rem',
                                    background: '#fef3c7', /* Amber-100 for visibility */
                                    borderBottom: '1px solid #d97706', color: '#78350f',
                                    display: 'flex', justifyContent: 'space-between', alignItems: 'center'
                                }}>
                                    <span>SEARCH RESULTS</span>
                                    <span style={{ fontSize: '0.8rem', color: '#92400e' }}>
                                        ({plays.filter(p => !p.archived && p.name.toLowerCase().includes(searchTerm.toLowerCase())).length})
                                    </span>
                                </div>
                                <div>
                                    {plays
                                        .filter(p => !p.archived && p.name.toLowerCase().includes(searchTerm.toLowerCase()))
                                        .map(renderDraggablePlay)}
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        function GamePlannerSideMenu({ plays, practicePlans, onQuickAddPlay, isOpen, onToggle, weekStats, gamePlan, gamePlanLayouts, playBuckets, playCategories, onAddSection, onUpdatePlay, onUpdateGamePlan, currentWeek }) {
            const [searchTerm, setSearchTerm] = useState('');
            const [quickAddValue, setQuickAddValue] = useState('');
            const [activeTab, setActiveTab] = useState('usage'); // usage, gameplan, install
            const [expandedSections, setExpandedSections] = useState({});
            const [situationModalPlayId, setSituationModalPlayId] = useState(null);

            const toggleSection = (id) => {
                setExpandedSections(prev => ({
                    ...prev,
                    [id]: !prev[id]
                }));
            };

            // Calculate Usage
            const playUsage = useMemo(() => {
                const map = {};
                (plays || []).forEach(p => {
                    map[p.id] = { total: 0, days: { M: 0, T: 0, W: 0, TH: 0, F: 0 } };
                });

                if (practicePlans) {
                    const dayMapping = {
                        'MONDAY': 'M',
                        'TUESDAY': 'T',
                        'WEDNESDAY': 'W',
                        'THURSDAY': 'TH',
                        'FRIDAY': 'F'
                    };

                    Object.entries(practicePlans).forEach(([day, plan]) => {
                        const keyUpper = day.toUpperCase();
                        const dayKey = dayMapping[keyUpper] || keyUpper;

                        if (!['M', 'T', 'W', 'TH', 'F'].includes(dayKey)) return;

                        (plan.segments || []).forEach(seg => {
                            (seg.script || []).forEach(item => {
                                const pid = (typeof item === 'object') ? (item.playId || item.id) : item; // Handle object with playId/id or string
                                if (pid && map[pid]) {
                                    map[pid].total++;
                                    if (map[pid].days[dayKey] !== undefined) {
                                        map[pid].days[dayKey]++;
                                    }
                                }
                            });
                        });
                    });
                }
                return map;
            }, [plays, practicePlans]);

            // Grouping for "Usage" Tab (Buckets Style)
            const usageData = useMemo(() => {
                let filteredPlays = (plays || []).filter(p => !p.archived);
                const query = searchTerm.toLowerCase();

                // Map of filtered plays for quick lookup
                const filteredMap = {};
                filteredPlays.forEach(p => {
                    if (!searchTerm ||
                        p.name.toLowerCase().includes(query) ||
                        p.formation?.toLowerCase().includes(query) ||
                        p.concept?.toLowerCase().includes(query)) {
                        filteredMap[p.id] = p;
                    }
                });

                const categories = (playCategories || []).map(cat => {
                    const families = (playBuckets || []).filter(b => b.categoryId === cat.id).map(bucket => {
                        // Find plays assigned to this category and family label
                        const bucketPlays = Object.values(filteredMap).filter(p =>
                            p.bucketId === cat.id && p.conceptFamily === bucket.label
                        ).sort((a, b) => a.name.localeCompare(b.name));

                        return { ...bucket, plays: bucketPlays };
                    }).filter(f => searchTerm ? f.plays.length > 0 : true);

                    const totalPlays = families.reduce((sum, f) => sum + f.plays.length, 0);
                    return { ...cat, families, totalPlays };
                }).filter(c => searchTerm ? c.totalPlays > 0 : true);

                // Find unassigned plays (those not matching a category/family combination)
                const unassignedPlays = Object.values(filteredMap).filter(p => {
                    if (!p.bucketId || !p.conceptFamily) return true;
                    // Also unassigned if its bucketId or conceptFamily doesn't exist in setup
                    const catExists = (playCategories || []).some(cat => cat.id === p.bucketId);
                    const bucketExists = (playBuckets || []).some(b => b.categoryId === p.bucketId && b.label === p.conceptFamily);
                    return !catExists || !bucketExists;
                }).sort((a, b) => a.name.localeCompare(b.name));

                if (unassignedPlays.length > 0 || !searchTerm) {
                    categories.push({
                        id: 'unassigned',
                        label: 'Unassigned',
                        color: '#64748b',
                        families: [{ id: 'unassigned-family', label: 'Other Plays', plays: unassignedPlays }],
                        totalPlays: unassignedPlays.length
                    });
                }

                return categories;
            }, [plays, playCategories, playBuckets, searchTerm]);

            const installData = useMemo(() => {
                const installList = currentWeek?.installList || [];
                const installedPlays = (plays || []).filter(p => !p.archived && installList.includes(p.id));
                const query = searchTerm.toLowerCase();

                // Map of filtered plays for quick lookup
                const filteredMap = {};
                installedPlays.forEach(p => {
                    if (!searchTerm ||
                        p.name.toLowerCase().includes(query) ||
                        p.formation?.toLowerCase().includes(query) ||
                        p.concept?.toLowerCase().includes(query)) {
                        filteredMap[p.id] = p;
                    }
                });

                const categories = (playCategories || []).map(cat => {
                    const families = (playBuckets || []).filter(b => b.categoryId === cat.id).map(bucket => {
                        const bucketPlays = Object.values(filteredMap).filter(p =>
                            p.bucketId === cat.id && p.conceptFamily === bucket.label
                        ).sort((a, b) => a.name.localeCompare(b.name));

                        return { ...bucket, plays: bucketPlays };
                    }).filter(f => searchTerm ? f.plays.length > 0 : true);

                    const totalPlays = families.reduce((sum, f) => sum + f.plays.length, 0);
                    return { ...cat, families, totalPlays };
                }).filter(c => searchTerm ? c.totalPlays > 0 : true);

                // Find unassigned plays that are installed
                const unassignedPlays = Object.values(filteredMap).filter(p => {
                    if (!p.bucketId || !p.conceptFamily) return true;
                    const catExists = (playCategories || []).some(cat => cat.id === p.bucketId);
                    const bucketExists = (playBuckets || []).some(b => b.categoryId === p.bucketId && b.label === p.conceptFamily);
                    return !catExists || !bucketExists;
                }).sort((a, b) => a.name.localeCompare(b.name));

                if (unassignedPlays.length > 0 || !searchTerm) {
                    categories.push({
                        id: 'unassigned-install',
                        label: 'Uncategorized',
                        color: '#64748b',
                        families: [{ id: 'unassigned-install-family', label: 'Other Installed Plays', plays: unassignedPlays }],
                        totalPlays: unassignedPlays.length
                    });
                }

                return categories;
            }, [plays, playCategories, playBuckets, currentWeek, searchTerm]);

            const handleDragStart = (e, play) => {
                e.dataTransfer.setData('application/react-dnd', JSON.stringify({ playId: play.id, name: play.name })); // Pass name too just in case
                e.dataTransfer.effectAllowed = 'copy';
            };

            const handleAssignSituation = (playId, situationId, type) => {
                if (!onUpdateGamePlan) return;

                const updatedGamePlan = { ...gamePlan };

                // Helper to find and update target in sets or miniScripts
                const findAndAdd = (list) => {
                    if (!list) return false;
                    let found = false;
                    if (Array.isArray(list)) {
                        const target = list.find(s => s.id === situationId);
                        if (target) {
                            if (!target.assignedPlayIds) target.assignedPlayIds = [];
                            if (!target.assignedPlayIds.includes(playId)) {
                                target.assignedPlayIds.push(playId);
                                found = true;
                            }
                        }
                    } else if (typeof list === 'object') {
                        const target = list[situationId];
                        if (target) {
                            if (!target.assignedPlayIds) target.assignedPlayIds = [];
                            if (!target.assignedPlayIds.includes(playId)) {
                                target.assignedPlayIds.push(playId);
                                found = true;
                            }
                        }
                    }
                    return found;
                };

                const updatedSets = findAndAdd(updatedGamePlan.sets);
                const updatedMinis = findAndAdd(updatedGamePlan.miniScripts);

                if (updatedSets || updatedMinis) {
                    onUpdateGamePlan(updatedGamePlan);
                }
            };

            const renderRow = (play) => {
                const u = playUsage[play.id] || { days: { M: 0, T: 0, W: 0, TH: 0, F: 0 } };
                return (
                    <div
                        key={play.id}
                        style={{ display: 'flex', alignItems: 'center', padding: '6px 0', borderBottom: '1px solid #f1f5f9', fontSize: '0.8rem', cursor: 'default' }}
                        onDoubleClick={() => setSituationModalPlayId(play.id)}
                    >
                        <div
                            draggable
                            onDragStart={(e) => handleDragStart(e, play)}
                            style={{ flex: 1, minWidth: 0, cursor: 'grab' }}
                        >
                            <div style={{ fontWeight: '500', color: '#1e293b', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                                {play.name}
                            </div>
                            {play.priority && <div style={{ fontSize: '0.7rem', color: '#ca8a04' }}>★</div>}
                        </div>
                        <div style={{ display: 'flex', gap: '2px', marginLeft: '8px', flexShrink: 0 }}>
                            {['M', 'T', 'W', 'TH', 'F'].map(day => (
                                <div key={day} style={{
                                    width: '18px', height: '18px', display: 'flex', alignItems: 'center', justifyContent: 'center',
                                    background: u.days[day] > 0 ? '#1e293b' : '#f1f5f9',
                                    color: u.days[day] > 0 ? 'white' : '#94a3b8',
                                    fontWeight: '900', fontSize: '0.6rem', borderRadius: '2px'
                                }}>
                                    {u.days[day] > 0 ? u.days[day] : ''}
                                </div>
                            ))}
                        </div>
                    </div>
                );
            };

            const renderGamePlanContent = () => {
                if (!gamePlanLayouts) return <div style={{ padding: '1rem', color: '#64748b' }}>No Game Plan Layouts found.</div>;

                // Helper to get plays for a section
                const getPlaysForSection = (type, sectionId, extraData = {}) => {
                    let playList = [];
                    if (type === 'matrix_formation') {
                        // Matrix logic
                        const matrixFormation = extraData.formation;
                        const playIds = new Set();
                        const layout = gamePlanLayouts?.MATRIX;
                        if (layout) {
                            layout.playTypes.forEach(pt => {
                                layout.cols.forEach(col => {
                                    const setId = `matrix_${matrixFormation.id}_${pt.id}_${col.id}`;
                                    const cellData = gamePlan?.sets?.find(s => s.id === setId);
                                    if (cellData && cellData.assignedPlayIds) cellData.assignedPlayIds.forEach(id => playIds.add(id));
                                    else if (cellData && cellData.playIds) cellData.playIds.forEach(id => playIds.add(id));
                                });
                            });
                        }
                        playList = Array.from(playIds).map(id => plays.find(p => p.id === id)).filter(Boolean);
                    } else {

                        // Standard set logic
                        let rawIds = [];

                        // 1. Try Game Plan Data (Primary)
                        const setInSets = gamePlan?.sets?.[sectionId] || (Array.isArray(gamePlan?.sets) ? gamePlan.sets.find(s => s.id === sectionId) : null);
                        const setInMini = gamePlan?.miniScripts?.[sectionId] || (Array.isArray(gamePlan?.miniScripts) ? gamePlan.miniScripts.find(s => s.id === sectionId) : null);
                        const setData = setInSets || setInMini;

                        if (setData && (setData.assignedPlayIds || setData.playIds)) {
                            rawIds = setData.assignedPlayIds || setData.playIds || [];
                        }

                        // 2. Fallback to Layouts (Parallel Process - Fail-safe)
                        if ((!rawIds || rawIds.length === 0) && gamePlanLayouts?.CALL_SHEET?.sections) {
                            for (const sec of gamePlanLayouts.CALL_SHEET.sections) {
                                if (!sec.boxes) continue;
                                const box = sec.boxes.find(b => b.setId === sectionId);
                                if (box) {
                                    // For Grids
                                    if (box.assignedPlayIds && box.assignedPlayIds.length > 0) {
                                        rawIds = box.assignedPlayIds;
                                    }
                                    // For Scripts
                                    else if (box.rows) {
                                        const scriptIds = [];
                                        box.rows.forEach(r => {
                                            if (r.content) scriptIds.push(r.content);
                                            if (r.contentRight) scriptIds.push(r.contentRight);
                                        });
                                        rawIds = [...new Set(scriptIds)];
                                    }
                                    break;
                                }
                            }
                        }

                        playList = rawIds.map(id => {
                            const pid = typeof id === 'object' ? id.id : id;
                            if (pid === 'GAP') return null;
                            return plays.find(p => p.id === pid);
                        }).filter(Boolean);
                    }
                    return playList;
                };

                return (
                    <div style={{ padding: '0 0.75rem 0.75rem', overflowY: 'auto', flex: 1 }}>
                        {/* Header Row */}
                        <div style={{ display: 'flex', alignItems: 'center', paddingBottom: '4px', marginRight: '10px', marginTop: '8px' }}>
                            <div style={{ flex: 1 }}></div>
                            <div style={{ display: 'flex', gap: '2px', marginLeft: '8px' }}>
                                {['M', 'T', 'W', 'TH', 'F'].map(day => (
                                    <div key={day} style={{ width: '18px', textAlign: 'center', fontSize: '0.6rem', fontWeight: 'bold', color: '#64748b' }}>
                                        {day}
                                    </div>
                                ))}
                            </div>
                        </div>
                        {/* Call Sheet Sections */}
                        {(gamePlanLayouts?.CALL_SHEET?.sections || []).map(section => (
                            <div key={section.id}>
                                <div style={{ padding: '8px 0', fontSize: '0.75rem', fontWeight: 'bold', color: '#64748b', textTransform: 'uppercase' }}>{section.title}</div>
                                {section.boxes.map(box => {
                                    const items = getPlaysForSection('box', box.setId);
                                    // if (items.length === 0) return null; // Always show
                                    const isExpanded = expandedSections[box.setId];

                                    return (
                                        <div key={box.setId} style={{ marginBottom: '4px', border: '1px solid #e2e8f0', borderRadius: '4px', overflow: 'hidden' }}>
                                            <div
                                                onClick={() => toggleSection(box.setId)}
                                                style={{ padding: '8px', background: '#f8fafc', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}
                                            >
                                                <span style={{ fontSize: '0.85rem', fontWeight: '600', color: '#1e293b' }}>{box.header}</span>
                                                <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                                    <span style={{ fontSize: '0.7rem', color: '#64748b' }}>{items.length}</span>
                                                    <Icon name={isExpanded ? "ChevronDown" : "ChevronRight"} size={14} color="#64748b" />
                                                </div>
                                            </div>
                                            {isExpanded && (
                                                <div style={{ padding: '8px', borderTop: '1px solid #e2e8f0', background: 'white' }}>
                                                    {items.length > 0 ? (
                                                        <>
                                                            <button
                                                                onClick={(e) => { e.stopPropagation(); onAddSection(box.setId); }}
                                                                style={{
                                                                    width: '100%',
                                                                    marginBottom: '8px',
                                                                    fontSize: '0.75rem',
                                                                    padding: '6px',
                                                                    background: '#f1f5f9',
                                                                    color: '#000000',
                                                                    border: '1px solid #cbd5e1',
                                                                    borderRadius: '4px',
                                                                    fontWeight: '700',
                                                                    cursor: 'pointer'
                                                                }}
                                                            >
                                                                + Add All
                                                            </button>
                                                            {items.map(renderRow)}
                                                        </>
                                                    ) : (
                                                        <div style={{ fontSize: '0.75rem', color: '#94a3b8', fontStyle: 'italic', padding: '4px' }}>No plays found.</div>
                                                    )}
                                                </div>
                                            )}
                                        </div>
                                    );
                                })}
                            </div>
                        ))}

                        {/* Matrix Formations */}
                        <div style={{ padding: '8px 0', fontSize: '0.75rem', fontWeight: 'bold', color: '#64748b', textTransform: 'uppercase', marginTop: '1rem' }}>Formations (Matrix)</div>
                        {(gamePlanLayouts?.MATRIX?.formations || []).map(formation => {
                            const items = getPlaysForSection('matrix_formation', formation.id, { formation });
                            // if (items.length === 0) return null; // Always show
                            const isExpanded = expandedSections[formation.id];

                            return (
                                <div key={formation.id} style={{ marginBottom: '4px', border: '1px solid #e2e8f0', borderRadius: '4px', overflow: 'hidden' }}>
                                    <div
                                        onClick={() => toggleSection(formation.id)}
                                        style={{ padding: '8px', background: '#f8fafc', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}
                                    >
                                        <span style={{ fontSize: '0.85rem', fontWeight: '600', color: '#1e293b' }}>{formation.label}</span>
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                            <span style={{ fontSize: '0.7rem', color: '#64748b' }}>{items.length}</span>
                                            <Icon name={isExpanded ? "ChevronDown" : "ChevronRight"} size={14} color="#64748b" />
                                        </div>
                                    </div>
                                    {isExpanded && (
                                        <div style={{ padding: '8px', borderTop: '1px solid #e2e8f0', background: 'white' }}>
                                            {items.length > 0 ? (
                                                <>
                                                    <button
                                                        onClick={(e) => { e.stopPropagation(); onAddSection(formation.id); }}
                                                        style={{
                                                            width: '100%',
                                                            marginBottom: '8px',
                                                            fontSize: '0.75rem',
                                                            padding: '6px',
                                                            background: '#f1f5f9',
                                                            color: '#000000',
                                                            border: '1px solid #cbd5e1',
                                                            borderRadius: '4px',
                                                            fontWeight: '700',
                                                            cursor: 'pointer'
                                                        }}
                                                    >
                                                        + Add All
                                                    </button>
                                                    {items.map(renderRow)}
                                                </>
                                            ) : (
                                                <div style={{ fontSize: '0.75rem', color: '#94a3b8', fontStyle: 'italic', padding: '4px' }}>No plays found.</div>
                                            )}
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                );
            };

            const renderInstallContent = () => {
                if (!playCategories || !playBuckets) return <div style={{ padding: '1rem', color: '#64748b' }}>No Categories or Play Families found.</div>;

                if (installData.length === 0) {
                    return (
                        <div style={{ padding: '1rem', color: '#64748b', fontStyle: 'italic' }}>
                            {searchTerm ? "No installed plays matching search." : "No plays installed this week."}
                        </div>
                    );
                }

                return (
                    <div style={{ padding: '0 0.75rem 0.75rem', overflowY: 'auto', flex: 1 }}>
                        {/* Header Row */}
                        <div style={{ display: 'flex', alignItems: 'center', paddingBottom: '4px', marginRight: '10px', marginTop: '8px' }}>
                            <div style={{ flex: 1 }}></div>
                            <div style={{ display: 'flex', gap: '2px', marginLeft: '8px' }}>
                                {['M', 'T', 'W', 'TH', 'F'].map(day => (
                                    <div key={day} style={{ width: '18px', textAlign: 'center', fontSize: '0.6rem', fontWeight: 'bold', color: '#64748b' }}>
                                        {day}
                                    </div>
                                ))}
                            </div>
                        </div>

                        {installData.map(category => {
                            const isCatExpanded = expandedSections[`cat-install-${category.id}`];
                            return (
                                <div key={category.id} style={{ marginBottom: '8px' }}>
                                    <div
                                        onClick={() => toggleSection(`cat-install-${category.id}`)}
                                        style={{
                                            padding: '8px 10px',
                                            background: category.color || '#3b82f6',
                                            cursor: 'pointer',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'space-between',
                                            borderRadius: '4px',
                                            marginBottom: '2px'
                                        }}
                                    >
                                        <span style={{ fontSize: '0.8rem', fontWeight: '700', color: 'white', textTransform: 'uppercase' }}>
                                            {category.label}
                                        </span>
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                            <span style={{ fontSize: '0.65rem', color: 'white', opacity: 0.9 }}>{category.totalPlays}</span>
                                            <Icon name={isCatExpanded ? "ChevronDown" : "ChevronRight"} size={14} color="white" />
                                        </div>
                                    </div>

                                    {isCatExpanded && (
                                        <div style={{ marginLeft: '8px', borderLeft: `2px solid ${category.color || '#3b82f6'}`, paddingLeft: '6px', paddingTop: '4px' }}>
                                            {category.totalPlays > 0 && (
                                                    <button
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            const allPlayIds = category.families.flatMap(f => f.plays.map(p => p.id));
                                                            onAddSection(allPlayIds);
                                                        }}
                                                        style={{
                                                            width: '100%',
                                                            marginBottom: '8px',
                                                            fontSize: '0.7rem',
                                                            padding: '6px',
                                                            background: 'white',
                                                            color: '#1e293b',
                                                            border: `1px solid ${category.color || '#3b82f6'}`,
                                                            borderRadius: '4px',
                                                            fontWeight: '700',
                                                            cursor: 'pointer',
                                                            display: 'flex',
                                                            alignItems: 'center',
                                                            justifyContent: 'center',
                                                            gap: '4px'
                                                        }}
                                                    >
                                                        <Icon name="PlusCircle" size={14} /> Add all to script ({category.totalPlays})
                                                    </button>
                                                )}
                                                {category.families.map(family => {
                                                const isFamExpanded = expandedSections[`fam-install-${family.id}`];
                                                return (
                                                    <div key={family.id} style={{ marginBottom: '4px', border: '1px solid #e2e8f0', borderRadius: '4px', overflow: 'hidden' }}>
                                                        <div
                                                            onClick={() => toggleSection(`fam-install-${family.id}`)}
                                                            style={{ padding: '6px 8px', background: '#f8fafc', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}
                                                        >
                                                            <span style={{ fontSize: '0.75rem', fontWeight: '600', color: '#1e293b' }}>{family.label || family.name}</span>
                                                            <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                                                                <span style={{ fontSize: '0.65rem', color: '#64748b' }}>{family.plays.length}</span>
                                                                <Icon name={isFamExpanded ? "ChevronDown" : "ChevronRight"} size={12} color="#64748b" />
                                                            </div>
                                                        </div>
                                                        {isFamExpanded && (
                                                            <div style={{ padding: '4px 8px', borderTop: '1px solid #e2e8f0', background: 'white' }}>
                                                                {family.plays.length > 0 && (
                                                                        <button
                                                                            onClick={(e) => {
                                                                                e.stopPropagation();
                                                                                const familyPlayIds = family.plays.map(p => p.id);
                                                                                onAddSection(familyPlayIds);
                                                                            }}
                                                                            style={{
                                                                                width: '100%',
                                                                                marginBottom: '6px',
                                                                                fontSize: '0.65rem',
                                                                                padding: '4px',
                                                                                background: '#f1f5f9',
                                                                                color: '#1e293b',
                                                                                border: '1px solid #cbd5e1',
                                                                                borderRadius: '4px',
                                                                                fontWeight: '700',
                                                                                cursor: 'pointer',
                                                                                display: 'flex',
                                                                                alignItems: 'center',
                                                                                justifyContent: 'center',
                                                                                gap: '4px'
                                                                            }}
                                                                        >
                                                                            <Icon name="Plus" size={12} /> Add all to script ({family.plays.length})
                                                                        </button>
                                                                    )}
                                                                    {family.plays.map(renderRow)}
                                                            </div>
                                                        )}
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                );
            };



            return (
                <div style={{
                    width: isOpen ? '360px' : '0px',
                    transition: 'width 0.3s ease-in-out',
                    borderLeft: isOpen ? '1px solid var(--border)' : 'none',
                    background: 'white',
                    display: 'flex',
                    flexDirection: 'column',
                    height: '100%',
                    flexShrink: 0,
                    position: 'relative' // For absolute handle
                }}>

                    <div
                        onClick={() => onToggle(!isOpen)}
                        title={isOpen ? "Collapse Sidebar" : "Expand Sidebar"}
                        style={{
                            position: 'absolute',
                            left: '-24px',
                            top: '50%',
                            transform: 'translateY(-50%)',
                            width: '24px',
                            height: '48px',
                            background: 'white',
                            border: '1px solid var(--border)',
                            borderRight: 'none',
                            borderTopLeftRadius: '8px',
                            borderBottomLeftRadius: '8px',
                            cursor: 'pointer',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            zIndex: 10,
                            boxShadow: '-2px 0 5px rgba(0,0,0,0.05)'
                        }}
                    >
                        <Icon name={isOpen ? "ChevronRight" : "ChevronLeft"} size={16} color="#64748b" />
                    </div>


                    <div style={{ width: '360px', display: 'flex', flexDirection: 'column', height: '100%', overflow: 'hidden' }}>
                        {/* Header with Close Button */}
                        <div style={{
                            padding: '1rem',
                            borderBottom: '1px solid #334155',
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center',
                            background: '#1e293b',
                            color: 'white'
                        }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                <Icon name="BookOpen" size={20} color="#cbd5e1" />
                                <h3 style={{ margin: 0, fontSize: '1.25rem', fontWeight: '800', letterSpacing: '0.025em' }}>Playbook</h3>
                            </div>
                            <button
                                onClick={() => onToggle(false)}
                                title="Close Sidebar"
                                style={{
                                    padding: '6px 12px',
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '6px',
                                    background: 'rgba(255,255,255,0.1)',
                                    border: '1px solid rgba(255,255,255,0.2)',
                                    borderRadius: '6px',
                                    color: '#f8fafc',
                                    fontSize: '0.85rem',
                                    fontWeight: '600',
                                    cursor: 'pointer',
                                    transition: 'all 0.2s'
                                }}
                                onMouseOver={(e) => e.target.style.background = 'rgba(255,255,255,0.2)'}
                                onMouseOut={(e) => e.target.style.background = 'rgba(255,255,255,0.1)'}
                            >
                                <span style={{ fontSize: '1.2rem', lineHeight: 0.8 }}>×</span> Close
                            </button>
                        </div>

                        {/* THIS WEEK Counter */}
                        {weekStats && (
                            <div style={{
                                padding: '0.75rem',
                                borderBottom: '1px solid var(--border)',
                                display: 'flex',
                                flexDirection: 'column',
                                alignItems: 'center',
                                background: '#f8fafc',
                                gap: '6px'
                            }}>
                                <div style={{ fontSize: '0.6rem', fontWeight: 'bold', color: '#64748b', marginBottom: '0', textTransform: 'uppercase', letterSpacing: '0.05em' }}>THIS WEEK</div>
                                <div style={{
                                    display: 'flex',
                                    alignItems: 'center',
                                    background: '#e0e7ff',
                                    borderRadius: '20px',
                                    padding: '0.2rem 0.6rem',
                                    border: '1px solid #c7d2fe',
                                    height: '36px'
                                }}>
                                    <div style={{ display: 'flex', alignItems: 'center', marginRight: '0.5rem', paddingRight: '0.5rem', borderRight: '1px solid #a5b4fc' }}>
                                        <span style={{ fontSize: '1.1rem', fontWeight: 'bold', color: 'white', marginRight: '0.2rem', textShadow: '0px 1px 2px rgba(0,0,0,0.1)' }}>{weekStats.uniquePlaysCount}</span>
                                        <span style={{ fontSize: '0.65rem', color: '#6366f1', fontWeight: 'bold' }}>Unique</span>
                                    </div>
                                    <div style={{ display: 'flex', alignItems: 'center', marginRight: '0.5rem', paddingRight: '0.5rem', borderRight: '1px solid #a5b4fc' }}>
                                        <span style={{ fontSize: '1.1rem', fontWeight: 'bold', color: '#059669', marginRight: '0.2rem' }}>{weekStats.newPlaysCount}</span>
                                        <span style={{ fontSize: '0.65rem', color: '#6366f1', fontWeight: 'bold' }}>New</span>
                                    </div>
                                    <div style={{ display: 'flex', alignItems: 'center' }}>
                                        <span style={{ fontSize: '1.1rem', fontWeight: 'bold', color: '#6366f1', marginRight: '0.2rem' }}>{weekStats.totalScriptSlots}</span>
                                        <span style={{ fontSize: '0.65rem', color: '#6366f1', fontWeight: 'bold' }}>Scripts</span>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Tabs */}
                        <div style={{ display: 'flex', borderBottom: '1px solid #e2e8f0' }}>
                            {['Play Usage', 'Game Plan', 'Install'].map(tab => {
                                const key = tab === 'Play Usage' ? 'usage' : tab === 'Game Plan' ? 'gameplan' : 'install';
                                const isActive = activeTab === key;
                                return (
                                    <div
                                        key={key}
                                        onClick={() => setActiveTab(key)}
                                        style={{
                                            flex: 1,
                                            textAlign: 'center',
                                            padding: '8px 4px',
                                            fontSize: '0.75rem',
                                            fontWeight: '600',
                                            color: isActive ? '#0f172a' : '#64748b',
                                            borderBottom: isActive ? '2px solid #0f172a' : '2px solid transparent',
                                            cursor: 'pointer',
                                            background: isActive ? 'white' : '#f8fafc'
                                        }}
                                    >
                                        {tab}
                                    </div>
                                );
                            })}
                        </div>

                        {/* Content */}
                        {activeTab === 'usage' && (
                            <>
                                <div style={{ padding: '0.5rem' }}>
                                    <input
                                        placeholder="Add / Search..."
                                        value={quickAddValue}
                                        onChange={e => {
                                            setQuickAddValue(e.target.value.toUpperCase());
                                            setSearchTerm(e.target.value.toUpperCase());
                                        }}
                                        onKeyDown={e => {
                                            if (e.key === 'Enter' && quickAddValue) {
                                                onQuickAddPlay(quickAddValue);
                                                setQuickAddValue('');
                                                setSearchTerm('');
                                            }
                                        }}
                                        style={{ width: '100%', padding: '6px', borderRadius: '4px', border: '1px solid #cbd5e1', fontSize: '0.85rem' }}
                                    />
                                </div>

                                <div style={{ flex: 1, overflowY: 'auto', padding: '0 0.75rem 0.75rem' }}>
                                    {/* Header Row */}
                                    <div style={{ display: 'flex', alignItems: 'center', paddingBottom: '4px', marginRight: '10px' }}>
                                        <div style={{ flex: 1 }}></div>
                                        <div style={{ display: 'flex', gap: '2px', marginLeft: '8px' }}>
                                            {['M', 'T', 'W', 'TH', 'F'].map(day => (
                                                <div key={day} style={{ width: '18px', textAlign: 'center', fontSize: '0.6rem', fontWeight: 'bold', color: '#64748b' }}>
                                                    {day}
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                    {usageData.length > 0 ? (
                                        usageData.map(category => {
                                            const isCatExpanded = expandedSections[`cat-usage-${category.id}`];
                                            return (
                                                <div key={category.id} style={{ marginBottom: '8px' }}>
                                                    <div
                                                        onClick={() => toggleSection(`cat-usage-${category.id}`)}
                                                        style={{
                                                            padding: '8px 10px',
                                                            background: category.color || '#3b82f6',
                                                            cursor: 'pointer',
                                                            display: 'flex',
                                                            alignItems: 'center',
                                                            justifyContent: 'space-between',
                                                            borderRadius: '4px',
                                                            marginBottom: '2px'
                                                        }}
                                                    >
                                                        <span style={{ fontSize: '0.8rem', fontWeight: '700', color: 'white', textTransform: 'uppercase' }}>
                                                            {category.label}
                                                        </span>
                                                        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                                            <span style={{ fontSize: '0.65rem', color: 'white', opacity: 0.9 }}>{category.totalPlays}</span>
                                                            <Icon name={isCatExpanded ? "ChevronDown" : "ChevronRight"} size={14} color="white" />
                                                        </div>
                                                    </div>

                                                    {isCatExpanded && (
                                                        <div style={{ marginLeft: '8px', borderLeft: `2px solid ${category.color || '#3b82f6'}`, paddingLeft: '6px', paddingTop: '4px' }}>
                                                            {category.totalPlays > 0 && (
                                                    <button
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            const allPlayIds = category.families.flatMap(f => f.plays.map(p => p.id));
                                                            onAddSection(allPlayIds);
                                                        }}
                                                        style={{
                                                            width: '100%',
                                                            marginBottom: '8px',
                                                            fontSize: '0.7rem',
                                                            padding: '6px',
                                                            background: 'white',
                                                            color: '#1e293b',
                                                            border: `1px solid ${category.color || '#3b82f6'}`,
                                                            borderRadius: '4px',
                                                            fontWeight: '700',
                                                            cursor: 'pointer',
                                                            display: 'flex',
                                                            alignItems: 'center',
                                                            justifyContent: 'center',
                                                            gap: '4px'
                                                        }}
                                                    >
                                                        <Icon name="PlusCircle" size={14} /> Add all to script ({category.totalPlays})
                                                    </button>
                                                )}
                                                {category.families.map(family => {
                                                                const isFamExpanded = expandedSections[`fam-usage-${family.id}`];
                                                                return (
                                                                    <div key={family.id} style={{ marginBottom: '4px', border: '1px solid #e2e8f0', borderRadius: '4px', overflow: 'hidden' }}>
                                                                        <div
                                                                            onClick={() => toggleSection(`fam-usage-${family.id}`)}
                                                                            style={{ padding: '6px 8px', background: '#f8fafc', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}
                                                                        >
                                                                            <span style={{ fontSize: '0.75rem', fontWeight: '600', color: '#1e293b' }}>{family.label || family.name}</span>
                                                                            <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                                                                                <span style={{ fontSize: '0.65rem', color: '#64748b' }}>{family.plays.length}</span>
                                                                                <Icon name={isFamExpanded ? "ChevronDown" : "ChevronRight"} size={12} color="#64748b" />
                                                                            </div>
                                                                        </div>
                                                                        {isFamExpanded && (
                                                                            <div style={{ padding: '4px 8px', borderTop: '1px solid #e2e8f0', background: 'white' }}>
                                                                                {family.plays.length > 0 && (
                                                                        <button
                                                                            onClick={(e) => {
                                                                                e.stopPropagation();
                                                                                const familyPlayIds = family.plays.map(p => p.id);
                                                                                onAddSection(familyPlayIds);
                                                                            }}
                                                                            style={{
                                                                                width: '100%',
                                                                                marginBottom: '6px',
                                                                                fontSize: '0.65rem',
                                                                                padding: '4px',
                                                                                background: '#f1f5f9',
                                                                                color: '#1e293b',
                                                                                border: '1px solid #cbd5e1',
                                                                                borderRadius: '4px',
                                                                                fontWeight: '700',
                                                                                cursor: 'pointer',
                                                                                display: 'flex',
                                                                                alignItems: 'center',
                                                                                justifyContent: 'center',
                                                                                gap: '4px'
                                                                            }}
                                                                        >
                                                                            <Icon name="Plus" size={12} /> Add all to script ({family.plays.length})
                                                                        </button>
                                                                    )}
                                                                    {family.plays.map(renderRow)}
                                                                            </div>
                                                                        )}
                                                                    </div>
                                                                );
                                                            })}
                                                        </div>
                                                    )}
                                                </div>
                                            );
                                        })
                                    ) : (
                                        <div style={{ padding: '2rem', textAlign: 'center', color: '#94a3b8', fontSize: '0.85rem' }}>
                                            No plays found matching "{searchTerm}"
                                        </div>
                                    )}
                                </div>
                            </>
                        )}

                        {activeTab === 'gameplan' && renderGamePlanContent()}


                        {activeTab === 'install' && renderInstallContent()}
                    </div>

                    {situationModalPlayId && (
                        <PlayDetailsModal
                            playId={situationModalPlayId}
                            onClose={() => setSituationModalPlayId(null)}
                            plays={plays}
                            gamePlanLayouts={gamePlanLayouts}
                            onUpdatePlay={onUpdatePlay}
                            onAssignSituation={(playId, situationId, type) => {
                                handleAssignSituation(playId, situationId, type);
                            }}
                            playBuckets={playBuckets}
                            playCategories={playCategories}
                            currentWeek={currentWeek}
                        />
                    )}
                </div>
            );
        };



        const OffensiveGamePlan = ({ plays, weekDate, gamePlan, practicePlans = {}, onUpdateGamePlan, onQuickAddPlay, onUpdatePlay, gamePlanLayouts = GAME_PLAN_LAYOUTS, onUpdateLayouts, isLocked, layoutVersions = {}, onSaveLayoutVersion, onDeleteLayoutVersion, onLoadLayoutVersion, wbSettings, drills = [], newInstallIds = [], onUpdateWeek, weeks = [], currentWeek = {}, playCategories = [], playBuckets = [], setAppSidebarCollapsed, appSidebarCollapsed }) => {
            const { openPlayDetails } = usePlayDetailsModal();
            const [layoutSaveState, setLayoutSaveState] = useState({ isSaving: false, name: '' });
            const [layoutConfirmAction, setLayoutConfirmAction] = useState(null); // { type: 'load'|'delete', name: 'versionName' }
            const [showLayoutVersions, setShowLayoutVersions] = useState(false);
            const [assignmentModalState, setAssignmentModalState] = useState(null); // { playId, x, y }
            const [showImportModal, setShowImportModal] = useState(false);
            const [importSourceWeekId, setImportSourceWeekId] = useState('');
            // const [isSideMenuOpen, setIsSideMenuOpen] = useState(false); // Removed in favor of showSideMenu

            const [viewMode, setViewMode] = useState('sheet'); // 'sheet', 'matrix', 'list'
            const [selectedSetId, setSelectedSetId] = useState(null);
            const [showPlaySelector, setShowPlaySelector] = useState(false);
            const [playSelectorFilters, setPlaySelectorFilters] = useState({ formation: '', concept: '', tag: '', situation: '' });

            // Side Menu State
            const [showSideMenu, setShowSideMenu] = useState(false);

            // Function to toggle side menu and collapse global sidebar
            const handleToggleSideMenu = (newState) => {
                setShowSideMenu(newState);
                if (newState && setAppSidebarCollapsed) {
                    setAppSidebarCollapsed(true);
                }
            };

            // Effect to close right side menu when left sidebar is expanded
            useEffect(() => {
                if (!appSidebarCollapsed && showSideMenu) {
                    setShowSideMenu(false);
                }
            }, [appSidebarCollapsed, showSideMenu]);

            // For Wristband Autocomplete
            const [showWristband, setShowWristband] = useState(true);
            const [wristbandFocus, setWristbandFocus] = useState(null);
            const [wbAutocomplete, setWbAutocomplete] = useState({ playId: null, query: '' });
            const [showPrintPreview, setShowPrintPreview] = useState(false); // Print Preview Toggle
            const [printPreviewTab, setPrintPreviewTab] = useState('staples'); // Selected tab for print preview
            const [printScale, setPrintScale] = useState(0.85); // Default to 85% for better fit

            const effectiveBuckets = useMemo(() => {
                if (playCategories && playCategories.length > 0) return playCategories;
                return [
                    { id: 'run', label: 'Run', color: '#10b981', textColor: '#ffffff' },
                    { id: 'pass', label: 'Pass', color: '#3b82f6', textColor: '#ffffff' },
                    { id: 'screen', label: 'Screen', color: '#8b5cf6', textColor: '#ffffff' }
                ];
            }, [playCategories]);

            const validWristbandSlots = useMemo(() => {
                if (!wbSettings) return [];
                const slots = [];
                const cardKeys = ['card1', 'card2', 'card3', 'card4', 'card5', 'card6'];
                for (const key of cardKeys) {
                    const card = wbSettings[key];
                    if (!card) continue;
                    const cardNum = parseInt(key.replace('card', ''));

                    if (card.type && (card.type === 'wiz' || card.type === 'rooski')) {
                        // Wiz: Series X, 01-16
                        for (let i = 1; i <= 16; i++) {
                            slots.push(`${cardNum}${String(i).padStart(2, '0')}`);
                        }
                    } else {
                        // Standard/Modular: 48 slots per card (X01-X48)
                        const start = cardNum * 100 + 1;
                        const end = start + 47;
                        for (let i = start; i <= end; i++) slots.push(String(i));
                    }
                }
                return slots;
            }, [wbSettings]);

            const assignedSlots = useMemo(() => {
                const set = new Set();
                if (plays) {
                    plays.forEach(p => {
                        if (p.wristbandSlot) set.add(p.wristbandSlot);
                    });
                }
                return set;
            }, [plays]);

            // Calculate week stats for sidebar
            const weekStats = useMemo(() => {
                // Calculate unique plays in game plan
                const allGamePlanPlayIds = new Set();
                Object.values(gamePlan?.sets || {}).forEach(set => {
                    (set.playIds || []).forEach(item => {
                        const id = typeof item === 'object' ? item.id : item;
                        if (id) allGamePlanPlayIds.add(id);
                    });
                });
                Object.values(gamePlan?.miniScripts || {}).forEach(script => {
                    (script.playIds || []).forEach(item => {
                        const id = typeof item === 'object' ? item.id : item;
                        if (id) allGamePlanPlayIds.add(id);
                    });
                });
                const uniquePlaysCount = allGamePlanPlayIds.size;

                // Calculate new plays (plays added this week that weren't in previous weeks)
                const previousWeekPlayIds = new Set();
                weeks.forEach(w => {
                    if (w.weekNumber < currentWeek.weekNumber) {
                        const prevGamePlan = w.gamePlan || {};
                        Object.values(prevGamePlan.sets || {}).forEach(set => {
                            (set.playIds || []).forEach(item => {
                                const id = typeof item === 'object' ? item.id : item;
                                if (id) previousWeekPlayIds.add(id);
                            });
                        });
                        Object.values(prevGamePlan.miniScripts || {}).forEach(script => {
                            (script.playIds || []).forEach(item => {
                                const id = typeof item === 'object' ? item.id : item;
                                if (id) previousWeekPlayIds.add(id);
                            });
                        });
                    }
                });
                const newPlaysCount = Array.from(allGamePlanPlayIds).filter(id => !previousWeekPlayIds.has(id)).length;

                // Calculate total practice script slots for the week
                let totalScriptSlots = 0;
                const plansList = Array.isArray(practicePlans) ? practicePlans : Object.values(practicePlans || {});
                plansList.forEach(plan => {
                    plan.segments.forEach(seg => {
                        if (seg.hasScript && seg.script && seg.script.length > 0) {
                            totalScriptSlots += seg.script.length;
                        }
                    });
                });

                return { uniquePlaysCount, newPlaysCount, totalScriptSlots };
            }, [gamePlan, weeks, currentWeek, practicePlans]);

            // Auto-Assign Priority Plays to Categories based on Type
            useEffect(() => {
                if (isLocked || !gamePlan) return;

                const priorityCategories = gamePlan.priorityCategories || {};
                const categorizedIds = new Set(Object.values(priorityCategories).flat());

                // Filter for unassigned priority plays with types
                const unassigned = plays.filter(p => p.priority && p.type && !categorizedIds.has(p.id));

                if (unassigned.length === 0) return;

                // Dynamic Mapping from Play Type to Category ID
                // We assume Play Type matches Category ID (normalized) or Label
                const typeToCat = {};
                (playCategories.length > 0 ? playCategories : DEFAULT_PLAY_CATEGORIES).forEach(cat => {
                    typeToCat[cat.label] = cat.id;
                    typeToCat[cat.id] = cat.id;
                    typeToCat[cat.label.toUpperCase()] = cat.id; // Handle uppercase types
                    typeToCat[cat.id.toUpperCase()] = cat.id;
                });

                // Fallback for known hardcoded types if they differ from category IDs
                typeToCat['RPO'] = 'rpo';
                typeToCat['QUICK'] = 'quick';
                typeToCat['INTER'] = 'intermediate';
                typeToCat['SHOT'] = 'deep';
                typeToCat['Screen'] = 'screen';
                typeToCat['GADGET'] = 'gadget';


                let updates = null;

                unassigned.forEach(p => {
                    const catId = typeToCat[p.type] || typeToCat[p.type.toUpperCase()];
                    // Verify the target category actually exists in our list (to avoid junk data)
                    const targetExists = (playCategories.length > 0 ? playCategories : DEFAULT_PLAY_CATEGORIES).some(c => c.id === catId);

                    if (catId && targetExists) {
                        if (!updates) updates = { ...priorityCategories };
                        updates[catId] = [...(updates[catId] || []), p.id];
                    }
                });

                if (updates) {
                    onUpdateGamePlan({ ...gamePlan, priorityCategories: updates });
                }

            }, [plays, gamePlan, isLocked, onUpdateGamePlan, playCategories]);

            // Import Handler
            const handleImportGamePlan = () => {
                if (!importSourceWeekId) return;
                const sourceWeek = weeks.find(w => w.id === importSourceWeekId);
                if (sourceWeek) {
                    if (confirm(`Import Game Plan from ${sourceWeek.name}? This will REPLACE current Game Plan and Call Sheet data.`)) {
                        // Deep copy ensures we don't link by reference
                        const newGamePlan = sourceWeek.offensiveGamePlan ? JSON.parse(JSON.stringify(sourceWeek.offensiveGamePlan)) : { sets: [] };
                        const newDumbData = sourceWeek.dumbCallSheetData ? JSON.parse(JSON.stringify(sourceWeek.dumbCallSheetData)) : {};
                        const newLayouts = sourceWeek.gamePlanLayouts ? JSON.parse(JSON.stringify(sourceWeek.gamePlanLayouts)) : null;

                        if (onUpdateWeek) {
                            onUpdateWeek(currentWeek.id, 'offensiveGamePlan', newGamePlan);
                            onUpdateWeek(currentWeek.id, 'dumbCallSheetData', newDumbData);
                            if (newLayouts) onUpdateWeek(currentWeek.id, 'gamePlanLayouts', newLayouts);
                        }
                        setShowImportModal(false);
                    }
                }
            };

            const handleClearGamePlan = () => {
                const confirm = window.prompt(`Are you sure you want to CLEAR the entire Game Plan and Call Sheet for this week? This cannot be undone.\n\nType "delete" to confirm.`);
                if (confirm && confirm.trim().toLowerCase() !== 'delete') return;

                // 1. Clear Week Data (Sets, Dumb Data)
                if (onUpdateWeek) {
                    onUpdateWeek(currentWeek.id, 'offensiveGamePlan', { sets: [], miniScripts: [] });
                    onUpdateWeek(currentWeek.id, 'dumbCallSheetData', {});
                }

                // 2. Clear Layout Content (Scripts & Grids stored in Layouts)
                if (onUpdateLayouts && gamePlanLayouts) {
                    const newLayouts = JSON.parse(JSON.stringify(gamePlanLayouts));
                    if (newLayouts.CALL_SHEET && newLayouts.CALL_SHEET.sections) {
                        newLayouts.CALL_SHEET.sections.forEach(section => {
                            if (section.boxes) {
                                section.boxes.forEach(box => {
                                    // Clear Script Rows
                                    if (box.rows) {
                                        box.rows.forEach(row => {
                                            row.content = '';
                                            if (row.contentRight) row.contentRight = '';
                                        });
                                    }
                                    // Clear Grid Assignments
                                    if (box.assignedPlayIds) {
                                        box.assignedPlayIds = [];
                                    }
                                });
                            }
                        });
                    }
                    onUpdateLayouts(newLayouts);
                }
            };

            // For Matrix/Grid Cell Editing
            const [activeCellSetId, setActiveCellSetId] = useState(null); // The setId currently being edited via modal
            const [editingFormationId, setEditingFormationId] = useState(null); // ID of formation currently being renamed

            const [isCreatingScript, setIsCreatingScript] = useState(false); // For inline script creation
            const [confirmDeleteScriptId, setConfirmDeleteScriptId] = useState(null); // For inline delete confirmation
            const [configuringSection, setConfiguringSection] = useState(null); // { idx: number }

            // For Strike 'Em Out matrix collapsible groups
            const [collapsedGroups, setCollapsedGroups] = useState(new Set());
            const [collapsedRows, setCollapsedRows] = useState(new Set());

            // For Strike 'Em Out matrix collapsible hash columns (LEFT/RIGHT)
            const [collapsedHashColumns, setCollapsedHashColumns] = useState(() => {
                const saved = localStorage.getItem('collapsedHashColumns_strikeEmOut');
                return saved ? new Set(JSON.parse(saved)) : new Set();
            });

            const toggleRow = (rowId) => {
                setCollapsedRows(prev => {
                    const newCollapsed = new Set(prev);
                    if (newCollapsed.has(rowId)) {
                        newCollapsed.delete(rowId);
                    } else {
                        newCollapsed.add(rowId);
                    }
                    return newCollapsed;
                });
            };

            const toggleHashColumn = (groupId, hashSide) => {
                const key = `${groupId}_${hashSide}`;
                setCollapsedHashColumns(prev => {
                    const newSet = new Set(prev);
                    if (newSet.has(key)) {
                        newSet.delete(key);
                    } else {
                        newSet.add(key);
                    }
                    localStorage.setItem('collapsedHashColumns_strikeEmOut', JSON.stringify([...newSet]));
                    return newSet;
                });
            };

            // For FZDnD collapsible rows
            const [collapsedFZDnDRows, setCollapsedFZDnDRows] = useState(new Set());

            const toggleFZDnDRow = (zoneId, rowIdx) => {
                const key = `${zoneId}_${rowIdx}`;
                setCollapsedFZDnDRows(prev => {
                    const newCollapsed = new Set(prev);
                    if (newCollapsed.has(key)) {
                        newCollapsed.delete(key);
                    } else {
                        newCollapsed.add(key);
                    }
                    return newCollapsed;
                });
            };

            // For FZDnD autocomplete input
            const [fzdndAutocomplete, setFzdndAutocomplete] = useState({
                zoneId: null,
                rowIdx: null,
                colIdx: null,
                query: ''
            });

            // For FZDnD wristband autocomplete
            const [fzdndWbAutocomplete, setFzdndWbAutocomplete] = useState({
                playId: null,
                query: ''
            });

            // Helper to get wristband type indicator (T/W/M) for a slot
            const getWristbandTypeIndicator = (slot) => {
                if (!wbSettings || !slot) return '';

                // Determine which card this slot belongs to
                const cardKeys = ['card1', 'card2', 'card3', 'card4', 'card5', 'card6'];
                for (const key of cardKeys) {
                    const card = wbSettings[key];
                    if (!card) continue;
                    const cardNum = parseInt(key.replace('card', ''));

                    // Check if this slot belongs to this card
                    if (card.type && (card.type === 'wiz' || card.type === 'rooski')) {
                        // Wiz cards: X01-X16 format
                        const slotPattern = new RegExp(`^${cardNum}(0[1-9]|1[0-6])$`);
                        if (slotPattern.test(slot)) {
                            return 'W'; // Wrist Coach (Wiz)
                        }
                    } else {
                        // Standard/Modular cards: X01-X48 format
                        const start = cardNum * 100 + 1;
                        const end = start + 47;
                        const slotNum = parseInt(slot);
                        if (slotNum >= start && slotNum <= end) {
                            // Determine if it's mini-scripts (modular) or traditional
                            if (card.type === 'mini-scripts') {
                                return 'M'; // Modular
                            } else {
                                return 'T'; // Traditional
                            }
                        }
                    }
                }
                return '';
            };

            // Helper to create new play from FZDnD autocomplete
            const createFZDnDPlay = (playName, zoneId, rowIdx, colIdx) => {
                if (!onQuickAddPlay) return;

                // Create the play using the quick add function
                const newPlay = onQuickAddPlay(playName.trim());

                // Assign to cell
                assignPlayToFZDnDCell(zoneId, rowIdx, colIdx, newPlay.id);

                // Reset autocomplete
                setFzdndAutocomplete({ zoneId: null, rowIdx: null, colIdx: null, query: '' });
            };

            // Helper to assign play to FZDnD cell
            const assignPlayToFZDnDCell = (zoneId, rowIdx, colIdx, playId) => {
                const setId = `fzdnd_${zoneId}_${colIdx}`;
                let sets = [...(gamePlan?.sets || [])];
                let set = sets.find(s => s.id === setId);

                if (!set) {
                    set = { id: setId, playIds: [] };
                    sets.push(set);
                }

                // Ensure playIds array has at least rowIdx + 1 elements
                while (set.playIds.length <= rowIdx) {
                    set.playIds.push(null);
                }

                // Set the play at this row index
                set.playIds[rowIdx] = playId;

                onUpdateGamePlan({ ...gamePlan, sets });

                // Reset autocomplete
                setFzdndAutocomplete({ zoneId: null, rowIdx: null, colIdx: null, query: '' });
            };

            // Helper to get play objects for a set ID
            const getPlaysForSet = (setId) => {
                let set = gamePlan?.sets?.find(s => s.id === setId);
                if (!set && setId.startsWith('ms_')) {
                    set = gamePlan?.miniScripts?.find(s => s.id === setId);
                }
                if (!set) return [];
                return set.playIds.map((item, idx) => {
                    if (item === 'GAP') return null;

                    // Handle String ID (Legacy)
                    if (typeof item === 'string') {
                        if (item.startsWith('NOTE:')) {
                            return { id: item, name: item.replace('NOTE:', ''), type: 'note', _index: idx, _raw: item };
                        }
                        const play = plays.find(p => p.id === item);
                        return play ? { ...play, type: 'play', _index: idx, _raw: item } : null;
                    }

                    // Handle Object ID (New: { id, tempo, ... })
                    else if (typeof item === 'object' && item.id) {
                        if (item.id.startsWith('NOTE:')) {
                            return { ...item, name: item.id.replace('NOTE:', ''), type: 'note', _index: idx, _raw: item };
                        }
                        const play = plays.find(p => p.id === item.id);
                        return play ? { ...play, ...item, type: 'play', _index: idx, _raw: item } : null;
                    }
                    return null;
                }).filter(Boolean);
            };

            // Play Selector specific helper to get grid array (20 items)
            const getGridPlays = (setId, limit = 20, assignedIds = null) => {
                let rawIds = [];
                if (assignedIds && Array.isArray(assignedIds) && assignedIds.length > 0) {
                    rawIds = [...assignedIds];
                } else {
                    let set = gamePlan?.sets?.find(s => s.id === setId);
                    if (!set && setId && setId.startsWith('ms_')) {
                        set = gamePlan?.miniScripts?.find(s => s.id === setId);
                    }
                    rawIds = set ? [...set.playIds] : [];
                }
                // Pad to 20
                while (rawIds.length < limit) {
                    rawIds.push('GAP');
                }
                // If more than 20, keep them? User asked for 10 rows. Let's just show 20 for now.
                // We map rawIds to objects or 'GAP'
                return rawIds.slice(0, limit).map((item, idx) => {
                    if (item === 'GAP') return { type: 'GAP', _index: idx, _raw: item };

                    if (typeof item === 'string') {
                        if (item.startsWith('NOTE:')) {
                            return { id: item, name: item.replace('NOTE:', ''), type: 'note', _index: idx, _raw: item };
                        }
                        const play = plays.find(p => p.id === item);
                        return play ? { ...play, type: 'play', _index: idx, _raw: item } : { type: 'GAP', _index: idx, _raw: item };
                    }
                    else if (typeof item === 'object' && item.id) {
                        if (item.id.startsWith('NOTE:')) {
                            return { ...item, name: item.id.replace('NOTE:', ''), type: 'note', _index: idx, _raw: item };
                        }
                        const play = plays.find(p => p.id === item.id);
                        return play ? { ...play, ...item, type: 'play', _index: idx, _raw: item } : { type: 'GAP', _index: idx, _raw: item };
                    }
                    return { type: 'GAP', _index: idx, _raw: item };
                });
            };

            const handleGridCellUpdate = (setId, index, playId) => {
                // Safety check: ensure setId is defined
                if (!setId) {
                    console.warn('handleGridCellUpdate called with undefined setId');
                    return;
                }

                let set = gamePlan?.sets?.find(s => s.id === setId);
                if (!set && setId.startsWith('ms_')) {
                    set = gamePlan?.miniScripts?.find(s => s.id === setId);
                }
                const rawIds = set ? [...set.playIds] : [];
                // Pad if needed
                while (rawIds.length <= index) {
                    rawIds.push('GAP');
                }

                rawIds[index] = playId || 'GAP';

                if (setId.startsWith('ms_')) {
                    const newMiniScripts = (gamePlan?.miniScripts || []).map(s =>
                        s.id === setId ? { ...s, playIds: rawIds } : s
                    );
                    onUpdateGamePlan({ ...gamePlan, miniScripts: newMiniScripts });
                } else {
                    const existingSet = gamePlan?.sets?.find(s => s.id === setId);
                    let newSets;
                    if (existingSet) {
                        newSets = (gamePlan?.sets || []).map(s => s.id === setId ? { ...s, playIds: rawIds } : s);
                    } else {
                        // Implicit create
                        newSets = [...(gamePlan?.sets || []), { id: setId, name: setId, playIds: rawIds }];
                    }
                    onUpdateGamePlan({ ...gamePlan, sets: newSets });
                }
            };

            const handleGridMove = (fromIndex, toIndex) => {
                // Safety check: ensure activeCellSetId is defined
                if (!activeCellSetId) {
                    console.warn('handleGridMove called with undefined activeCellSetId');
                    return;
                }

                const currentGrid = getGridPlays(activeCellSetId);
                // We need the raw IDs not objects to save
                let set = gamePlan?.sets?.find(s => s.id === activeCellSetId);
                if (!set && activeCellSetId.startsWith('ms_')) {
                    set = gamePlan?.miniScripts?.find(s => s.id === activeCellSetId);
                }
                const rawIds = set ? [...set.playIds] : [];
                // Pad local rawIds to ensure indices exist
                while (rawIds.length <= Math.max(fromIndex, toIndex)) {
                    rawIds.push('GAP');
                }

                // Swap
                const temp = rawIds[fromIndex];
                rawIds[fromIndex] = rawIds[toIndex];
                rawIds[toIndex] = temp;

                // Save
                // Strip trailing GAPs? Maybe not, to preserve layout if user wanted gaps.
                // But for now let's just save.
                if (activeCellSetId.startsWith('ms_')) {
                    const newMiniScripts = (gamePlan?.miniScripts || []).map(s =>
                        s.id === activeCellSetId ? { ...s, playIds: rawIds } : s
                    );
                    onUpdateGamePlan({ ...gamePlan, miniScripts: newMiniScripts });
                } else {
                    const existingSet = gamePlan?.sets?.find(s => s.id === activeCellSetId);
                    let newSets;
                    if (existingSet) {
                        newSets = (gamePlan?.sets || []).map(s => s.id === activeCellSetId ? { ...s, playIds: rawIds } : s);
                    } else {
                        // Should not happen in selector usually, but implicit create
                        newSets = [...(gamePlan?.sets || []), { id: activeCellSetId, name: activeCellSetId, playIds: rawIds }];
                    }
                    onUpdateGamePlan({ ...gamePlan, sets: newSets });
                }
            };

            const handleGridAdd = (playId) => {
                // Safety check: ensure activeCellSetId is defined
                if (!activeCellSetId) {
                    console.warn('handleGridAdd called with undefined activeCellSetId');
                    return;
                }

                let set = gamePlan?.sets?.find(s => s.id === activeCellSetId);
                if (!set && activeCellSetId.startsWith('ms_')) {
                    set = gamePlan?.miniScripts?.find(s => s.id === activeCellSetId);
                }
                const rawIds = set ? [...set.playIds] : [];

                // Find first GAP or push
                let insertIdx = rawIds.indexOf('GAP');
                if (insertIdx === -1) {
                    insertIdx = rawIds.length;
                    if (insertIdx >= 20) {
                        alert("Grid is full (20 plays max for this view)");
                        return;
                    }
                }

                rawIds[insertIdx] = playId;

                // Save (Same logic as move basically)
                if (activeCellSetId.startsWith('ms_')) {
                    const newMiniScripts = (gamePlan?.miniScripts || []).map(s =>
                        s.id === activeCellSetId ? { ...s, playIds: rawIds } : s
                    );
                    onUpdateGamePlan({ ...gamePlan, miniScripts: newMiniScripts });
                } else {
                    const existingSet = gamePlan?.sets?.find(s => s.id === activeCellSetId);
                    let newSets;
                    if (existingSet) {
                        newSets = (gamePlan?.sets || []).map(s => s.id === activeCellSetId ? { ...s, playIds: rawIds } : s);
                    } else {
                        newSets = [...(gamePlan?.sets || []), { id: activeCellSetId, name: activeCellSetId, playIds: rawIds }];
                    }
                    onUpdateGamePlan({ ...gamePlan, sets: newSets });
                }
            }

            const handleGridRemove = (index) => {
                let set = gamePlan?.sets?.find(s => s.id === activeCellSetId);
                if (!set && activeCellSetId.startsWith('ms_')) {
                    set = gamePlan?.miniScripts?.find(s => s.id === activeCellSetId);
                }
                const rawIds = set ? [...set.playIds] : [];
                if (rawIds[index]) {
                    rawIds[index] = 'GAP';
                    // Save
                    if (activeCellSetId.startsWith('ms_')) {
                        const newMiniScripts = (gamePlan?.miniScripts || []).map(s =>
                            s.id === activeCellSetId ? { ...s, playIds: rawIds } : s
                        );
                        onUpdateGamePlan({ ...gamePlan, miniScripts: newMiniScripts });
                    } else {
                        const existingSet = gamePlan?.sets?.find(s => s.id === activeCellSetId);
                        let newSets;
                        if (existingSet) {
                            newSets = (gamePlan?.sets || []).map(s => s.id === activeCellSetId ? { ...s, playIds: rawIds } : s);
                        }
                        // If implicitly creating on remove? weird. Ignore.
                        if (newSets) onUpdateGamePlan({ ...gamePlan, sets: newSets });
                    }
                }
            };

            const [draggedGridIndex, setDraggedGridIndex] = useState(null);

            // Helper to get the set object (or create if implicit)
            const getSet = (setId) => {
                if (setId.startsWith('ms_')) {
                    return gamePlan?.miniScripts?.find(s => s.id === setId);
                }
                return gamePlan?.sets?.find(s => s.id === setId);
            };

            const handleAddPlayToSet = (setId, playId) => {
                if (setId.startsWith('ms_')) {
                    // Handle Mini Script Update
                    const newMiniScripts = (gamePlan?.miniScripts || []).map(s =>
                        s.id === setId ? { ...s, playIds: [...s.playIds, playId] } : s
                    );
                    onUpdateGamePlan({ ...gamePlan, miniScripts: newMiniScripts });
                } else {
                    // Handle Standard Set Update
                    const existingSet = gamePlan?.sets?.find(s => s.id === setId);
                    let newSets;
                    if (existingSet) {
                        newSets = (gamePlan?.sets || []).map(s => s.id === setId ? { ...s, playIds: [...s.playIds, playId] } : s);
                    } else {
                        // Implicit creation for grid cells
                        newSets = [...(gamePlan?.sets || []), { id: setId, name: setId, playIds: [playId] }];
                    }
                    onUpdateGamePlan({ ...gamePlan, sets: newSets });
                }
            };

            const handleRemovePlayFromSet = (setId, playId) => {
                if (setId.startsWith('ms_')) {
                    const existingScript = gamePlan?.miniScripts?.find(s => s.id === setId);
                    if (!existingScript) return;
                    const newPlayIds = existingScript.playIds.filter(id => id !== playId);
                    const newMiniScripts = (gamePlan?.miniScripts || []).map(s => s.id === setId ? { ...s, playIds: newPlayIds } : s);
                    onUpdateGamePlan({ ...gamePlan, miniScripts: newMiniScripts });
                } else {
                    const existingSet = gamePlan?.sets?.find(s => s.id === setId);
                    if (!existingSet) return;
                    const newPlayIds = existingSet.playIds.filter(id => id !== playId);
                    const newSets = (gamePlan?.sets || []).map(s => s.id === setId ? { ...s, playIds: newPlayIds } : s);
                    onUpdateGamePlan({ ...gamePlan, sets: newSets });
                }
            };

            // Quick add play to a set
            const handleQuickAddToSet = (setId, playName) => {
                const trimmed = playName.trim();
                if (!trimmed || !onQuickAddPlay) return;

                // Check for Note Syntax
                if (trimmed.toUpperCase().startsWith('NOTE:') || trimmed.toLowerCase().startsWith('n: ')) {
                    const noteText = trimmed.includes(':') ? trimmed.split(':').slice(1).join(':').trim() : trimmed;
                    const noteId = `NOTE:${noteText}`;
                    handleAddPlayToSet(setId, noteId);
                    return;
                }

                // Create the incomplete play
                const newPlay = onQuickAddPlay(trimmed);

                // Add to the set
                handleAddPlayToSet(setId, newPlay.id);
            };


            // Selector Logic (Shared)
            const filteredSelectorPlays = plays.filter(play => {
                const matchFormation = !playSelectorFilters.formation || play.formation === playSelectorFilters.formation;
                const matchConcept = !playSelectorFilters.concept || play.concept === playSelectorFilters.concept;
                const matchTag = !playSelectorFilters.tag || [play.tag1, play.tag2, ...(play.tags || [])].includes(playSelectorFilters.tag);
                const matchSituation = !playSelectorFilters.situation ||
                    (TAG_CATEGORIES["Field Position"] && TAG_CATEGORIES["Field Position"].includes(playSelectorFilters.situation) && play.tags.includes(playSelectorFilters.situation)) ||
                    (TAG_CATEGORIES["Down & Distance"] && TAG_CATEGORIES["Down & Distance"].includes(playSelectorFilters.situation) && play.tags.includes(playSelectorFilters.situation));
                const matchSearch = !playSelectorFilters.search ||
                    play.name.toLowerCase().includes(playSelectorFilters.search.toLowerCase());
                return matchFormation && matchConcept && matchTag && matchSituation && matchSearch;
            });
            const uniqueFormations = [...new Set(plays.map(p => p.formation).filter(Boolean))].sort();
            const uniqueConcepts = [...new Set(plays.map(p => p.concept).filter(Boolean))].sort();
            const allTags = [...new Set(plays.flatMap(p => [p.tag1, p.tag2, ...(p.tags || [])]))].filter(Boolean).sort();
            const situationTags = [...(TAG_CATEGORIES["Field Position"] || []), ...(TAG_CATEGORIES["Down & Distance"] || [])];

            const openPlaySelector = (setId) => {
                setActiveCellSetId(setId);
                setShowPlaySelector(true);
            };

            // Helper to get all assigned wristband coordinates
            const getAssignedWristbandCoordinates = (excludePlayId = null) => {
                const assigned = new Set();
                plays.forEach(play => {
                    if (play.wristbandSlot && play.id !== excludePlayId) {
                        assigned.add(play.wristbandSlot.trim());
                    }
                });
                return assigned;
            };

            // --- RENDERERS ---

            const renderPlayListSimple = (setId, isEditing) => {
                const playsInSet = getPlaysForSet(setId);

                const handleToggleTempo = (playIndex, currentTempo) => {
                    const nextIdx = (PLAY_PROTOCOLS.findIndex(p => p.id === (currentTempo || 'REGULAR')) + 1) % PLAY_PROTOCOLS.length;
                    const nextTempo = PLAY_PROTOCOLS[nextIdx].id;

                    const set = getSet(setId);
                    if (!set) return;

                    const newPlayIds = [...set.playIds];
                    const item = newPlayIds[playIndex];

                    if (typeof item === 'string') {
                        newPlayIds[playIndex] = { id: item, tempo: nextTempo };
                    } else if (typeof item === 'object') {
                        newPlayIds[playIndex] = { ...item, tempo: nextTempo };
                    }

                    if (setId.startsWith('ms_')) {
                        const newMiniScripts = (gamePlan?.miniScripts || []).map(s => s.id === setId ? { ...s, playIds: newPlayIds } : s);
                        onUpdateGamePlan({ ...gamePlan, miniScripts: newMiniScripts });
                    } else {
                        const newSets = (gamePlan?.sets || []).map(s => s.id === setId ? { ...s, playIds: newPlayIds } : s);
                        onUpdateGamePlan({ ...gamePlan, sets: newSets });
                    }
                };

                const renderTempoBadge = (tempo) => {
                    const protocol = PLAY_PROTOCOLS.find(p => p.id === (tempo || 'REGULAR'));
                    if (!protocol || protocol.id === 'REGULAR') return <span style={{ width: '20px', display: 'inline-block', textAlign: 'center', color: '#cbd5e1', cursor: 'pointer', fontSize: '0.65rem' }}>-</span>;

                    return (
                        <span style={{
                            background: protocol.color, color: 'white', fontSize: '0.6rem', padding: '1px 3px', borderRadius: '3px',
                            cursor: 'pointer', minWidth: '18px', display: 'inline-block', textAlign: 'center', fontWeight: 'bold'
                        }} title={protocol.label}>
                            {protocol.code}
                        </span>
                    );
                };

                return (
                    <div style={{ padding: '0' }}>
                        {playsInSet.map((p, pIdx) => (
                            <div key={`${p.id}_${pIdx}`} style={{
                                display: 'flex', alignItems: 'center', gap: '4px', padding: '2px 0', position: 'relative',
                                cursor: 'pointer', userSelect: 'none'
                            }}
                                onDoubleClick={(e) => {
                                    if (p.type === 'note') return;
                                    e.stopPropagation();
                                    setAssignmentModalState({ playId: p.id, x: e.clientX, y: e.clientY });
                                }}
                            >
                                {p.type === 'note' ? (
                                    <div style={{
                                        fontSize: '0.75rem', marginTop: '4px', marginBottom: '4px', padding: '2px 4px',
                                        background: '#fef3c7', color: '#92400e', textAlign: 'center', fontWeight: 'bold',
                                        borderRadius: '4px', border: '1px dashed #d97706', flex: 1
                                    }}>
                                        {p.name}
                                    </div>
                                ) : (
                                    <>
                                        <div onClick={(e) => { e.stopPropagation(); handleToggleTempo(pIdx, p.tempo); }}>
                                            {renderTempoBadge(p.tempo)}
                                        </div>
                                        <span style={{ fontSize: '0.75rem', flex: 1, whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', color: '#1e293b' }}>{p.name}</span>
                                        <input
                                            type="text"
                                            value={wbAutocomplete.playId === p.id ? wbAutocomplete.query : (p.wristbandSlot || '')}
                                            placeholder="#"
                                            style={{
                                                width: '32px',
                                                padding: '0 2px',
                                                fontSize: '0.65rem',
                                                border: '1px solid #e2e8f0',
                                                borderRadius: '2px',
                                                marginLeft: '4px',
                                                textAlign: 'center',
                                                background: '#f8fafc',
                                                color: '#475569',
                                                height: '16px',
                                                lineHeight: '14px'
                                            }}
                                            onClick={(e) => e.stopPropagation()}
                                            onFocus={(e) => {
                                                setWbAutocomplete({ playId: p.id, query: e.target.value });
                                            }}
                                            onChange={(e) => {
                                                setWbAutocomplete({ playId: p.id, query: e.target.value });
                                            }}
                                            onKeyDown={(e) => {
                                                if (e.key === 'Enter') {
                                                    const val = e.currentTarget.value.trim();
                                                    // Process selection or validation
                                                    if (val && val !== (p.wristbandSlot || '')) {
                                                        // Validation logic (same as before)
                                                        let isValid = false;
                                                        const cardKeys = ['card1', 'card2', 'card3', 'card4', 'card5', 'card6'];
                                                        for (const key of cardKeys) {
                                                            const card = wbSettings[key];
                                                            if (!card) continue;
                                                            if (wbSettings.enabledSections && wbSettings.enabledSections[key] === false) continue;

                                                            const cardNum = parseInt(key.replace('card', ''));
                                                            if (card.type && (card.type === 'wiz' || card.type === 'rooski')) {
                                                                for (let i = 1; i <= 16; i++) if (val === `${cardNum}${String(i).padStart(2, '0')}`) isValid = true;
                                                            } else {
                                                                const start = cardNum * 100 + 1;
                                                                const end = start + 47;
                                                                const num = parseInt(val);
                                                                if (!isNaN(num) && num >= start && num <= end) isValid = true;
                                                            }
                                                        }

                                                        // Check Staples (10-89)
                                                        const num = parseInt(val);
                                                        if (!isNaN(num) && num >= 10 && num <= 89) {
                                                            if (!wbSettings.enabledSections || wbSettings.enabledSections.staples !== false) {
                                                                isValid = true;
                                                            }
                                                        }

                                                        if (!isValid) {
                                                            alert(`Invalid wristband slot "${val}".\n\nMust be a valid coordinate from your configured wristbands.`);
                                                            e.currentTarget.value = p.wristbandSlot || '';
                                                            return;
                                                        }
                                                        // Check for duplicates
                                                        if (assignedSlots.has(val)) {
                                                            alert(`Wristband slot "${val}" is already assigned to another play.`);
                                                            e.currentTarget.value = p.wristbandSlot || '';
                                                            return;
                                                        }

                                                        onUpdatePlay({ ...p, wristbandSlot: val });
                                                    }
                                                    e.currentTarget.blur();
                                                    setWbAutocomplete({ playId: null, query: '' });
                                                }
                                            }}
                                            onBlur={(e) => {
                                                // Delayed blur to allow click on suggestion
                                                setTimeout(() => {
                                                    // Determine if we need to validate/save
                                                    const val = e.target.value.trim();
                                                    if (val !== (p.wristbandSlot || '')) {
                                                        // Validation here is redundant if Enter caught it, but good for blur
                                                        // We might skip complex validation on blur if it's annoying, 
                                                        // but for consistency we keep it or rely on the previous validation logic.
                                                        // Let's rely on the user having selected or typed correctly.
                                                        // Real validation happens on update or explicit check.
                                                        // Simple check:
                                                        let isValid = !val;
                                                        if (val) {
                                                            const cardKeys = ['card1', 'card2', 'card3', 'card4', 'card5', 'card6'];
                                                            for (const key of cardKeys) {
                                                                const card = wbSettings[key];
                                                                if (!card) continue;
                                                                const cardNum = parseInt(key.replace('card', ''));
                                                                if (card.type && card.type.includes('wiz')) {
                                                                    for (let i = 1; i <= 16; i++) if (val === `${cardNum}${String(i).padStart(2, '0')}`) isValid = true;
                                                                } else {
                                                                    const start = cardNum * 100 + 1;
                                                                    const end = start + 47;
                                                                    const num = parseInt(val);
                                                                    if (!isNaN(num) && num >= start && num <= end) isValid = true;
                                                                }
                                                            }
                                                        }

                                                        if (isValid && val && assignedSlots.has(val)) {
                                                            alert(`Wristband slot "${val}" is already assigned to another play.`);
                                                            isValid = false;
                                                        }

                                                        if (isValid) {
                                                            onUpdatePlay({ ...p, wristbandSlot: val });
                                                        } else {
                                                            if (val && !assignedSlots.has(val)) alert(`Invalid wristband slot "${val}".`); // Only alert valid range if not duplicate alert done
                                                            // if duplicates, alert already shown. 
                                                            // Wait, logic above shows alert. 
                                                            e.target.value = p.wristbandSlot || '';
                                                        }
                                                    }
                                                    setWbAutocomplete({ playId: null, query: '' });
                                                }, 200);
                                            }}
                                        />
                                        {/* Autocomplete Dropdown */}
                                        {wbAutocomplete.playId === p.id && (
                                            <div style={{
                                                position: 'absolute',
                                                top: '100%',
                                                right: 0,
                                                zIndex: 100,
                                                background: 'white',
                                                border: '1px solid #e2e8f0',
                                                borderRadius: '4px',
                                                boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)',
                                                maxHeight: '150px',
                                                overflowY: 'auto',
                                                width: '60px',
                                                display: 'flex',
                                                flexDirection: 'column'
                                            }}>
                                                {validWristbandSlots
                                                    .filter(slot => {
                                                        if (!slot.startsWith(wbAutocomplete.query)) return false;
                                                        // Filter out assigned slots, unless it's THIS play's slot
                                                        if (assignedSlots.has(slot) && slot !== (p.wristbandSlot || '')) return false;
                                                        return true;
                                                    })
                                                    .slice(0, 50) // Limit results
                                                    .map(slot => (
                                                        <div
                                                            key={slot}
                                                            style={{
                                                                padding: '4px 8px',
                                                                fontSize: '0.7rem',
                                                                cursor: 'pointer',
                                                                borderBottom: '1px solid #f1f5f9',
                                                                background: 'white',
                                                                color: '#334155'
                                                            }}
                                                            onMouseDown={(e) => {
                                                                e.preventDefault(); // Prevent blur
                                                                onUpdatePlay({ ...p, wristbandSlot: slot });
                                                                // Update input visually if not controlled (it is uncontrolled with defaultValue)
                                                                // We need to re-render renderPlayListSimple or force update. 
                                                                // Since onUpdatePlay will trigger re-render of component, we are good.
                                                                setWbAutocomplete({ playId: null, query: '' });
                                                            }}
                                                            onMouseEnter={(e) => e.currentTarget.style.background = '#f8fafc'}
                                                            onMouseLeave={(e) => e.currentTarget.style.background = 'white'}
                                                        >
                                                            {slot}
                                                        </div>
                                                    ))}
                                            </div>
                                        )}
                                        {isEditing && (
                                            <div style={{ cursor: 'pointer', opacity: 0.5, marginLeft: '4px' }}
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    handleRemovePlayFromSet(setId, p.id);
                                                }}
                                            >×</div>
                                        )}
                                    </>
                                )}
                            </div>
                        ))}

                    </div>
                );
            };

            const handleSaveNewScript = (name) => {
                if (!name.trim()) {
                    setIsCreatingScript(false);
                    return;
                }

                const newScriptId = `ms_${Date.now()}`;
                const newScript = {
                    id: newScriptId,
                    name: name.trim(),
                    playIds: [],
                    color: '#8b5cf6' // Default purple
                };

                // Add to game plan data
                const newGamePlan = {
                    ...gamePlan,
                    miniScripts: [...(gamePlan?.miniScripts || []), newScript]
                };
                onUpdateGamePlan(newGamePlan);

                // Add to layout (if supported)
                if (onUpdateLayouts && gamePlanLayouts) {
                    const newLayouts = { ...gamePlanLayouts };
                    const sheet = { ...newLayouts.CALL_SHEET };
                    sheet.sections = [...sheet.sections];

                    // Find 'MINI SCRIPTS' section or last section
                    let targetIdx = sheet.sections.findIndex(s => s.title === 'MINI SCRIPTS');
                    if (targetIdx === -1) targetIdx = sheet.sections.length - 1;

                    const targetSection = { ...sheet.sections[targetIdx] };
                    targetSection.rows = [...targetSection.rows, {
                        header: newScript.name,
                        setId: newScript.id,
                        colSpan: 1,
                        color: newScript.color
                    }];
                    sheet.sections[targetIdx] = targetSection;
                    newLayouts.CALL_SHEET = sheet;
                    onUpdateLayouts(newLayouts);
                }

                setIsCreatingScript(false);
            };

            const handleDeleteMiniScript = (scriptId, e) => {
                if (e) e.stopPropagation();

                // Update Game Plan Data
                const newGamePlan = {
                    ...gamePlan,
                    miniScripts: (gamePlan?.miniScripts || []).filter(s => s.id !== scriptId)
                };
                onUpdateGamePlan(newGamePlan);
                setConfirmDeleteScriptId(null);

                // Update Layout
                if (onUpdateLayouts && gamePlanLayouts) {
                    const newLayouts = { ...gamePlanLayouts };
                    const sheet = { ...newLayouts.CALL_SHEET };
                    sheet.sections = sheet.sections.map(section => ({
                        ...section,
                        rows: section.rows.filter(row => row.setId !== scriptId)
                    }));
                    newLayouts.CALL_SHEET = sheet;
                    onUpdateLayouts(newLayouts);
                }
            };

            const handleUpdateFormationName = (formationId, newName) => {
                const newOverrides = { ...(gamePlan.formationOverrides || {}), [formationId]: newName };
                onUpdateGamePlan({ ...gamePlan, formationOverrides: newOverrides });
                setEditingFormationId(null);
            };

            // Layout Drag State
            const [confirmResetLayout, setConfirmResetLayout] = useState(false);
            const [draggedCell, setDraggedCell] = useState(null); // { sectionIdx, rowIdx }
            const [draggedSection, setDraggedSection] = useState(null); // { sectionIdx }
            const [editingHeader, setEditingHeader] = useState(null); // { sectionIdx, rowIdx }

            const handleDragStart = (e, sectionIdx, rowIdx) => {
                if (isLocked || draggedSection) return; // Don't allow cell drag if section is being dragged
                setDraggedCell({ sectionIdx, rowIdx });
                e.dataTransfer.effectAllowed = 'move';
                e.stopPropagation(); // Prevent section drag from firing
            };

            const handleDragOver = (e) => {
                if (isLocked) return;
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            };

            const handleDrop = (e, targetSectionIdx, targetRowIdx) => {
                if (isLocked || !draggedCell) return;
                e.preventDefault();

                // Clone layouts
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                sheet.sections = [...sheet.sections];

                // Get source and target arrays
                // FIX: Use .boxes instead of .rows
                const sourceBoxes = [...(sheet.sections[draggedCell.sectionIdx].boxes || [])]; const targetBoxes = draggedCell.sectionIdx === targetSectionIdx ? sourceBoxes : [...(sheet.sections[targetSectionIdx].boxes || [])];

                const itemToMove = sourceBoxes[draggedCell.rowIdx];
                if (!itemToMove) return; // Safety check

                // Verify index to prevent duplication if state is stale
                const realSourceIdx = sourceBoxes.findIndex(r => r.setId === itemToMove.setId);
                if (realSourceIdx === -1) return; // Item not found? Abort.

                // Remove from source
                sourceBoxes.splice(realSourceIdx, 1);

                // Insert into target
                if (draggedCell.sectionIdx === targetSectionIdx) {
                    // SAME LIST
                    // If we removed from BEFORE the target, the target index shifted down by 1.
                    // But wait, standard behavior:
                    // [A, B, C]. Drag A (0) to C (2).
                    // Remove A. [B, C].
                    // Visual Drop Target was Index 2 (C). C is now at Index 1.
                    // We want to insert AFTER C. So Index 2.

                    // Simple logic:
                    let insertionIdx = targetRowIdx;

                    // Checkbounds
                    if (insertionIdx > sourceBoxes.length) insertionIdx = sourceBoxes.length;

                    sourceBoxes.splice(insertionIdx, 0, itemToMove);

                    // Assign back
                    sheet.sections[draggedCell.sectionIdx].boxes = sourceBoxes;

                } else {
                    // DIFFERENT LIST
                    // Insert into target list at specific index
                    let insertionIdx = targetRowIdx;
                    if (insertionIdx > targetBoxes.length) insertionIdx = targetBoxes.length; // Safety

                    targetBoxes.splice(insertionIdx, 0, itemToMove);

                    // Update both sections
                    sheet.sections[draggedCell.sectionIdx].boxes = sourceBoxes;
                    sheet.sections[targetSectionIdx].boxes = targetBoxes;
                }

                // Update State
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                setDraggedCell(null);
            };

            // Section drag handlers
            const handleSectionDragStart = (e, sectionIdx) => {
                if (isLocked) return;
                setDraggedSection({ sectionIdx });
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleSectionDragOver = (e) => {
                if (isLocked || (!draggedSection && !draggedCell)) return;
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'move';
            };

            const handleSectionDrop = (e, targetSectionIdx) => {
                if (isLocked) return;

                // Case 1: Dropping a Section (Reordering Sections)
                if (draggedSection) {
                    e.preventDefault();
                    e.stopPropagation();

                    const sourceSectionIdx = draggedSection.sectionIdx;
                    if (sourceSectionIdx === targetSectionIdx) {
                        setDraggedSection(null);
                        return;
                    }

                    // Reorder sections array
                    const newLayouts = { ...gamePlanLayouts };
                    const sheet = { ...newLayouts.CALL_SHEET };
                    const sections = [...sheet.sections];

                    // Remove source section
                    const [movedSection] = sections.splice(sourceSectionIdx, 1);

                    // Insert at target position
                    sections.splice(targetSectionIdx, 0, movedSection);

                    sheet.sections = sections;
                    newLayouts.CALL_SHEET = sheet;
                    if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                    setDraggedSection(null);
                    return;
                }

                // Case 2: Dropping a Box (Moving Box to Section)
                if (draggedCell) {
                    e.preventDefault();
                    e.stopPropagation();

                    // If dropped on the same section, do nothing (draggedCell logic in handleDrop handles intra-section sorts usually, 
                    // but dropping on the *container* usually implies appending or no-op if same. 
                    // Let's allow appending if same section? Or just return if same to avoid jumping.)
                    if (draggedCell.sectionIdx === targetSectionIdx) return;

                    // Move dragged item to this section
                    const newLayouts = { ...gamePlanLayouts };
                    const sheet = { ...newLayouts.CALL_SHEET };
                    sheet.sections = [...sheet.sections];

                    // Source
                    const sourceBoxes = [...(sheet.sections[draggedCell.sectionIdx].boxes || [])];
                    const itemToMove = sourceBoxes[draggedCell.rowIdx];

                    // Safety
                    if (!itemToMove) return;

                    // Remove from source
                    sourceBoxes.splice(draggedCell.rowIdx, 1);
                    sheet.sections[draggedCell.sectionIdx] = { ...sheet.sections[draggedCell.sectionIdx], boxes: sourceBoxes };

                    // Target (Append to this section)
                    // Ensure boxes array exists
                    const targetBoxes = [...(sheet.sections[targetSectionIdx].boxes || []), itemToMove];
                    sheet.sections[targetSectionIdx] = { ...sheet.sections[targetSectionIdx], boxes: targetBoxes };

                    newLayouts.CALL_SHEET = sheet;
                    if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                    setDraggedCell(null);
                }
            };


            const saveHeader = (sectionIdx, rowIdx, newName) => {
                if (!onUpdateLayouts) return;
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                sheet.sections = [...sheet.sections];
                const boxes = [...sheet.sections[sectionIdx].boxes];
                boxes[rowIdx] = { ...boxes[rowIdx], header: newName };
                sheet.sections[sectionIdx] = { ...sheet.sections[sectionIdx], boxes };
                newLayouts.CALL_SHEET = sheet;
                onUpdateLayouts(newLayouts);
                setEditingHeader(null);
            };

            const toggleSectionExpansion = (sectionIdx) => {
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                const section = { ...sheet.sections[sectionIdx] };

                // Toggle expansion state
                section.expandToFill = !section.expandToFill;

                sheet.sections[sectionIdx] = section;
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
            };

            const toggleVisibility = (sectionIdx, rowIdx) => {
                if (!onUpdateLayouts) return;
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                sheet.sections = [...sheet.sections];
                const boxes = [...sheet.sections[sectionIdx].boxes];
                boxes[rowIdx] = { ...boxes[rowIdx], hidden: !boxes[rowIdx].hidden };
                sheet.sections[sectionIdx].boxes = boxes;
                newLayouts.CALL_SHEET = sheet;
                onUpdateLayouts(newLayouts);
            };

            // Extracted logic for Active Plays
            const getAllActivePlays = () => {
                const allActivePlayIds = new Set();
                Object.values(gamePlan?.sets || {}).forEach(set => set.playIds.forEach(id => allActivePlayIds.add(id)));
                Object.values(gamePlan?.miniScripts || {}).forEach(script => script.playIds.forEach(id => allActivePlayIds.add(id)));
                return Array.from(allActivePlayIds).map(id => plays.find(p => p.id === id)).filter(Boolean);
            };

            const renderPlayerTouches = () => {
                const allActivePlays = getAllActivePlays();
                const targets = TAG_CATEGORIES["Primary Target"] || [];
                return (
                    <div className="animate-fade-in" style={{ height: '100%', overflowY: 'auto', paddingRight: '1rem', background: 'white', padding: '1rem', borderRadius: '8px' }}>
                        <div style={{ marginBottom: '1.5rem', border: '1px solid #ddd', borderRadius: '8px', overflow: 'hidden' }}>
                            <div style={{ background: '#f8fafc', padding: '0.5rem 1rem', borderBottom: '1px solid #ddd', fontWeight: 'bold', color: '#64748b', fontSize: '0.8rem', textTransform: 'uppercase' }}>
                                Player Touches Summary
                            </div>
                            <div style={{ display: 'grid', gridTemplateColumns: `repeat(${targets.length}, 1fr)`, divideX: '1px solid #eee' }}>
                                {targets.map((target, idx) => {
                                    const targetPlays = allActivePlays.filter(p => (p.tags || []).includes(target) || p.primaryTarget === target || p.tag1 === target || p.tag2 === target);

                                    return (
                                        <div key={target} style={{ borderRight: idx < targets.length - 1 ? '1px solid #eee' : 'none' }}>
                                            <div style={{ background: '#f1f5f9', padding: '0.25rem', textAlign: 'center', fontWeight: 'bold', fontSize: '0.9rem', borderBottom: '1px solid #eee' }}>
                                                {target} <span style={{ fontSize: '0.7rem', color: '#94a3b8', marginLeft: '4px' }}>({targetPlays.length})</span>
                                            </div>
                                            <div style={{ padding: '0.5rem', maxHeight: '600px', overflowY: 'auto' }}>
                                                {targetPlays.length > 0 ? (
                                                    targetPlays.map(p => (
                                                        <div key={p.id} style={{ fontSize: '0.7rem', marginBottom: '4px', padding: '2px 4px', background: 'white', border: '1px solid #eee', borderRadius: '3px' }}>
                                                            {p.name}
                                                        </div>
                                                    ))
                                                ) : (
                                                    <div style={{ fontSize: '0.7rem', color: '#cbd5e1', textAlign: 'center', fontStyle: 'italic', padding: '0.5rem 0' }}>-</div>
                                                )}
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    </div>
                );
            };

            const handleClearPlays = (setId) => {
                if (!onUpdateGamePlan) return;
                const newGamePlan = { ...gamePlan };
                let found = false;
                if (newGamePlan.sets) {
                    const set = newGamePlan.sets.find(s => s.id === setId);
                    if (set) {
                        set.playIds = [];
                        found = true;
                    }
                }
                if (!found && newGamePlan.miniScripts) {
                    const script = newGamePlan.miniScripts.find(s => s.id === setId);
                    if (script) {
                        script.playIds = [];
                        found = true;
                    }
                }
                if (found) onUpdateGamePlan(newGamePlan);
            };

            // --- Box Renderers & Helpers ---

            const handleAddRowToSection = (sectionIdx) => {
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                const section = { ...sheet.sections[sectionIdx] };

                const newId = `cell_${Date.now()}`;
                section.rows.push({ id: newId, content: '' });

                sheet.sections[sectionIdx] = section;
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
            };

            const handleAddBoxToSection = (sectionIdx, type = 'grid') => {
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                const section = { ...sheet.sections[sectionIdx] };

                // Ensure boxes array exists
                if (!section.boxes) section.boxes = [];

                // Create new Box
                const newBox = {
                    header: type === 'script' ? 'New Script' : 'New Grid Box',
                    color: '#3b82f6',
                    setId: `box_${Date.now()}`,
                    type: type,
                    colSpan: 1,
                    hidden: false
                };

                if (type === 'grid') {
                    newBox.gridHeadings = ['LEFT HASH', 'MIDDLE', 'RIGHT HASH', 'NOTES'];
                    newBox.gridRowLabels = ['Group 1', 'Group 2', 'Group 3', 'Group 4'];
                    newBox.cornerLabel = 'Group/Type';
                } else if (type === 'script') {
                    newBox.rows = [{ content: null, contentRight: null, id: `slot_${Date.now()}` }];
                }

                section.boxes.push(newBox);

                sheet.sections[sectionIdx] = section;
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
            };

            const setTempo = (sectionIdx, rowIdx, value) => {
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                const section = { ...sheet.sections[sectionIdx] };
                if (!section.tempos) section.tempos = {};

                section.tempos[rowIdx] = value;
                sheet.sections[sectionIdx] = section;
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
            };




            const GridPlayInput = ({ setId, onSelectPlay, onQuickAdd }) => {
                const [searchTerm, setSearchTerm] = useState('');
                const [showDropdown, setShowDropdown] = useState(false);
                const [selectedIndex, setSelectedIndex] = useState(0);
                const inputRef = useRef(null);
                const dropdownRef = useRef(null);

                const filteredResults = useMemo(() => {
                    if (!searchTerm) return [];
                    const lower = searchTerm.toLowerCase();
                    return plays.filter(p => {
                        return (p.name || '').toLowerCase().includes(lower) ||
                            (p.formation || '').toLowerCase().includes(lower) ||
                            (p.concept || '').toLowerCase().includes(lower) ||
                            (p.wristbandSlot || '').toLowerCase().includes(lower);
                    }).slice(0, 8);
                }, [searchTerm, plays]);

                useEffect(() => {
                    if (showDropdown && filteredResults.length > 0) setSelectedIndex(0);
                }, [showDropdown, filteredResults.length]);

                useEffect(() => {
                    const handleClickOutside = (event) => {
                        if (dropdownRef.current && !dropdownRef.current.contains(event.target) && !inputRef.current.contains(event.target)) {
                            setShowDropdown(false);
                        }
                    };
                    document.addEventListener("mousedown", handleClickOutside);
                    return () => document.removeEventListener("mousedown", handleClickOutside);
                }, []);

                const handleKeyDown = (e) => {
                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        setSelectedIndex(prev => Math.min(prev + 1, filteredResults.length - 1));
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        setSelectedIndex(prev => Math.max(prev - 1, 0));
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        if (showDropdown && filteredResults.length > 0) {
                            onSelectPlay(filteredResults[selectedIndex].id);
                            setSearchTerm('');
                            setShowDropdown(false);
                        } else if (searchTerm.trim()) {
                            onQuickAdd(searchTerm);
                            setSearchTerm('');
                            setShowDropdown(false);
                        }
                    } else if (e.key === 'Escape') {
                        setShowDropdown(false);
                    }
                };

                return (
                    <div style={{ position: 'relative', width: '100%', marginTop: '0' }}>
                        <input
                            ref={inputRef}
                            type="text"
                            placeholder="+"
                            value={searchTerm}
                            onChange={(e) => {
                                setSearchTerm(e.target.value.toUpperCase());
                                setShowDropdown(true);
                            }}
                            onFocus={() => setShowDropdown(true)}
                            onKeyDown={handleKeyDown}
                            onClick={(e) => e.stopPropagation()}
                            style={{
                                width: '100%',
                                padding: '2px 4px',
                                fontSize: '0.75rem',
                                border: '1px dashed var(--border)',
                                borderRadius: '3px',
                                background: 'rgba(255,255,255,0.1)'
                            }}
                        />
                        {showDropdown && searchTerm && (
                            <div
                                ref={dropdownRef}
                                style={{
                                    position: 'absolute',
                                    top: '100%',
                                    left: 0,
                                    width: '200px',
                                    maxHeight: '150px',
                                    overflowY: 'auto',
                                    background: 'white',
                                    border: '1px solid #cbd5e1',
                                    borderRadius: '4px',
                                    boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)',
                                    zIndex: 1000,
                                    marginTop: '2px'
                                }}
                            >
                                {filteredResults.map((p, idx) => (
                                    <div
                                        key={p.id}
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            onSelectPlay(p.id);
                                            setSearchTerm('');
                                            setShowDropdown(false);
                                        }}
                                        style={{
                                            padding: '4px 8px',
                                            fontSize: '0.75rem',
                                            cursor: 'pointer',
                                            background: idx === selectedIndex ? '#f1f5f9' : 'white',
                                            borderBottom: '1px solid #f1f5f9',
                                            color: '#0f172a' // Force dark text
                                        }}
                                        onMouseEnter={() => setSelectedIndex(idx)}
                                    >
                                        <div style={{ fontWeight: 'bold', color: '#0f172a' }}>{p.name}</div>
                                    </div>
                                ))}
                                {filteredResults.length === 0 && (
                                    <div style={{ padding: '4px 8px', fontSize: '0.7rem', color: '#94a3b8', fontStyle: 'italic' }}>
                                        Enter to create "{searchTerm}"
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                );
            };

            const handleAssignPlayToSituation = (playId, box) => {
                if (!playId || !box || !box.setId) return;

                const isScript = box.type === 'script';
                const collectionKey = isScript ? 'miniScripts' : 'sets';
                const targetId = box.setId;

                const updatedGamePlan = { ...gamePlan };

                // Ensure collection array exists
                if (!Array.isArray(updatedGamePlan[collectionKey])) {
                    updatedGamePlan[collectionKey] = [];
                }

                // Find existing set/script in the array
                const existingItem = updatedGamePlan[collectionKey].find(item => item.id === targetId);

                // Get current assigned IDs
                const currentData = existingItem || { playIds: [], assignedPlayIds: [] };
                let currentAssigned = currentData.assignedPlayIds || currentData.playIds || [];

                const isAssigned = currentAssigned.includes(playId);
                let newAssignedIds;

                if (isAssigned) {
                    // Remove play (toggle off)
                    newAssignedIds = currentAssigned.filter(id => id !== playId);
                } else {
                    // Add play - use Set to prevent duplicates from rapid clicks
                    newAssignedIds = [...new Set([...currentAssigned, playId])];
                }

                if (existingItem) {
                    // Update existing item
                    updatedGamePlan[collectionKey] = updatedGamePlan[collectionKey].map(item =>
                        item.id === targetId
                            ? { ...item, assignedPlayIds: newAssignedIds }
                            : item
                    );
                } else {
                    // Create new item
                    updatedGamePlan[collectionKey] = [
                        ...updatedGamePlan[collectionKey],
                        { id: targetId, name: targetId, assignedPlayIds: newAssignedIds, playIds: [] }
                    ];
                }

                onUpdateGamePlan(updatedGamePlan);
            };

            const getPlaySituations = (playId) => {
                if (!playId || !gamePlanLayouts?.CALL_SHEET?.sections) return [];

                const assignedSituations = [];

                gamePlanLayouts.CALL_SHEET.sections.forEach(section => {
                    if (!section.boxes) return;
                    section.boxes.forEach(box => {
                        if (!box.setId) return;

                        const isScript = box.type === 'script';
                        const collection = isScript ? (gamePlan?.miniScripts || []) : (gamePlan?.sets || []);

                        // Handle both array and object formats
                        let data;
                        if (Array.isArray(collection)) {
                            data = collection.find(item => item.id === box.setId);
                        } else {
                            data = collection[box.setId];
                        }

                        // Check if play is assigned
                        if (data?.assignedPlayIds?.includes(playId)) {
                            assignedSituations.push({
                                id: box.setId,
                                header: box.header,
                                color: box.color,
                                type: box.type
                            });
                        }
                    });
                });

                return assignedSituations;
            };

            const PlaySlot = ({ playId, onUpdate, isLocked, placeholder = "+", dropUp = false, renderWristbandInput }) => {
                const play = plays.find(p => p.id === playId);
                const [isHovered, setIsHovered] = useState(false);
                const [searchTerm, setSearchTerm] = useState('');
                const [showDropdown, setShowDropdown] = useState(false);
                const [selectedIndex, setSelectedIndex] = useState(0);
                const dropdownRef = useRef(null);
                const inputRef = useRef(null);

                // Derived state for filtered results
                const filteredResults = useMemo(() => {
                    if (!searchTerm || isLocked) return [];
                    const lower = searchTerm.toLowerCase();

                    // Search Criteria: Name, Formulation, Concept, Wristband Slot
                    return plays.filter(p => {
                        const matchName = p.name.toLowerCase().includes(lower);
                        const matchFormation = (p.formation || '').toLowerCase().includes(lower);
                        const matchConcept = (p.concept || '').toLowerCase().includes(lower);
                        const matchWB = (p.wristbandSlot || '').toLowerCase().includes(lower);

                        return matchName || matchFormation || matchConcept || matchWB;
                    }).slice(0, 10); // Limit results
                }, [searchTerm, plays, isLocked]);

                // Close dropdown when clicking outside
                useEffect(() => {
                    const handleClickOutside = (event) => {
                        if (dropdownRef.current && !dropdownRef.current.contains(event.target) && !inputRef.current.contains(event.target)) {
                            setShowDropdown(false);
                        }
                    };
                    document.addEventListener("mousedown", handleClickOutside);
                    return () => document.removeEventListener("mousedown", handleClickOutside);
                }, []);

                useEffect(() => {
                    if (showDropdown && filteredResults.length > 0) {
                        setSelectedIndex(0);
                    }
                }, [showDropdown, filteredResults.length]);

                const handleKeyDown = (e) => {
                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        setSelectedIndex(prev => Math.min(prev + 1, filteredResults.length - 1));
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        setSelectedIndex(prev => Math.max(prev - 1, 0));
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        if (showDropdown && filteredResults.length > 0) {
                            // Select from dropdown
                            onUpdate(filteredResults[selectedIndex].id);
                            setShowDropdown(false);
                            setSearchTerm('');
                        } else {
                            // Quick Add New
                            if (onQuickAddPlay) {
                                const newPlay = onQuickAddPlay(searchTerm);
                                onUpdate(newPlay.id);
                                setShowDropdown(false);
                                setSearchTerm('');
                            }
                        }
                    } else if (e.key === 'Escape') {
                        setShowDropdown(false);
                    }
                };

                return (
                    <div
                        style={{
                            width: '100%',
                            height: '100%',
                            position: 'relative',
                            display: 'flex',
                            alignItems: 'center',
                            padding: '0 4px',
                            background: isHovered ? '#e0f2fe' : 'transparent',
                            cursor: play ? 'pointer' : 'text'  // Use 'text' cursor when showing input
                        }}
                        onDragOver={(e) => { e.preventDefault(); setIsHovered(true); }}
                        onDragLeave={() => setIsHovered(false)}
                        onDrop={(e) => {
                            e.preventDefault(); setIsHovered(false); if (isLocked) return;
                            try { const data = JSON.parse(e.dataTransfer.getData('application/react-dnd')); if (data && data.playId) onUpdate(data.playId); } catch (e) { }
                        }}
                        onDoubleClick={(e) => {
                            if (isLocked || !play) return;
                            e.stopPropagation();
                            setAssignmentModalState({ playId: play.id, x: e.clientX, y: e.clientY });
                        }}
                    >
                        {play ? (
                            <div style={{ width: '100%', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap', fontSize: '0.75rem', display: 'flex', alignItems: 'center' }}>
                                <span style={{ fontWeight: 'bold', color: '#0f172a' }}>{getPlayDisplayName(play)}</span>
                                {play.staplesSlot && <span style={{ fontSize: '0.8em', background: '#fef3c7', color: '#b45309', padding: '1px 3px', borderRadius: '3px', marginLeft: '4px', fontWeight: 'bold' }}>S:{play.staplesSlot}</span>}

                                {renderWristbandInput && renderWristbandInput(play.id)}

                                {!renderWristbandInput && play.wristbandSlot && (
                                    <span style={{ fontSize: '0.8em', background: '#e0f2fe', color: '#0369a1', padding: '1px 3px', borderRadius: '3px', marginLeft: '6px', fontWeight: 'bold' }}>
                                        {typeof getWristbandLabel === 'function' ? getWristbandLabel(play) : play.wristbandSlot + (play.isMiniScript || play.isWiz ? '' : 'T')}
                                    </span>
                                )}

                                {!isLocked && <button style={{ marginLeft: 'auto', background: 'none', border: 'none', color: '#ef4444', cursor: 'pointer', padding: '0 4px', fontSize: '1.2em', lineHeight: '1' }} onClick={() => onUpdate(null)}>×</button>}
                            </div>
                        ) : (
                            !isLocked && (
                                <div
                                    style={{ position: 'relative', width: '100%' }}
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        if (inputRef.current) {
                                            inputRef.current.focus();
                                        }
                                    }}
                                >
                                    <input
                                        ref={inputRef}
                                        placeholder={placeholder}
                                        value={searchTerm}
                                        onChange={(e) => {
                                            setSearchTerm(e.target.value.toUpperCase());
                                            setShowDropdown(true);
                                        }}
                                        onFocus={() => setShowDropdown(true)}
                                        onKeyDown={handleKeyDown}
                                        style={{ width: '100%', border: 'none', fontSize: '0.9rem', background: 'transparent', outline: 'none' }}
                                    />
                                    {showDropdown && searchTerm && (
                                        <div
                                            ref={dropdownRef}
                                            style={{
                                                position: 'absolute',
                                                top: dropUp ? 'auto' : '100%',
                                                bottom: dropUp ? '100%' : 'auto',
                                                left: 0,
                                                width: '300px', // Wider than input
                                                maxHeight: '200px',
                                                overflowY: 'auto',
                                                background: 'white',
                                                border: '1px solid #cbd5e1',
                                                borderRadius: '4px',
                                                boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)',
                                                zIndex: 1000,
                                                marginTop: dropUp ? '0' : '4px',
                                                marginBottom: dropUp ? '4px' : '0'
                                            }}
                                        >
                                            {filteredResults.map((p, idx) => (
                                                <div
                                                    key={p.id}
                                                    onClick={() => {
                                                        onUpdate(p.id);
                                                        setShowDropdown(false);
                                                        setSearchTerm('');
                                                    }}
                                                    style={{
                                                        padding: '6px 12px',
                                                        fontSize: '0.85rem',
                                                        cursor: 'pointer',
                                                        background: idx === selectedIndex ? '#f1f5f9' : 'white',
                                                        borderBottom: '1px solid #f1f5f9',
                                                        display: 'flex', alignItems: 'center', justifyContent: 'space-between',
                                                        color: '#0f172a' // Force dark text color
                                                    }}
                                                    onMouseEnter={() => setSelectedIndex(idx)}
                                                >
                                                    <div style={{ display: 'flex', flexDirection: 'column' }}>
                                                        <span style={{ fontWeight: 'bold', color: '#0f172a' }}>{p.name}</span>
                                                    </div>
                                                    {p.wristbandSlot && (
                                                        <div style={{ fontSize: '0.7em', background: '#dbeafe', color: '#1e40af', padding: '2px 6px', borderRadius: '12px', fontWeight: 'bold' }}>
                                                            {p.wristbandSlot}
                                                        </div>
                                                    )}
                                                </div>
                                            ))}
                                            {filteredResults.length === 0 && (
                                                <div style={{ padding: '8px', fontSize: '0.8rem', color: '#64748b', fontStyle: 'italic' }}>
                                                    Press Enter to create "{searchTerm}"
                                                </div>
                                            )}
                                        </div>
                                    )}
                                </div>
                            )
                        )}

                        {/* Situation Assignment UI - DOTS ONLY */}
                        {
                            (playId && !isLocked) && (
                                <div style={{ display: 'flex', alignItems: 'center', marginLeft: 'auto', paddingLeft: '4px' }}>
                                    {/* Render Assigned Situations */}
                                    {getPlaySituations(playId).map(sit => (
                                        <div
                                            key={sit.id}
                                            title={`Assigned to ${sit.header}`}
                                            style={{
                                                width: '8px', height: '8px', borderRadius: '50%',
                                                backgroundColor: sit.color || '#cbd5e1',
                                                marginRight: '2px',
                                                cursor: 'help'
                                            }}
                                        />
                                    ))}
                                </div>
                            )
                        }

                    </div >
                );
            };

            const renderInteriorConfig = (box, sectionIdx, boxIdx) => (
                <div style={{ background: '#f8fafc', border: '1px solid #e2e8f0', borderRadius: '6px', padding: '8px', marginBottom: '8px', display: 'flex', flexDirection: 'column', gap: '8px' }}>
                    <div style={{ width: '100%' }}>
                        <div style={{ fontSize: '0.65rem', fontWeight: 'bold', color: '#64748b', textTransform: 'uppercase', marginBottom: '2px' }}>Box Name</div>
                        <input
                            type="text"
                            value={box.header || ''}
                            onChange={(e) => {
                                const newLayouts = { ...gamePlanLayouts };
                                newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx].header = e.target.value;
                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                            }}
                            placeholder="Enter box name (e.g. 3rd & Long)"
                            style={{ width: '100%', padding: '6px', border: '1px solid #cbd5e1', borderRadius: '4px', fontSize: '0.8rem', fontFamily: 'inherit', marginBottom: '8px' }}
                        />
                        <div style={{ fontSize: '0.65rem', fontWeight: 'bold', color: '#64748b', textTransform: 'uppercase', marginBottom: '2px' }}>Box Notes / Situation Detail</div>
                        <textarea
                            value={box.notes || ''}
                            onChange={(e) => {
                                const newLayouts = { ...gamePlanLayouts };
                                newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx].notes = e.target.value;
                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                            }}
                            placeholder="Add situation details, notes, or instructions here..."
                            style={{ width: '100%', padding: '6px', border: '1px solid #cbd5e1', borderRadius: '4px', fontSize: '0.8rem', minHeight: '60px', resize: 'vertical', fontFamily: 'inherit' }}
                        />
                    </div>
                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: '8px' }}>
                        <div style={{ flex: 1 }}>
                            <div style={{ fontSize: '0.65rem', fontWeight: 'bold', color: '#64748b', textTransform: 'uppercase', marginBottom: '2px' }}>Box Type</div>
                            <select
                                value={box.type || 'grid'}
                                onChange={(e) => {
                                    const newLayouts = { ...gamePlanLayouts };
                                    newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx].type = e.target.value;
                                    if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                }}
                                style={{ width: '100%', padding: '4px', border: '1px solid #cbd5e1', borderRadius: '4px', fontSize: '0.8rem' }}
                            >
                                <option value="grid">Grid (4x4)</option>
                                <option value="script">Script (Rows)</option>
                            </select>
                        </div>
                        <button
                            className="btn-sm"
                            onClick={() => {
                                if (confirm('Delete this box?')) {
                                    const newLayouts = { ...gamePlanLayouts };
                                    newLayouts.CALL_SHEET.sections[sectionIdx].boxes.splice(boxIdx, 1);
                                    if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                    setEditingHeader(null);
                                    setEditingBox(null);
                                }
                            }}
                            style={{ background: '#fee2e2', color: '#dc2626', fontSize: '0.7rem', padding: '6px', borderRadius: '4px', border: '1px solid #fca5a5' }}
                        ><Icon name="Trash2" size={14} /></button>
                    </div>
                </div>
            );

            const renderAssignedPlaysPanel = (box) => {
                // Get the setId from the box to look up assigned plays
                const setId = box.setId;
                if (!setId) return null;

                // Get the set/script data object
                const sets = Array.isArray(gamePlan?.sets) ? gamePlan.sets : [];
                const scripts = Array.isArray(gamePlan?.miniScripts) ? gamePlan.miniScripts : [];
                const setData = sets.find(s => s.id === setId) || scripts.find(s => s.id === setId) || {};

                // Get assigned play IDs (safely defaulting to empty array)
                // Note: handling both 'playIds' and 'assignedPlayIds' for backward compatibility/migration
                let assignedPlayIds = setData.assignedPlayIds || setData.playIds || [];

                // PATCH: For Opening Script, aggregate from Left/Right hash sets AND Install List situations
                if (setId === 'opening_script') {
                    const leftSet = sets.find(s => s.id === 'opening_script_left') || {};
                    const rightSet = sets.find(s => s.id === 'opening_script_right') || {};
                    const leftIds = leftSet.assignedPlayIds || leftSet.playIds || [];
                    const rightIds = rightSet.assignedPlayIds || rightSet.playIds || [];

                    // Also find plays tagged with "Opening Script" in the Install List / Play Data
                    const taggedPlays = plays.filter(p => {
                        // Check if play is in install list (optional, but good practice)
                        // And check if its situation matches "Opening Script"
                        // This depends on how situation is stored. Assuming p.situation or p.tags
                        return p.situation === 'Opening Script' || (p.tags && p.tags.includes('Opening Script'));
                    }).map(p => p.id);

                    // Merge and Deduplicate
                    const allIds = new Set([...assignedPlayIds, ...leftIds, ...rightIds, ...taggedPlays]);
                    assignedPlayIds = Array.from(allIds);
                }

                // Map play IDs to full play objects
                const assignedPlays = assignedPlayIds
                    .map(playId => plays.find(p => p.id === playId))
                    .filter(Boolean);

                // Handle adding a play
                // Determine if this is a script or set
                const isScript = box.type === 'script';
                const collectionKey = isScript ? 'miniScripts' : 'sets';

                // Handle adding a play
                const handleAddPlay = (playId) => {
                    if (!assignedPlayIds.includes(playId)) {
                        const updatedGamePlan = { ...gamePlan };

                        // Ensure collection array exists
                        if (!updatedGamePlan[collectionKey]) {
                            updatedGamePlan[collectionKey] = [];
                        }

                        // Find existing set/script in the array
                        const existingItem = updatedGamePlan[collectionKey].find(item => item.id === setId);
                        const newAssignedIds = [...assignedPlayIds, playId];

                        if (existingItem) {
                            // Update existing item - only update assignedPlayIds, NOT playIds (grid uses playIds)
                            updatedGamePlan[collectionKey] = updatedGamePlan[collectionKey].map(item =>
                                item.id === setId
                                    ? { ...item, assignedPlayIds: newAssignedIds }
                                    : item
                            );
                        } else {
                            // Create new item - initialize playIds as empty array (used by Grid), assignedPlayIds for Quick List
                            updatedGamePlan[collectionKey] = [
                                ...updatedGamePlan[collectionKey],
                                { id: setId, name: setId, assignedPlayIds: newAssignedIds, playIds: [] }
                            ];
                        }

                        onUpdateGamePlan(updatedGamePlan);
                    }
                };

                // Handle removing a play
                const handleRemovePlay = (playId) => {
                    const updatedGamePlan = { ...gamePlan };

                    if (!updatedGamePlan[collectionKey]) return;

                    const newAssignedIds = assignedPlayIds.filter(id => id !== playId);

                    // Update the item in the array - only update assignedPlayIds, NOT playIds
                    updatedGamePlan[collectionKey] = updatedGamePlan[collectionKey].map(item =>
                        item.id === setId
                            ? { ...item, assignedPlayIds: newAssignedIds }
                            : item
                    );

                    onUpdateGamePlan(updatedGamePlan);
                };

                // Handle reordering plays
                const handleMovePlay = (playId, direction) => {
                    const currentIndex = assignedPlayIds.indexOf(playId);
                    if (currentIndex === -1) return;

                    const newIndex = direction === 'up' ? currentIndex - 1 : currentIndex + 1;
                    if (newIndex < 0 || newIndex >= assignedPlayIds.length) return;

                    const updatedGamePlan = { ...gamePlan };
                    if (!updatedGamePlan[collectionKey]) return;

                    const newPlayIds = [...assignedPlayIds];
                    [newPlayIds[currentIndex], newPlayIds[newIndex]] = [newPlayIds[newIndex], newPlayIds[currentIndex]];

                    // Update the item in the array - only update assignedPlayIds, NOT playIds
                    updatedGamePlan[collectionKey] = updatedGamePlan[collectionKey].map(item =>
                        item.id === setId
                            ? { ...item, assignedPlayIds: newPlayIds }
                            : item
                    );

                    onUpdateGamePlan(updatedGamePlan);
                };

                return (
                    <div style={{
                        display: 'flex',
                        flexDirection: 'column',
                        height: '100%',
                        background: '#f8fafc',
                        borderRadius: '8px',
                        overflow: 'visible'  // Changed from 'hidden' to allow dropdown to show
                    }}>
                        {/* Header */}
                        <div style={{
                            padding: '1rem',
                            borderBottom: '2px solid #e2e8f0',
                            background: 'white'
                        }}>
                            <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                                <h4 style={{ margin: 0, fontSize: '0.9rem', fontWeight: 'bold', color: '#1e293b' }}>
                                    QUICK LIST
                                </h4>
                                <span style={{
                                    background: box.color || '#64748b',
                                    color: 'white',
                                    padding: '2px 8px',
                                    borderRadius: '12px',
                                    fontSize: '0.75rem',
                                    fontWeight: 'bold'
                                }}>
                                    {assignedPlays.length}
                                </span>
                            </div>
                        </div>

                        {/* Play List */}
                        <div style={{ flex: 1, overflowY: 'auto', padding: '0.5rem' }}>
                            {assignedPlays.length > 0 ? (
                                assignedPlays.map((play, idx) => (
                                    <div
                                        key={play.id}
                                        draggable={true}
                                        style={{
                                            background: 'white',
                                            border: '1px solid #e2e8f0',
                                            borderRadius: '6px',
                                            padding: '0.4rem',
                                            marginBottom: '0.25rem',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '0.5rem',
                                            cursor: 'grab'
                                        }}
                                        onDragStart={(e) => {
                                            e.dataTransfer.setData('application/react-dnd', JSON.stringify({ playId: play.id }));
                                            e.currentTarget.style.cursor = 'grabbing';
                                            e.currentTarget.style.opacity = '0.5';
                                        }}
                                        onDragEnd={(e) => {
                                            e.currentTarget.style.cursor = 'grab';
                                            e.currentTarget.style.opacity = '1';
                                        }}
                                        onDoubleClick={(e) => {
                                            e.stopPropagation();
                                            setAssignmentModalState({ playId: play.id, x: e.clientX, y: e.clientY });
                                        }}
                                    >
                                        {/* Reorder Buttons */}
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '2px' }}>
                                            <button
                                                onClick={() => handleMovePlay(play.id, 'up')}
                                                disabled={idx === 0}
                                                style={{
                                                    padding: '2px 4px',
                                                    fontSize: '0.7rem',
                                                    background: idx === 0 ? '#f1f5f9' : '#e2e8f0',
                                                    border: 'none',
                                                    borderRadius: '3px',
                                                    cursor: idx === 0 ? 'not-allowed' : 'pointer',
                                                    color: idx === 0 ? '#cbd5e1' : '#475569'
                                                }}
                                            >
                                                ▲
                                            </button>
                                            <button
                                                onClick={() => handleMovePlay(play.id, 'down')}
                                                disabled={idx === assignedPlays.length - 1}
                                                style={{
                                                    padding: '2px 4px',
                                                    fontSize: '0.7rem',
                                                    background: idx === assignedPlays.length - 1 ? '#f1f5f9' : '#e2e8f0',
                                                    border: 'none',
                                                    borderRadius: '3px',
                                                    cursor: idx === assignedPlays.length - 1 ? 'not-allowed' : 'pointer',
                                                    color: idx === assignedPlays.length - 1 ? '#cbd5e1' : '#475569'
                                                }}
                                            >
                                                ▼
                                            </button>
                                        </div>

                                        {/* Play Info */}
                                        <div style={{ flex: 1, minWidth: 0 }}>
                                            <div style={{ fontWeight: 'bold', fontSize: '0.85rem', color: '#1e293b', marginBottom: '2px', display: 'flex', alignItems: 'center', gap: '4px' }}>
                                                {play.priority && <Icon name="Star" size={12} fill="gold" color="gold" />}
                                                {getPlayDisplayName(play)}
                                                {play.wristbandSlot && (
                                                    <span style={{
                                                        marginLeft: '6px',
                                                        fontSize: '0.7rem',
                                                        background: '#dbeafe',
                                                        color: '#1e40af',
                                                        padding: '1px 6px',
                                                        borderRadius: '10px',
                                                        fontWeight: 'normal'
                                                    }}>
                                                        {play.wristbandSlot}
                                                    </span>
                                                )}
                                            </div>

                                        </div>

                                        {/* Remove Button */}
                                        <button
                                            onClick={() => handleRemovePlay(play.id)}
                                            style={{
                                                padding: '4px 8px',
                                                fontSize: '0.9rem',
                                                background: '#fee2e2',
                                                color: '#dc2626',
                                                border: 'none',
                                                borderRadius: '4px',
                                                cursor: 'pointer',
                                                fontWeight: 'bold'
                                            }}
                                            onMouseEnter={(e) => e.currentTarget.style.background = '#fecaca'}
                                            onMouseLeave={(e) => e.currentTarget.style.background = '#fee2e2'}
                                        >
                                            ×
                                        </button>
                                    </div>
                                ))
                            ) : (
                                <div style={{
                                    textAlign: 'center',
                                    padding: '2rem 1rem',
                                    color: '#94a3b8',
                                    fontSize: '0.85rem',
                                    fontStyle: 'italic'
                                }}>
                                    No plays assigned yet.
                                    <br />
                                    Click "Add Play" below to get started.
                                </div>
                            )}
                        </div>

                        {/* Add Play Button */}
                        <div style={{ padding: '0.75rem', borderTop: '2px solid #e2e8f0', background: 'white' }}>
                            <PlaySlot
                                playId={null}
                                isLocked={false}
                                onUpdate={handleAddPlay}
                                placeholder="+ Add Play to Situation"
                                dropUp={true}
                            />
                        </div>
                    </div>
                );
            };

            const [editingBox, setEditingBox] = useState(null); // { sectionIdx, boxIdx }

            const renderBoxEditorModal = () => {
                if (!editingBox) return null;
                const { sectionIdx, boxIdx } = editingBox;
                const section = gamePlanLayouts.CALL_SHEET.sections[sectionIdx];
                if (!section) return null;
                const box = section.boxes[boxIdx];
                if (!box) return null;

                const renderWristbandInput = (playId) => {
                    const play = plays.find(p => p.id === playId);
                    if (!play) return null;

                    const isFocused = wbAutocomplete.playId === playId;

                    // Filter available slots
                    const usedSlots = new Set(plays.filter(p => p.id !== playId && p.wristbandSlot).map(p => p.wristbandSlot));
                    const availableSlots = (validWristbandSlots || []).filter(slot => !usedSlots.has(slot));

                    const query = isFocused ? wbAutocomplete.query : (play.wristbandSlot || '');
                    const filteredSlots = isFocused && query
                        ? availableSlots.filter(s => s.toString().includes(query))
                        : []; // Only show when typing? Or show all available? Let's show filtered.

                    // Limit results
                    const candidates = filteredSlots.slice(0, 10);

                    return (
                        <div style={{ position: 'relative', marginLeft: '6px' }}>
                            <input
                                placeholder="#"
                                value={isFocused ? wbAutocomplete.query : (getWristbandLabel(play) || '')}
                                onFocus={() => setWbAutocomplete({ playId, query: play.wristbandSlot || '' })}
                                onChange={(e) => {
                                    setWbAutocomplete({ playId, query: e.target.value });
                                }}
                                onBlur={() => {
                                    // Delay to allow click
                                    setTimeout(() => {
                                        if (wbAutocomplete.playId === playId) {
                                            const slot = wbAutocomplete.query;

                                            // Validation Logic
                                            let isBlocked = false;
                                            const currentWbSettings = currentWeek?.wristbands || {};
                                            const enabledSections = currentWbSettings.enabledSections || {};

                                            const cardKeys = ['card1', 'card2', 'card3', 'card4', 'card5', 'card6'];
                                            for (const key of cardKeys) {
                                                if (enabledSections[key] !== false) continue;
                                                const card = currentWbSettings[key];
                                                if (!card) continue;
                                                const cardNum = parseInt(key.replace('card', ''));

                                                if (card.type && (card.type === 'rooski' || card.type === 'wiz')) {
                                                    for (let i = 1; i <= 16; i++) {
                                                        if (slot === `${cardNum}${String(i).padStart(2, '0')}`) isBlocked = true;
                                                    }
                                                } else {
                                                    const start = cardNum * 100 + 1;
                                                    const end = start + 47;
                                                    const num = parseInt(slot);
                                                    if (!isNaN(num) && num >= start && num <= end && String(num) === slot) isBlocked = true;
                                                }
                                            }

                                            // Check Staples
                                            if (enabledSections.staples === false) {
                                                const num = parseInt(slot);
                                                if (!isNaN(num) && num >= 10 && num <= 89 && String(num) === slot) isBlocked = true;
                                            }

                                            if (isBlocked) {
                                                alert("This wristband section is disabled.");
                                                setWbAutocomplete({ playId: null, query: '' }); // Reset
                                                return;
                                            }

                                            if (onUpdatePlay) onUpdatePlay({ ...play, wristbandSlot: wbAutocomplete.query });
                                            setWbAutocomplete({ playId: null, query: '' });
                                        }
                                    }, 200);
                                }}
                                style={{
                                    width: '36px', fontSize: '0.75rem', padding: '2px 4px',
                                    border: '1px solid #cbd5e1', borderRadius: '4px', textAlign: 'center',
                                    background: play.wristbandSlot ? '#dbeafe' : 'white',
                                    color: play.wristbandSlot ? '#1e40af' : '#64748b',
                                    fontWeight: 'bold'
                                }}
                            />
                            {isFocused && candidates.length > 0 && (
                                <div style={{
                                    position: 'absolute', top: '100%', right: 0,
                                    background: 'white', border: '1px solid #cbd5e1', borderRadius: '4px',
                                    boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)', zIndex: 50,
                                    maxHeight: '150px', overflowY: 'auto', minWidth: '60px'
                                }}>
                                    {candidates.map(slot => (
                                        <div
                                            key={slot}
                                            onMouseDown={(e) => {
                                                e.preventDefault(); // Prevent blur

                                                // Validation Logic Same as onBlur but checking 'slot'
                                                let isBlocked = false;
                                                const currentWbSettings = currentWeek?.wristbands || {};
                                                const enabledSections = currentWbSettings.enabledSections || {};

                                                const cardKeys = ['card1', 'card2', 'card3', 'card4', 'card5', 'card6'];
                                                for (const key of cardKeys) {
                                                    if (enabledSections[key] !== false) continue;
                                                    const card = currentWbSettings[key];
                                                    if (!card) continue;
                                                    const cardNum = parseInt(key.replace('card', ''));

                                                    if (card.type && (card.type === 'rooski' || card.type === 'wiz')) {
                                                        for (let i = 1; i <= 16; i++) {
                                                            if (String(slot) === `${cardNum}${String(i).padStart(2, '0')}`) isBlocked = true;
                                                        }
                                                    } else {
                                                        const start = cardNum * 100 + 1;
                                                        const end = start + 47;
                                                        const num = parseInt(slot);
                                                        if (!isNaN(num) && num >= start && num <= end && String(num) === String(slot)) isBlocked = true;
                                                    }
                                                }

                                                if (enabledSections.staples === false) {
                                                    const num = parseInt(slot);
                                                    if (!isNaN(num) && num >= 10 && num <= 89 && String(num) === String(slot)) isBlocked = true;
                                                }

                                                if (isBlocked) {
                                                    alert("This wristband section is disabled.");
                                                    setWbAutocomplete({ playId: null, query: '' }); // Reset
                                                    return;
                                                }

                                                if (onUpdatePlay) onUpdatePlay({ ...play, wristbandSlot: slot });
                                                setWbAutocomplete({ playId: null, query: '' });
                                            }}
                                            style={{
                                                padding: '4px 8px', fontSize: '0.75rem', cursor: 'pointer',
                                                borderBottom: '1px solid #f1f5f9', hover: { background: '#f8fafc' } // Inline hover not supported, relying on standard behavior
                                            }}
                                        >
                                            {slot}
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>
                    );
                };


                return (
                    <div style={{
                        position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
                        backgroundColor: 'rgba(0,0,0,0.8)', zIndex: 1100,
                        display: 'flex', alignItems: 'center', justifyContent: 'center'
                    }} onClick={() => setEditingBox(null)}>
                        <div style={{
                            width: '95%', maxWidth: '1300px', maxHeight: '90vh',
                            background: 'white', borderRadius: '8px',
                            display: 'flex', flexDirection: 'column',
                            overflow: 'hidden'
                        }} onClick={e => e.stopPropagation()}>
                            <div style={{ padding: '1rem', borderBottom: '1px solid #ddd', display: 'flex', justifyContent: 'space-between', alignItems: 'center', background: box.color || '#f8fafc', color: 'white' }}>
                                <h3 style={{ margin: 0, textTransform: 'uppercase' }}>Edit {box.header}</h3>
                                <button className="btn" onClick={() => setEditingBox(null)} style={{ background: 'rgba(255,255,255,0.2)', border: 'none', color: 'white' }}>Close</button>
                            </div>
                            <div style={{ display: 'flex', flex: 1, overflow: 'hidden' }}>
                                {/* Left Panel: QUICK LIST */}
                                <div style={{ width: '350px', borderRight: '1px solid #e2e8f0', overflow: 'hidden' }}>
                                    {renderAssignedPlaysPanel(box)}
                                </div>

                                {/* Right Panel: Editor */}
                                <div style={{ flex: 1, padding: '1rem', overflowY: 'auto' }}>
                                    {box.type === 'script' ? renderScriptBox(box, sectionIdx, boxIdx, true, renderWristbandInput) : renderGridBox(box, sectionIdx, boxIdx, true, renderWristbandInput)}
                                </div>
                            </div>
                        </div>
                    </div>
                );
            };

            const renderScriptBox = (box, sectionIdx, boxIdx, isEditing, renderWristbandInput) => {
                const rows = (box.rows && box.rows.length > 0) ? box.rows : [{ id: 'default', label: '1', content: '' }];
                const tempos = box.tempos || {};
                const protocolList = box.customTempos || PLAY_PROTOCOLS;



                return (
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '4px', background: 'white', borderRadius: '4px', height: '100%' }}>
                        {isEditing && renderInteriorConfig(box, sectionIdx, boxIdx)}

                        <div style={{ flex: 1 }}>
                            {/* Header Row */}
                            <div style={{ display: 'grid', gridTemplateColumns: '60px 1fr 1fr', gap: '4px', marginBottom: '4px' }}>
                                <div></div>
                                <div style={{ fontSize: '0.7rem', fontWeight: 'bold', color: '#64748b', textAlign: 'center', textTransform: 'uppercase' }}>LEFT HASH</div>
                                <div style={{ fontSize: '0.7rem', fontWeight: 'bold', color: '#64748b', textAlign: 'center', textTransform: 'uppercase' }}>RIGHT HASH</div>
                            </div>

                            {rows.map((row, rowIdx) => (
                                <React.Fragment key={row.id || rowIdx}>
                                    <div style={{ display: 'grid', gridTemplateColumns: '60px 1fr 1fr', gap: '4px', alignItems: 'stretch' }}>

                                        {/* Editable Label Column */}
                                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                                            <input
                                                value={row.label || (rowIdx + 1).toString()}
                                                onChange={(e) => {
                                                    const newLayouts = { ...gamePlanLayouts };
                                                    const targetSection = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                                                    if (!targetSection.rows) targetSection.rows = [];
                                                    if (!targetSection.rows[rowIdx]) targetSection.rows[rowIdx] = { id: Date.now(), label: (rowIdx + 1).toString(), content: '' };
                                                    if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                }}
                                                style={{
                                                    width: '100%', textAlign: 'center', fontWeight: 'bold',
                                                    border: '1px solid #e2e8f0', color: '#64748b', fontSize: '0.9rem',
                                                    padding: '8px 4px', borderRadius: '4px', background: !isLocked ? 'white' : 'transparent',
                                                    height: '100%'
                                                }}
                                                disabled={isLocked}
                                            />
                                        </div>

                                        {/* Left Play Slot */}
                                        <div style={{ border: '1px solid #e2e8f0', borderRadius: '4px', background: 'white', minHeight: '40px', display: 'flex', alignItems: 'center', paddingRight: '4px' }}>
                                            <div style={{ flex: 1 }}>
                                                <PlaySlot
                                                    playId={row.content}
                                                    isLocked={isLocked}
                                                    renderWristbandInput={renderWristbandInput}
                                                    onQuickAddPlay={onQuickAddPlay}
                                                    onUpdate={(pid) => {
                                                        const newLayouts = { ...gamePlanLayouts };
                                                        const targetSection = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                                                        if (!targetSection.rows) targetSection.rows = [];
                                                        if (!targetSection.rows[rowIdx]) targetSection.rows[rowIdx] = { id: Date.now(), label: (rowIdx + 1).toString(), content: '' };
                                                        targetSection.rows[rowIdx].content = pid;
                                                        if (onUpdateLayouts) onUpdateLayouts(newLayouts);

                                                        // Sync to Data Model (miniScripts/sets)
                                                        if (box.setId && onUpdateGamePlan && gamePlan) {
                                                            const updatedRows = targetSection.rows;
                                                            const allIds = [];
                                                            updatedRows.forEach(r => {
                                                                if (r.content) allIds.push(r.content);
                                                                if (r.contentRight) allIds.push(r.contentRight);
                                                            });

                                                            const collectionKey = box.type === 'script' ? 'miniScripts' : 'sets';
                                                            let collection = Array.isArray(gamePlan[collectionKey]) ? [...gamePlan[collectionKey]] : [];

                                                            const uniqueIds = Array.from(new Set(allIds));

                                                            const existingIndex = collection.findIndex(item => item.id === box.setId);
                                                            if (existingIndex >= 0) {
                                                                // Only update playIds (script rows), keep assignedPlayIds (Quick List) separate
                                                                collection[existingIndex] = { ...collection[existingIndex], playIds: allIds };
                                                            } else {
                                                                // Create new item - only set playIds, assignedPlayIds (Quick List) starts empty
                                                                collection.push({ id: box.setId, playIds: allIds, assignedPlayIds: [] });
                                                            }

                                                            const updatedGamePlan = { ...gamePlan, [collectionKey]: collection };
                                                            onUpdateGamePlan(updatedGamePlan);
                                                        }
                                                    }}
                                                />
                                            </div>
                                        </div>

                                        {/* Right Play Slot */}
                                        <div style={{ border: '1px solid #e2e8f0', borderRadius: '4px', background: 'white', minHeight: '40px', display: 'flex', alignItems: 'center', paddingRight: '4px' }}>
                                            <div style={{ flex: 1 }}>
                                                <PlaySlot
                                                    playId={row.contentRight}
                                                    isLocked={isLocked}
                                                    renderWristbandInput={renderWristbandInput}
                                                    onQuickAddPlay={onQuickAddPlay}
                                                    onUpdate={(pid) => {
                                                        const newLayouts = { ...gamePlanLayouts };
                                                        const targetSection = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                                                        targetSection.rows[rowIdx].contentRight = pid;
                                                        if (onUpdateLayouts) onUpdateLayouts(newLayouts);

                                                        // Sync to Data Model (miniScripts/sets)
                                                        if (box.setId && onUpdateGamePlan && gamePlan) {
                                                            const updatedRows = targetSection.rows;
                                                            const allIds = [];
                                                            updatedRows.forEach(r => {
                                                                if (r.content) allIds.push(r.content);
                                                                if (r.contentRight) allIds.push(r.contentRight);
                                                            });

                                                            const collectionKey = box.type === 'script' ? 'miniScripts' : 'sets';
                                                            let collection = Array.isArray(gamePlan[collectionKey]) ? [...gamePlan[collectionKey]] : [];

                                                            const uniqueIds = Array.from(new Set(allIds));

                                                            const existingIndex = collection.findIndex(item => item.id === box.setId);
                                                            if (existingIndex >= 0) {
                                                                // Only update playIds (script rows), keep assignedPlayIds (Quick List) separate
                                                                collection[existingIndex] = { ...collection[existingIndex], playIds: allIds };
                                                            } else {
                                                                // Create new item - only set playIds, assignedPlayIds (Quick List) starts empty
                                                                collection.push({ id: box.setId, playIds: allIds, assignedPlayIds: [] });
                                                            }

                                                            const updatedGamePlan = { ...gamePlan, [collectionKey]: collection };
                                                            onUpdateGamePlan(updatedGamePlan);
                                                        }
                                                    }}
                                                />
                                            </div>
                                        </div>
                                    </div>

                                    {rowIdx < rows.length - 1 && (
                                        <div style={{ margin: '4px auto', width: 'fit-content' }}>
                                            <select
                                                disabled={isLocked}
                                                value={tempos[rowIdx] || 'REGULAR'}
                                                onChange={(e) => {
                                                    const newLayouts = { ...gamePlanLayouts };
                                                    const b = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                                                    if (!b.tempos) b.tempos = {};
                                                    b.tempos[rowIdx] = e.target.value;
                                                    if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                }}
                                                style={{
                                                    fontSize: '0.65rem', fontWeight: 'bold', padding: '2px 4px', borderRadius: '12px',
                                                    border: '1px solid #e2e8f0', background: '#f1f5f9', cursor: !isLocked ? 'pointer' : 'default',
                                                    color: protocolList.find(p => p.id === (tempos[rowIdx] || 'REGULAR'))?.color || '#64748b',
                                                    appearance: 'none', textAlign: 'center', minWidth: '100px'
                                                }}
                                            >
                                                {protocolList.map(proto => (
                                                    <option key={proto.id} value={proto.id}>{proto.label}</option>
                                                ))}
                                            </select>
                                        </div>
                                    )}
                                </React.Fragment>
                            ))}
                            {!isLocked && (
                                <button
                                    className="btn-sm"
                                    style={{ marginTop: '4px', width: '100%', border: '1px dashed #cbd5e1', color: '#64748b', padding: '4px' }}
                                    onClick={() => {
                                        const newLayouts = { ...gamePlanLayouts };
                                        const b = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                                        if (!b.rows) b.rows = [];
                                        b.rows.push({ content: null, contentRight: null, id: `slot_${Date.now()}` });
                                        if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                    }}
                                >
                                    + Add Play Slot
                                </button>
                            )}
                        </div>
                        {box.notes && (
                            <div style={{ marginTop: '8px', padding: '6px', background: '#fffbeb', border: '1px solid #fde68a', borderRadius: '4px', fontSize: '0.8rem', color: '#92400e', fontStyle: 'italic' }}>
                                <span style={{ fontWeight: 'bold', textTransform: 'uppercase', fontSize: '0.7rem', display: 'block', marginBottom: '2px' }}>Notes:</span>
                                {box.notes}
                            </div>
                        )}
                        {isEditing && (
                            <div style={{ borderTop: '2px solid #e2e8f0', paddingTop: '12px', marginTop: '12px' }}>
                                <div style={{ fontSize: '0.75rem', fontWeight: 'bold', color: '#64748b', textTransform: 'uppercase', marginBottom: '8px' }}>Manage Script Tempos</div>
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '6px', marginBottom: '12px' }}>
                                    {(box.customTempos || PLAY_PROTOCOLS).map((proto, pIdx) => (
                                        <div key={proto.id || pIdx} style={{ display: 'flex', alignItems: 'center', gap: '8px', background: '#f8fafc', padding: '4px 8px', borderRadius: '6px', border: '1px solid #e2e8f0' }}>
                                            <input type="color" value={proto.color} onChange={(e) => {
                                                const newLayouts = { ...gamePlanLayouts };
                                                const b = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                                                if (!b.customTempos) b.customTempos = [...PLAY_PROTOCOLS];
                                                b.customTempos[pIdx] = { ...b.customTempos[pIdx], color: e.target.value };
                                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                            }} style={{ width: '24px', height: '24px', border: 'none', padding: 0, background: 'none', cursor: 'pointer' }} />
                                            <input value={proto.label} onChange={(e) => {
                                                const newLayouts = { ...gamePlanLayouts };
                                                const b = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                                                if (!b.customTempos) b.customTempos = [...PLAY_PROTOCOLS];
                                                b.customTempos[pIdx] = { ...b.customTempos[pIdx], label: e.target.value };
                                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                            }} style={{ flex: 1, border: 'none', background: 'transparent', fontWeight: 'bold', color: '#334155' }} />
                                            <button onClick={() => {
                                                const newLayouts = { ...gamePlanLayouts };
                                                const b = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                                                if (!b.customTempos) b.customTempos = [...PLAY_PROTOCOLS];
                                                b.customTempos = b.customTempos.filter((_, i) => i !== pIdx);
                                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                            }} style={{ color: '#ef4444', background: 'none', border: 'none', cursor: 'pointer' }}>🗑</button>
                                        </div>
                                    ))}
                                    <input placeholder="Add tempo label..." onKeyDown={(e) => {
                                        if (e.key === 'Enter' && e.target.value) {
                                            const newLayouts = { ...gamePlanLayouts };
                                            const b = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                                            if (!b.customTempos) b.customTempos = [...PLAY_PROTOCOLS];
                                            b.customTempos.push({ id: `custom_${Date.now()}`, label: e.target.value, color: '#3b82f6' });
                                            if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                            e.target.value = '';
                                        }
                                    }} style={{ padding: '6px', border: '1px solid #e2e8f0', borderRadius: '4px', fontSize: '0.8rem' }} />
                                </div>
                            </div>
                        )}
                    </div>
                );
            };

            const renderGridBox = (box, sectionIdx, boxIdx, isEditing, renderWristbandInput) => {
                const cols = box.gridColumns || 4;
                const rowsCount = box.gridRows || 5;
                const totalSlots = cols * rowsCount;

                // Ensure headings match columns
                let headings = box.gridHeadings || [];
                if (headings.length < cols) {
                    const diff = cols - headings.length;
                    for (let i = 0; i < diff; i++) headings.push(`COL ${headings.length + 1}`);
                }
                if (headings.length > cols) {
                    headings = headings.slice(0, cols);
                }

                const allPlays = getGridPlays(box.setId, totalSlots, box.assignedPlayIds);
                const assignedPlays = (allPlays || []).filter(p => p.type !== 'GAP');

                const updateLayout = (updates) => {
                    const newLayouts = { ...gamePlanLayouts };
                    const targetBox = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                    Object.assign(targetBox, updates);
                    if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                };

                return (
                    <div style={{ padding: '8px', display: 'flex', flexDirection: 'column', height: '100%' }}>
                        {isEditing && (
                            <div style={{ marginBottom: '8px', padding: '6px', background: '#e2e8f0', borderRadius: '4px', display: 'flex', gap: '8px', alignItems: 'center', fontSize: '0.75rem', color: '#0f172a' }}>
                                <span style={{ fontWeight: 'bold' }}>Columns:</span>
                                <button className="btn btn-xs" style={{ background: 'white', color: 'black', border: '1px solid #cbd5e1' }} onClick={() => updateLayout({ gridColumns: Math.max(1, cols - 1) })}>-</button>
                                <span style={{ fontWeight: 'bold', minWidth: '16px', textAlign: 'center' }}>{cols}</span>
                                <button className="btn btn-xs" style={{ background: 'white', color: 'black', border: '1px solid #cbd5e1' }} onClick={() => updateLayout({ gridColumns: cols + 1 })}>+</button>

                                <span style={{ width: '12px', borderRight: '1px solid #cbd5e1', height: '16px' }}></span>
                                <span style={{ width: '4px' }}></span>

                                <span style={{ fontWeight: 'bold' }}>Rows:</span>
                                <button className="btn btn-xs" style={{ background: 'white', color: 'black', border: '1px solid #cbd5e1' }} onClick={() => updateLayout({ gridRows: Math.max(1, rowsCount - 1) })}>-</button>
                                <span style={{ fontWeight: 'bold', minWidth: '16px', textAlign: 'center' }}>{rowsCount}</span>
                                <button className="btn btn-xs" style={{ background: 'white', color: 'black', border: '1px solid #cbd5e1' }} onClick={() => updateLayout({ gridRows: rowsCount + 1 })}>+</button>
                            </div>
                        )}
                        {isEditing && renderInteriorConfig(box, sectionIdx, boxIdx)}

                        <div style={{ display: 'grid', gridTemplateColumns: `50px repeat(${cols}, 1fr)`, gap: '0', marginBottom: '8px', border: '1px solid #e2e8f0' }}>
                            <div style={{ fontSize: '0.6rem', color: '#94a3b8', fontStyle: 'italic', display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '4px', borderRight: '1px solid #e2e8f0', borderBottom: '1px solid #e2e8f0' }}>
                                {isEditing ? (
                                    <input
                                        value={box.cornerLabel || ''}
                                        onChange={(e) => updateLayout({ cornerLabel: e.target.value })}
                                        style={{ width: '100%', fontSize: '0.6rem', border: 'none', background: 'transparent', textAlign: 'center', color: '#94a3b8' }}
                                        placeholder="#"
                                    />
                                ) : (
                                    box.cornerLabel || '#'
                                )}
                            </div>
                            {headings.map((h, hIdx) => (
                                <div key={hIdx} style={{ textAlign: 'center', borderRight: hIdx < cols - 1 ? '1px solid #e2e8f0' : 'none', borderBottom: '1px solid #e2e8f0', background: '#f8fafc', padding: '4px' }}>
                                    {isEditing ? (
                                        <input
                                            value={h}
                                            onChange={(e) => {
                                                const newHeadings = [...headings];
                                                newHeadings[hIdx] = e.target.value;
                                                updateLayout({ gridHeadings: newHeadings });
                                            }}
                                            style={{ width: '100%', fontSize: '0.6rem', border: 'none', background: 'transparent', textAlign: 'center', fontWeight: 'bold', color: '#64748b' }}
                                        />
                                    ) : (
                                        <span style={{ fontSize: '0.6rem', fontWeight: 'bold', color: '#64748b' }}>{h}</span>
                                    )}
                                </div>
                            ))}

                            {/* Row Headers and Slots */}
                            {Array.from({ length: rowsCount }).map((_, rIdx) => (
                                <React.Fragment key={rIdx}>
                                    {/* Row Header */}
                                    <div style={{
                                        fontSize: '0.6rem', color: '#94a3b8', fontWeight: 'bold',
                                        display: 'flex', alignItems: 'center', justifyContent: 'center',
                                        borderRight: '1px solid #e2e8f0', borderBottom: '1px dotted #e2e8f0', padding: '2px'
                                    }}>
                                        {isEditing ? (
                                            <input
                                                value={(box.gridRowLabels && box.gridRowLabels[rIdx]) || (rIdx + 1).toString()}
                                                onChange={(e) => {
                                                    const newLabels = [...(box.gridRowLabels || [])];
                                                    // Ensure array is padded up to this index if it was empty/short
                                                    for (let i = 0; i <= rIdx; i++) {
                                                        if (newLabels[i] === undefined) newLabels[i] = (i + 1).toString();
                                                    }
                                                    newLabels[rIdx] = e.target.value;
                                                    updateLayout({ gridRowLabels: newLabels });
                                                }}
                                                style={{
                                                    width: '100%', fontSize: '0.6rem', border: 'none', background: 'transparent',
                                                    textAlign: 'center', fontWeight: 'bold', color: '#94a3b8'
                                                }}
                                            />
                                        ) : (
                                            (box.gridRowLabels && box.gridRowLabels[rIdx]) || (rIdx + 1)
                                        )}
                                    </div>
                                    {/* Slot Cells */}
                                    {Array.from({ length: cols }).map((_, cIdx) => {
                                        const linearIdx = (rIdx * cols) + cIdx;
                                        const play = allPlays[linearIdx];

                                        const handleGridCellUpdate = (newPlayId) => {
                                            // 1. Get current plays (including GAPs)
                                            const currentPlays = [...allPlays];

                                            // 2. Update the specific slot
                                            // If newPlayId is null, it becomes a GAP. 
                                            // If it's a valid ID, we verify it exists.

                                            if (newPlayId) {
                                                const targetPlay = plays.find(p => p.id === newPlayId);
                                                if (targetPlay) {
                                                    currentPlays[linearIdx] = targetPlay;
                                                }
                                            } else {
                                                currentPlays[linearIdx] = { type: 'GAP' };
                                            }

                                            // 3. Convert back to ID list for storage
                                            // 'GAP' objects should be stored as 'GAP' strings or nulls depending on how getGridPlays expects them.
                                            // Looking at getGridPlays, it pads with 'GAP'. So we should likely store the IDs or 'GAP'.

                                            // Actually, let's look at how data is stored.
                                            // It seems we store an array of IDs in `assignedPlayIds`.
                                            // getGridPlays pads this array.

                                            // So we just need to reconstruct the `assignedPlayIds` array from our `currentPlays`
                                            // But we only want to persist up to the last non-gap? Or minimal set?
                                            // The simplest valid storage is the full array of IDs/'GAP's up to the grid size.

                                            const newAssignedIds = currentPlays.map(p => (p && p.id) ? p.id : 'GAP');

                                            // Clean up trailing GAPs if desired, or keep them to preserve structure?
                                            // To be safe and preserve "empty" slots in middle, we keep them.

                                            updateLayout({ assignedPlayIds: newAssignedIds });
                                        };

                                        return (
                                            <div key={`${rIdx}-${cIdx}`} style={{
                                                minHeight: '40px', // Increased height for better interaction
                                                borderRight: cIdx < cols - 1 ? '1px solid #e2e8f0' : 'none',
                                                borderBottom: '1px dotted #e2e8f0',
                                                display: 'flex', alignItems: 'center', justifyContent: 'center',
                                                padding: '2px',
                                                background: play && play.type !== 'GAP' ? 'white' : 'transparent',
                                                position: 'relative'
                                            }}>
                                                <PlaySlot
                                                    playId={play && play.type !== 'GAP' ? play.id : null}
                                                    onUpdate={handleGridCellUpdate}
                                                    isLocked={!isEditing}
                                                    placeholder="+"
                                                    showWristband={true} // Enable wristband display if available in PlaySlot
                                                    renderWristbandInput={renderWristbandInput} // Pass the hoisted renderer
                                                />
                                            </div>
                                        );
                                    })}
                                </React.Fragment>
                            ))}
                        </div>
                    </div>
                );
            };

            const renderGridSection = (section, sectionIdx) => {
                const headings = section.gridHeadings || ['LEFT HASH', 'MIDDLE', 'RIGHT HASH', 'NOTES'];
                const allPlays = getGridPlays(section.id);
                // For a full section grid (20 slots = 5 rows x 4 cols) -> logic uses slice 0-19 implicitly if length 5
                const assignedPlays = allPlays;

                return (
                    <div style={{ padding: '8px', display: 'flex', flexDirection: 'column', height: '100%', background: 'white', borderRadius: '8px', border: '1px solid #cbd5e1' }}>
                        <div style={{ display: 'grid', gridTemplateColumns: '50px repeat(4, 1fr)', gap: '1px', marginBottom: '8px' }}>
                            <div style={{ fontSize: '0.6rem', color: '#94a3b8', fontStyle: 'italic', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                                {!isLocked ? (
                                    <input
                                        value={section.cornerLabel || ''}
                                        onChange={(e) => {
                                            const newLayouts = { ...gamePlanLayouts };
                                            newLayouts.CALL_SHEET.sections[sectionIdx].cornerLabel = e.target.value;
                                            if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                        }}
                                        style={{ width: '100%', fontSize: '0.6rem', border: 'none', background: 'transparent', textAlign: 'center', color: '#94a3b8' }}
                                        placeholder="Label..."
                                    />
                                ) : (
                                    section.cornerLabel || ''
                                )}
                            </div>
                            {headings.map((h, hIdx) => (
                                <div key={hIdx} style={{ textAlign: 'center' }}>
                                    {!isLocked ? (
                                        <input
                                            value={h}
                                            onChange={(e) => {
                                                const newLayouts = { ...gamePlanLayouts };
                                                const newSections = [...newLayouts.CALL_SHEET.sections];
                                                const newHeadings = [...(newSections[sectionIdx].gridHeadings || ['LEFT HASH', 'MIDDLE', 'RIGHT HASH', 'NOTES'])];
                                                newHeadings[hIdx] = e.target.value;
                                                newSections[sectionIdx] = { ...newSections[sectionIdx], gridHeadings: newHeadings };
                                                newLayouts.CALL_SHEET = { ...newLayouts.CALL_SHEET, sections: newSections };
                                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                            }}
                                            style={{ width: '100%', fontSize: '0.7rem', fontWeight: 'bold', color: '#64748b', textAlign: 'center', border: 'none', background: 'transparent' }}
                                        />
                                    ) : (
                                        <div style={{ fontSize: '0.7rem', fontWeight: 'bold', color: '#64748b' }}>{h}</div>
                                    )}
                                </div>
                            ))}
                        </div>

                        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '1px' }}>
                            {Array.from({ length: 5 }).map((_, rIdx) => {
                                const startIdx = rIdx * 4;
                                const rowPlays = allPlays.slice(startIdx, startIdx + 4);
                                const rowLabel = (section.rowLabels || ['Group 1', 'Group 2', 'Group 3', 'Group 4', 'Group 5'])[rIdx];

                                return (
                                    <div key={rIdx} style={{ display: 'grid', gridTemplateColumns: '50px repeat(4, 1fr)', gap: '1px', flex: 1 }}>
                                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', background: '#f1f5f9', borderRadius: '4px' }}>
                                            {!isLocked ? (
                                                <input
                                                    value={rowLabel || ''}
                                                    onChange={(e) => {
                                                        const newLayouts = { ...gamePlanLayouts };
                                                        const newSections = [...newLayouts.CALL_SHEET.sections];
                                                        const newLabels = [...(newSections[sectionIdx].rowLabels || ['Group 1', 'Group 2', 'Group 3', 'Group 4', 'Group 5'])];
                                                        newLabels[rIdx] = e.target.value;
                                                        newSections[sectionIdx] = { ...newSections[sectionIdx], rowLabels: newLabels };
                                                        newLayouts.CALL_SHEET = { ...newLayouts.CALL_SHEET, sections: newSections };
                                                        if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                    }}
                                                    style={{ width: '100%', fontSize: '0.65rem', fontWeight: '600', color: '#475569', textAlign: 'center', border: 'none', background: 'transparent', padding: '0' }}
                                                />
                                            ) : (
                                                <span style={{ fontSize: '0.65rem', fontWeight: '600', color: '#475569' }}>{rowLabel}</span>
                                            )}
                                        </div>
                                        {rowPlays.map((play, cIdx) => (
                                            <div key={cIdx} style={{ position: 'relative', height: '100%', minHeight: '50px' }}>
                                                <PlaySlot
                                                    playId={play.type === 'GAP' ? null : play.id}
                                                    onUpdate={(newPlayId) => {
                                                        handleGridCellUpdate(section.id, startIdx + cIdx, newPlayId);
                                                    }}
                                                    isLocked={isLocked}
                                                />
                                            </div>
                                        ))}
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                );
            };

            const renderScriptSection = (section, sectionIdx) => {
                return (
                    <div style={{ background: 'white', borderRadius: '8px', border: '1px solid #cbd5e1', padding: '1rem' }}>
                        <div style={{ padding: '2rem', textAlign: 'center', color: '#666' }}>Script Section (Use Modular + Script Box for now)</div>
                    </div>
                );
            };
            const renderFieldPositionSection = (section, sectionIdx) => renderGridSection(section, sectionIdx);

            const renderBox = (box, sectionIdx, boxIdx, isExpanded = false) => {
                const isEditing = editingHeader && editingHeader.sectionIdx === sectionIdx && editingHeader.rowIdx === boxIdx;
                const isBoxEditing = editingBox && editingBox.sectionIdx === sectionIdx && editingBox.boxIdx === boxIdx;

                // Summary Logic
                let summaryText = "";
                if (box.type === 'script') {
                    const playCount = (box.rows || []).filter(r => r.content).length;
                    summaryText = `${playCount} Plays in Script`;
                } else {
                    const playCount = getGridPlays(box.setId).filter(p => p.type !== 'GAP').length;
                    summaryText = `${playCount} Situational Plays`;
                }

                // Default spans: Grid = 5, Script = 2
                const defaultSpan = box.type === 'grid' ? 5 : 2;
                const span = box.colSpan || defaultSpan;

                return (
                    <div
                        key={box.setId}
                        draggable={!isLocked}
                        onDragStart={(e) => handleDragStart(e, sectionIdx, boxIdx)}
                        onDragOver={handleDragOver}
                        onDrop={(e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            handleDrop(e, sectionIdx, boxIdx);
                        }}
                        style={{
                            // Flexbox expansion logic
                            // Flexbox expansion logic
                            flexGrow: isExpanded ? span : 0,
                            gridColumn: isExpanded ? 'auto' : `span ${span}`,
                            maxWidth: isExpanded ? '100%' : undefined,
                            minWidth: isExpanded ? '125px' : undefined, // Force wrap if too squished
                            flexBasis: isExpanded ? '0' : undefined, // Ignore size, use grow ratio

                            border: isEditing ? '2px solid var(--accent)' : '1px solid #ddd',
                            borderRadius: '4px', overflow: 'hidden',
                            minHeight: '80px', // Smaller collapsed height
                            backgroundColor: 'white', cursor: !isLocked ? 'move' : 'default',
                            opacity: draggedCell && draggedCell.sectionIdx === sectionIdx && draggedCell.rowIdx === boxIdx ? 0.5 : (box.hidden && !isLocked ? 0.5 : 1),
                            display: (box.hidden && isLocked) ? 'none' : 'block',
                            position: 'relative'
                        }}
                        onDoubleClick={(e) => {
                            if (isLocked) return;
                            e.preventDefault();
                            e.stopPropagation();
                            setEditingBox({ sectionIdx, boxIdx });
                        }}
                    >
                        <div style={{ backgroundColor: box.color, color: 'white', padding: '0.25rem 0.5rem', fontWeight: 'bold', fontSize: '0.8rem', textAlign: 'center', textTransform: 'uppercase', display: 'flex', justifyContent: 'center', alignItems: 'center', position: 'relative' }}>
                            {isEditing ? (
                                <div style={{ display: 'flex', alignItems: 'center', width: '100%', gap: '4px' }}>
                                    <input
                                        autoFocus
                                        defaultValue={box.header}
                                        onBlur={(e) => saveHeader(sectionIdx, boxIdx, e.target.value)}
                                        onKeyDown={(e) => { if (e.key === 'Enter') saveHeader(sectionIdx, boxIdx, e.target.value); }}
                                        style={{ background: 'rgba(255,255,255,0.2)', border: 'none', color: 'white', textAlign: 'center', flex: 1, fontSize: '0.8rem', fontWeight: 'bold', outline: 'none' }}
                                    />
                                    <input
                                        type="color"
                                        value={box.color || '#8b5cf6'}
                                        onChange={(e) => {
                                            const newLayouts = { ...gamePlanLayouts };
                                            newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx].color = e.target.value;
                                            if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                        }}
                                        style={{ width: '20px', height: '20px', border: '1px solid rgba(255,255,255,0.3)', cursor: 'pointer', padding: 0 }}
                                    />
                                    <div style={{ cursor: 'pointer' }} onClick={() => setEditingHeader(null)}><Icon name="X" size={14} /></div>
                                </div>
                            ) : (
                                <>
                                    <span style={{ cursor: 'default', width: '100%', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{box.header}</span>
                                    {!isLocked && (
                                        <div style={{ position: 'absolute', right: '4px', cursor: 'pointer' }} onClick={(e) => { e.stopPropagation(); setEditingHeader({ sectionIdx, rowIdx: boxIdx }); }}>
                                            <Icon name="Pencil" size={14} />
                                        </div>
                                    )}
                                </>
                            )}
                        </div>

                        {/* Summary View */}
                        <div style={{ padding: '1rem', textAlign: 'center', color: '#64748b', fontSize: '0.85rem' }}>
                            <div style={{ fontWeight: 'bold', fontSize: '1.2rem', color: '#1e293b' }}>
                                {box.type === 'script' ? '📜' : '🔢'}
                            </div>
                            <div style={{ marginTop: '0.5rem' }}>{summaryText}</div>
                            {box.notes && (
                                <div style={{ marginTop: '0.5rem', fontSize: '0.7rem', color: '#64748b', fontStyle: 'italic', overflow: 'hidden', textOverflow: 'ellipsis', display: '-webkit-box', WebkitLineClamp: 2, WebkitBoxOrient: 'vertical', maxHeight: '2.4em' }}>
                                    "{box.notes}"
                                </div>
                            )}
                            <div style={{ fontSize: '0.7rem', color: '#94a3b8', fontStyle: 'italic', marginTop: '0.5rem' }}>Double-click to edit</div>
                        </div>

                    </div>
                );
            };

            const renderCallSheet = () => {

                const layout = gamePlanLayouts.CALL_SHEET;

                // Safety check for gamePlan
                const safeGamePlan = gamePlan || { miniScripts: [] };
                const miniScripts = safeGamePlan.miniScripts || [];

                return (
                    <div className="animate-fade-in" style={{ height: '100%', overflowY: 'auto', background: 'white', borderRadius: '8px', position: 'relative' }}>
                        {/* CONTROL BAR */}
                        <div style={{ position: 'sticky', top: 0, zIndex: 40, backgroundColor: 'white', padding: '1rem', borderBottom: '1px solid #e2e8f0', display: 'flex', justifyContent: 'flex-end', gap: '0.5rem', alignItems: 'center' }}>
                            {!isLocked && (
                                <>
                                    {/* Layout Versions Dropdown */}
                                    <div style={{ position: 'relative', display: 'inline-block', marginRight: '0.5rem' }}>
                                        <button
                                            className="btn btn-sm"
                                            onClick={() => setShowLayoutVersions(!showLayoutVersions)}
                                            style={{ fontSize: '0.75rem', background: '#e5e7eb', color: '#374151', display: 'flex', alignItems: 'center', gap: '4px' }}
                                        >
                                            <Icon name="Save" size={14} /> Layout Versions
                                        </button>

                                        {showLayoutVersions && (
                                            <div style={{ position: 'absolute', top: '100%', right: 0, zIndex: 50, background: 'white', border: '1px solid #cbd5e1', borderRadius: '4px', boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)', minWidth: '250px', padding: '0.5rem' }}>
                                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.5rem', paddingBottom: '0.25rem', borderBottom: '1px solid #e2e8f0' }}>
                                                    <div style={{ fontWeight: 'bold', fontSize: '0.75rem', color: '#64748b' }}>SAVED LAYOUTS</div>
                                                    <button
                                                        onClick={() => setShowLayoutVersions(false)}
                                                        style={{ background: 'none', border: 'none', cursor: 'pointer', color: '#94a3b8' }}
                                                    >
                                                        <Icon name="X" size={12} />
                                                    </button>
                                                </div>

                                                {/* Save Controls */}
                                                {layoutSaveState.isSaving ? (
                                                    <div style={{ marginBottom: '0.5rem' }}>
                                                        <input
                                                            autoFocus
                                                            className="form-input"
                                                            style={{ fontSize: '0.75rem', padding: '4px', width: '100%', marginBottom: '4px' }}
                                                            placeholder="Version Name..."
                                                            value={layoutSaveState.name}
                                                            onChange={(e) => setLayoutSaveState({ ...layoutSaveState, name: e.target.value })}
                                                            onKeyDown={(e) => {
                                                                if (e.key === 'Enter' && layoutSaveState.name && onSaveLayoutVersion) {
                                                                    onSaveLayoutVersion(layoutSaveState.name);
                                                                    setLayoutSaveState({ isSaving: false, name: '' });
                                                                }
                                                                if (e.key === 'Escape') setLayoutSaveState({ isSaving: false, name: '' });
                                                            }}
                                                        />
                                                        <div style={{ display: 'flex', gap: '4px' }}>
                                                            <button
                                                                className="btn btn-xs btn-primary"
                                                                style={{ flex: 1 }}
                                                                disabled={!layoutSaveState.name}
                                                                onClick={() => {
                                                                    if (layoutSaveState.name && onSaveLayoutVersion) {
                                                                        onSaveLayoutVersion(layoutSaveState.name);
                                                                        setLayoutSaveState({ isSaving: false, name: '' });
                                                                    }
                                                                }}
                                                            >
                                                                Save
                                                            </button>
                                                            <button
                                                                className="btn btn-xs"
                                                                style={{ flex: 1, background: '#e2e8f0', color: '#475569' }}
                                                                onClick={() => setLayoutSaveState({ isSaving: false, name: '' })}
                                                            >
                                                                Cancel
                                                            </button>
                                                        </div>
                                                    </div>
                                                ) : (
                                                    <button
                                                        className="btn btn-xs btn-primary"
                                                        style={{ width: '100%', marginBottom: '0.5rem', fontSize: '0.75rem' }}
                                                        onClick={() => setLayoutSaveState({ isSaving: true, name: '' })}
                                                    >
                                                        + Save Current Layout
                                                    </button>
                                                )}

                                                <div style={{ maxHeight: '150px', overflowY: 'auto' }}>
                                                    {Object.keys(layoutVersions).length === 0 && <div style={{ fontSize: '0.75rem', color: '#94a3b8', fontStyle: 'italic', padding: '0.25rem' }}>No saved layouts</div>}
                                                    {Object.keys(layoutVersions).map(versionName => (
                                                        <div key={versionName} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '0.25rem', borderBottom: '1px solid #f1f5f9' }}>
                                                            <span style={{ fontSize: '0.75rem', fontWeight: '500', color: '#334155' }}>{versionName}</span>

                                                            {/* Item Actions */}
                                                            {layoutConfirmAction?.name === versionName ? (
                                                                <div style={{ display: 'flex', gap: '4px', alignItems: 'center' }}>
                                                                    <span style={{ fontSize: '0.65rem', color: layoutConfirmAction.type === 'delete' ? '#ef4444' : '#3b82f6', marginRight: '2px' }}>
                                                                        {layoutConfirmAction.type === 'delete' ? 'Delete?' : 'Load?'}
                                                                    </span>
                                                                    <button
                                                                        className="btn btn-icon"
                                                                        style={{ color: 'var(--success)' }}
                                                                        onClick={() => {
                                                                            if (layoutConfirmAction.type === 'delete' && onDeleteLayoutVersion) onDeleteLayoutVersion(versionName);
                                                                            if (layoutConfirmAction.type === 'load' && onLoadLayoutVersion) onLoadLayoutVersion(versionName);
                                                                            setLayoutConfirmAction(null);
                                                                        }}
                                                                    >
                                                                        <Icon name="Check" size={12} />
                                                                    </button>
                                                                    <button
                                                                        className="btn btn-icon"
                                                                        style={{ color: 'var(--text-secondary)' }}
                                                                        onClick={() => setLayoutConfirmAction(null)}
                                                                    >
                                                                        <Icon name="X" size={12} />
                                                                    </button>
                                                                </div>
                                                            ) : (
                                                                <div style={{ display: 'flex', gap: '4px' }}>
                                                                    <button
                                                                        title="Load"
                                                                        style={{ background: 'none', border: 'none', cursor: 'pointer', color: '#3b82f6', padding: '2px' }}
                                                                        onClick={() => setLayoutConfirmAction({ type: 'load', name: versionName })}
                                                                    >
                                                                        <Icon name="Download" size={12} />
                                                                    </button>
                                                                    <button
                                                                        title="Delete"
                                                                        style={{ background: 'none', border: 'none', cursor: 'pointer', color: '#ef4444', padding: '2px' }}
                                                                        onClick={() => setLayoutConfirmAction({ type: 'delete', name: versionName })}
                                                                    >
                                                                        <Icon name="Trash2" size={12} />
                                                                    </button>
                                                                </div>
                                                            )}
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        )}
                                    </div>

                                    {confirmResetLayout ? (
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                                            <span style={{ fontSize: '0.75rem', color: '#dc2626', fontWeight: 'bold' }}>Reset?</span>
                                            <button
                                                className="btn btn-sm"
                                                style={{ fontSize: '0.75rem', padding: '0.25rem 0.5rem', background: '#dc2626', color: 'white' }}
                                                onClick={() => {
                                                    onUpdateLayouts(GAME_PLAN_LAYOUTS);
                                                    setConfirmResetLayout(false);
                                                }}
                                            >
                                                Yes
                                            </button>
                                            <button
                                                className="btn btn-sm"
                                                style={{ fontSize: '0.75rem', padding: '0.25rem 0.5rem', background: '#e5e7eb', color: '#374151' }}
                                                onClick={() => setConfirmResetLayout(false)}
                                            >
                                                No
                                            </button>
                                        </div>
                                    ) : (
                                        <button
                                            className="btn btn-sm"
                                            style={{ fontSize: '0.75rem', background: '#e5e7eb', color: '#374151' }}
                                            onClick={() => setConfirmResetLayout(true)}
                                        >
                                            ↺ Reset Layout
                                        </button>
                                    )}
                                    <div style={{ width: '1px', height: '20px', background: '#ccc', margin: '0 0.5rem' }}></div>
                                    {isCreatingScript ? (
                                        <input
                                            autoFocus
                                            placeholder="New Script Name..."
                                            style={{ fontSize: '0.8rem', padding: '0.25rem', borderRadius: '4px', border: '1px solid var(--primary)' }}
                                            onKeyDown={(e) => {
                                                if (e.key === 'Enter') handleSaveNewScript(e.target.value);
                                                if (e.key === 'Escape') setIsCreatingScript(false);
                                            }}
                                            onBlur={() => setIsCreatingScript(false)}
                                        />
                                    ) : (
                                        <button onClick={() => setIsCreatingScript(true)} className="btn btn-secondary" style={{ display: 'flex', alignItems: 'center', gap: '6px', backgroundColor: 'var(--accent)', color: 'white' }}>
                                            + Add Script
                                        </button>
                                    )}
                                </>
                            )}
                            {!isLocked && (
                                <button
                                    className="btn btn-secondary"
                                    onClick={() => {
                                        const newLayouts = { ...gamePlanLayouts };
                                        const sheet = { ...newLayouts.CALL_SHEET };
                                        sheet.sections.push({
                                            id: `section_${Date.now()}`,
                                            title: 'New Section',
                                            type: 'unconfigured',
                                            color: '#1e293b',
                                            boxes: []
                                        });
                                        newLayouts.CALL_SHEET = sheet;
                                        if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                    }}
                                    style={{
                                        display: 'flex', alignItems: 'center', gap: '6px',
                                        backgroundColor: 'var(--accent)',
                                        color: 'white'
                                    }}
                                >
                                    + Add Section
                                </button>
                            )}
                        </div>


                        {/* PLAYER TOUCHES SUMMARY */}

                        <div style={{ padding: '1rem' }}>
                            {(layout?.sections || []).map((section, idx) => (
                                <div
                                    key={idx}
                                    draggable={!isLocked}
                                    onDragStart={(e) => handleSectionDragStart(e, idx)}
                                    onDragOver={handleSectionDragOver}
                                    onDrop={(e) => handleSectionDrop(e, idx)}
                                    style={{
                                        marginBottom: '2rem',
                                        cursor: !isLocked ? 'grab' : 'default',
                                        opacity: draggedSection?.sectionIdx === idx ? 0.5 : 1,
                                        border: draggedSection && draggedSection.sectionIdx !== idx ? '2px dashed #cbd5e1' : 'none',
                                        borderRadius: '8px',
                                        padding: draggedSection ? '0.5rem' : '0',
                                        transition: 'opacity 0.2s, border 0.2s'
                                    }}
                                >
                                    {/* Section Header */}
                                    {section.title && (
                                        <div
                                            style={{ marginBottom: '1rem', borderBottom: '2px solid #ddd', paddingBottom: '0.25rem', position: 'relative' }}
                                            onDragOver={(e) => {
                                                if (isLocked) return;
                                                e.preventDefault();
                                                e.dataTransfer.dropEffect = 'move';
                                            }}
                                            onDrop={(e) => {
                                                if (isLocked || !draggedCell) return;
                                                e.preventDefault();

                                                // If dropped on the same section, do nothing (or maybe move to top?)
                                                if (draggedCell.sectionIdx === idx) return;

                                                // Move dragged item to this section
                                                const newLayouts = { ...gamePlanLayouts };
                                                const sheet = { ...newLayouts.CALL_SHEET };
                                                sheet.sections = [...sheet.sections];

                                                // Source
                                                const sourceBoxes = [...sheet.sections[draggedCell.sectionIdx].boxes];
                                                const itemToMove = sourceBoxes[draggedCell.rowIdx];
                                                sourceBoxes.splice(draggedCell.rowIdx, 1);
                                                sheet.sections[draggedCell.sectionIdx] = { ...sheet.sections[draggedCell.sectionIdx], boxes: sourceBoxes };

                                                // Target (Append to this section)
                                                const targetBoxes = [...sheet.sections[idx].boxes, itemToMove];
                                                sheet.sections[idx] = { ...sheet.sections[idx], boxes: targetBoxes };

                                                newLayouts.CALL_SHEET = sheet;
                                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                setDraggedCell(null);
                                            }}
                                        >
                                            {/* Editable Title with Drag Handle */}
                                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                {!isLocked && (
                                                    <span
                                                        style={{
                                                            cursor: 'grab',
                                                            fontSize: '1.2rem',
                                                            opacity: 0.5,
                                                            userSelect: 'none',
                                                            lineHeight: 1
                                                        }}
                                                        title="Drag to reorder section"
                                                    >
                                                        ⋮⋮
                                                    </span>
                                                )}
                                                <h3
                                                    style={{ fontSize: '1.1rem', fontWeight: 'bold', color: section.headerColor || '#1e293b', margin: 0, cursor: !isLocked ? 'pointer' : 'default', textTransform: 'uppercase', display: 'inline-block' }}
                                                    onClick={() => !isLocked && setEditingHeader({ sectionIdx: idx, isSectionTitle: true })}
                                                >
                                                    {section.title}
                                                </h3>
                                                {!isLocked && (
                                                    <button
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            setEditingHeader({ sectionIdx: idx, isSectionTitle: true });
                                                        }}
                                                        style={{
                                                            background: 'none', border: 'none', cursor: 'pointer', color: '#94a3b8',
                                                            padding: '4px', display: 'flex', alignItems: 'center'
                                                        }}
                                                        title="Edit Section"
                                                    >
                                                        <Icon name="Edit2" size={14} />
                                                    </button>
                                                )}
                                            </div>

                                            {/* Section Edit Menu */}
                                            {editingHeader && editingHeader.sectionIdx === idx && editingHeader.isSectionTitle && (
                                                <div style={{
                                                    position: 'absolute', top: '100%', left: 0, width: '250px', zIndex: 1000,
                                                    background: 'white', border: '1px solid #ccc', borderRadius: '4px',
                                                    boxShadow: '0 4px 10px rgba(0,0,0,0.2)', padding: '0.75rem',
                                                    display: 'flex', flexDirection: 'column', gap: '8px', color: '#1e293b',
                                                    marginTop: '4px'
                                                }}
                                                    onClick={(e) => e.stopPropagation()}
                                                >
                                                    <div style={{ fontSize: '0.75rem', fontWeight: 'bold', color: '#64748b', textTransform: 'uppercase', marginBottom: '2px' }}>Edit Section</div>

                                                    {/* Rename */}
                                                    <input
                                                        autoFocus
                                                        defaultValue={section.title}
                                                        placeholder="Section Name..."
                                                        onKeyDown={(e) => {
                                                            if (e.key === 'Enter') {
                                                                const newLayouts = { ...gamePlanLayouts };
                                                                newLayouts.CALL_SHEET.sections[idx].title = e.target.value;
                                                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                                setEditingHeader(null);
                                                            }
                                                        }}
                                                        style={{ width: '100%', border: '1px solid #cbd5e1', borderRadius: '4px', padding: '6px', fontSize: '0.9rem', color: '#0f172a' }}
                                                    />

                                                    {/* Layout Type */}
                                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                                        <label style={{ fontSize: '0.75rem', color: '#64748b' }}>Layout Type</label>
                                                        <select
                                                            value={section.type === 'grid' || section.type === 'field_position' ? 'grid' : 'modular'}
                                                            onChange={(e) => {
                                                                const newLayouts = { ...gamePlanLayouts };
                                                                const newType = e.target.value;
                                                                newLayouts.CALL_SHEET.sections[idx].type = newType;

                                                                if (newType === 'grid') {
                                                                    if (!newLayouts.CALL_SHEET.sections[idx].gridHeadings) {
                                                                        newLayouts.CALL_SHEET.sections[idx].gridHeadings = ['LEFT HASH', 'MIDDLE', 'RIGHT HASH', 'NOTES'];
                                                                    }
                                                                    if (!newLayouts.CALL_SHEET.sections[idx].rowLabels) {
                                                                        newLayouts.CALL_SHEET.sections[idx].rowLabels = ['Group 1', 'Group 2', 'Group 3', 'Group 4', 'Group 5'];
                                                                    }
                                                                } else {
                                                                    // Ensure boxes array exists if switching to modular
                                                                    if (!newLayouts.CALL_SHEET.sections[idx].boxes) {
                                                                        newLayouts.CALL_SHEET.sections[idx].boxes = [];
                                                                    }
                                                                }

                                                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                            }}
                                                            style={{ width: '100%', border: '1px solid #cbd5e1', borderRadius: '4px', padding: '6px', fontSize: '0.9rem', color: '#0f172a', background: 'white' }}
                                                        >
                                                            <option value="modular">Modular Container</option>
                                                            <option value="grid">Stand-alone Grid</option>
                                                        </select>
                                                    </div>

                                                    {/* Color Picker */}
                                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                                        <label style={{ fontSize: '0.75rem', color: '#64748b' }}>Header Color</label>
                                                        <input
                                                            type="color"
                                                            value={section.headerColor || '#1e293b'}
                                                            onChange={(e) => {
                                                                const newLayouts = { ...gamePlanLayouts };
                                                                newLayouts.CALL_SHEET.sections[idx].headerColor = e.target.value;
                                                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                            }}
                                                            style={{ width: '100%', height: '32px', border: '1px solid #cbd5e1', borderRadius: '4px', cursor: 'pointer' }}
                                                        />
                                                    </div>

                                                    {idx >= 0 && (
                                                        <button
                                                            className="btn-sm"
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                toggleSectionExpansion(idx);
                                                                setEditingHeader(null);
                                                            }}
                                                            style={{
                                                                background: section.expandToFill ? '#dcfce7' : '#e0f2fe',
                                                                color: section.expandToFill ? '#166534' : '#0369a1',
                                                                border: section.expandToFill ? '1px solid #86efac' : '1px solid #bae6fd',
                                                                width: '100%', fontSize: '0.8rem', padding: '6px', cursor: 'pointer',
                                                                borderRadius: '4px', textAlign: 'left', display: 'flex', alignItems: 'center', gap: '6px',
                                                                marginBottom: '4px'
                                                            }}
                                                        >
                                                            <Icon name={section.expandToFill ? "Minimize" : "Maximize"} size={12} />
                                                            {section.expandToFill ? "Fixed Width" : "Expand to Fill"}
                                                        </button>
                                                    )}

                                                    {/* Delete Section */}
                                                    {idx >= 0 && (
                                                        <button
                                                            className="btn-sm"
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                if (window.confirm('Delete this section? All boxes will move to the section above.')) {
                                                                    const newLayouts = { ...gamePlanLayouts };
                                                                    const sheet = { ...newLayouts.CALL_SHEET };
                                                                    sheet.sections = [...sheet.sections];

                                                                    // Move all boxes from this section to the previous section
                                                                    // If idx is 0, we can't move to previous. Just delete? Or warn?
                                                                    // If idx > 0
                                                                    if (idx > 0) {
                                                                        const currentSectionBoxes = [...sheet.sections[idx].boxes];
                                                                        const previousSectionBoxes = [...sheet.sections[idx - 1].boxes];
                                                                        sheet.sections[idx - 1] = {
                                                                            ...sheet.sections[idx - 1],
                                                                            boxes: [...previousSectionBoxes, ...currentSectionBoxes]
                                                                        };
                                                                    } else {
                                                                        // Index 0, just delete? Or maybe move to next? 
                                                                        // Let's just delete for now, user confirmed.
                                                                    }

                                                                    // Remove this section
                                                                    sheet.sections.splice(idx, 1);

                                                                    newLayouts.CALL_SHEET = sheet;
                                                                    if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                                }
                                                                setEditingHeader(null);
                                                            }}
                                                            style={{
                                                                background: '#fee2e2', color: '#dc2626', border: '1px solid #fca5a5',
                                                                width: '100%', fontSize: '0.8rem', padding: '6px', cursor: 'pointer',
                                                                borderRadius: '4px', textAlign: 'left', display: 'flex', alignItems: 'center', gap: '6px'
                                                            }}
                                                        >
                                                            <Icon name="Trash2" size={12} /> Delete Section
                                                        </button>
                                                    )}

                                                    <div style={{ textAlign: 'right', marginTop: '4px' }}>
                                                        <span
                                                            style={{ fontSize: '0.75rem', color: '#64748b', cursor: 'pointer', textDecoration: 'underline' }}
                                                            onClick={() => setEditingHeader(null)}
                                                        >
                                                            Close
                                                        </span>
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    )}

                                    {/* Content based on Type */}
                                    {section.type === 'unconfigured' ? (
                                        <div style={{
                                            border: '2px dashed #cbd5e1', borderRadius: '8px', padding: '3rem',
                                            background: '#f8fafc',
                                            display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '2rem'
                                        }}>
                                            <div style={{ textAlign: 'center' }}>
                                                <h3 style={{ fontSize: '1.2rem', fontWeight: 'bold', color: '#475569', marginBottom: '0.5rem' }}>Configuration Required</h3>
                                                <p style={{ color: '#94a3b8' }}>Select a layout type for this section.</p>
                                            </div>

                                            <div style={{ display: 'flex', gap: '2rem', flexWrap: 'wrap', justifyContent: 'center' }}>
                                                {/* OPTION 1: Stand-alone Grid */}
                                                <div
                                                    onClick={() => {
                                                        const newLayouts = { ...gamePlanLayouts };
                                                        newLayouts.CALL_SHEET.sections[idx].type = 'grid';
                                                        newLayouts.CALL_SHEET.sections[idx].gridHeadings = ['LEFT HASH', 'MIDDLE', 'RIGHT HASH', 'NOTES'];
                                                        newLayouts.CALL_SHEET.sections[idx].rowLabels = ['Group 1', 'Group 2', 'Group 3', 'Group 4', 'Group 5'];
                                                        if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                    }}
                                                    style={{
                                                        background: 'white', border: '1px solid #e2e8f0', borderRadius: '8px', padding: '2rem',
                                                        cursor: 'pointer', width: '220px', textAlign: 'center', transition: 'all 0.2s',
                                                        boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)'
                                                    }}
                                                    onMouseEnter={e => { e.currentTarget.style.borderColor = 'var(--primary)'; e.currentTarget.style.transform = 'translateY(-2px)'; }}
                                                    onMouseLeave={e => { e.currentTarget.style.borderColor = '#e2e8f0'; e.currentTarget.style.transform = 'translateY(0)'; }}
                                                >
                                                    <div style={{ fontSize: '3rem', marginBottom: '1rem' }}>▦</div>
                                                    <div style={{ fontWeight: 'bold', color: '#334155', marginBottom: '0.5rem' }}>Stand-alone Grid</div>
                                                    <div style={{ fontSize: '0.8rem', color: '#94a3b8', lineHeight: '1.4' }}>
                                                        A single 5x4 "Strike 'Em Out" grid. Best for Field Zone or specialized situational sheets.
                                                    </div>
                                                </div>

                                                {/* OPTION 2: Modular Section */}
                                                <div
                                                    onClick={() => {
                                                        const newLayouts = { ...gamePlanLayouts };
                                                        newLayouts.CALL_SHEET.sections[idx].type = 'modular'; // 'modular' triggers default box container layout
                                                        newLayouts.CALL_SHEET.sections[idx].boxes = [];
                                                        if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                    }}
                                                    style={{
                                                        background: 'white', border: '1px solid #e2e8f0', borderRadius: '8px', padding: '2rem',
                                                        cursor: 'pointer', width: '220px', textAlign: 'center', transition: 'all 0.2s',
                                                        boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)'
                                                    }}
                                                    onMouseEnter={e => { e.currentTarget.style.borderColor = 'var(--accent)'; e.currentTarget.style.transform = 'translateY(-2px)'; }}
                                                    onMouseLeave={e => { e.currentTarget.style.borderColor = '#e2e8f0'; e.currentTarget.style.transform = 'translateY(0)'; }}
                                                >
                                                    <div style={{ fontSize: '3rem', marginBottom: '1rem' }}>▣</div>
                                                    <div style={{ fontWeight: 'bold', color: '#334155', marginBottom: '0.5rem' }}>Modular Container</div>
                                                    <div style={{ fontSize: '0.8rem', color: '#94a3b8', lineHeight: '1.4' }}>
                                                        A flexible container. Add multiple Script Boxes, Grid Boxes, or mix and match.
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    ) : section.type === 'script' ? (
                                        renderScriptSection(section, idx)
                                    ) : section.type === 'grid' ? (
                                        renderGridSection(section, idx)
                                    ) : section.type === 'field_position' ? (
                                        renderFieldPositionSection(section, idx)
                                    ) : section.type === 'standard' ? (
                                        renderStandardSection(section, idx)
                                    ) : (
                                        /* Default/Grid Layout */
                                        <div
                                            style={{
                                                display: section.expandToFill ? 'flex' : 'grid',
                                                flexWrap: section.expandToFill ? 'wrap' : undefined,
                                                gridTemplateColumns: section.expandToFill ? undefined : `repeat(7, 1fr)`,
                                                gap: '4px',
                                                minHeight: '100px', // Ensure empty sections are drop targets
                                                border: isLocked ? 'none' : '1px dashed #cbd5e1', // Visual cue
                                                borderRadius: '8px',
                                                padding: '4px'
                                            }}
                                            onDragOver={(e) => {
                                                if (isLocked) return;
                                                e.preventDefault();
                                                e.dataTransfer.dropEffect = 'move';
                                            }}
                                            onDrop={(e) => {
                                                // This handles drop on empty space in section
                                                if (isLocked || !draggedCell) return;
                                                e.preventDefault();
                                                e.stopPropagation();

                                                if (draggedCell.sectionIdx === idx) return; // Same section, no-op if dropped on container (append? already there)

                                                // Move dragged item to this section (Append)
                                                const newLayouts = { ...gamePlanLayouts };
                                                const sheet = { ...newLayouts.CALL_SHEET };
                                                sheet.sections = [...sheet.sections];

                                                const sourceBoxes = [...sheet.sections[draggedCell.sectionIdx].boxes];
                                                const itemToMove = sourceBoxes[draggedCell.rowIdx];
                                                sourceBoxes.splice(draggedCell.rowIdx, 1);
                                                sheet.sections[draggedCell.sectionIdx] = { ...sheet.sections[draggedCell.sectionIdx], boxes: sourceBoxes };

                                                const targetBoxes = [...sheet.sections[idx].boxes, itemToMove];
                                                sheet.sections[idx] = { ...sheet.sections[idx], boxes: targetBoxes };

                                                newLayouts.CALL_SHEET = sheet;
                                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                setDraggedCell(null);
                                            }}
                                        >
                                            {(section.boxes || []).map((box, boxIdx) => renderBox(box, idx, boxIdx, section.expandToFill))}
                                        </div>
                                    )}
                                </div>
                            ))
                            }
                        </div>
                    </div>
                );
            };

            // spreadsheet editing state
            const [isSheetEditing, setIsSheetEditing] = useState(false);

            const handleAddSheetSection = () => {
                const newSection = {
                    title: 'New Section',
                    boxes: []
                };
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                sheet.sections = [...(sheet.sections || []), newSection];
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
            };

            const handleUpdateSheetSection = (index, updatedSection) => {
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                const newSections = [...sheet.sections];
                newSections[index] = updatedSection;
                sheet.sections = newSections;
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
            };

            const handleDeleteSheetSection = (index) => {
                if (!confirm('Delete this section and all its boxes?')) return;
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                const newSections = [...sheet.sections];
                newSections.splice(index, 1);
                sheet.sections = newSections;
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
            };

            const handleAddSheetBox = (sectionIndex) => {
                const newBox = {
                    header: 'New Box',
                    setId: `box_${Date.now()}`,
                    color: '#3b82f6',
                    type: 'script', // Default to script
                    colSpan: 2, // Default width
                    rows: []
                };
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                const newSections = [...sheet.sections];
                const targetSection = { ...newSections[sectionIndex] };
                targetSection.boxes = [...(targetSection.boxes || []), newBox];
                newSections[sectionIndex] = targetSection;
                sheet.sections = newSections;
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
            };

            const handleDeleteSheetBox = (sectionIndex, boxIndex) => {
                if (!confirm('Delete this box?')) return;
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                const newSections = [...sheet.sections];
                const targetSection = { ...newSections[sectionIndex] };
                const newBoxes = [...targetSection.boxes];
                newBoxes.splice(boxIndex, 1);
                targetSection.boxes = newBoxes;
                newSections[sectionIndex] = targetSection;
                sheet.sections = newSections;
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
            };

            const handleSheetBoxDrop = (e, targetSectionIdx, targetBoxIdx) => {
                if (!isSheetEditing || !draggedCell) return;
                e.preventDefault();

                // draggedCell contains { sectionIdx, boxIdx } from the start
                // We need to move the box from source to target

                const sourceSectionIdx = draggedCell.sectionIdx;
                const sourceBoxIdx = draggedCell.boxIdx;

                if (sourceSectionIdx === targetSectionIdx && sourceBoxIdx === targetBoxIdx) return;

                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                const newSections = [...sheet.sections];

                const sourceSection = { ...newSections[sourceSectionIdx] };
                const sourceBoxes = [...sourceSection.boxes];
                const [movedBox] = sourceBoxes.splice(sourceBoxIdx, 1);

                if (sourceSectionIdx === targetSectionIdx) {
                    // Same section move
                    sourceBoxes.splice(targetBoxIdx, 0, movedBox);
                    sourceSection.boxes = sourceBoxes;
                    newSections[sourceSectionIdx] = sourceSection;
                } else {
                    // Different section move
                    const targetSection = { ...newSections[targetSectionIdx] };
                    const targetBoxes = [...targetSection.boxes];

                    // Update source first
                    sourceSection.boxes = sourceBoxes;
                    newSections[sourceSectionIdx] = sourceSection;

                    // Update target
                    targetBoxes.splice(targetBoxIdx, 0, movedBox);
                    targetSection.boxes = targetBoxes;
                    newSections[targetSectionIdx] = targetSection;
                }

                sheet.sections = newSections;
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                setDraggedCell(null);
            };

            const handleSheetSectionDragOver = (e) => {
                if (!isSheetEditing || !draggedCell) return;
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'move';
            };

            const handleSheetSectionDrop = (e, targetSectionIdx) => {
                if (!isSheetEditing || !draggedCell) return;
                e.preventDefault();
                e.stopPropagation();

                // If dropping on same section, usually handled by box drop, but allowed for append.
                if (draggedCell.sectionIdx === targetSectionIdx) return;

                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                const newSections = [...sheet.sections];

                const sourceSection = { ...newSections[draggedCell.sectionIdx] };
                const sourceBoxes = [...(sourceSection.boxes || [])];

                if (!sourceBoxes[draggedCell.boxIdx]) return;

                const [movedBox] = sourceBoxes.splice(draggedCell.boxIdx, 1);

                // Update source
                sourceSection.boxes = sourceBoxes;
                newSections[draggedCell.sectionIdx] = sourceSection;

                // Update target (Append)
                const targetSection = { ...newSections[targetSectionIdx] };
                const targetBoxes = [...(targetSection.boxes || []), movedBox];
                targetSection.boxes = targetBoxes;
                newSections[targetSectionIdx] = targetSection;

                sheet.sections = newSections;
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                setDraggedCell(null);
            };

            const renderFZDnDView = () => {
                const FZDND_ZONES = [
                    { id: 'openers', title: 'Openers vs.', color: '#fef08a', textColor: 'black', columns: ['1st & 10', '2nd & <5', '2nd & 5+', '3rd & <5', '3rd & 5+'] },
                    { id: 'black', title: 'Black Zone (Goalline to -10)', color: 'black', textColor: 'white' },
                    { id: 'red', title: 'Red Zone (-10 to -40)', color: '#ef4444', textColor: 'white' },
                    { id: 'yellow', title: 'Yellow Zone (-40 to +40)', color: '#fef08a', textColor: 'black' },
                    { id: 'gold', title: 'Gold Zone - Take A Shot (+40 to Endzone)', color: '#f59e0b', textColor: 'black' },
                    { id: 'green', title: 'Green Zone (+20 to Endzone)', color: '#22c55e', textColor: 'black' },
                    { id: '4min', title: '4:00 Offense', color: '#1e1b4b', textColor: '#fef08a' }, // Dark Blue
                    { id: '2min', title: '2:00 Offense', color: '#dc2626', textColor: 'black', columns: ['Personnel', 'Timeouts', 'Max Protect', 'First Downs', 'Think Plays'] },
                    { id: '2pt', title: 'Two Point Plays', color: 'black', textColor: 'white', columns: [' ', ' '] }
                ];

                const handleFZDnDDrop = (e, zoneId, colIdx) => {
                    e.preventDefault();
                    if (isLocked) return;
                    try {
                        const data = JSON.parse(e.dataTransfer.getData('application/react-dnd'));
                        if (data && data.playId) {
                            const setId = `fzdnd_${zoneId}_${colIdx}`;
                            let newSets = [...(gamePlan?.sets || [])];
                            let setIndex = newSets.findIndex(s => s.id === setId);

                            if (setIndex === -1) {
                                newSets.push({ id: setId, name: `${zoneId} - ${colIdx}`, playIds: [data.playId] });
                            } else {
                                const existingSet = { ...newSets[setIndex] };
                                if (!existingSet.playIds.includes(data.playId)) {
                                    existingSet.playIds = [...existingSet.playIds, data.playId];
                                    newSets[setIndex] = existingSet;
                                }
                            }
                            onUpdateGamePlan({ ...gamePlan, sets: newSets });
                        }
                    } catch (e) { }
                };

                const handleRemoveFromFZDnD = (zoneId, colIdx, playId) => {
                    const setId = `fzdnd_${zoneId}_${colIdx}`;
                    let newSets = [...(gamePlan?.sets || [])];
                    let setIndex = newSets.findIndex(s => s.id === setId);
                    if (setIndex !== -1) {
                        const existingSet = { ...newSets[setIndex] };
                        existingSet.playIds = existingSet.playIds.filter(id => id !== playId);
                        newSets[setIndex] = existingSet;
                        onUpdateGamePlan({ ...gamePlan, sets: newSets });
                    }
                };

                const updateZoneNote = (zoneId, note) => {
                    const newNotes = { ...(gamePlan?.zoneNotes || {}) };
                    newNotes[zoneId] = note;
                    onUpdateGamePlan({ ...gamePlan, zoneNotes: newNotes });
                };

                const updatePlayWristband = (playId, slot) => {
                    // Validation Logic
                    let isBlocked = false;
                    const currentWbSettings = currentWeek?.wristbands || {};
                    const enabledSections = currentWbSettings.enabledSections || {};

                    const cardKeys = ['card1', 'card2', 'card3', 'card4', 'card5', 'card6'];
                    for (const key of cardKeys) {
                        if (enabledSections[key] !== false) continue;
                        const card = currentWbSettings[key];
                        if (!card) continue;
                        const cardNum = parseInt(key.replace('card', ''));

                        if (card.type && (card.type === 'rooski' || card.type === 'wiz')) {
                            for (let i = 1; i <= 16; i++) {
                                if (slot === `${cardNum}${String(i).padStart(2, '0')}`) isBlocked = true;
                            }
                        } else {
                            const start = cardNum * 100 + 1;
                            const end = start + 47;
                            const num = parseInt(slot);
                            if (!isNaN(num) && num >= start && num <= end && String(num) === slot) isBlocked = true;
                        }
                    }

                    // Check Staples
                    if (enabledSections.staples === false) {
                        const num = parseInt(slot);
                        if (!isNaN(num) && num >= 10 && num <= 89 && String(num) === slot) isBlocked = true;
                    }

                    if (isBlocked) {
                        alert("This wristband section is disabled.");
                        return;
                    }

                    if (onUpdatePlay) {
                        const play = plays.find(p => p.id === playId);
                        if (play) {
                            onUpdatePlay({ ...play, wristbandSlot: slot });
                        }
                    }
                };

                return (
                    <div style={{ display: 'flex', height: '100%', overflow: 'hidden' }}>
                        <div style={{ flex: 1, height: '100%', overflowY: 'auto', padding: '20px', background: 'white' }}>
                            {FZDND_ZONES.map((zone) => {
                                const definedCols = zone.columns || ['1st and 10', '2nd and <5', '2nd and 5+', '3rd and <5', '3rd and 5+'];
                                // Get custom zone data from gamePlan
                                const customZone = (gamePlan?.customZones || {})[zone.id] || {};
                                const zoneTitle = customZone.title || zone.title;
                                const zoneColor = customZone.color || zone.color;
                                const zoneTextColor = customZone.textColor || zone.textColor || '#000';
                                const zonePhilosophy = (gamePlan?.zoneNotes || {})[zone.id] || '';

                                const customCols = (gamePlan?.customColumns || {})[zone.id] || {};

                                return (
                                    <div key={zone.id} className="fzdnd-zone-container" style={{ marginBottom: '0', border: '2px solid black' }}>
                                        {/* SPLIT HEADER: Title Left, Philosophy Right */}
                                        <div style={{
                                            display: 'grid',
                                            gridTemplateColumns: '1fr 1fr',
                                            borderBottom: '2px solid black',
                                            background: zoneColor
                                        }}>
                                            {/* Zone Title - Left Side - Editable */}
                                            <div style={{
                                                borderRight: '1px solid black',
                                                padding: '4px 8px',
                                                display: 'flex',
                                                alignItems: 'center',
                                                gap: '8px'
                                            }}>
                                                <input
                                                    type="text"
                                                    value={zoneTitle}
                                                    onChange={(e) => {
                                                        const newCustomZones = { ...(gamePlan?.customZones || {}) };
                                                        newCustomZones[zone.id] = {
                                                            ...newCustomZones[zone.id],
                                                            title: e.target.value
                                                        };
                                                        onUpdateGamePlan({ ...gamePlan, customZones: newCustomZones });
                                                    }}
                                                    disabled={isLocked}
                                                    className="hide-on-print"
                                                    style={{
                                                        flex: 1,
                                                        background: 'transparent',
                                                        border: 'none',
                                                        color: zoneTextColor,
                                                        fontWeight: 'bold',
                                                        fontSize: '1rem',
                                                        textTransform: 'uppercase',
                                                        outline: 'none',
                                                        cursor: isLocked ? 'default' : 'text'
                                                    }}
                                                />
                                                <span className="print-only-text" style={{
                                                    flex: 1,
                                                    color: zoneTextColor,
                                                    fontWeight: 'bold',
                                                    fontSize: '1rem',
                                                    textTransform: 'uppercase'
                                                }}>
                                                    {zoneTitle}
                                                </span>
                                                {!isLocked && (
                                                    <div style={{ display: 'flex', gap: '4px' }}>
                                                        <input
                                                            type="color"
                                                            value={zoneColor}
                                                            onChange={(e) => {
                                                                const newCustomZones = { ...(gamePlan?.customZones || {}) };
                                                                newCustomZones[zone.id] = {
                                                                    ...newCustomZones[zone.id],
                                                                    color: e.target.value
                                                                };
                                                                onUpdateGamePlan({ ...gamePlan, customZones: newCustomZones });
                                                            }}
                                                            style={{
                                                                width: '18px',
                                                                height: '18px',
                                                                border: '1px solid rgba(0,0,0,0.3)',
                                                                borderRadius: '3px',
                                                                cursor: 'pointer',
                                                                padding: 0
                                                            }}
                                                            title="Change zone color"
                                                        />
                                                        <input
                                                            type="color"
                                                            value={zoneTextColor}
                                                            onChange={(e) => {
                                                                const newCustomZones = { ...(gamePlan?.customZones || {}) };
                                                                newCustomZones[zone.id] = {
                                                                    ...newCustomZones[zone.id],
                                                                    textColor: e.target.value
                                                                };
                                                                onUpdateGamePlan({ ...gamePlan, customZones: newCustomZones });
                                                            }}
                                                            style={{
                                                                width: '18px',
                                                                height: '18px',
                                                                border: '1px solid rgba(0,0,0,0.3)',
                                                                borderRadius: '3px',
                                                                cursor: 'pointer',
                                                                padding: 0
                                                            }}
                                                            title="Change text color"
                                                        />
                                                    </div>
                                                )}
                                            </div>

                                            {/* Philosophy Notes - Right Side */}
                                            <div style={{ padding: '4px 8px' }}>
                                                <input
                                                    type="text"
                                                    value={zonePhilosophy}
                                                    onChange={(e) => updateZoneNote(zone.id, e.target.value)}
                                                    disabled={isLocked}
                                                    placeholder="Philosophy reminders..."
                                                    style={{
                                                        width: '100%',
                                                        background: 'transparent',
                                                        border: 'none',
                                                        color: zoneTextColor,
                                                        fontWeight: '600',
                                                        fontSize: '0.9rem',
                                                        fontStyle: 'italic',
                                                        textAlign: 'center',
                                                        outline: 'none',
                                                        cursor: isLocked ? 'default' : 'text'
                                                    }}
                                                />
                                            </div>
                                        </div>

                                        {/* Content Grid */}
                                        <div className="fzdnd-content-wrapper" style={{ display: 'flex', flexDirection: 'column' }}>
                                            {definedCols.length > 0 && (
                                                <>
                                                    {/* COLUMN HEADERS */}
                                                    <div className="fzdnd-header-row" style={{
                                                        display: 'grid',
                                                        gridTemplateColumns: `40px repeat(${definedCols.length}, minmax(0, 1fr))`,
                                                        borderBottom: '1px solid black'
                                                    }}>
                                                        <div style={{ borderRight: '1px solid black', borderBottom: '1px solid black' }}></div>
                                                        {definedCols.map((colName, cIdx) => (
                                                            <div key={`header-${cIdx}`} style={{
                                                                padding: '4px',
                                                                textAlign: 'center',
                                                                borderRight: cIdx < definedCols.length - 1 ? '1px solid black' : 'none',
                                                                borderBottom: '1px solid black',
                                                                background: 'white',
                                                                display: 'flex',
                                                                alignItems: 'center',
                                                                justifyContent: 'center'
                                                            }}>
                                                                <input
                                                                    type="text"
                                                                    value={customCols[cIdx] || colName}
                                                                    onChange={(e) => {
                                                                        const newCustomCols = { ...(gamePlan?.customColumns || {}) };
                                                                        newCustomCols[zone.id] = {
                                                                            ...(newCustomCols[zone.id] || {}),
                                                                            [cIdx]: e.target.value
                                                                        };
                                                                        onUpdateGamePlan({ ...gamePlan, customColumns: newCustomCols });
                                                                    }}
                                                                    disabled={isLocked}
                                                                    style={{
                                                                        width: '100%',
                                                                        background: 'transparent',
                                                                        border: 'none',
                                                                        color: 'black',
                                                                        fontWeight: '800',
                                                                        fontSize: '0.85rem',
                                                                        fontStyle: 'italic',
                                                                        textAlign: 'center',
                                                                        outline: 'none',
                                                                        cursor: isLocked ? 'default' : 'text'
                                                                    }}
                                                                />
                                                                <span className="print-only-text" style={{
                                                                    color: 'black',
                                                                    fontWeight: '800',
                                                                    fontSize: '0.85rem',
                                                                    fontStyle: 'italic',
                                                                    textAlign: 'center'
                                                                }}>
                                                                    {customCols[cIdx] || colName}
                                                                </span>
                                                            </div>
                                                        ))}
                                                    </div>

                                                    {/* ROWS */}
                                                    {[0, 1, 2, 3, 4].map(rowIdx => {
                                                        const rowKey = `${zone.id}_${rowIdx}`;
                                                        const isRowCollapsed = collapsedFZDnDRows.has(rowKey);

                                                        if (isRowCollapsed) {
                                                            return (
                                                                <div
                                                                    key={`row-${rowIdx}`}
                                                                    className="hide-on-print"
                                                                    onClick={() => toggleFZDnDRow(zone.id, rowIdx)}
                                                                    style={{
                                                                        padding: '4px 8px',
                                                                        background: '#eff6ff',
                                                                        cursor: 'pointer',
                                                                        borderBottom: '1px solid #cbd5e1',
                                                                        color: '#1e3a8a',
                                                                        fontSize: '0.8rem',
                                                                        fontStyle: 'italic',
                                                                        display: 'flex',
                                                                        alignItems: 'center',
                                                                        gap: '0.5rem'
                                                                    }}
                                                                    title="Click to expand row"
                                                                >
                                                                    <span style={{ fontSize: '0.7rem' }}>▶</span>
                                                                    <span>Row {rowIdx + 1} (Collapsed)</span>
                                                                </div>
                                                            );
                                                        }

                                                        return (
                                                            <div
                                                                key={`row-${rowIdx}`}
                                                                className="fzdnd-row-container"
                                                                style={{
                                                                    display: 'grid',
                                                                    gridTemplateColumns: `40px repeat(${definedCols.length}, minmax(0, 1fr))`,
                                                                    minHeight: '32px'
                                                                }}
                                                            >
                                                                {/* COLLAPSE ARROW */}
                                                                <div
                                                                    className="fzdnd-toggle-cell"
                                                                    onClick={() => toggleFZDnDRow(zone.id, rowIdx)}
                                                                    style={{
                                                                        borderRight: '1px solid black',
                                                                        borderBottom: '1px solid #e2e8f0',
                                                                        background: '#dbeafe',
                                                                        cursor: 'pointer',
                                                                        display: 'flex',
                                                                        alignItems: 'center',
                                                                        justifyContent: 'center',
                                                                        fontSize: '0.7rem',
                                                                        color: '#1e40af'
                                                                    }}
                                                                    title="Click to collapse row"
                                                                >
                                                                    <span className="hide-on-print">▼</span>
                                                                </div>

                                                                {/* CELLS FOR EACH COLUMN */}
                                                                {definedCols.map((_, cIdx) => {
                                                                    const setId = `fzdnd_${zone.id}_${cIdx}`;
                                                                    const set = (gamePlan?.sets || []).find(s => s.id === setId);
                                                                    const playId = set?.playIds?.[rowIdx];
                                                                    const play = playId ? plays.find(p => p.id === playId) : null;

                                                                    return (
                                                                        <div
                                                                            key={`cell-${cIdx}`}
                                                                            className="fzdnd-cell"
                                                                            style={{
                                                                                borderRight: cIdx < definedCols.length - 1 ? '1px solid black' : 'none',
                                                                                borderBottom: '1px solid #e2e8f0',
                                                                                background: play ? (play.priority ? '#fef08a' : (rowIdx % 2 === 0 ? 'white' : '#f8fafc')) : 'white',
                                                                                padding: play ? '4px 6px' : '0',
                                                                                minHeight: '32px',
                                                                                display: 'flex',
                                                                                alignItems: 'center'
                                                                            }}
                                                                            onDragOver={(e) => e.preventDefault()}
                                                                            onDrop={(e) => {
                                                                                e.preventDefault();
                                                                                const playId = e.dataTransfer.getData('playId');
                                                                                if (!playId) return;

                                                                                const setId = `fzdnd_${zone.id}_${cIdx}`;
                                                                                let sets = [...(gamePlan?.sets || [])];
                                                                                let set = sets.find(s => s.id === setId);

                                                                                if (!set) {
                                                                                    set = { id: setId, playIds: [] };
                                                                                    sets.push(set);
                                                                                }

                                                                                // Ensure playIds array has at least rowIdx + 1 elements
                                                                                while (set.playIds.length <= rowIdx) {
                                                                                    set.playIds.push(null);
                                                                                }

                                                                                // Set the play at this row index
                                                                                set.playIds[rowIdx] = playId;

                                                                                onUpdateGamePlan({ ...gamePlan, sets });
                                                                            }}
                                                                        >
                                                                            {play ? (
                                                                                <div
                                                                                    style={{
                                                                                        display: 'flex',
                                                                                        justifyContent: 'space-between',
                                                                                        alignItems: 'center',
                                                                                        width: '100%',
                                                                                        fontSize: '0.8rem',
                                                                                        fontWeight: '600',
                                                                                        color: 'black',
                                                                                        cursor: 'context-menu'
                                                                                    }}
                                                                                    onContextMenu={(e) => {
                                                                                        e.preventDefault();
                                                                                        e.stopPropagation();
                                                                                        openPlayDetails(play.id);
                                                                                    }}
                                                                                >
                                                                                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px', flex: 1, minWidth: 0 }}>
                                                                                        <span style={{ overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                                                                                            {play.name}
                                                                                        </span>

                                                                                        {/* WRISTBAND INPUT WITH AUTOCOMPLETE */}
                                                                                        {(() => {
                                                                                            const isFocused = fzdndWbAutocomplete.playId === play.id;

                                                                                            // Get used slots excluding current play
                                                                                            const usedSlots = new Set(
                                                                                                plays
                                                                                                    .filter(p => p.id !== play.id && p.wristbandSlot)
                                                                                                    .map(p => p.wristbandSlot)
                                                                                            );

                                                                                            // Filter available slots
                                                                                            const availableSlots = (validWristbandSlots || [])
                                                                                                .filter(slot => !usedSlots.has(slot));

                                                                                            const query = isFocused ? fzdndWbAutocomplete.query : '';

                                                                                            // Filter slots based on query
                                                                                            const filteredSlots = query
                                                                                                ? availableSlots.filter(s => s.toString().includes(query)).slice(0, 10)
                                                                                                : [];

                                                                                            return (
                                                                                                <div style={{ position: 'relative', width: '36px' }}>
                                                                                                    <input
                                                                                                        type="text"
                                                                                                        value={isFocused ? query : (play.wristbandSlot || '')}
                                                                                                        placeholder="#"
                                                                                                        onFocus={() => setFzdndWbAutocomplete({
                                                                                                            playId: play.id,
                                                                                                            query: play.wristbandSlot || ''
                                                                                                        })}
                                                                                                        onChange={(e) => {
                                                                                                            setFzdndWbAutocomplete({
                                                                                                                playId: play.id,
                                                                                                                query: e.target.value
                                                                                                            });
                                                                                                        }}
                                                                                                        onKeyDown={(e) => {
                                                                                                            if (e.key === 'Enter' && query.trim()) {
                                                                                                                // Select first match or use typed value
                                                                                                                const slot = filteredSlots.length > 0
                                                                                                                    ? filteredSlots[0]
                                                                                                                    : query.trim();
                                                                                                                updatePlayWristband(play.id, slot);
                                                                                                                setFzdndWbAutocomplete({ playId: null, query: '' });
                                                                                                            } else if (e.key === 'Escape') {
                                                                                                                setFzdndWbAutocomplete({ playId: null, query: '' });
                                                                                                            }
                                                                                                        }}
                                                                                                        onBlur={() => {
                                                                                                            setTimeout(() => {
                                                                                                                if (fzdndWbAutocomplete.playId === play.id) {
                                                                                                                    // Save the value on blur
                                                                                                                    if (fzdndWbAutocomplete.query.trim()) {
                                                                                                                        updatePlayWristband(play.id, fzdndWbAutocomplete.query.trim());
                                                                                                                    }
                                                                                                                    setFzdndWbAutocomplete({ playId: null, query: '' });
                                                                                                                }
                                                                                                            }, 200);
                                                                                                        }}
                                                                                                        onClick={(e) => e.stopPropagation()}
                                                                                                        style={{
                                                                                                            width: '100%',
                                                                                                            fontSize: '0.75rem',
                                                                                                            border: isFocused ? '1px solid #3b82f6' : '1px solid #94a3b8',
                                                                                                            borderRadius: '4px',
                                                                                                            textAlign: 'center',
                                                                                                            background: play.wristbandSlot ? '#dbeafe' : 'white',
                                                                                                            color: play.wristbandSlot ? '#1e40af' : '#64748b',
                                                                                                            fontWeight: 'bold',
                                                                                                            outline: 'none'
                                                                                                        }}
                                                                                                    />

                                                                                                    {/* AUTOCOMPLETE DROPDOWN */}
                                                                                                    {isFocused && filteredSlots.length > 0 && (
                                                                                                        <div style={{
                                                                                                            position: 'absolute',
                                                                                                            top: '100%',
                                                                                                            left: 0,
                                                                                                            minWidth: '60px',
                                                                                                            background: 'white',
                                                                                                            border: '1px solid #cbd5e1',
                                                                                                            borderRadius: '4px',
                                                                                                            boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
                                                                                                            maxHeight: '200px',
                                                                                                            overflowY: 'auto',
                                                                                                            zIndex: 1000,
                                                                                                            marginTop: '2px'
                                                                                                        }}>
                                                                                                            {filteredSlots.map(slot => (
                                                                                                                <div
                                                                                                                    key={slot}
                                                                                                                    onMouseDown={(e) => {
                                                                                                                        e.preventDefault();
                                                                                                                        updatePlayWristband(play.id, slot);
                                                                                                                        setFzdndWbAutocomplete({ playId: null, query: '' });
                                                                                                                    }}
                                                                                                                    style={{
                                                                                                                        padding: '6px 8px',
                                                                                                                        cursor: 'pointer',
                                                                                                                        fontSize: '0.75rem',
                                                                                                                        borderBottom: '1px solid #f1f5f9',
                                                                                                                        background: 'white',
                                                                                                                        color: '#1f2937',
                                                                                                                        textAlign: 'center',
                                                                                                                        fontWeight: 'bold'
                                                                                                                    }}
                                                                                                                    onMouseEnter={(e) => e.currentTarget.style.background = '#dbeafe'}
                                                                                                                    onMouseLeave={(e) => e.currentTarget.style.background = 'white'}
                                                                                                                >
                                                                                                                    {slot}{getWristbandTypeIndicator(slot)}
                                                                                                                </div>
                                                                                                            ))}
                                                                                                        </div>
                                                                                                    )}
                                                                                                </div>
                                                                                            );
                                                                                        })()}
                                                                                    </div>
                                                                                    {!isLocked && (
                                                                                        <button
                                                                                            onClick={() => {
                                                                                                const setId = `fzdnd_${zone.id}_${cIdx}`;
                                                                                                let sets = [...(gamePlan?.sets || [])];
                                                                                                let set = sets.find(s => s.id === setId);
                                                                                                if (set && set.playIds[rowIdx]) {
                                                                                                    set.playIds[rowIdx] = null;
                                                                                                    onUpdateGamePlan({ ...gamePlan, sets });
                                                                                                }
                                                                                            }}
                                                                                            style={{
                                                                                                border: 'none',
                                                                                                background: 'none',
                                                                                                color: '#dc2626',
                                                                                                cursor: 'pointer',
                                                                                                fontSize: '1rem',
                                                                                                fontWeight: 'bold'
                                                                                            }}
                                                                                        >
                                                                                            ×
                                                                                        </button>
                                                                                    )}
                                                                                </div>
                                                                            ) : (
                                                                                // AUTOCOMPLETE INPUT FOR EMPTY CELLS
                                                                                (() => {
                                                                                    const isFocused = fzdndAutocomplete.zoneId === zone.id &&
                                                                                        fzdndAutocomplete.rowIdx === rowIdx &&
                                                                                        fzdndAutocomplete.colIdx === cIdx;

                                                                                    const query = isFocused ? fzdndAutocomplete.query : '';

                                                                                    // Filter plays based on query
                                                                                    const filteredPlays = query
                                                                                        ? plays.filter(p => p.name.toLowerCase().includes(query.toLowerCase())).slice(0, 10)
                                                                                        : [];

                                                                                    const showCreateOption = query.trim() && filteredPlays.length === 0;

                                                                                    return (
                                                                                        <div style={{ position: 'relative', width: '100%', padding: '2px' }}>
                                                                                            <input
                                                                                                type="text"
                                                                                                placeholder="Type play name..."
                                                                                                value={query}
                                                                                                disabled={isLocked}
                                                                                                onFocus={() => setFzdndAutocomplete({
                                                                                                    zoneId: zone.id,
                                                                                                    rowIdx,
                                                                                                    colIdx: cIdx,
                                                                                                    query: ''
                                                                                                })}
                                                                                                onChange={(e) => setFzdndAutocomplete({
                                                                                                    zoneId: zone.id,
                                                                                                    rowIdx,
                                                                                                    colIdx: cIdx,
                                                                                                    query: e.target.value.toUpperCase()
                                                                                                })}
                                                                                                onKeyDown={(e) => {
                                                                                                    if (e.key === 'Enter' && query.trim()) {
                                                                                                        if (filteredPlays.length > 0) {
                                                                                                            assignPlayToFZDnDCell(zone.id, rowIdx, cIdx, filteredPlays[0].id);
                                                                                                        } else {
                                                                                                            createFZDnDPlay(query, zone.id, rowIdx, cIdx);
                                                                                                        }
                                                                                                    } else if (e.key === 'Escape') {
                                                                                                        setFzdndAutocomplete({ zoneId: null, rowIdx: null, colIdx: null, query: '' });
                                                                                                    }
                                                                                                }}
                                                                                                onBlur={() => {
                                                                                                    setTimeout(() => {
                                                                                                        setFzdndAutocomplete({ zoneId: null, rowIdx: null, colIdx: null, query: '' });
                                                                                                    }, 200);
                                                                                                }}
                                                                                                style={{
                                                                                                    width: '100%',
                                                                                                    fontSize: '0.8rem',
                                                                                                    padding: '4px 6px',
                                                                                                    border: isFocused ? '1px solid #3b82f6' : '1px solid #e2e8f0',
                                                                                                    borderRadius: '4px',
                                                                                                    outline: 'none',
                                                                                                    background: 'white',
                                                                                                    color: '#1f2937',
                                                                                                    cursor: isLocked ? 'not-allowed' : 'text'
                                                                                                }}
                                                                                            />

                                                                                            {/* AUTOCOMPLETE DROPDOWN */}
                                                                                            {isFocused && (filteredPlays.length > 0 || showCreateOption) && (
                                                                                                <div style={{
                                                                                                    position: 'absolute',
                                                                                                    top: '100%',
                                                                                                    left: 0,
                                                                                                    right: 0,
                                                                                                    background: 'white',
                                                                                                    border: '1px solid #cbd5e1',
                                                                                                    borderRadius: '4px',
                                                                                                    boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
                                                                                                    maxHeight: '200px',
                                                                                                    overflowY: 'auto',
                                                                                                    zIndex: 1000,
                                                                                                    marginTop: '2px'
                                                                                                }}>
                                                                                                    {filteredPlays.map(p => (
                                                                                                        <div
                                                                                                            key={p.id}
                                                                                                            onMouseDown={(e) => {
                                                                                                                e.preventDefault();
                                                                                                                assignPlayToFZDnDCell(zone.id, rowIdx, cIdx, p.id);
                                                                                                            }}
                                                                                                            style={{
                                                                                                                padding: '6px 8px',
                                                                                                                cursor: 'pointer',
                                                                                                                fontSize: '0.8rem',
                                                                                                                borderBottom: '1px solid #f1f5f9',
                                                                                                                background: 'white',
                                                                                                                color: '#1f2937',
                                                                                                                ':hover': { background: '#f8fafc' }
                                                                                                            }}
                                                                                                            onMouseEnter={(e) => e.currentTarget.style.background = '#f8fafc'}
                                                                                                            onMouseLeave={(e) => e.currentTarget.style.background = 'white'}
                                                                                                        >
                                                                                                            {p.name}
                                                                                                        </div>
                                                                                                    ))}
                                                                                                    {showCreateOption && (
                                                                                                        <div
                                                                                                            onMouseDown={(e) => {
                                                                                                                e.preventDefault();
                                                                                                                createFZDnDPlay(query, zone.id, rowIdx, cIdx);
                                                                                                            }}
                                                                                                            style={{
                                                                                                                padding: '6px 8px',
                                                                                                                cursor: 'pointer',
                                                                                                                fontSize: '0.8rem',
                                                                                                                background: '#eff6ff',
                                                                                                                color: '#1e40af',
                                                                                                                fontWeight: '600',
                                                                                                                fontStyle: 'italic'
                                                                                                            }}
                                                                                                            onMouseEnter={(e) => e.currentTarget.style.background = '#dbeafe'}
                                                                                                            onMouseLeave={(e) => e.currentTarget.style.background = '#eff6ff'}
                                                                                                        >
                                                                                                            + Create "{query}"
                                                                                                        </div>
                                                                                                    )}
                                                                                                </div>
                                                                                            )}
                                                                                        </div>
                                                                                    );
                                                                                })()
                                                                            )}
                                                                        </div>
                                                                    );
                                                                })}
                                                            </div>
                                                        );
                                                    })}
                                                </>
                                            )}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                );
            };

            const renderSheetView = () => {
                return (
                    <div className="animate-fade-in" style={{ height: '100%', overflowY: 'auto', padding: '1rem' }}>

                        {/* Edit Toolbar */}
                        <div style={{ display: 'flex', justifyContent: 'flex-end', marginBottom: '1rem' }}>
                            {!isLocked && (
                                <button
                                    onClick={() => setIsSheetEditing(!isSheetEditing)}
                                    style={{
                                        padding: '6px 12px',
                                        borderRadius: '6px',
                                        fontSize: '0.85rem',
                                        fontWeight: '600',
                                        cursor: 'pointer',
                                        backgroundColor: isSheetEditing ? '#2563eb' : 'white',
                                        color: isSheetEditing ? 'white' : '#0f172a',
                                        border: isSheetEditing ? '1px solid #2563eb' : '1px solid #94a3b8',
                                        boxShadow: '0 1px 2px 0 rgba(0, 0, 0, 0.05)'
                                    }}
                                >
                                    {isSheetEditing ? 'Done Editing' : 'Edit Layout'}
                                </button>
                            )}
                        </div>

                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(7, 1fr)', gap: '1rem', alignItems: 'start' }}>
                            {(gamePlanLayouts?.CALL_SHEET?.sections || []).map((section, sIdx) => {
                                // Show all boxes in edit mode
                                const visibleBoxes = isSheetEditing ? (section.boxes || []) : (section.boxes || []).filter(b => !b.hidden);
                                if (!isSheetEditing && visibleBoxes.length === 0) return null;

                                return (
                                    <div
                                        key={sIdx}
                                        className="call-sheet-section"
                                        style={{ gridColumn: '1 / -1', breakInside: 'avoid', marginBottom: '0.5rem', border: isSheetEditing ? '1px dashed #3b82f6' : '1px solid #cbd5e1', borderRadius: '4px', overflow: 'hidden', background: 'white', display: 'flex', flexDirection: 'column' }}
                                        onDragOver={handleSheetSectionDragOver}
                                        onDrop={(e) => handleSheetSectionDrop(e, sIdx)}
                                    >
                                        <div style={{
                                            background: '#f1f5f9', padding: '0.5rem', fontWeight: 'bold',
                                            borderBottom: '1px solid #cbd5e1', textTransform: 'uppercase', fontSize: '0.8rem',
                                            color: '#334155', display: 'flex', justifyContent: 'space-between', alignItems: 'center'
                                        }}>
                                            {isSheetEditing ? (
                                                <div style={{ display: 'flex', gap: '8px', flex: 1, alignItems: 'center' }}>
                                                    <input
                                                        value={section.title}
                                                        onChange={(e) => handleUpdateSheetSection(sIdx, { ...section, title: e.target.value })}
                                                        style={{ flex: 1, padding: '2px 4px', fontSize: '0.8rem', fontWeight: 'bold' }}
                                                    />
                                                    <button
                                                        className="btn-sm"
                                                        onClick={() => handleUpdateSheetSection(sIdx, { ...section, expandToFill: !section.expandToFill })}
                                                        style={{
                                                            background: section.expandToFill ? 'var(--accent)' : '#e2e8f0',
                                                            color: section.expandToFill ? 'white' : '#64748b',
                                                            fontSize: '0.7rem',
                                                            padding: '4px 8px',
                                                            whiteSpace: 'nowrap'
                                                        }}
                                                        title={section.expandToFill ? 'Return to fixed width layout' : 'Expand boxes to fill row equally'}
                                                    >
                                                        {section.expandToFill ? '📏 Fixed Width' : '↔️ Expand to Fill'}
                                                    </button>
                                                    <button className="btn-sm" style={{ color: '#ef4444' }} onClick={() => handleDeleteSheetSection(sIdx)}>
                                                        <Icon name="Trash2" size={14} />
                                                    </button>
                                                </div>
                                            ) : (
                                                <span>{section.title}</span>
                                            )}
                                        </div>
                                        <div style={{
                                            display: 'flex', flexDirection: 'column',
                                            borderTop: '0',
                                            padding: isSheetEditing ? '4px' : '0'
                                        }}>
                                            {(() => {
                                                // 1. Group boxes into rows based on Grid Logic (7 cols)
                                                const rows = [];
                                                let currentRow = [];
                                                let currentSpan = 0;

                                                visibleBoxes.forEach((box, bIdx) => {
                                                    const span = Number(box.colSpan) > 1 ? Number(box.colSpan) : (box.type === 'grid' ? 5 : 2);

                                                    if (currentSpan + span > 7 && currentRow.length > 0) {
                                                        // Push previous row
                                                        rows.push(currentRow);
                                                        // Start new row
                                                        currentRow = [];
                                                        currentSpan = 0;
                                                    }

                                                    currentRow.push({ box, originalIndex: bIdx, span });
                                                    currentSpan += span;
                                                });

                                                if (currentRow.length > 0) {
                                                    rows.push(currentRow);
                                                }

                                                // 2. Render each row
                                                return rows.map((rowBoxes, rIdx) => (
                                                    <div key={rIdx} style={{
                                                        display: section.expandToFill ? 'flex' : 'grid',
                                                        gridTemplateColumns: section.expandToFill ? undefined : 'repeat(7, 1fr)',
                                                        width: '100%',
                                                        gap: isSheetEditing ? '4px' : '0',
                                                        marginBottom: isSheetEditing ? '4px' : '0'
                                                    }}>
                                                        {rowBoxes.map(({ box, originalIndex: bIdx, span }, i) => {
                                                            // Calculate isFirstInRow for legacy badge logic (simplified)
                                                            const isFirstInRow = i === 0;
                                                            const currentBoxRowNumber = rIdx + 1; // 1-based row number


                                                            const renderBoxContent = () => {
                                                                if (box.type === 'grid') {
                                                                    const cols = box.gridColumns || 4;
                                                                    const rowsCount = box.gridRows || 5;
                                                                    const totalSlots = cols * rowsCount;

                                                                    const gridPlays = (getGridPlays(box.setId, totalSlots, box.assignedPlayIds) || []);
                                                                    const headings = box.gridHeadings || Array(cols).fill('').map((_, i) => i === 0 ? 'LEFT HASH' : (i === cols - 1 ? 'NOTES' : `COL ${i + 1}`));

                                                                    const rows = [];
                                                                    for (let i = 0; i < gridPlays.length; i += cols) {
                                                                        rows.push(gridPlays.slice(i, i + cols));
                                                                    }

                                                                    // Helper: Check if a grid row is empty (all cells are empty or dashes)
                                                                    const isGridRowEmpty = (rowSlots) => {
                                                                        return rowSlots.every(slot => {
                                                                            if (slot.type === 'GAP') return true;
                                                                            const play = plays.find(p => p.id === slot.id);
                                                                            return !play || !play.name || play.name === '-' || play.name.trim() === '';
                                                                        });
                                                                    };

                                                                    // Helper: Check if entire grid has no filled rows
                                                                    const isGridEmpty = (rows) => {
                                                                        return rows.every(rowSlots => isGridRowEmpty(rowSlots));
                                                                    };

                                                                    // Skip rendering completely empty grids (unless in edit mode)
                                                                    if (!isSheetEditing && isGridEmpty(rows)) {
                                                                        return null;
                                                                    }

                                                                    return (
                                                                        <div style={{ display: 'grid', gridTemplateColumns: `min-content repeat(${cols}, 1fr)`, gap: '0', width: '100%' }}>
                                                                            {/* Header Row */}
                                                                            <div style={{ padding: '2px', fontSize: '0.55rem', fontWeight: 'bold', color: '#94a3b8', textAlign: 'center', alignSelf: 'end' }}>
                                                                                {box.cornerLabel || '#'}
                                                                            </div>
                                                                            {headings.slice(0, cols).map((h, i) => (
                                                                                <div key={`h-${i}`} style={{
                                                                                    padding: '2px', fontSize: '0.55rem', fontWeight: 'bold', color: '#64748b', textAlign: 'center',
                                                                                    background: '#f1f5f9', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis',
                                                                                    borderRight: i < cols - 1 ? '1px solid #cbd5e1' : 'none',
                                                                                    borderBottom: '1px solid #cbd5e1'
                                                                                }}>
                                                                                    {h}
                                                                                </div>
                                                                            ))}

                                                                            {/* Data Rows */}
                                                                            {rows.map((rowSlots, rIdx) => {
                                                                                const isEmpty = isGridRowEmpty(rowSlots);
                                                                                return (
                                                                                    <React.Fragment key={rIdx}>
                                                                                        <div className={isEmpty ? 'hidden-row' : ''} style={{
                                                                                            padding: '2px', fontSize: '0.6rem', color: '#94a3b8', textAlign: 'right', fontWeight: 'bold',
                                                                                            display: 'flex', alignItems: 'center', justifyContent: 'flex-end', minWidth: '15px',
                                                                                            borderBottom: '1px dotted #f1f5f9'
                                                                                        }}>
                                                                                            {(box.gridRowLabels && box.gridRowLabels[rIdx]) || (rIdx + 1)}
                                                                                        </div>
                                                                                        {rowSlots.map((slot, cIdx) => {
                                                                                            const play = plays.find(p => p.id === slot.id);
                                                                                            return (
                                                                                                <div key={cIdx} className={isEmpty ? 'hidden-row' : ''} style={{
                                                                                                    fontSize: '0.65rem', overflow: 'hidden', whiteSpace: 'nowrap', textOverflow: 'ellipsis',
                                                                                                    background: play?.priority ? '#fef08a' : (slot.type === 'GAP' ? 'transparent' : '#f8fafc'),
                                                                                                    padding: '2px', minHeight: '16px', color: '#334155',
                                                                                                    display: 'flex', alignItems: 'center',
                                                                                                    borderRight: cIdx < cols - 1 ? '1px solid #e2e8f0' : 'none',
                                                                                                    borderBottom: '1px dotted #e2e8f0'
                                                                                                }} title={play ? play.name : ''}>
                                                                                                    {play ? (
                                                                                                        <>
                                                                                                            {getWristbandLabel(play) && <span style={{ marginRight: '3px', fontSize: '0.9em', fontWeight: 'bold', color: '#3b82f6' }}>{getWristbandLabel(play)}</span>}
                                                                                                            {getPlayDisplayName(play)}
                                                                                                        </>
                                                                                                    ) : (slot.type === 'GAP' ? '' : '-')}
                                                                                                </div>
                                                                                            );
                                                                                        })}
                                                                                    </React.Fragment>
                                                                                );
                                                                            })}
                                                                        </div>
                                                                    );
                                                                }
                                                                if (box.type === 'script' && box.rows && box.rows.length > 0) {
                                                                    return (
                                                                        <div style={{ display: 'grid', gridTemplateColumns: 'minmax(0, 1fr) minmax(0, 1fr)', columnGap: '0', rowGap: '0' }}>
                                                                            {box.rows.map((row, rIdx) => {
                                                                                const playLeft = plays.find(p => p.id === row.content);
                                                                                const playRight = plays.find(p => p.id === row.contentRight);
                                                                                return [
                                                                                    <div key={`${rIdx}-L`} style={{
                                                                                        display: 'flex', gap: '4px', alignItems: 'baseline', lineHeight: '1.2',
                                                                                        borderBottom: '1px dotted #f1f5f9', overflow: 'hidden',
                                                                                        borderRight: '1px solid #e2e8f0', paddingRight: '4px',
                                                                                        background: playLeft?.priority ? '#fef08a' : 'transparent'
                                                                                    }}>
                                                                                        <span style={{ color: '#64748b', width: '20px', textAlign: 'right', flexShrink: 0, fontWeight: 'bold' }}>{row.label || rIdx + 1}</span>
                                                                                        {playLeft ? (
                                                                                            <span style={{ fontWeight: '600', color: '#1e293b', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>
                                                                                                {playLeft.name}
                                                                                                {getWristbandLabel(playLeft) && <span style={{ marginLeft: '4px', fontSize: '0.7em', color: '#3b82f6' }}>{getWristbandLabel(playLeft)}</span>}
                                                                                            </span>
                                                                                        ) : (
                                                                                            <span style={{ color: '#cbd5e1', fontStyle: 'italic' }}>-</span>
                                                                                        )}
                                                                                    </div>,
                                                                                    <div key={`${rIdx}-R`} style={{
                                                                                        display: 'flex', gap: '4px', alignItems: 'baseline', lineHeight: '1.2',
                                                                                        borderBottom: '1px dotted #f1f5f9', overflow: 'hidden',
                                                                                        paddingLeft: '4px',
                                                                                        background: playRight?.priority ? '#fef08a' : 'transparent'
                                                                                    }}>
                                                                                        {playRight ? (
                                                                                            <span style={{ fontWeight: '600', color: '#1e293b', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>
                                                                                                {playRight.name}
                                                                                                {getWristbandLabel(playRight) && <span style={{ marginLeft: '4px', fontSize: '0.7em', color: '#3b82f6' }}>{getWristbandLabel(playRight)}</span>}
                                                                                            </span>
                                                                                        ) : (
                                                                                            <span style={{ color: '#cbd5e1', fontStyle: 'italic' }}>+</span>
                                                                                        )}
                                                                                    </div>
                                                                                ];
                                                                            })}
                                                                        </div>
                                                                    );
                                                                }
                                                                const playsInBox = getPlaysForSet(box.setId);
                                                                if (playsInBox.length === 0) {
                                                                    return <div style={{ color: '#cbd5e1', fontStyle: 'italic', paddingTop: '4px' }}>Empty</div>;
                                                                }
                                                                return (
                                                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '3px' }}>
                                                                        {playsInBox.map((p, pIdx) => (
                                                                            <div key={pIdx} style={{ display: 'flex', gap: '4px', alignItems: 'baseline', lineHeight: '1.2', background: p.priority ? '#fef08a' : 'transparent' }}>
                                                                                <span style={{ color: '#94a3b8', width: '14px', textAlign: 'right', flexShrink: 0 }}>{pIdx + 1}.</span>
                                                                                <span style={{ fontWeight: '600', color: '#1e293b' }}>{p.name}</span>
                                                                                {p.formation && <span style={{ color: '#64748b', fontSize: '0.65rem' }}>({p.formation})</span>}
                                                                            </div>
                                                                        ))}
                                                                    </div>
                                                                );
                                                            };
                                                            const playsInBox = getPlaysForSet(box.setId);

                                                            return (
                                                                <div
                                                                    key={bIdx}
                                                                    draggable={isSheetEditing}
                                                                    onDragStart={(e) => {
                                                                        if (!isSheetEditing) return;
                                                                        setDraggedCell({ sectionIdx: sIdx, boxIdx: bIdx });
                                                                        e.dataTransfer.effectAllowed = 'move';
                                                                        e.stopPropagation();
                                                                    }}
                                                                    onDragOver={(e) => {
                                                                        if (!isSheetEditing) return;
                                                                        e.preventDefault();
                                                                        e.dataTransfer.dropEffect = 'move';
                                                                    }}
                                                                    onDrop={(e) => handleSheetBoxDrop(e, sIdx, bIdx)}
                                                                    style={{
                                                                        flexGrow: section.expandToFill ? span : 0,
                                                                        flexBasis: section.expandToFill ? '0' : undefined,
                                                                        minWidth: section.expandToFill ? '125px' : undefined,
                                                                        gridColumn: section.expandToFill ? 'auto' : `span ${span}`,
                                                                        borderBottom: !isSheetEditing && Math.floor(bIdx / 2) < Math.ceil(visibleBoxes.length / 2) - 1 ? '1px solid #cbd5e1' : 'none',
                                                                        borderRight: !isSheetEditing && bIdx % 2 === 0 ? '1px solid #cbd5e1' : 'none',
                                                                        border: isSheetEditing ? '1px solid #e2e8f0' : undefined,
                                                                        background: 'white',
                                                                        minHeight: '120px',
                                                                        cursor: isSheetEditing ? 'grab' : 'pointer',
                                                                        display: 'flex', flexDirection: 'column',
                                                                        opacity: (draggedCell?.sectionIdx === sIdx && draggedCell?.boxIdx === bIdx) ? 0.5 : 1
                                                                    }}
                                                                    onClick={() => {
                                                                        if (!isSheetEditing) setEditingBox({ box, sectionIdx: sIdx, boxIdx: bIdx });
                                                                    }}
                                                                >
                                                                    {/* Sheet Box Header */}
                                                                    <div style={{
                                                                        padding: '4px 8px',
                                                                        background: box.color || '#3b82f6',
                                                                        color: 'white',
                                                                        fontSize: '0.75rem',
                                                                        fontWeight: 'bold',
                                                                        display: 'flex', justifyContent: 'space-between', alignItems: 'center'
                                                                    }}>
                                                                        <span style={{ whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>{box.header}</span>
                                                                        {isSheetEditing ? (
                                                                            <div
                                                                                onClick={(e) => { e.stopPropagation(); handleDeleteSheetBox(sIdx, bIdx); }}
                                                                                style={{ cursor: 'pointer', padding: '0 4px' }}
                                                                            >
                                                                                ×
                                                                            </div>
                                                                        ) : (
                                                                            <span style={{ fontSize: '0.7rem', opacity: 0.9, background: 'rgba(0,0,0,0.2)', padding: '0 4px', borderRadius: '4px' }}>{playsInBox.length}</span>
                                                                        )}
                                                                    </div>

                                                                    {/* Sheet Box Content */}
                                                                    <div style={{ padding: '6px', fontSize: '0.7rem', flex: 1 }}>
                                                                        {/* Row Expand Badge - only show on first box of each row */}
                                                                        {isFirstInRow && isSheetEditing && (
                                                                            <button
                                                                                className="btn-sm"
                                                                                onClick={(e) => {
                                                                                    e.stopPropagation();
                                                                                    const expandedRows = section.expandedRows || [];
                                                                                    const isExpanded = expandedRows.includes(currentBoxRowNumber);
                                                                                    const newExpandedRows = isExpanded
                                                                                        ? expandedRows.filter(r => r !== currentBoxRowNumber)
                                                                                        : [...expandedRows, currentBoxRowNumber];
                                                                                    handleUpdateSheetSection(sIdx, { ...section, expandedRows: newExpandedRows });
                                                                                }}
                                                                                style={{
                                                                                    position: 'absolute',
                                                                                    top: '2px',
                                                                                    left: '2px',
                                                                                    background: (section.expandedRows || []).includes(currentBoxRowNumber) ? 'var(--accent)' : '#e2e8f0',
                                                                                    color: (section.expandedRows || []).includes(currentBoxRowNumber) ? 'white' : '#64748b',
                                                                                    fontSize: '0.6rem',
                                                                                    padding: '2px 4px',
                                                                                    zIndex: 100,
                                                                                    borderRadius: '3px'
                                                                                }}
                                                                                title={(section.expandedRows || []).includes(currentBoxRowNumber) ? 'Fixed Width' : 'Expand Row'}
                                                                            >
                                                                                {(section.expandedRows || []).includes(currentBoxRowNumber) ? '📏' : '↔️'}
                                                                            </button>
                                                                        )}

                                                                        {/* Render Strategy: Script Rows vs Assigned Plays */}
                                                                        {renderBoxContent()}
                                                                    </div>
                                                                </div>
                                                            );
                                                        })}
                                                    </div>
                                                ))
                                            })()}
                                            {isSheetEditing && (
                                                <div
                                                    style={{
                                                        border: '2px dashed #e2e8f0', borderRadius: '4px', minHeight: '120px',
                                                        display: 'flex', alignItems: 'center', justifyContent: 'center',
                                                        cursor: 'pointer', color: '#64748b', fontWeight: '500', background: '#f8fafc'
                                                    }}
                                                    onClick={() => handleAddSheetBox(sIdx)}
                                                >
                                                    + Add Box
                                                </div>
                                            )}
                                        </div>
                                    </div >
                                );
                            })
                            }

                            {
                                isSheetEditing && (
                                    <button
                                        style={{
                                            border: '2px dashed #cbd5e1',
                                            height: '80px',
                                            width: '100%',
                                            gridColumn: '1 / -1',
                                            background: '#f1f5f9',
                                            color: '#475569',
                                            fontWeight: '600',
                                            borderRadius: '8px',
                                            cursor: 'pointer',
                                            fontSize: '0.9rem',
                                            display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px'
                                        }}
                                        onClick={handleAddSheetSection}
                                    >
                                        <span style={{ fontSize: '1.2rem' }}>+</span> Add New Section
                                    </button>
                                )
                            }
                        </div >
                    </div >
                );
            };

            const renderMatrix = () => {
                const layout = GAME_PLAN_LAYOUTS.MATRIX;

                // Group columns by pitch type
                const columnGroups = [
                    { id: 'FB', label: 'BASE/INITIAL', cols: layout.cols.slice(0, 2) },
                    { id: 'CB', label: 'BASE W/ DRESSING', cols: layout.cols.slice(2, 4) },
                    { id: 'CU', label: 'CONVERT', cols: layout.cols.slice(4, 6) },
                    { id: 'SO', label: 'EXPLOSIVE', cols: layout.cols.slice(6, 8) }
                ];

                const toggleGroup = (groupId) => {
                    setCollapsedGroups(prev => {
                        const newCollapsed = new Set(prev);
                        if (newCollapsed.has(groupId)) {
                            newCollapsed.delete(groupId);
                        } else {
                            newCollapsed.add(groupId);
                        }
                        return newCollapsed;
                    });
                };

                return (
                    <div className="animate-fade-in" style={{ height: '100%', overflowX: 'auto', overflowY: 'auto' }}>
                        <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '0.75rem' }}>
                            <thead>
                                <tr>
                                    <th rowSpan={2} style={{ padding: '0.5rem', border: '1px solid var(--border)', width: '120px', position: 'sticky', left: 0, top: 0, backgroundColor: 'white', zIndex: 20 }}>Formation / Type</th>
                                    {columnGroups.map(group => {
                                        const isCollapsed = collapsedGroups.has(group.id);
                                        return (
                                            <React.Fragment key={group.id}>
                                                {isCollapsed ? (
                                                    <th
                                                        rowSpan={2}
                                                        style={{ padding: '0.5rem', border: '1px solid var(--border)', backgroundColor: '#334155', color: 'white', cursor: 'pointer', minWidth: '60px', top: 0, position: 'sticky', zIndex: 10 }}
                                                        onClick={() => toggleGroup(group.id)}
                                                        title={`Click to expand ${group.label}`}
                                                    >
                                                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '0.25rem' }}>
                                                            <span>▶</span>
                                                            <span style={{ writingMode: 'vertical-rl', transform: 'rotate(180deg)' }}>{group.label}</span>
                                                        </div>
                                                    </th>
                                                ) : (
                                                    <th
                                                        colSpan={2}
                                                        style={{
                                                            padding: '0.5rem',
                                                            border: '1px solid var(--border)',
                                                            backgroundColor: '#334155',
                                                            color: 'white',
                                                            cursor: 'pointer',
                                                            textAlign: 'center',
                                                            top: 0,
                                                            position: 'sticky',
                                                            zIndex: 10
                                                        }}
                                                        onClick={() => toggleGroup(group.id)}
                                                        title={`Click to collapse ${group.label}`}
                                                    >
                                                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', justifyContent: 'center' }}>
                                                            <span style={{ fontSize: '0.7rem' }}>▼</span>
                                                            <span>{group.label}</span>
                                                        </div>
                                                    </th>
                                                )}
                                            </React.Fragment>
                                        );
                                    })}
                                </tr>
                                <tr>
                                    {columnGroups.map(group => {
                                        if (collapsedGroups.has(group.id)) return null;
                                        const leftHashCollapsed = collapsedHashColumns.has(`${group.id}_LEFT`);
                                        const rightHashCollapsed = collapsedHashColumns.has(`${group.id}_RIGHT`);
                                        return (
                                            <React.Fragment key={group.id + '_sub'}>
                                                {!leftHashCollapsed && (
                                                    <th
                                                        style={{
                                                            padding: '0.25rem',
                                                            border: '1px solid var(--border)',
                                                            backgroundColor: '#475569',
                                                            color: 'white',
                                                            fontSize: '0.7rem',
                                                            textAlign: 'center',
                                                            top: '35px',
                                                            position: 'sticky',
                                                            zIndex: 10,
                                                            cursor: 'pointer'
                                                        }}
                                                        onClick={() => toggleHashColumn(group.id, 'LEFT')}
                                                        title="Click to collapse LEFT HASH"
                                                    >
                                                        ◀ LEFT HASH
                                                    </th>
                                                )}
                                                {leftHashCollapsed && (
                                                    <th
                                                        style={{
                                                            padding: '0.25rem',
                                                            border: '1px solid var(--border)',
                                                            backgroundColor: '#64748b',
                                                            color: 'white',
                                                            fontSize: '0.7rem',
                                                            textAlign: 'center',
                                                            top: '35px',
                                                            position: 'sticky',
                                                            zIndex: 10,
                                                            cursor: 'pointer',
                                                            width: '20px'
                                                        }}
                                                        onClick={() => toggleHashColumn(group.id, 'LEFT')}
                                                        title="Click to expand LEFT HASH"
                                                    >
                                                        ▶
                                                    </th>
                                                )}
                                                {!rightHashCollapsed && (
                                                    <th
                                                        style={{
                                                            padding: '0.25rem',
                                                            border: '1px solid var(--border)',
                                                            backgroundColor: '#475569',
                                                            color: 'white',
                                                            fontSize: '0.7rem',
                                                            textAlign: 'center',
                                                            top: '35px',
                                                            position: 'sticky',
                                                            zIndex: 10,
                                                            cursor: 'pointer'
                                                        }}
                                                        onClick={() => toggleHashColumn(group.id, 'RIGHT')}
                                                        title="Click to collapse RIGHT HASH"
                                                    >
                                                        RIGHT HASH ▶
                                                    </th>
                                                )}
                                                {rightHashCollapsed && (
                                                    <th
                                                        style={{
                                                            padding: '0.25rem',
                                                            border: '1px solid var(--border)',
                                                            backgroundColor: '#64748b',
                                                            color: 'white',
                                                            fontSize: '0.7rem',
                                                            textAlign: 'center',
                                                            top: '35px',
                                                            position: 'sticky',
                                                            zIndex: 10,
                                                            cursor: 'pointer',
                                                            width: '20px'
                                                        }}
                                                        onClick={() => toggleHashColumn(group.id, 'RIGHT')}
                                                        title="Click to expand RIGHT HASH"
                                                    >
                                                        ◀
                                                    </th>
                                                )}
                                            </React.Fragment>
                                        );
                                    })}
                                </tr>
                            </thead>
                            <tbody>
                                {layout.formations.map(formation => (
                                    <React.Fragment key={formation.id}>
                                        {/* Formation Header Row */}
                                        <tr>
                                            <td
                                                colSpan={columnGroups.reduce((acc, g) => {
                                                    if (collapsedGroups.has(g.id)) return acc + 1;
                                                    // Always count 2 columns per group (visible + collapsed)
                                                    return acc + 2;
                                                }, 1)}
                                                style={{ padding: '2px 4px', border: '1px solid var(--border)', fontWeight: 'bold', backgroundColor: formation.color, color: 'white', fontSize: '0.8rem', lineHeight: '1.1', cursor: 'pointer' }}
                                                onClick={() => setEditingFormationId(formation.id)}
                                            >
                                                {editingFormationId === formation.id ? (
                                                    <input
                                                        autoFocus
                                                        defaultValue={(gamePlan?.formationOverrides || {})[formation.id] || formation.label}
                                                        style={{ background: 'white', color: 'black', border: 'none', padding: '2px 4px', borderRadius: '2px', width: '200px' }}
                                                        onBlur={(e) => handleUpdateFormationName(formation.id, e.target.value)}
                                                        onKeyDown={(e) => {
                                                            if (e.key === 'Enter') handleUpdateFormationName(formation.id, e.target.currentTarget.value);
                                                        }}
                                                        onClick={(e) => e.stopPropagation()}
                                                    />
                                                ) : (
                                                    (gamePlan?.formationOverrides || {})[formation.id] || formation.label
                                                )}
                                            </td>
                                        </tr>
                                        {/* Play Type Rows */}
                                        {layout.playTypes.map(playType => {
                                            const isRowCollapsed = collapsedRows.has(playType.id);
                                            const totalColSpan = columnGroups.reduce((acc, g) => {
                                                if (collapsedGroups.has(g.id)) return acc + 1;
                                                // Always count full columns (2)
                                                return acc + g.cols.length;
                                            }, 1);

                                            if (isRowCollapsed) {
                                                return (
                                                    <tr key={`${formation.id}_${playType.id}`}>
                                                        <td
                                                            colSpan={totalColSpan}
                                                            style={{
                                                                padding: '0.5rem',
                                                                border: '1px solid var(--border)',
                                                                fontWeight: '500',
                                                                backgroundColor: '#eff6ff',
                                                                cursor: 'pointer',
                                                                color: '#1e3a8a',
                                                                fontSize: '0.8rem',
                                                                fontStyle: 'italic'
                                                            }}
                                                            onClick={() => toggleRow(playType.id)}
                                                        >
                                                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                                <span style={{ fontSize: '0.7rem' }}>▶</span>
                                                                <span>{playType.label} (Collapsed)</span>
                                                            </div>
                                                        </td>
                                                    </tr>
                                                );
                                            }

                                            return (
                                                <tr key={`${formation.id}_${playType.id}`}>
                                                    <td
                                                        style={{
                                                            padding: '2px 4px',
                                                            border: '1px solid var(--border)',
                                                            fontWeight: 'bold',
                                                            backgroundColor: '#dbeafe',
                                                            position: 'sticky',
                                                            left: 0,
                                                            zIndex: 5,
                                                            cursor: 'pointer',
                                                            color: '#1e40af',
                                                            fontSize: '0.75rem',
                                                            lineHeight: '1.1'
                                                        }}
                                                        onClick={() => toggleRow(playType.id)}
                                                        title="Click to collapse row"
                                                    >
                                                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                            <span style={{ fontSize: '0.7rem' }}>▼</span>
                                                            {playType.label}
                                                        </div>
                                                    </td>
                                                    {columnGroups.map(group => {
                                                        const isCollapsed = collapsedGroups.has(group.id);
                                                        const leftHashCollapsed = collapsedHashColumns.has(`${group.id}_LEFT`);
                                                        const rightHashCollapsed = collapsedHashColumns.has(`${group.id}_RIGHT`);

                                                        if (isCollapsed) {
                                                            // Show collapsed placeholder
                                                            return (
                                                                <td
                                                                    key={group.id}
                                                                    style={{ padding: '0.25rem', border: '1px solid var(--border)', backgroundColor: '#e5e7eb', textAlign: 'center' }}
                                                                >
                                                                    <span style={{ fontSize: '0.7rem', color: '#6b7280' }}>•••</span>
                                                                </td>
                                                            );
                                                        } else {
                                                            // Show expanded columns
                                                            return group.cols.map(col => {
                                                                const commonStyle = { padding: '0', border: '1px solid #e2e8f0', verticalAlign: 'middle', backgroundColor: '#f8fafc', width: '20px' };

                                                                // Show placeholder for collapsed LEFT HASH
                                                                if (col.id === 'LEFT' && leftHashCollapsed) {
                                                                    return <td key={`matrix_${formation.id}_${playType.id}_${col.id}_collapsed`} style={commonStyle}></td>;
                                                                }
                                                                // Show placeholder for collapsed RIGHT HASH
                                                                if (col.id === 'RIGHT' && rightHashCollapsed) {
                                                                    return <td key={`matrix_${formation.id}_${playType.id}_${col.id}_collapsed`} style={commonStyle}></td>;
                                                                }

                                                                const setId = `matrix_${formation.id}_${playType.id}_${col.id}`;
                                                                return (
                                                                    <td
                                                                        key={setId}
                                                                        style={{ padding: '0', border: '1px solid #ddd', verticalAlign: 'top', cursor: 'default', backgroundColor: 'white', lineHeight: '1' }}
                                                                    >
                                                                        {renderPlayListSimple(setId)}
                                                                        {onQuickAddPlay && (
                                                                            <GridPlayInput
                                                                                setId={setId}
                                                                                onSelectPlay={(playId) => handleAddPlayToSet(setId, playId)}
                                                                                onQuickAdd={(name) => handleQuickAddToSet(setId, name)}
                                                                            />
                                                                        )}
                                                                    </td>
                                                                );
                                                            });
                                                        }
                                                    })}
                                                </tr>
                                            );
                                        })}
                                    </React.Fragment>
                                ))}
                            </tbody>
                        </table>
                    </div>
                );
            };

            const handleConfigureSection = (sectionIdx, type) => {
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                const section = { ...sheet.sections[sectionIdx] };

                section.type = type;

                // Initialize defaults based on type
                if (type === 'script') {
                    // Script gets 1 column
                    section.cols = 1;
                    // Ensure rows exist
                    if (!section.rows) section.rows = [];
                } else if (type === 'grid') {
                    // Grid Section defaults
                    if (!section.gridHeadings) section.gridHeadings = ['LEFT HASH', 'MIDDLE', 'RIGHT HASH', 'NOTES'];
                    if (!section.rowLabels) section.rowLabels = ['Group 1', 'Group 2', 'Group 3', 'Group 4', 'Group 5'];
                } else if (type === 'field_position') {
                    // Field Position defaults -> Treat as Grid Section for now as per user request for "Strike Em Out" grid
                    if (!section.gridHeadings) section.gridHeadings = ['LEFT HASH', 'MIDDLE', 'RIGHT HASH', 'NOTES'];
                    if (!section.rowLabels) section.rowLabels = ['Group 1', 'Group 2', 'Group 3', 'Group 4', 'Group 5'];
                    section.type = 'grid'; // Force to grid type internally to reuse logic
                } else if (type === 'standard') {
                } else if (type === 'standard') {
                    // Standard defaults (Spreadsheet)
                    section.cols = 1; // It renders as a list
                    if (!section.rows) section.rows = [];
                }

                sheet.sections[sectionIdx] = section;
                newLayouts.CALL_SHEET = sheet;

                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                setConfiguringSection(null);
            };

            const renderSectionConfigurationModal = () => {
                if (!configuringSection) return null;
                const sectionIdx = configuringSection.idx;
                const section = gamePlanLayouts.CALL_SHEET.sections[sectionIdx];
                if (!section) return null; // Safety check

                return (
                    <div className="modal-overlay" onClick={() => setConfiguringSection(null)} style={{ zIndex: 2000 }}>
                        <div className="modal-content" onClick={e => e.stopPropagation()} style={{ width: '500px' }}>
                            <div className="modal-header">
                                <h3>Configure Box Type</h3>
                                <button className="modal-close" onClick={() => setConfiguringSection(null)}>×</button>
                            </div>
                            <div className="modal-body">
                                <p style={{ marginBottom: '1rem', color: '#666' }}>Select a layout type for "{section.title}":</p>

                                <div style={{ display: 'grid', gap: '1rem' }}>
                                    {/* Script Menu */}
                                    <div
                                        onClick={() => handleConfigureSection(sectionIdx, 'script')}
                                        style={{
                                            border: '1px solid #ddd', borderRadius: '8px', padding: '1rem', cursor: 'pointer',
                                            display: 'flex', gap: '1rem', alignItems: 'center',
                                            background: '#f8fafc', transition: 'all 0.2s'
                                        }}
                                        onMouseEnter={e => e.currentTarget.style.borderColor = 'var(--primary)'}
                                        onMouseLeave={e => e.currentTarget.style.borderColor = '#ddd'}
                                    >
                                        <div style={{ fontSize: '2rem' }}>📜</div>
                                        <div>
                                            <div style={{ fontWeight: 'bold' }}>Script Menu</div>
                                            <div style={{ fontSize: '0.8rem', color: '#666' }}>Vertical list with editable tempo indicators.</div>
                                        </div>
                                    </div>

                                    {/* Field Position Menu */}
                                    <div
                                        onClick={() => handleConfigureSection(sectionIdx, 'field_position')}
                                        style={{
                                            border: '1px solid #ddd', borderRadius: '8px', padding: '1rem', cursor: 'pointer',
                                            display: 'flex', gap: '1rem', alignItems: 'center',
                                            background: '#f8fafc', transition: 'all 0.2s'
                                        }}
                                        onMouseEnter={e => e.currentTarget.style.borderColor = 'var(--primary)'}
                                        onMouseLeave={e => e.currentTarget.style.borderColor = '#ddd'}
                                    >
                                        <div style={{ fontSize: '2rem' }}>🏟️</div>
                                        <div>
                                            <div style={{ fontWeight: 'bold' }}>Field Position Menu</div>
                                            <div style={{ fontSize: '0.8rem', color: '#666' }}>Strike 'Em Out style table with editable headers.</div>
                                        </div>
                                    </div>

                                    {/* Standard Menu */}
                                    <div
                                        onClick={() => handleConfigureSection(sectionIdx, 'standard')}
                                        style={{
                                            border: '1px solid #ddd', borderRadius: '8px', padding: '1rem', cursor: 'pointer',
                                            display: 'flex', gap: '1rem', alignItems: 'center',
                                            background: '#f8fafc', transition: 'all 0.2s'
                                        }}
                                        onMouseEnter={e => e.currentTarget.style.borderColor = 'var(--primary)'}
                                        onMouseLeave={e => e.currentTarget.style.borderColor = '#ddd'}
                                    >
                                        <div style={{ fontSize: '2rem' }}>📋</div>
                                        <div>
                                            <div style={{ fontWeight: 'bold' }}>Standard Menu</div>
                                            <div style={{ fontSize: '0.8rem', color: '#666' }}>Spreadsheet-style list with quick add support.</div>
                                        </div>
                                    </div>

                                    {/* Situational Menu (Grid) */}
                                    <div
                                        onClick={() => handleConfigureSection(sectionIdx, 'grid')}
                                        style={{
                                            border: '1px solid #ddd', borderRadius: '8px', padding: '1rem', cursor: 'pointer',
                                            display: 'flex', gap: '1rem', alignItems: 'center',
                                            background: '#f8fafc', transition: 'all 0.2s'
                                        }}
                                        onMouseEnter={e => e.currentTarget.style.borderColor = 'var(--primary)'}
                                        onMouseLeave={e => e.currentTarget.style.borderColor = '#ddd'}
                                    >
                                        <div style={{ fontSize: '2rem' }}>🔢</div>
                                        <div>
                                            <div style={{ fontWeight: 'bold' }}>Situational Menu</div>
                                            <div style={{ fontSize: '0.8rem', color: '#666' }}>Grid layout for holding Situational Boxes (e.g. 3rd Down).</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            };

            const renderPlaySelector = () => {

                if (!showPlaySelector) return null;

                // Find the box being edited
                let activeBox = null;
                gamePlanLayouts.CALL_SHEET.sections.forEach(section => {
                    const found = (section.boxes || []).find(b => b.setId === activeCellSetId);
                    if (found) activeBox = found;
                });

                const isGridMode = activeBox?.type === 'grid';
                const gridPlays = getGridPlays(activeCellSetId);

                // Split into Left (0-9) and Right (10-19) for normal mode
                const leftPlays = gridPlays.slice(0, 10); // Indices 0-9
                const rightPlays = gridPlays.slice(10, 20); // Indices 10-19

                // Slice for Grid mode (16 plays)
                const gridModePlays = gridPlays.slice(0, 16);
                const gridHeadings = activeBox?.gridHeadings || ['LEFT HASH', 'MIDDLE', 'RIGHT HASH', 'NOTES'];
                const gridRowLabels = activeBox?.gridRowLabels || ['Group 1', 'Group 2', 'Group 3', 'Group 4'];
                const cornerLabel = activeBox?.cornerLabel || 'Group/Type';

                // Wristband Input Component with Autocomplete
                const WristbandInput = ({ play, playIndex }) => {
                    const assignedCoords = getAssignedWristbandCoordinates(play.id);
                    const isDuplicate = play.wristbandSlot && assignedCoords.has(play.wristbandSlot.trim());
                    const currentValue = play.wristbandSlot || '';

                    // Generate suggested coordinates (101-199, 201-299, etc.)
                    const suggestedCoords = [];
                    for (let i = 101; i <= 999; i++) {
                        const coord = i.toString();
                        if (!assignedCoords.has(coord)) {
                            suggestedCoords.push(coord);
                        }
                        if (suggestedCoords.length >= 50) break; // Limit suggestions
                    }

                    // Filter suggestions based on current input
                    const filteredSuggestions = currentValue
                        ? suggestedCoords.filter(c => c.startsWith(currentValue))
                        : suggestedCoords.slice(0, 10);

                    const isFocused = wristbandFocus === playIndex;

                    const validateWristbandAssignment = (val) => {
                        let isBlocked = false;
                        const currentWbSettings = currentWeek?.wristbands || {};
                        const enabledSections = currentWbSettings.enabledSections || {};

                        const cardKeys = ['card1', 'card2', 'card3', 'card4', 'card5', 'card6'];
                        for (const key of cardKeys) {
                            if (enabledSections[key] !== false) continue;
                            const card = currentWbSettings[key];
                            if (!card) continue;
                            const cardNum = parseInt(key.replace('card', ''));

                            if (card.type && (card.type === 'rooski' || card.type === 'wiz')) {
                                for (let i = 1; i <= 16; i++) {
                                    if (val === `${cardNum}${String(i).padStart(2, '0')}`) isBlocked = true;
                                }
                            } else {
                                const start = cardNum * 100 + 1;
                                const end = start + 47;
                                const num = parseInt(val);
                                if (!isNaN(num) && num >= start && num <= end && String(num) === val) isBlocked = true;
                            }
                        }

                        // Check Staples
                        if (enabledSections.staples === false) {
                            const num = parseInt(val);
                            if (!isNaN(num) && num >= 10 && num <= 89 && String(num) === val) isBlocked = true;
                        }

                        if (isBlocked) {
                            alert("This wristband section is disabled.");
                            return false;
                        }
                        return true;
                    };

                    return (
                        <div style={{ position: 'relative' }}>
                            <input
                                type="text"
                                value={currentValue}
                                placeholder="#"
                                onFocus={() => setWristbandFocus(playIndex)}
                                onBlur={() => {
                                    // Delay to allow dropdown click to register
                                    setTimeout(() => setWristbandFocus(null), 150);
                                }}
                                onChange={(e) => {
                                    const val = e.target.value;
                                    if (validateWristbandAssignment(val)) {
                                        if (onUpdatePlay) onUpdatePlay({ ...play, wristbandSlot: val });
                                    }
                                }}
                                style={{
                                    width: '30px',
                                    fontSize: '0.7rem',
                                    textAlign: 'center',
                                    padding: '2px',
                                    border: isDuplicate ? '2px solid #dc2626' : '1px solid #ccc',
                                    borderRadius: '2px',
                                    color: isDuplicate ? '#dc2626' : '#1e293b',
                                    fontWeight: isDuplicate ? 'bold' : 'normal',
                                    background: isDuplicate ? '#fee2e2' : 'white'
                                }}
                                title={isDuplicate ? 'Warning: This coordinate is already assigned!' : ''}
                            />
                            {/* Autocomplete Dropdown */}
                            {isFocused && filteredSuggestions.length > 0 && (
                                <div style={{
                                    position: 'absolute',
                                    top: '100%',
                                    left: 0,
                                    zIndex: 10000,
                                    background: 'white',
                                    border: '1px solid #cbd5e1',
                                    borderRadius: '4px',
                                    boxShadow: '0 4px 10px rgba(0,0,0,0.2)',
                                    maxHeight: '150px',
                                    overflowY: 'auto',
                                    minWidth: '60px',
                                    marginTop: '2px'
                                }}>
                                    {filteredSuggestions.map(coord => (
                                        <div
                                            key={coord}
                                            onMouseDown={(e) => {
                                                e.preventDefault(); // Prevent blur
                                                if (validateWristbandAssignment(coord)) {
                                                    if (onUpdatePlay) {
                                                        onUpdatePlay({ ...play, wristbandSlot: coord });
                                                    }
                                                }
                                                setWristbandFocus(null);
                                            }}
                                            style={{
                                                padding: '4px 8px',
                                                cursor: 'pointer',
                                                fontSize: '0.75rem',
                                                color: '#1e293b',
                                                background: 'white'
                                            }}
                                            onMouseEnter={(e) => e.target.style.background = '#f1f5f9'}
                                            onMouseLeave={(e) => e.target.style.background = 'white'}
                                        >
                                            {coord}
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>
                    );
                };

                return (
                    <div style={{
                        position: 'fixed', top: 0, left: 0, width: '100vw', height: '100vh',
                        backgroundColor: 'rgba(0,0,0,0.8)', zIndex: 1000, display: 'flex', justifyContent: 'center', alignItems: 'center'
                    }} onClick={() => setShowPlaySelector(false)}>
                        <div style={{ width: '90%', height: '90%', backgroundColor: 'var(--bg-panel)', borderRadius: '12px', padding: '1.5rem', display: 'flex', flexDirection: 'column' }} onClick={e => e.stopPropagation()}>
                            <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem', alignItems: 'center' }}>
                                <h2>Select Plays {activeBox?.header ? `(${activeBox.header})` : ''}</h2>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>

                                    <button className="btn" onClick={() => setShowPlaySelector(false)}>Close</button>
                                </div>
                            </div>

                            {/* Filters Row - Condensed */}
                            <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '1rem', alignItems: 'center' }}>
                                <input
                                    type="text"
                                    className="form-input"
                                    placeholder="🔍 Search..."
                                    value={playSelectorFilters.search || ''}
                                    onChange={e => setPlaySelectorFilters({ ...playSelectorFilters, search: e.target.value })}
                                    style={{ flex: 1 }}
                                />
                                <select className="form-select" style={{ width: '150px' }} value={playSelectorFilters.formation} onChange={e => setPlaySelectorFilters({ ...playSelectorFilters, formation: e.target.value })}>
                                    <option value="">All Formations</option>
                                    {uniqueFormations.map(f => <option key={f} value={f}>{f}</option>)}
                                </select>
                                <select className="form-select" style={{ width: '150px' }} value={playSelectorFilters.concept} onChange={e => setPlaySelectorFilters({ ...playSelectorFilters, concept: e.target.value })}>
                                    <option value="">All Concepts</option>
                                    {uniqueConcepts.map(c => <option key={c} value={c}>{c}</option>)}
                                </select>
                                <select className="form-select" style={{ width: '150px' }} value={playSelectorFilters.situation} onChange={e => setPlaySelectorFilters({ ...playSelectorFilters, situation: e.target.value })}>
                                    <option value="">All Situations</option>
                                    {situationTags.map(s => <option key={s} value={s}>{s}</option>)}
                                </select>
                                <select className="form-select" style={{ width: '150px' }} value={playSelectorFilters.tag} onChange={e => setPlaySelectorFilters({ ...playSelectorFilters, tag: e.target.value })}>
                                    <option value="">All Tags</option>
                                    {allTags.map(t => <option key={t} value={t}>{t}</option>)}
                                </select>
                            </div>

                            <div style={{ display: 'flex', flex: 1, gap: '1rem', overflow: 'hidden' }}>

                                {/* GRID SIDE */}
                                <div style={{ flex: isGridMode ? '1' : '0 0 450px', maxWidth: isGridMode ? 'none' : '450px', display: 'flex', flexDirection: 'column', borderRight: '1px solid var(--border)', paddingRight: '1rem' }}>
                                    <h4 style={{ marginBottom: '0.5rem', textAlign: 'center' }}>Selected Plays (Drag to Move)</h4>

                                    {isGridMode ? (
                                        /* 4x4 Grid Mode */
                                        <div style={{ display: 'flex', flexDirection: 'column', height: '100%', overflow: 'hidden' }}>
                                            {/* Column Headers Row */}
                                            <div style={{ display: 'grid', gridTemplateColumns: '120px repeat(4, 1fr)', gap: '10px', marginBottom: '8px' }}>
                                                {/* Corner Label */}
                                                <div style={{ position: 'relative' }}>
                                                    <input
                                                        value={cornerLabel}
                                                        onChange={(e) => {
                                                            const newLayouts = { ...gamePlanLayouts };
                                                            const sheet = { ...newLayouts.CALL_SHEET };
                                                            sheet.sections.forEach(section => {
                                                                (section.boxes || []).forEach(b => {
                                                                    if (b.setId === activeCellSetId) {
                                                                        b.cornerLabel = e.target.value;
                                                                    }
                                                                });
                                                            });
                                                            if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                        }}
                                                        style={{
                                                            width: '100%', fontSize: '0.7rem', fontWeight: 'bold',
                                                            background: '#475569', color: 'white', border: 'none',
                                                            padding: '6px 4px', borderRadius: '4px', textAlign: 'center'
                                                        }}
                                                        placeholder="Corner..."
                                                    />
                                                </div>
                                                {gridHeadings.map((h, i) => (
                                                    <div key={i} style={{ textAlign: 'center', position: 'relative' }}>
                                                        <input
                                                            value={h}
                                                            onChange={(e) => {
                                                                const newLayouts = { ...gamePlanLayouts };
                                                                const sheet = { ...newLayouts.CALL_SHEET };
                                                                sheet.sections.forEach(section => {
                                                                    (section.boxes || []).forEach(b => {
                                                                        if (b.setId === activeCellSetId) {
                                                                            if (!b.gridHeadings) b.gridHeadings = ['LEFT HASH', 'MIDDLE', 'RIGHT HASH', 'NOTES'];
                                                                            b.gridHeadings[i] = e.target.value;
                                                                        }
                                                                    });
                                                                });
                                                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                            }}
                                                            style={{
                                                                width: '100%', fontSize: '0.7rem', fontWeight: 'bold',
                                                                background: '#334155', color: 'white', border: 'none',
                                                                padding: '6px 4px', borderRadius: '4px', textAlign: 'center'
                                                            }}
                                                        />
                                                    </div>
                                                ))}
                                            </div>

                                            {/* Grid Body with Row Labels */}
                                            <div style={{ display: 'flex', flexDirection: 'column', gap: '8px', flex: 1, overflowY: 'auto', paddingBottom: '1rem' }}>
                                                {[0, 1, 2, 3].map(rowNum => (
                                                    <div key={rowNum} style={{ display: 'grid', gridTemplateColumns: '120px repeat(4, 1fr)', gap: '8px', alignItems: 'stretch' }}>
                                                        {/* Row Label */}
                                                        <div style={{ display: 'flex', alignItems: 'center' }}>
                                                            <input
                                                                value={gridRowLabels[rowNum]}
                                                                onChange={(e) => {
                                                                    const newLayouts = { ...gamePlanLayouts };
                                                                    const sheet = { ...newLayouts.CALL_SHEET };
                                                                    sheet.sections.forEach(section => {
                                                                        (section.boxes || []).forEach(b => {
                                                                            if (b.setId === activeCellSetId) {
                                                                                if (!b.gridRowLabels) b.gridRowLabels = ['Group 1', 'Group 2', 'Group 3', 'Group 4'];
                                                                                b.gridRowLabels[rowNum] = e.target.value;
                                                                            }
                                                                        });
                                                                    });
                                                                    if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                                }}
                                                                style={{
                                                                    width: '100%', fontSize: '0.7rem', fontWeight: 'bold',
                                                                    background: '#334155', color: 'white', border: 'none',
                                                                    padding: '6px 4px', borderRadius: '4px', textAlign: 'center',
                                                                    height: '100%'
                                                                }}
                                                            />
                                                        </div>

                                                        {/* 4 Data Cells for this row */}
                                                        {[0, 1, 2, 3].map(colNum => {
                                                            const idx = rowNum * 4 + colNum;
                                                            const p = gridModePlays[idx];
                                                            return (
                                                                <div key={idx}
                                                                    draggable
                                                                    onDragStart={(e) => {
                                                                        e.dataTransfer.setData('text/plain', idx);
                                                                        setDraggedGridIndex(idx);
                                                                    }}
                                                                    onDragOver={(e) => { e.preventDefault(); }}
                                                                    onDrop={(e) => {
                                                                        e.preventDefault();
                                                                        const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                                                                        handleGridMove(fromIdx, idx);
                                                                        setDraggedGridIndex(null);
                                                                    }}
                                                                    style={{
                                                                        height: '100px', border: '2px dashed #cbd5e1', borderRadius: '8px',
                                                                        display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: '8px', gap: '4px',
                                                                        background: p.type === 'GAP' ? '#f8fafc' : 'white',
                                                                        opacity: draggedGridIndex === idx ? 0.5 : 1,
                                                                        transition: 'all 0.2s',
                                                                        textAlign: 'center',
                                                                        cursor: p.type !== 'GAP' ? 'pointer' : 'default'
                                                                    }}
                                                                    onDoubleClick={(e) => {
                                                                        if (isLocked || p.type === 'GAP') return;
                                                                        e.stopPropagation();
                                                                        setAssignmentModalState({ playId: p.id, x: e.clientX, y: e.clientY });
                                                                    }}
                                                                >
                                                                    {p.type !== 'GAP' ? (
                                                                        <>
                                                                            <div style={{ width: '100%', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                                                {showWristband && <WristbandInput play={p} playIndex={idx} />}
                                                                                <div
                                                                                    style={{ cursor: 'pointer', color: '#94a3b8', fontSize: '14px', padding: '2px' }}
                                                                                    onClick={() => handleGridRemove(idx)}
                                                                                >✖</div>
                                                                            </div>
                                                                            <div style={{ flex: 1, fontSize: '0.85rem', fontWeight: 'bold', color: '#1e293b', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                                                                                {p.name}
                                                                            </div>
                                                                            <div style={{ fontSize: '0.65rem', color: '#64748b' }}>{p.formation}</div>
                                                                        </>
                                                                    ) : (
                                                                        <div style={{ color: '#94a3b8', fontSize: '0.75rem' }}>+ Empty</div>
                                                                    )}
                                                                </div>
                                                            );
                                                        })}
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    ) : (
                                        /* Default 2-Column List */
                                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px', height: '100%', overflowY: 'auto' }}>

                                            {/* Left Column */}
                                            <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                                <div style={{ textAlign: 'center', fontWeight: 'bold', fontSize: '0.8rem', background: '#334155', color: 'white', padding: '4px', borderRadius: '4px' }}>LEFT HASH</div>
                                                {leftPlays.map((p, idx) => (
                                                    <div key={idx}
                                                        draggable
                                                        onDragStart={(e) => {
                                                            e.dataTransfer.setData('text/plain', idx); // Global index 0-9
                                                            setDraggedGridIndex(idx);
                                                        }}
                                                        onDragOver={(e) => { e.preventDefault(); }}
                                                        onDrop={(e) => {
                                                            e.preventDefault();
                                                            const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                                                            handleGridMove(fromIdx, idx);
                                                            setDraggedGridIndex(null);
                                                        }}
                                                        style={{
                                                            height: '40px', border: '1px solid #cbd5e1', borderRadius: '4px',
                                                            display: 'flex', alignItems: 'center', padding: '0 4px', gap: '4px',
                                                            background: p.type === 'GAP' ? '#f8fafc' : 'white',
                                                            opacity: draggedGridIndex === idx ? 0.5 : 1,
                                                            cursor: 'pointer'
                                                        }}
                                                        onDoubleClick={(e) => {
                                                            if (isLocked) return;
                                                            e.stopPropagation();
                                                            setAssignmentModalState({ playId: p.id, x: e.clientX, y: e.clientY });
                                                        }}
                                                    >
                                                        {p.type !== 'GAP' && (
                                                            <>
                                                                {showWristband && (
                                                                    <WristbandInput play={p} playIndex={idx} />
                                                                )}
                                                                <div style={{ flex: 1, fontSize: '0.7rem', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap', fontWeight: 'bold', color: '#1e293b' }} title={p.name}>
                                                                    {p.name}
                                                                </div>
                                                                <div
                                                                    style={{ cursor: 'pointer', color: '#94a3b8', fontSize: '10px' }}
                                                                    onClick={() => handleGridRemove(idx)}
                                                                >✖</div>
                                                            </>
                                                        )}
                                                    </div>
                                                ))}
                                            </div>

                                            {/* Right Column */}
                                            <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                                <div style={{ textAlign: 'center', fontWeight: 'bold', fontSize: '0.8rem', background: '#334155', color: 'white', padding: '4px', borderRadius: '4px' }}>RIGHT HASH</div>
                                                {rightPlays.map((p, localIdx) => {
                                                    const globalIdx = localIdx + 10;
                                                    return (
                                                        <div key={globalIdx}
                                                            draggable
                                                            onDragStart={(e) => {
                                                                e.dataTransfer.setData('text/plain', globalIdx);
                                                                setDraggedGridIndex(globalIdx);
                                                            }}
                                                            onDragOver={(e) => { e.preventDefault(); }}
                                                            onDrop={(e) => {
                                                                e.preventDefault();
                                                                const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                                                                handleGridMove(fromIdx, globalIdx);
                                                                setDraggedGridIndex(null);
                                                            }}
                                                            style={{
                                                                height: '40px', border: '1px solid #cbd5e1', borderRadius: '4px',
                                                                display: 'flex', alignItems: 'center', padding: '0 4px', gap: '4px',
                                                                background: p.type === 'GAP' ? '#f8fafc' : 'white',
                                                                opacity: draggedGridIndex === globalIdx ? 0.5 : 1,
                                                                cursor: 'pointer'
                                                            }}
                                                            onDoubleClick={(e) => {
                                                                if (isLocked) return;
                                                                e.stopPropagation();
                                                                setAssignmentModalState({ playId: p.id, x: e.clientX, y: e.clientY });
                                                            }}
                                                        >
                                                            {p.type !== 'GAP' && (
                                                                <>
                                                                    {showWristband && (
                                                                        <WristbandInput play={p} playIndex={globalIdx} />
                                                                    )}
                                                                    <div style={{ flex: 1, fontSize: '0.7rem', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap', fontWeight: 'bold', color: '#1e293b' }} title={p.name}>
                                                                        {p.name}
                                                                    </div>
                                                                    <div
                                                                        style={{ cursor: 'pointer', color: '#94a3b8', fontSize: '10px' }}
                                                                        onClick={() => handleGridRemove(globalIdx)}
                                                                    >✖</div>
                                                                </>
                                                            )}
                                                        </div>
                                                    );
                                                })}
                                            </div>

                                        </div>
                                    )}
                                </div>

                                {/* AVAILABLE PLAYS */}
                                <div style={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
                                    <h4 style={{ marginBottom: '0.5rem' }}>Available Plays</h4>
                                    <div style={{ flex: 1, overflowY: 'auto', display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(130px, 1fr))', gap: '0.5rem', alignContent: 'start', paddingRight: '4px' }}>
                                        {filteredSelectorPlays.map(play => (
                                            <div key={play.id}
                                                style={{ padding: '0.4rem', border: '1px solid var(--border)', borderRadius: '4px', cursor: 'pointer', backgroundColor: 'white', display: 'flex', flexDirection: 'column', boxShadow: '0 1px 2px rgba(0,0,0,0.05)' }}
                                                onClick={() => handleGridAdd(play.id)}
                                            >
                                                <div style={{ fontWeight: 'bold', fontSize: '0.75rem', marginBottom: '2px', lineHeight: '1.2', color: '#1e293b' }}>{play.name}</div>
                                                <div style={{ fontSize: '0.65rem', color: '#64748b', marginBottom: '4px' }}>{play.formation}</div>
                                                {play.image && (
                                                    <div style={{ height: '50px', backgroundColor: '#f8fafc', display: 'flex', justifyContent: 'center', alignItems: 'center', marginBottom: '4px', borderRadius: '2px' }}>
                                                        <img src={play.image} style={{ maxWidth: '100%', maxHeight: '100%', objectFit: 'contain' }} />
                                                    </div>
                                                )}
                                                <button className="btn btn-sm btn-primary" style={{ width: '100%', fontSize: '0.7rem', padding: '2px 0' }}>Add</button>
                                            </div>
                                        ))}
                                        {filteredSelectorPlays.length === 0 && (
                                            <div style={{ gridColumn: '1 / -1', textAlign: 'center', padding: '2rem', color: 'var(--text-secondary)' }}>
                                                No plays match filters.
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            };

            const renderStaples = () => {
                const staplesLayout = gamePlanLayouts.STAPLES || { sections: [] };

                const updateStaplesLayout = (newLayout) => {
                    const newLayouts = { ...gamePlanLayouts, STAPLES: newLayout };
                    if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                };

                const handleAddSection = () => {
                    const newSection = {
                        id: `staple_sec_${Date.now()}`,
                        title: "New Staples Section",
                        columns: ["Column 1", "Column 2", "Column 3"],
                        rows: [
                            { id: `row_${Date.now()}_1`, label: "Row 1", cells: {} },
                            { id: `row_${Date.now()}_2`, label: "Row 2", cells: {} }
                        ]
                    };
                    updateStaplesLayout({ ...staplesLayout, sections: [...staplesLayout.sections, newSection] });
                };

                const handleUpdateSection = (sectionIdx, updatedSection) => {
                    const newSections = [...staplesLayout.sections];
                    newSections[sectionIdx] = updatedSection;
                    updateStaplesLayout({ ...staplesLayout, sections: newSections });
                };

                const handleDeleteSection = (sectionIdx) => {
                    if (!confirm("Are you sure you want to delete this section?")) return;
                    const newSections = [...staplesLayout.sections];
                    newSections.splice(sectionIdx, 1);
                    updateStaplesLayout({ ...staplesLayout, sections: newSections });
                };

                return (
                    <div style={{ padding: '1rem', height: '100%', overflowY: 'auto' }}>
                        <div style={{ marginBottom: '1rem', display: 'flex', justifyContent: 'flex-end' }}>
                            {!isLocked && (
                                <button className="btn btn-primary" onClick={handleAddSection}>
                                    + Add Staples Section
                                </button>
                            )}
                        </div>

                        <div style={{ display: 'flex', flexDirection: 'column', gap: '2rem' }}>
                            {staplesLayout.sections.map((section, sIdx) => (
                                <StapleSection
                                    key={section.id}
                                    section={section}
                                    index={sIdx}
                                    isLocked={isLocked}
                                    onUpdate={(updated) => handleUpdateSection(sIdx, updated)}
                                    onDelete={() => handleDeleteSection(sIdx)}
                                    plays={plays}
                                />
                            ))}
                        </div>

                        {staplesLayout.sections.length === 0 && (
                            <div style={{ textAlign: 'center', padding: '4rem', color: '#94a3b8', border: '2px dashed #e2e8f0', borderRadius: '8px' }}>
                                <h3>No Staples Sections Yet</h3>
                                <p>Click the button above to create a customizable grid for your staple plays.</p>
                            </div>
                        )}
                    </div>
                );
            };

            const StapleSection = ({ section, index, isLocked, onUpdate, onDelete, plays }) => {
                const [isEditingLayout, setIsEditingLayout] = useState(false);

                const handleTitleChange = (e) => onUpdate({ ...section, title: e.target.value });

                const handleAddColumn = () => {
                    onUpdate({ ...section, columns: [...section.columns, "New Col"] });
                };
                const handleRemoveColumn = (colIdx) => {
                    const newCols = [...section.columns];
                    newCols.splice(colIdx, 1);
                    // Cleanup cells data
                    const newRows = section.rows.map(row => {
                        const newCells = {};
                        Object.keys(row.cells).forEach(key => {
                            const k = parseInt(key);
                            if (k < colIdx) newCells[k] = row.cells[k];
                            else if (k > colIdx) newCells[k - 1] = row.cells[k];
                        });
                        return { ...row, cells: newCells };
                    });
                    onUpdate({ ...section, columns: newCols, rows: newRows });
                };
                const handleColNameChange = (colIdx, val) => {
                    const newCols = [...section.columns];
                    newCols[colIdx] = val;
                    onUpdate({ ...section, columns: newCols });
                };

                const handleAddRow = () => {
                    onUpdate({
                        ...section,
                        rows: [...section.rows, { id: `row_${Date.now()}`, label: "New Row", cells: {} }]
                    });
                };
                const handleRemoveRow = (rowIdx) => {
                    const newRows = [...section.rows];
                    newRows.splice(rowIdx, 1);
                    onUpdate({ ...section, rows: newRows });
                };
                const handleRowLabelChange = (rowIdx, val) => {
                    const newRows = [...section.rows];
                    newRows[rowIdx] = { ...newRows[rowIdx], label: val };
                    onUpdate({ ...section, rows: newRows });
                };

                const handleDrop = (e, rowIdx, colIdx) => {
                    e.preventDefault();
                    if (isLocked) return;
                    try {
                        const data = JSON.parse(e.dataTransfer.getData('application/react-dnd'));
                        if (data && data.playId) {
                            const newRows = [...section.rows];
                            const currentCells = { ...(newRows[rowIdx].cells || {}) };
                            newRows[rowIdx] = {
                                ...newRows[rowIdx],
                                cells: { ...currentCells, [colIdx]: data.playId }
                            };
                            onUpdate({ ...section, rows: newRows });
                        }
                    } catch (e) { }
                };

                const handleClearCell = (rowIdx, colIdx) => {
                    const newRows = [...section.rows];
                    const currentCells = { ...newRows[rowIdx].cells };
                    delete currentCells[colIdx];
                    newRows[rowIdx] = { ...newRows[rowIdx], cells: currentCells };
                    onUpdate({ ...section, rows: newRows });
                };

                return (
                    <div style={{ background: 'white', border: '1px solid #e2e8f0', borderRadius: '8px', overflow: 'hidden' }}>
                        {/* Header */}
                        <div style={{ padding: '0.75rem 1rem', background: '#f1f5f9', borderBottom: '1px solid #e2e8f0', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                            {isEditingLayout ? (
                                <input
                                    value={section.title}
                                    onChange={handleTitleChange}
                                    style={{ fontSize: '1.1rem', fontWeight: 'bold', border: '1px solid #cbd5e1', padding: '4px', borderRadius: '4px' }}
                                />
                            ) : (
                                <h3 style={{ margin: 0, fontSize: '1.2rem', color: '#334155' }}>{section.title}</h3>
                            )}

                            {!isLocked && (
                                <div style={{ display: 'flex', gap: '8px' }}>
                                    <button
                                        className={`btn-sm ${isEditingLayout ? 'btn-primary' : 'btn-secondary'}`}
                                        onClick={() => setIsEditingLayout(!isEditingLayout)}
                                    >
                                        {isEditingLayout ? 'Done Editing' : 'Edit Layout'}
                                    </button>
                                    <button className="btn-sm" style={{ color: '#ef4444' }} onClick={onDelete}>
                                        <Icon name="Trash2" size={16} />
                                    </button>
                                </div>
                            )}
                        </div>

                        {/* Grid Content */}
                        <div style={{ padding: '1rem', overflowX: 'auto' }}>
                            <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                                <thead>
                                    <tr>
                                        <th style={{ width: '150px', padding: '8px', textAlign: 'left', borderBottom: '2px solid #e2e8f0', color: '#64748b', fontSize: '0.8rem' }}>
                                            {isEditingLayout ? "ROW LABELS" : ""}
                                        </th>
                                        {section.columns.map((col, cIdx) => (
                                            <th key={cIdx} style={{ padding: '8px', minWidth: '120px', textAlign: 'center', borderBottom: '2px solid #e2e8f0' }}>
                                                {isEditingLayout ? (
                                                    <div style={{ display: 'flex', gap: '4px', alignItems: 'center', justifyContent: 'center' }}>
                                                        <input
                                                            value={col}
                                                            onChange={(e) => handleColNameChange(cIdx, e.target.value)}
                                                            style={{ width: '100%', fontSize: '0.8rem', textAlign: 'center', padding: '2px' }}
                                                        />
                                                        <div style={{ cursor: 'pointer', color: '#ef4444' }} onClick={() => handleRemoveColumn(cIdx)}>×</div>
                                                    </div>
                                                ) : (
                                                    <div style={{ fontSize: '0.8rem', fontWeight: 'bold', color: '#475569', textTransform: 'uppercase' }}>{col}</div>
                                                )}
                                            </th>
                                        ))}
                                        {isEditingLayout && (
                                            <th style={{ width: '40px', padding: '8px', borderBottom: '2px solid #e2e8f0' }}>
                                                <button className="btn-sm" style={{ fontSize: '1.2rem', padding: '0 6px' }} onClick={handleAddColumn}>+</button>
                                            </th>
                                        )}
                                    </tr>
                                </thead>
                                <tbody>
                                    {section.rows.map((row, rIdx) => (
                                        <tr key={row.id}>
                                            <td style={{ padding: '8px', borderBottom: '1px solid #f1f5f9', fontWeight: 'bold', color: '#475569', fontSize: '0.9rem' }}>
                                                {isEditingLayout ? (
                                                    <div style={{ display: 'flex', gap: '4px', alignItems: 'center' }}>
                                                        <div style={{ cursor: 'pointer', color: '#ef4444' }} onClick={() => handleRemoveRow(rIdx)}>×</div>
                                                        <input
                                                            value={row.label}
                                                            onChange={(e) => handleRowLabelChange(rIdx, e.target.value)}
                                                            style={{ width: '100%', fontSize: '0.9rem', padding: '2px' }}
                                                        />
                                                    </div>
                                                ) : (
                                                    row.label
                                                )}
                                            </td>
                                            {section.columns.map((col, cIdx) => {
                                                const playId = row.cells ? row.cells[cIdx] : null;
                                                const play = playId ? plays.find(p => p.id === playId) : null;
                                                return (
                                                    <td
                                                        key={cIdx}
                                                        style={{ padding: '4px', borderBottom: '1px solid #f1f5f9', borderLeft: '1px solid #f1f5f9', textAlign: 'center' }}
                                                        onDragOver={e => e.preventDefault()}
                                                        onDrop={e => handleDrop(e, rIdx, cIdx)}
                                                    >
                                                        {play ? (
                                                            <div style={{
                                                                background: '#f0f9ff', border: '1px solid #bae6fd', borderRadius: '4px',
                                                                padding: '4px', fontSize: '0.8rem', position: 'relative',
                                                                display: 'flex', alignItems: 'center', justifyContent: 'center',
                                                                cursor: 'pointer'
                                                            }}
                                                                onDoubleClick={(e) => {
                                                                    if (isLocked) return;
                                                                    e.stopPropagation();
                                                                    setAssignmentModalState({ playId: play.id, x: e.clientX, y: e.clientY });
                                                                }}
                                                            >
                                                                <div style={{ overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{getPlayDisplayName(play)}</div>
                                                                {!isLocked && (
                                                                    <div
                                                                        onClick={() => handleClearCell(rIdx, cIdx)}
                                                                        style={{ position: 'absolute', right: '-4px', top: '-4px', background: '#ef4444', color: 'white', borderRadius: '50%', width: '14px', height: '14px', fontSize: '0.6rem', display: 'flex', alignItems: 'center', justifyContent: 'center', cursor: 'pointer' }}
                                                                    >×</div>
                                                                )}
                                                            </div>
                                                        ) : (
                                                            <div style={{ height: '32px', background: '#fafafa', borderRadius: '4px', border: '1px dashed #e2e8f0' }}></div>
                                                        )}
                                                    </td>
                                                );
                                            })}
                                            {isEditingLayout && <td style={{ borderBottom: '1px solid #f1f5f9' }}></td>}
                                        </tr>
                                    ))}
                                    {isEditingLayout && (
                                        <tr>
                                            <td style={{ padding: '8px' }}>
                                                <button className="btn-sm" onClick={handleAddRow}>+ Add Row</button>
                                            </td>
                                            <td colSpan={section.columns.length + 1}></td>
                                        </tr>
                                    )}
                                </tbody>
                            </table>
                        </div>
                    </div>
                );
            };


            const renderPriorityPlays = () => {
                // Use playCategories (Play Buckets) directly as the categories
                const CATEGORIES = (playCategories && playCategories.length > 0) ? playCategories : DEFAULT_PLAY_CATEGORIES;

                const priorityCategories = gamePlan?.priorityCategories || {};

                // Determine assigned IDs to filter Inbox
                const getAllAssignedIds = () => Object.values(priorityCategories).flat();
                const assignedIds = new Set(getAllAssignedIds());

                // Get all plays that are in the game plan (from any source: matrix, FZDND, scripts)
                const getAllGamePlanPlayIds = () => {
                    const playIds = new Set();

                    // Collect from all sets (includes matrix cells, FZDND, and script sections)
                    if (gamePlan?.sets && Array.isArray(gamePlan.sets)) {
                        gamePlan.sets.forEach(set => {
                            if (set.playIds && Array.isArray(set.playIds)) {
                                set.playIds.forEach(item => {
                                    const id = typeof item === 'string' ? item : item?.id;
                                    if (id && id !== 'GAP' && !id.startsWith('NOTE:')) {
                                        playIds.add(id);
                                    }
                                });
                            }
                        });
                    }

                    // Collect from mini scripts
                    if (gamePlan?.miniScripts && Array.isArray(gamePlan.miniScripts)) {
                        gamePlan.miniScripts.forEach(script => {
                            if (script.playIds && Array.isArray(script.playIds)) {
                                script.playIds.forEach(item => {
                                    const id = typeof item === 'string' ? item : item?.id;
                                    if (id && id !== 'GAP' && !id.startsWith('NOTE:')) {
                                        playIds.add(id);
                                    }
                                });
                            }
                        });
                    }

                    return playIds;
                };

                const gamePlanPlayIds = getAllGamePlanPlayIds();

                // Plays that are in the game plan but not yet assigned to a priority category
                const unassignedPriorityPlays = plays.filter(p => gamePlanPlayIds.has(p.id) && !assignedIds.has(p.id));

                const updateCategories = (newCategories) => {
                    if (onUpdateGamePlan) {
                        onUpdateGamePlan({ ...gamePlan, priorityCategories: newCategories });
                    }
                };



                // Handle changes for a specific category
                const handleCategoryListChange = (newItems, catId) => {
                    const newIds = newItems.map(p => p.id);
                    const newCats = { ...priorityCategories };

                    // 1. Update this category
                    newCats[catId] = newIds;

                    // 2. Remove these IDs from ALL other categories to prevent duplicates
                    const idsInThisCategory = new Set(newIds);
                    Object.keys(newCats).forEach(k => {
                        if (k !== catId && newCats[k]) {
                            newCats[k] = newCats[k].filter(id => !idsInThisCategory.has(id));
                        }
                    });

                    // 3. Update playCategory on plays that were moved (using playCategory instead of bucketId)
                    newItems.forEach(play => {
                        if (play.playCategory !== catId && onUpdatePlay) {
                            onUpdatePlay(play.id, { playCategory: catId });
                        }
                    });

                    updateCategories(newCats);
                };

                // Handle changes for Inbox
                const handleInboxListChange = (newItems) => {
                    // Logic: If item is in Inbox, it must NOT be in any category.
                    const inboxIds = new Set(newItems.map(p => p.id));

                    const newCats = { ...priorityCategories };
                    let changed = false;

                    Object.keys(newCats).forEach(k => {
                        if (newCats[k]) {
                            const originalLen = newCats[k].length;
                            newCats[k] = newCats[k].filter(id => !inboxIds.has(id));
                            if (newCats[k].length !== originalLen) changed = true;
                        }
                    });

                    // Clear playCategory for plays moved to inbox
                    newItems.forEach(play => {
                        if (play.playCategory && onUpdatePlay) {
                            onUpdatePlay(play.id, { playCategory: null });
                        }
                    });

                    // If items were moved TO inbox (from category), 'changed' will be true.
                    // If items were reordered in Inbox, 'changed' is false, and we do nothing (Inbox has no order).
                    // If item removed from Inbox (to Category), that event handles itself via handleCategoryListChange.

                    if (changed) {
                        updateCategories(newCats);
                    }
                };

                // Helper to remove from category directly via X button (if we add it back)
                const handleRemoveFromCategory = (catId, playId) => {
                    if (isLocked) return;
                    const newCats = { ...priorityCategories };
                    if (newCats[catId]) {
                        newCats[catId] = newCats[catId].filter(id => id !== playId);
                        updateCategories(newCats);
                    }
                };

                const handleUnstar = (playId) => {
                    if (isLocked) return;
                    if (onUpdatePlay) onUpdatePlay(playId, { priority: false });
                    // Cleanup from categories
                    const newCats = { ...priorityCategories };
                    let changed = false;
                    Object.keys(newCats).forEach(k => {
                        if (newCats[k] && newCats[k].includes(playId)) {
                            newCats[k] = newCats[k].filter(id => id !== playId);
                            changed = true;
                        }
                    });
                    if (changed) updateCategories(newCats);
                };

                return (
                    <div style={{ display: 'flex', height: '100%', gap: '1rem' }}>
                        {/* LEFT: Play Bucket Boxes (flat grid) */}
                        <div style={{ flex: 3, display: 'flex', flexDirection: 'column', gap: '1rem', overflowY: 'auto', paddingRight: '0.5rem', paddingBottom: '20px' }}>
                            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(280px, 1fr))', gap: '1rem' }}>
                                {CATEGORIES.map(bucket => {
                                    const playIds = priorityCategories[bucket.id] || [];
                                    const listItems = playIds.map(id => plays.find(p => p.id === id)).filter(p => p && p.priority);

                                    return (
                                        <div
                                            key={bucket.id}
                                            className="card"
                                            style={{ display: 'flex', flexDirection: 'column', background: 'var(--bg-panel)', border: '1px solid var(--border)', minHeight: '200px' }}
                                        >
                                            <h4 style={{ margin: '0 0 0.5rem 0', paddingBottom: '0.5rem', borderBottom: '1px solid var(--border)', color: 'var(--text-main)', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <span style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                    {bucket.color && (
                                                        <span style={{ width: '12px', height: '12px', borderRadius: '50%', background: bucket.color, flexShrink: 0 }}></span>
                                                    )}
                                                    {bucket.label}
                                                </span>
                                                <span className="badge">{playIds.length}</span>
                                            </h4>
                                            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', overflowY: 'auto' }}>
                                                <PrioritySortableColumn
                                                    items={listItems}
                                                    onListChange={(newItems) => handleCategoryListChange(newItems, bucket.id)}
                                                    style={{ minHeight: '100px', display: 'flex', flexDirection: 'column', gap: '0' }}
                                                    isLocked={isLocked}
                                                    onItemDoubleClick={(play, e) => setAssignmentModalState({ playId: play.id, x: e.clientX, y: e.clientY })}
                                                />
                                                {listItems.length === 0 && (
                                                    <div style={{ fontStyle: 'italic', opacity: 0.5, fontSize: '0.8rem', padding: '0.5rem', textAlign: 'center', pointerEvents: 'none' }}>
                                                        Drop plays here
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>

                        {/* RIGHT: Inbox (Unassigned) */}
                        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', background: 'var(--bg-panel)', border: '1px solid var(--border)', borderRadius: '8px', overflow: 'hidden' }}>
                            <div style={{ padding: '0.75rem', background: '#eff6ff', borderBottom: '1px solid var(--border)' }}>
                                <h4 style={{ margin: 0, color: '#1d4ed8', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                    <Icon name="Star" size={16} color="#eab308" style={{ fill: '#eab308' }} />
                                    Unassigned/Non-Priority Plays
                                </h4>
                            </div>
                            <div style={{ flex: 1, overflowY: 'auto', padding: '0', display: 'flex', flexDirection: 'column' }}>
                                {/* Inbox is also a Sortable to allow two-way dragging */}
                                <PrioritySortableColumn
                                    items={unassignedPriorityPlays}
                                    onListChange={handleInboxListChange}
                                    style={{ minHeight: '200px', padding: '0.5rem', display: 'flex', flexDirection: 'column', gap: '0.5rem' }}
                                    isLocked={isLocked}
                                    onItemDoubleClick={(play, e) => setAssignmentModalState({ playId: play.id, x: e.clientX, y: e.clientY })}
                                />
                                {unassignedPriorityPlays.length === 0 && (
                                    <div style={{ padding: '2rem', textAlign: 'center', opacity: 0.5, fontStyle: 'italic', fontSize: '0.9rem' }}>
                                        No plays in game plan yet. <br />Add plays via Strike 'Em Out, FZDND, or Situations & Scripts.
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                );
            };

            return (
                <div className="game-plan-container" style={{ display: 'flex', flexDirection: 'column', height: 'calc(100vh - 100px)', gap: '1rem' }}>

                    <style media="print">{`
                        @media print {
                            @page {
                                size: ${viewMode === 'sheet' ? 'landscape' : 'portrait'};
                                margin: 0.25in;
                            }
                            body { 
                                margin: 0; 
                                padding: 0; 
                                -webkit-print-color-adjust: exact !important; 
                                print-color-adjust: exact !important; 
                            }
                            .sidebar, .app-sidebar, header, nav, .app-toolbar, .no-print { 
                                display: none !important; 
                            }
                            /* OVERRIDE AGGRESSIVE HIDING */
                            .main-content > * { display: block !important; }
                            .main-content > *:not(.wristband-print-container) { display: block !important; }
                            
                            .game-plan-container, .game-plan-content {
                                display: block !important; /* Kill Flexbox for print */
                                width: 100% !important;
                                height: auto !important;
                                margin: 0 !important;
                                padding: 0 !important;
                                overflow: visible !important;
                                border: none !important;
                            }
                            ${viewMode === 'sheet' ? `
                                .game-plan-content {
                                    zoom: 0.75;
                                }
                            ` : ''}
                        }
                    `}</style>
                    {/* Toolbar */}
                    <div className="app-toolbar no-print" style={{ display: 'flex', justifyContent: 'space-between', gap: '1rem', borderBottom: '1px solid var(--border)', paddingBottom: '1rem', alignItems: 'center' }}>
                        <div style={{ display: 'flex', gap: '1rem', alignItems: 'center' }}>
                            <button
                                className="btn"
                                onClick={handleClearGamePlan}
                                title="Clear Game Plan"
                                style={{ height: '52px', width: '52px', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', textAlign: 'center', background: 'white', border: '1px solid #cbd5e1', color: '#ef4444' }}
                            >
                                <Icon name="Trash" size={16} />
                                <span style={{ fontSize: '0.7rem', marginTop: '4px' }}>CLR</span>
                            </button>
                            <button
                                className="btn"
                                onClick={() => setShowImportModal(true)}
                                style={{ height: '52px', width: '80px', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', textAlign: 'center', lineHeight: '1.2', background: 'white', border: '1px solid #cbd5e1', color: '#64748b' }}
                            >
                                <Icon name="Download" size={16} />
                                <span style={{ fontSize: '0.7rem', marginTop: '4px' }}>IMPORT</span>
                            </button>
                            <button className={`btn ${viewMode === 'matrix' ? 'btn-primary' : 'btn-secondary'}`} onClick={() => setViewMode('matrix')} style={{ height: '52px', width: '110px', display: 'flex', alignItems: 'center', justifyContent: 'center', textAlign: 'center', lineHeight: '1.2', fontSize: '0.75rem' }}>
                                STRIKE 'EM OUT
                            </button>
                            <button className={`btn ${viewMode === 'sheet' ? 'btn-primary' : 'btn-secondary'}`} onClick={() => setViewMode('sheet')} style={{ height: '52px', width: '110px', display: 'flex', alignItems: 'center', justifyContent: 'center', textAlign: 'center', lineHeight: '1.2', fontSize: '0.75rem' }}>
                                SITUATIONS & SCRIPTS
                            </button>
                            <button className={`btn ${viewMode === 'fzdnd' ? 'btn-primary' : 'btn-secondary'}`} onClick={() => setViewMode('fzdnd')} style={{ height: '52px', width: '80px', display: 'flex', alignItems: 'center', justifyContent: 'center', textAlign: 'center', lineHeight: '1.2', fontSize: '0.75rem' }}>
                                FZDnD
                            </button>
                            <button className={`btn ${viewMode === 'priority' ? 'btn-primary' : 'btn-secondary'}`} onClick={() => setViewMode('priority')} style={{ height: '52px', width: '110px', display: 'flex', alignItems: 'center', justifyContent: 'center', textAlign: 'center', lineHeight: '1.2', fontSize: '0.75rem' }}>
                                PRIORITY PLAYS
                            </button>
                            <button className={`btn ${viewMode === 'staples' ? 'btn-primary' : 'btn-secondary'}`} onClick={() => setViewMode('staples')} style={{ height: '52px', width: '90px', display: 'flex', alignItems: 'center', justifyContent: 'center', textAlign: 'center', lineHeight: '1.2', fontSize: '0.75rem' }}>
                                STAPLES
                            </button>
                            <button className={`btn ${viewMode === 'player-touches' ? 'btn-primary' : 'btn-secondary'}`} onClick={() => setViewMode('player-touches')} style={{ height: '52px', width: '110px', display: 'flex', alignItems: 'center', justifyContent: 'center', textAlign: 'center', lineHeight: '1.2', fontSize: '0.75rem' }}>
                                PLAYER TOUCHES
                            </button>
                            <button className="btn btn-secondary" onClick={() => window.print()} style={{ border: '2px solid var(--accent)', height: '52px', width: '110px', display: 'flex', alignItems: 'center', justifyContent: 'center', textAlign: 'center', lineHeight: '1.2', fontSize: '0.75rem' }}>
                                <Icon name="Printer" size={16} style={{ marginBottom: '4px' }} /> PRINT
                            </button>
                        </div>

                        {/* Game Plan Statistics Ticker */}
                        {/* Ticker temporarily removed */}
                    </div>

                    {/* View Content */}
                    <div style={{ flex: 1, display: 'flex', overflow: 'hidden', gap: '1rem' }}>
                        <div className="game-plan-content" style={{ flex: 1, overflow: 'hidden', background: ['priority', 'staples'].includes(viewMode) ? 'transparent' : 'white', padding: ['priority', 'staples'].includes(viewMode) ? '0' : '1rem', borderRadius: '8px', display: 'flex', flexDirection: 'column' }}>
                            {viewMode === 'call-sheet' && renderCallSheet()}
                            {viewMode === 'sheet' && renderSheetView()}
                            {viewMode === 'fzdnd' && renderFZDnDView()}
                            {viewMode === 'matrix' && renderMatrix()}
                            {viewMode === 'player-touches' && renderPlayerTouches()}
                            {viewMode === 'priority' && renderPriorityPlays()}
                            {viewMode === 'staples' && renderStaples()}
                        </div>
                        <div className="no-print">
                            <GamePlannerSideMenu
                                plays={plays}
                                practicePlans={practicePlans}
                                onQuickAddPlay={onQuickAddPlay}
                                isOpen={showSideMenu}
                                onToggle={handleToggleSideMenu}
                                weekStats={weekStats}
                                gamePlan={gamePlan}
                                gamePlanLayouts={gamePlanLayouts}
                                playBuckets={playBuckets}
                                playCategories={playCategories}
                                onAddSection={(newLayouts) => onUpdateLayouts(newLayouts)}
                                onUpdatePlay={onUpdatePlay}
                                onUpdateGamePlan={onUpdateGamePlan}
                                currentWeek={currentWeek}
                            />
                        </div>
                    </div>

                    {/* Play Selector Modal */}
                    {/* Play Selector Modal */}
                    {renderPlaySelector()}
                    {renderSectionConfigurationModal()}
                    {renderBoxEditorModal()}
                    {/* Standardized Play Details Modal */}
                    {assignmentModalState && (() => {
                        const { playId } = assignmentModalState;
                        const play = plays.find(p => p.id === playId);
                        if (!play) return null;
                        const assignedSits = getPlaySituations(playId);
                        const assignedIds = new Set(assignedSits.map(s => s.id));
                        return (
                            <PlayDetailsModal
                                playId={playId}
                                plays={plays}
                                gamePlanLayouts={gamePlanLayouts}
                                assignedIds={assignedIds}
                                onUpdatePlay={onUpdatePlay}
                                onAssignSituation={handleAssignPlayToSituation}
                                playBuckets={playBuckets}
                                playCategories={playCategories}
                                currentWeek={currentWeek}
                                onClose={() => setAssignmentModalState(null)}
                            />
                        );
                    })()}

                    {/* Import Modal */}
                    {showImportModal && (
                        <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 10000 }}>
                            <div className="card" style={{ width: '400px', padding: '1.5rem', background: 'white' }}>
                                <h3>Import Game Plan</h3>
                                <p>Select a week to copy Game Plan & Call Sheet from. <strong>This will overwrite current data.</strong></p>
                                <select
                                    className="form-select"
                                    value={importSourceWeekId}
                                    onChange={e => setImportSourceWeekId(e.target.value)}
                                    style={{ marginBottom: '1rem', width: '100%' }}
                                >
                                    <option value="">Select Week...</option>
                                    {weeks.filter(w => w.id !== currentWeek.id).map(w => (
                                        <option key={w.id} value={w.id}>{w.name}</option>
                                    ))}
                                </select>
                                <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '8px' }}>
                                    <button className="btn" onClick={() => setShowImportModal(false)}>Cancel</button>
                                    <button className="btn btn-primary" onClick={handleImportGamePlan} disabled={!importSourceWeekId}>Import</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Print Preview Modal */}
                    {showPrintPreview && ReactDOM.createPortal(
                        <div className="print-preview-modal-wrapper print-only-portal" style={{
                            position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
                            background: 'white', zIndex: 9999,
                            display: 'flex', flexDirection: 'column'
                        }}>
                            {/* Header with tab selector and controls */}
                            <div className="print-preview-header" style={{
                                background: '#1e293b', // darker background
                                padding: '1rem',
                                borderBottom: '1px solid #334155',
                                display: 'flex',
                                flexDirection: 'row',
                                justifyContent: 'space-between',
                                alignItems: 'center',
                                gap: '1rem',
                                flexWrap: 'wrap'
                            }}>
                                {/* Left: Navigation Tabs */}
                                <div style={{
                                    display: 'flex',
                                    gap: '0.25rem',
                                    overflowX: 'auto',
                                    paddingBottom: '4px',
                                    flex: 1,
                                    minWidth: 0 // Allow shrinking
                                }}>
                                    {[
                                        { id: 'staples', label: 'STAPLES' },
                                        { id: 'priority', label: 'PRIORITY PLAYS' },
                                        { id: 'sheet', label: 'SITUATIONS & SCRIPTS' },
                                        { id: 'matrix', label: "STRIKE 'EM OUT" },
                                        { id: 'fzdnd', label: 'FZDnD' },
                                        { id: 'player-touches', label: 'PLAYER TOUCHES' }
                                    ].map(tab => (
                                        <button
                                            key={tab.id}
                                            className={`btn`}
                                            onClick={() => setPrintPreviewTab(tab.id)}
                                            style={{
                                                fontSize: '0.85rem',
                                                padding: '0.5rem 1rem',
                                                borderRadius: '6px',
                                                border: '1px solid',
                                                borderColor: printPreviewTab === tab.id ? 'rgba(255,255,255,0.2)' : 'transparent',
                                                background: printPreviewTab === tab.id ? 'var(--primary)' : 'transparent',
                                                color: printPreviewTab === tab.id ? 'white' : '#94a3b8',
                                                fontWeight: printPreviewTab === tab.id ? '600' : '500',
                                                whiteSpace: 'nowrap',
                                                cursor: 'pointer',
                                                transition: 'all 0.2s ease'
                                            }}
                                        >
                                            {tab.label}
                                        </button>
                                    ))}
                                </div>

                                {/* Right: Controls (Scale, Print, Close) */}
                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.75rem', flexShrink: 0 }}>
                                    {/* Scale Dropdown */}
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', background: 'rgba(255,255,255,0.05)', padding: '0.25rem 0.75rem', borderRadius: '6px' }}>
                                        <label style={{ color: '#94a3b8', fontSize: '0.8rem', fontWeight: 500 }}>Scale:</label>
                                        <select
                                            value={printScale}
                                            onChange={(e) => setPrintScale(Number(e.target.value))}
                                            style={{
                                                background: 'transparent',
                                                color: 'white',
                                                border: 'none',
                                                fontSize: '0.9rem',
                                                cursor: 'pointer',
                                                outline: 'none',
                                                padding: '0.25rem'
                                            }}
                                        >
                                            <option value={0.5}>50%</option>
                                            <option value={0.75}>75%</option>
                                            <option value={0.85}>85%</option>
                                            <option value={1}>100%</option>
                                        </select>
                                    </div>

                                    {/* Print Button */}
                                    <button
                                        className="btn btn-primary"
                                        onClick={() => window.print()}
                                        style={{
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '0.5rem',
                                            padding: '0.5rem 1rem',
                                            boxShadow: '0 2px 4px rgba(0,0,0,0.2)'
                                        }}
                                    >
                                        <Icon name="Printer" size={16} />
                                        <span>PRINT</span>
                                    </button>

                                    {/* Close Button */}
                                    <button
                                        className="btn btn-secondary"
                                        onClick={() => setShowPrintPreview(false)}
                                        style={{
                                            width: '32px',
                                            height: '32px',
                                            padding: 0,
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            borderRadius: '50%',
                                            background: 'rgba(255,255,255,0.1)',
                                            color: 'white',
                                            border: 'none'
                                        }}
                                    >
                                        <Icon name="X" size={18} />
                                    </button>
                                </div>
                            </div>


                            {/* Print content area */}
                            <div className="print-preview-content" style={{ flex: 1, overflow: 'auto', background: 'white', padding: '2rem' }}>
                                <div style={{ zoom: printScale, transformOrigin: 'top left' }}>
                                    {printPreviewTab === 'staples' && renderStaples()}
                                    {printPreviewTab === 'priority' && renderPriorityPlays()}
                                    {printPreviewTab === 'sheet' && renderSheetView()}
                                    {printPreviewTab === 'matrix' && renderMatrix()}
                                    {printPreviewTab === 'fzdnd' && renderFZDnDView()}
                                    {printPreviewTab === 'player-touches' && renderPlayerTouches()}
                                </div>
                            </div>
                        </div>,
                        document.body
                    )}

                </div >
            );
        };



        // REMOVED FEATURES (available in git history):
        // - JerseyLottery (~267 lines)  
        // - EquipmentManager (~616 lines)
        // To restore: check git history before this commit

        // --- RBAC CONSTANTS & HELPERS ---
        // --- RBAC CONSTANTS & HELPERS ---
        const ROLES = [
            'Head Coach',
            'Assistant',
            'Student Manager',
            'Trainer',
            'Stats',
            'Player'
        ];

        const FEATURES = [
            { id: 'dashboard', label: 'Program Dashboard (Focus/Injuries)' },
            { id: 'playbook', label: 'Playbook' },
            { id: 'callsheet', label: 'Call Sheet & Game Planning' },
            { id: 'install', label: 'Install Schedule' },
            { id: 'scripts', label: 'Practice Scripts' },
            { id: 'depth', label: 'Depth Charts' },
            { id: 'recruiting', label: 'Recruiting Board' },
            { id: 'staff', label: 'Staff Management' },
            { id: 'settings', label: 'Settings & Config' }
        ];

        const DEFAULT_PERMISSIONS = {
            'Head Coach': {
                dashboard: { view: true, edit: true },
                playbook: { view: true, edit: true },
                callsheet: { view: true, edit: true },
                install: { view: true, edit: true },
                scripts: { view: true, edit: true },
                depth: { view: true, edit: true },
                recruiting: { view: true, edit: true },
                staff: { view: true, edit: true },
                settings: { view: true, edit: true }
            },
            'Assistant': {
                dashboard: { view: true, edit: true },
                playbook: { view: true, edit: true },
                callsheet: { view: true, edit: true },
                install: { view: true, edit: true },
                scripts: { view: true, edit: true },
                depth: { view: true, edit: true },
                recruiting: { view: true, edit: true },
                staff: { view: true, edit: false },
                settings: { view: false, edit: false }
            },
            'Student Manager': {
                dashboard: { view: true, edit: false },
                playbook: { view: false, edit: false },
                callsheet: { view: false, edit: false },
                install: { view: true, edit: false },
                scripts: { view: true, edit: true }, // Help with logistics
                depth: { view: true, edit: false },
                recruiting: { view: false, edit: false },
                staff: { view: false, edit: false },
                settings: { view: false, edit: false }
            },
            'Trainer': {
                dashboard: { view: true, edit: true }, // Update injuries
                playbook: { view: false, edit: false },
                callsheet: { view: false, edit: false },
                install: { view: false, edit: false },
                scripts: { view: false, edit: false },
                depth: { view: true, edit: false },
                recruiting: { view: false, edit: false },
                staff: { view: true, edit: false }, // View contact info
                settings: { view: false, edit: false }
            },
            'Stats': {
                dashboard: { view: true, edit: false },
                playbook: { view: true, edit: false },
                callsheet: { view: true, edit: false },
                install: { view: false, edit: false },
                scripts: { view: true, edit: false },
                depth: { view: true, edit: false },
                recruiting: { view: false, edit: false },
                staff: { view: false, edit: false },
                settings: { view: false, edit: false }
            },
            'Player': {
                dashboard: { view: true, edit: false },
                playbook: { view: true, edit: false },
                callsheet: { view: false, edit: false },
                install: { view: true, edit: false },
                scripts: { view: false, edit: false },
                depth: { view: true, edit: false },
                recruiting: { view: false, edit: false },
                staff: { view: false, edit: false },
                settings: { view: false, edit: false }
            }
        };

        const SchoolManagement = ({ currentUser, schoolId }) => {
            const [createLoading, setCreateLoading] = useState(false);
            const [joinLoading, setJoinLoading] = useState(false);
            const [joinInput, setJoinInput] = useState('');
            const [createAccessCode, setCreateAccessCode] = useState('');
            const [createMascot, setCreateMascot] = useState(''); // New: Mascot Input
            const [importData, setImportData] = useState(false); // Changed: Opt-in to data copy
            const [error, setError] = useState('');

            const handleCreateSchool = async () => {
                if (!createAccessCode.trim()) {
                    setError("Admin Access Code is required.");
                    return;
                }

                if (!confirm(importData
                    ? "This will copy your current workspace data to the new School Database. Proceed?"
                    : "You are creating a new empty school. Proceed?")) return;
                setCreateLoading(true);
                setError('');

                try {
                    // VERIFY ACCESS CODE
                    // In a real app, use a Cloud Function. Here, we check a secured Firestore doc or a hardcoded fallback.
                    let isValid = false;
                    try {
                        const configDoc = await window.db.collection('config').doc('access').get();
                        if (configDoc.exists && configDoc.data().createSchoolCode === createAccessCode) {
                            isValid = true;
                        } else if (createAccessCode === 'HEADCOACH101') {
                            // Fallback until config is set
                            isValid = true;
                        }
                    } catch (err) {
                        console.warn("Config check failed, checking fallback", err);
                        if (createAccessCode === 'HEADCOACH101') isValid = true;
                    }

                    if (!isValid) {
                        throw new Error("Invalid Admin Access Code.");
                    }

                    const newSchoolId = `SCH_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
                    const joinCode = Math.random().toString(36).substring(2, 8).toUpperCase(); // Consistent with SchoolSetupWizard

                    // 1. Gather all local data keys
                    const keys = [
                        'oc-dashboard-roster', 'oc-dashboard-plays', 'oc-dashboard-staff',
                        'oc-dashboard-depthchart', 'oc-dashboard-master-tasks', 'attendance_log',
                        'oc-dashboard-equipment-inventory', 'oc-dashboard-equipment-checkouts',
                        'formationLayouts', 'oc-dashboard-ratings', 'oc-dashboard-summer-comp',
                        'oc-dashboard-equipment-issuance', 'oc-dashboard-equipment-wishlist',
                        'athlete_assessments', 'oc-dashboard-formations', 'oc-dashboard-zone-philosophies',
                        'oc-dashboard-custom-focus', 'oc-dashboard-duties', 'oc-dashboard-metrics',
                        'fatigue-thresholds', 'position-fatigue-values', 'program_budget_data', 'program_onboarding_data',
                        'oc-dashboard-position-names', 'player_daily_connections', 'player_weight_logs', 'staff_role_tasks',
                        'wiz_ol_library', 'oc-dashboard-weeks'
                    ];

                    const schoolData = {
                        createdAt: new Date().toISOString(),
                        createdBy: currentUser.uid,
                        id: newSchoolId,
                        joinCode: joinCode, // Store Join Code
                        name: "My New School", // Default name
                        settings: {
                            schoolName: "My New School",
                            schoolMascot: createMascot || 'Tigers', // Default if empty
                            teamLogo: localStorage.getItem('oc-dashboard-logo') || '',
                            accentColor: localStorage.getItem('oc-dashboard-accent') || '#3b82f6',
                            theme: localStorage.getItem('oc-dashboard-theme') || 'dark',
                            activeYear: localStorage.getItem('hc-active-year') || '2025',
                            visibleFeatures: JSON.parse(localStorage.getItem('hc-visible-features') || '{}')
                        },
                        // Initialize empty arrays if NOT importing data
                        roster: [],
                        staff: [
                            {
                                id: currentUser.uid,
                                name: currentUser.displayName || 'Head Coach',
                                email: currentUser.email,
                                roles: ['Head Coach', 'Team Admin'], // FORCE ADMIN RIGHTS
                                phone: '',
                                bio: 'School Creator'
                            }
                        ],
                        plays: [],
                        billing: { // Initialize with trial
                            plan: 'premium_trial',
                            trialStartDate: new Date().toISOString(),
                            trialEndDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),
                            status: 'active'
                        }
                    };

                    // Populate schoolData only if importing data
                    if (importData) {
                        keys.forEach(k => {
                            const val = localStorage.getItem(k);
                            if (val) {
                                // Map local keys to cloud keys (reverse of loadUserData logic)
                                // This is a bit manual but necessary
                                if (k === 'oc-dashboard-roster') schoolData.roster = JSON.parse(val);
                                if (k === 'oc-dashboard-plays') schoolData.plays = JSON.parse(val);
                                if (k === 'oc-dashboard-staff') schoolData.staff = JSON.parse(val);
                                if (k === 'oc-dashboard-depthchart') schoolData.depthChart = JSON.parse(val);

                                if (k === 'oc-dashboard-weeks') schoolData.weeks = JSON.parse(val);
                                if (k === 'attendance_log') schoolData.attendance = JSON.parse(val);
                                if (k === 'oc-dashboard-valhalla') schoolData.valhalla = JSON.parse(val);
                                if (k === 'oc-dashboard-equipment-inventory') schoolData.inventory = JSON.parse(val);
                                if (k === 'oc-dashboard-equipment-checkouts') schoolData.checkouts = JSON.parse(val);
                                if (k === 'formationLayouts') schoolData.formationLayouts = JSON.parse(val);
                                if (k === 'oc-dashboard-ratings') schoolData.ratings = JSON.parse(val);

                                if (k === 'oc-dashboard-summer-comp') schoolData.summerComp = JSON.parse(val);

                                if (k === 'oc-dashboard-equipment-issuance') schoolData.issuance = JSON.parse(val);
                                if (k === 'oc-dashboard-equipment-wishlist') schoolData.wishlist = JSON.parse(val);
                                if (k === 'athlete_assessments') schoolData.athleteAssessments = JSON.parse(val);
                                if (k === 'oc-dashboard-formations') schoolData.formations = JSON.parse(val);
                                if (k === 'oc-dashboard-zone-philosophies') schoolData.zonePhilosophies = JSON.parse(val);
                                if (k === 'oc-dashboard-custom-focus') schoolData.customFocus = JSON.parse(val);
                                if (k === 'oc-dashboard-duties') schoolData.duties = JSON.parse(val);
                                if (k === 'oc-dashboard-metrics') schoolData.metrics = JSON.parse(val);
                                if (k === 'fatigue-thresholds') schoolData.fatigueThresholds = JSON.parse(val);
                                if (k === 'position-fatigue-values') schoolData.positionFatigue = JSON.parse(val);
                                if (k === 'program_budget_data') schoolData.budget = JSON.parse(val);
                                if (k === 'program_onboarding_data') schoolData.onboarding = JSON.parse(val);
                                if (k === 'oc-dashboard-position-names') schoolData.positionNames = JSON.parse(val);
                                if (k === 'player_daily_connections') schoolData.dailyConnections = JSON.parse(val);
                                if (k === 'player_weight_logs') schoolData.weightLogs = JSON.parse(val);
                                if (k === 'staff_role_tasks') schoolData.roleTasks = JSON.parse(val);
                                if (k === 'wiz_ol_library') schoolData.wizLib = JSON.parse(val);
                            }
                        });
                    }

                    // 2. Write School Doc
                    await window.db.collection('schools').doc(newSchoolId).set(schoolData);

                    // 3. Update User Doc
                    await window.db.collection('users').doc(currentUser.uid).update({ schoolId: newSchoolId });

                    alert(`School Created! ID: ${newSchoolId}. The app will now reload.`);
                    window.location.reload();

                } catch (e) {
                    console.error(e);
                    setError("Failed to create school: " + e.message);
                } finally {
                    setCreateLoading(false);
                }
            };

            const handleJoinSchool = async () => {
                const input = joinInput.trim();
                if (!input) return;

                setJoinLoading(true);
                setError('');
                try {
                    // Try to find by Join Code first (if len 6)
                    let targetSchoolId = null;
                    let targetSchoolName = '';

                    if (input.length === 6) {
                        try {
                            const querySnapshot = await window.db.collection('schools')
                                .where('joinCode', '==', input.toUpperCase())
                                .limit(1)
                                .get();

                            if (!querySnapshot.empty) {
                                targetSchoolId = querySnapshot.docs[0].id;
                                targetSchoolName = querySnapshot.docs[0].data().name;
                            }
                        } catch (err) {
                            console.log("Join Code lookup failed", err);
                        }
                    }

                    // Fallback to direct ID if not found by code
                    if (!targetSchoolId) {
                        const schoolDoc = await window.db.collection('schools').doc(input).get();
                        if (schoolDoc.exists) {
                            targetSchoolId = schoolDoc.id;
                            targetSchoolName = schoolDoc.data().name || 'Unknown School';
                        }
                    }

                    if (!targetSchoolId) {
                        throw new Error("School not found. Check the Code or ID.");
                    }

                    if (!confirm(`Join ${targetSchoolName}?`)) return;

                    await window.db.collection('users').doc(currentUser.uid).update({ schoolId: targetSchoolId });

                    // Add to member list (optional but good practice)
                    await window.db.collection('schools').doc(targetSchoolId).update({
                        [`memberList.${currentUser.uid}`]: {
                            email: currentUser.email,
                            role: 'viewer', // Default role
                            joinedAt: new Date().toISOString()
                        }
                    });

                    window.location.reload();
                } catch (e) {
                    setError(e.message);
                } finally {
                    setJoinLoading(false);
                }
            };

            const handleLeaveSchool = async () => {
                if (!confirm("Are you sure you want to leave this school? You will revert to your personal workspace.")) return;
                try {
                    await window.db.collection('users').doc(currentUser.uid).update({ schoolId: firebase.firestore.FieldValue.delete() });

                    // CLEAR LOCAL DATA to avoid ghost data
                    const keys = [
                        'oc-dashboard-roster', 'oc-dashboard-plays', 'oc-dashboard-staff',
                        'oc-dashboard-depthchart', 'oc-dashboard-master-tasks', 'attendance_log',
                        'oc-dashboard-equipment-inventory', 'oc-dashboard-equipment-checkouts',
                        'formationLayouts', 'oc-dashboard-ratings', 'oc-dashboard-game-grades', 'oc-dashboard-summer-comp',
                        'oc-dashboard-scouting', 'oc-dashboard-equipment-issuance', 'oc-dashboard-equipment-wishlist',
                        'athlete_assessments', 'oc-dashboard-formations', 'oc-dashboard-zone-philosophies',
                        'oc-dashboard-custom-focus', 'oc-dashboard-duties', 'oc-dashboard-metrics',
                        'fatigue-thresholds', 'position-fatigue-values', 'program_budget_data', 'program_onboarding_data',
                        'oc-dashboard-position-names', 'player_daily_connections', 'player_weight_logs', 'staff_role_tasks',
                        'wiz_ol_library', 'oc-dashboard-weeks',
                        'hc_school_id', 'hc_school_name' // Clear name too
                    ];
                    keys.forEach(k => localStorage.removeItem(k));

                    window.location.reload();
                } catch (e) {
                    console.error("Error leaving school:", e);
                    alert("Error leaving school: " + e.message);
                }
            };

            return (
                <div style={{ padding: '2rem', maxWidth: '800px', margin: '0 auto' }}>

                    <div style={{ marginBottom: '2rem' }}>
                        <h1 style={{ fontSize: '2rem', marginBottom: '0.5rem' }}>Welcome, {currentUser.displayName || 'Coach'}</h1>
                        <p style={{ color: 'var(--text-secondary)' }}>
                            You are currently in your <strong>Personal Workspace</strong>. Data is saved locally.
                        </p>
                    </div>

                    {error && (
                        <div className="alert alert-danger" style={{ marginBottom: '1.5rem' }}>
                            {error}
                        </div>
                    )}

                    {schoolId ? (
                        <div className="card">
                            <h2>Current School</h2>
                            <div style={{ background: 'var(--bg-body)', padding: '1rem', borderRadius: '8px', marginBottom: '1.5rem' }}>
                                <p style={{ fontSize: '0.9rem', color: 'var(--text-secondary)', marginBottom: '0.5rem' }}>School ID</p>
                                <div style={{ display: 'flex', gap: '0.5rem' }}>
                                    <code style={{ flex: 1, padding: '0.5rem', background: 'var(--bg-body)', borderRadius: '4px', border: '1px solid var(--border)' }}>
                                        {schoolId}
                                    </code>
                                    <button className="btn btn-secondary" onClick={() => navigator.clipboard.writeText(schoolId)}>Copy</button>
                                </div>
                                <p style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginTop: '0.5rem' }}>
                                    Share this ID with other coaches so they can join this team.
                                </p>
                            </div>
                            <button className="btn btn-danger" onClick={handleLeaveSchool}>Leave School</button>
                        </div>
                    ) : (
                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '2rem' }}>
                            {/* Create School */}
                            <div className="card">
                                <h2>Create New School</h2>
                                <p style={{ color: 'var(--text-secondary)', marginBottom: '1.5rem' }}>
                                    Convert your personal workspace into a shared Team Database. You will become the admin.
                                </p>
                                <div style={{ marginBottom: '1rem' }}>
                                    <label style={{ display: 'block', marginBottom: '0.5rem', fontSize: '0.9rem' }}>School Mascot</label>
                                    <input
                                        type="text"
                                        className="form-input"
                                        placeholder="e.g. Tigers, Eagles..."
                                        value={createMascot}
                                        onChange={e => setCreateMascot(e.target.value)}
                                        style={{ width: '100%', marginBottom: '1rem' }}
                                    />
                                    <label style={{ display: 'block', marginBottom: '0.5rem', fontSize: '0.9rem' }}>Admin Access Code</label>
                                    <input
                                        type="password"
                                        className="form-input"
                                        placeholder="Required to create school..."
                                        value={createAccessCode}
                                        onChange={e => setCreateAccessCode(e.target.value)}
                                        style={{ width: '100%' }}
                                    />
                                    <label style={{ display: 'flex', alignItems: 'center', marginTop: '1rem', cursor: 'pointer' }}>
                                        <input
                                            type="checkbox"
                                            checked={importData}
                                            onChange={e => setImportData(e.target.checked)}
                                            style={{ marginRight: '0.5rem', width: 'auto' }}
                                        />
                                        <span style={{ fontSize: '0.9rem', color: 'var(--text-primary)' }}>Copy my current workspace data (Optional)</span>
                                    </label>
                                </div>
                                <button
                                    className="btn btn-primary"
                                    onClick={handleCreateSchool}
                                    disabled={createLoading}
                                    style={{ width: '100%' }}
                                >
                                    {createLoading ? 'Creating...' : (importData ? 'Create & Import Data' : 'Create New School')}
                                </button>
                            </div>

                            {/* Join School */}
                            <div className="card">
                                <h2>Join Existing School</h2>
                                <p style={{ color: 'var(--text-secondary)', marginBottom: '1.5rem' }}>
                                    Enter a <strong>Join Code</strong> (from your HC) or a legacy School ID to sync with your team.
                                </p>
                                <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '1rem' }}>
                                    <input
                                        type="text"
                                        className="form-input"
                                        placeholder="Enter 6-digit Join Code..."
                                        value={joinInput}
                                        onChange={e => setJoinInput(e.target.value)}
                                    />
                                    <button
                                        className="btn btn-secondary"
                                        onClick={handleJoinSchool}
                                        disabled={joinLoading || !joinInput}
                                    >
                                        {joinLoading ? 'Joining...' : 'Join'}
                                    </button>
                                </div>
                                {error && <div style={{ color: '#ef4444', fontSize: '0.9rem' }}>{error}</div>}
                            </div>
                        </div>
                    )}
                </div>
            );
        };
        const PermissionsView = ({ permissions, onUpdatePermissions, onResetDefaults }) => {
            const togglePermission = (role, featureId, type) => {
                const newPermissions = JSON.parse(JSON.stringify(permissions));
                if (!newPermissions[role]) newPermissions[role] = {};
                if (!newPermissions[role][featureId]) newPermissions[role][featureId] = { view: false, edit: false };

                newPermissions[role][featureId][type] = !newPermissions[role][featureId][type];

                // Logic: If edit is true, view must be true
                if (type === 'edit' && newPermissions[role][featureId].edit) {
                    newPermissions[role][featureId].view = true;
                }
                // Logic: If view is false, edit must be false
                if (type === 'view' && !newPermissions[role][featureId].view) {
                    newPermissions[role][featureId].edit = false;
                }

                onUpdatePermissions(newPermissions);
            };

            return (
                <div style={{ padding: '2rem', height: '100%', overflowY: 'auto' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '2rem' }}>
                        <div>
                            <h1 style={{ fontSize: '2rem', marginBottom: '0.5rem' }}>Permissions Management</h1>
                            <div style={{ color: 'var(--text-secondary)' }}>Configure View and Edit access for each staff role.</div>
                        </div>
                        <button className="btn btn-outline" onClick={onResetDefaults}>
                            <Icon name="RotateCcw" size={16} /> Reset to Defaults
                        </button>
                    </div>

                    <div className="card" style={{ overflowX: 'auto' }}>
                        <table style={{ width: '100%', borderCollapse: 'collapse', minWidth: '800px' }}>
                            <thead>
                                <tr style={{ borderBottom: '1px solid var(--border)' }}>
                                    <th style={{ textAlign: 'left', padding: '1rem' }}>Feature</th>
                                    {ROLES.map(role => (
                                        <th key={role} style={{ textAlign: 'center', padding: '1rem', minWidth: '120px' }}>
                                            {role.replace(' Coordinator', ' Coord.')}
                                        </th>
                                    ))}
                                </tr>
                            </thead>
                            <tbody>
                                {FEATURES.map(feature => (
                                    <tr key={feature.id} style={{ borderBottom: '1px solid rgba(255,255,255,0.05)' }}>
                                        <td style={{ padding: '1rem', fontWeight: 'bold' }}>{feature.label}</td>
                                        {ROLES.map(role => {
                                            const rolePerms = permissions[role] || DEFAULT_PERMISSIONS[role] || { view: false, edit: false };
                                            const p = rolePerms[feature.id] || { view: false, edit: false };
                                            const isHC = role === 'Head Coach';

                                            return (
                                                <td key={`${role}-${feature.id}`} style={{ padding: '1rem', textAlign: 'center' }}>
                                                    <div style={{ display: 'flex', justifyContent: 'center', gap: '0.5rem' }}>
                                                        <button
                                                            onClick={() => !isHC && togglePermission(role, feature.id, 'view')}
                                                            title="Toggle View"
                                                            style={{
                                                                background: p.view ? 'rgba(59, 130, 246, 0.2)' : 'rgba(255,255,255,0.05)',
                                                                border: p.view ? '1px solid #3b82f6' : '1px solid transparent',
                                                                color: p.view ? '#3b82f6' : 'var(--text-secondary)',
                                                                padding: '4px 8px', borderRadius: '4px', cursor: isHC ? 'default' : 'pointer',
                                                                opacity: isHC ? 0.5 : 1
                                                            }}
                                                        >
                                                            View
                                                        </button>
                                                        <button
                                                            onClick={() => !isHC && togglePermission(role, feature.id, 'edit')}
                                                            title="Toggle Edit"
                                                            style={{
                                                                background: p.edit ? 'rgba(34, 197, 94, 0.2)' : 'rgba(255,255,255,0.05)',
                                                                border: p.edit ? '1px solid #22c55e' : '1px solid transparent',
                                                                color: p.edit ? '#22c55e' : 'var(--text-secondary)',
                                                                padding: '4px 8px', borderRadius: '4px', cursor: isHC ? 'default' : 'pointer',
                                                                opacity: isHC ? 0.5 : 1
                                                            }}
                                                        >
                                                            Edit
                                                        </button>
                                                    </div>
                                                </td>
                                            );
                                        })}
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                </div>
            );
        };


        // PLAYER LOAD MANAGEMENT
        const LOAD_WEIGHTS = [3, 2, 1]; // Slot 1 (3pts), Slot 2 (2pts), Slot 3 (1pt)

        const calculatePlayerLoad = (playerId, depthCharts) => {
            let totalScore = 0;
            const breakdown = [];

            if (!depthCharts || typeof depthCharts !== 'object') return { totalScore, breakdown };

            Object.entries(depthCharts).forEach(([chartKey, positions]) => {
                if (!positions) return;

                // Parse Unit Name from Key (e.g. "V_OFFENSE" -> "Varsity Offense")
                let unitName = chartKey
                    .replace('V_', 'Varsity ')
                    .replace('JV_', 'JV ')
                    .replace('J2_', 'JV2 ')
                    .replace(/_/g, ' '); // Replace all underscores

                // Capitalize each word
                unitName = unitName.replace(/\w\S*/g, (w) => (w.replace(/^\w/, (c) => c.toUpperCase())));

                Object.entries(positions).forEach(([posId, playerIds]) => {
                    if (Array.isArray(playerIds)) {
                        playerIds.forEach((pId, index) => {
                            if (pId === playerId) {
                                const weight = LOAD_WEIGHTS[index] || 1; // Default to 1 if deep depth
                                totalScore += weight;

                                // Determine Role Name if position structure is standard "UNIT_POS"
                                let roleName = posId;
                                if (posId.includes('_')) {
                                    roleName = posId.split('_').pop();
                                }

                                breakdown.push({
                                    unit: unitName,
                                    role: roleName,
                                    weight: weight,
                                    type: index === 0 ? 'Starter' : (index === 1 ? 'Rotation' : 'Depth')
                                });
                            }
                        });
                    }
                });
            });

            return { totalScore, breakdown };
        };

        // POSITION-BASED FATIGUE SYSTEM
        const DEFAULT_POSITION_FATIGUE = {
            // Offense - Moderate fatigue
            'QB': 2, 'RB': 3, 'WR': 2, 'TE': 2,
            'LT': 2, 'LG': 2, 'C': 2, 'RG': 2, 'RT': 2,
            'X': 2, 'Y': 2, 'Z': 2, 'A': 2, // WR positions

            // Defense - Higher fatigue (more physical)
            'DE': 3, 'DT': 3, 'NT': 3, 'LDE': 3, 'RDE': 3, 'LDT': 3, 'RDT': 3,
            'Will': 3, 'Mike': 3, 'WLB': 3, 'MLB': 3, 'SLB': 3,
            'CB': 2, 'LCB': 2, 'RCB': 2, 'FS': 2, 'SS': 2, 'Nickel': 2, 'Nick': 2,

            // Special Teams - High effort/contact positions
            'K': 1, 'P': 1, 'LS': 1, 'PP': 1, // Low fatigue
            'KR': 3, 'Ret': 3, 'R': 3, 'R1': 3, 'R2': 3, // Returners - high
            'Gunner': 3, 'G1': 3, 'G2': 3, // Gunners - high
            'L1': 2, 'L2': 2, 'L3': 2, 'L4': 2, 'L5': 2, // Coverage - moderate
            'R1': 2, 'R2': 2, 'R3': 2, 'R4': 2, 'R5': 2,
            'Rush': 2, 'Jam': 2, 'Front': 2, 'Mid': 2, 'Back': 2, 'Deep': 2,
            'Wing': 2, 'Off': 1,

            // Default for unlisted positions
            'DEFAULT': 1
        };

        const calculatePlayerFatigue = (playerId, depthCharts, positionFatigueWeights = null) => {
            // Read from localStorage if no custom weights provided
            if (!positionFatigueWeights) {
                try {
                    const stored = localStorage.getItem('position-fatigue-values');
                    positionFatigueWeights = stored ? JSON.parse(stored) : DEFAULT_POSITION_FATIGUE;
                } catch (e) {
                    positionFatigueWeights = DEFAULT_POSITION_FATIGUE;
                }
            }

            let totalFatigue = 0;
            const assignments = [];

            if (!depthCharts || typeof depthCharts !== 'object') return { totalFatigue, assignments };

            Object.entries(depthCharts).forEach(([chartKey, positions]) => {
                if (!positions) return;

                // Parse Unit Name
                let unitName = chartKey
                    .replace('V_', 'Varsity ')
                    .replace('JV_', 'JV ')
                    .replace('J2_', 'JV2 ')
                    .replace(/_/g, ' ');
                unitName = unitName.replace(/\w\S*/g, (w) => (w.replace(/^\w/, (c) => c.toUpperCase())));

                Object.entries(positions).forEach(([posId, playerIds]) => {
                    if (Array.isArray(playerIds) && playerIds.includes(playerId)) {
                        // Extract position name from posId (e.g., "OFF_QB" -> "QB")
                        let posName = posId.includes('_') ? posId.split('_').pop() : posId;

                        const fatigueValue = positionFatigueWeights[posName] || positionFatigueWeights['DEFAULT'];
                        totalFatigue += fatigueValue;

                        assignments.push({
                            unit: unitName,
                            position: posName,
                            fatigue: fatigueValue
                        });
                    }
                });
            });

            return { totalFatigue, assignments };
        };

        // Helper: Get Fatigue Color
        const getFatigueColor = (fatigueScore, thresholds = null) => {
            // Read from localStorage if no custom thresholds provided
            if (!thresholds) {
                try {
                    const stored = localStorage.getItem('fatigue-thresholds');
                    thresholds = stored ? JSON.parse(stored) : { moderate: 5, high: 8, veryHigh: 12 };
                } catch (e) {
                    thresholds = { moderate: 5, high: 8, veryHigh: 12 };
                }
            }

            if (fatigueScore >= thresholds.veryHigh) return '#ef4444'; // Red
            if (fatigueScore >= thresholds.high) return '#eab308'; // Yellow
            if (fatigueScore >= thresholds.moderate) return '#f97316'; // Orange
            return '#10b981'; // Green
        };

        // DEFAULT 2025 DATA
        const DEFAULT_ROSTER_2025 = [];

        const DEFAULT_STAFF_2025 = [];

        // Default Formation Presets
        const DEFAULT_FORMATIONS = [
            {
                id: 'blue',
                name: 'Blue',
                description: '2x2 Spread - Balanced receivers',
                positions: [
                    { label: 'LT', x: 35, y: 52 },
                    { label: 'LG', x: 42, y: 52 },
                    { label: 'C', x: 50, y: 52 },
                    { label: 'RG', x: 58, y: 52 },
                    { label: 'RT', x: 65, y: 52 },
                    { label: 'QB', x: 50, y: 58 },
                    { label: 'RB', x: 50, y: 65 },
                    { label: 'X', x: 10, y: 52 },
                    { label: 'Z', x: 90, y: 52 },
                    { label: 'A', x: 70, y: 56 },
                    { label: 'Y', x: 30, y: 56 }
                ]
            },
            {
                id: 'red',
                name: 'Red',
                description: '3x1 Spread - Trips right',
                positions: [
                    { label: 'LT', x: 35, y: 52 },
                    { label: 'LG', x: 42, y: 52 },
                    { label: 'C', x: 50, y: 52 },
                    { label: 'RG', x: 58, y: 52 },
                    { label: 'RT', x: 65, y: 52 },
                    { label: 'QB', x: 50, y: 58 },
                    { label: 'RB', x: 50, y: 65 },
                    { label: 'X', x: 10, y: 52 },
                    { label: 'Z', x: 90, y: 52 },
                    { label: 'A', x: 80, y: 52 },
                    { label: 'Y', x: 85, y: 56 }
                ]
            },
            {
                id: 'green',
                name: 'Green',
                description: '2x2 Spread with tight slot',
                positions: [
                    { label: 'LT', x: 35, y: 52 },
                    { label: 'LG', x: 42, y: 52 },
                    { label: 'C', x: 50, y: 52 },
                    { label: 'RG', x: 58, y: 52 },
                    { label: 'RT', x: 65, y: 52 },
                    { label: 'QB', x: 50, y: 58 },
                    { label: 'RB', x: 50, y: 65 },
                    { label: 'X', x: 10, y: 52 },
                    { label: 'Z', x: 90, y: 52 },
                    { label: 'A', x: 68, y: 53 },
                    { label: 'Y', x: 32, y: 53 }
                ]
            },
            {
                id: 'orange',
                name: 'Orange',
                description: 'Empty backfield 3x2',
                positions: [
                    { label: 'LT', x: 35, y: 52 },
                    { label: 'LG', x: 42, y: 52 },
                    { label: 'C', x: 50, y: 52 },
                    { label: 'RG', x: 58, y: 52 },
                    { label: 'RT', x: 65, y: 52 },
                    { label: 'QB', x: 50, y: 58 },
                    { label: 'X', x: 10, y: 52 },
                    { label: 'Z', x: 90, y: 52 },
                    { label: 'A', x: 80, y: 52 },
                    { label: 'Y', x: 30, y: 56 },
                    { label: 'F', x: 70, y: 60 }
                ]
            },
            {
                id: 'diamond_rt',
                name: 'Diamond Rt',
                description: 'Diamond formation right',
                positions: [
                    { label: 'LT', x: 35, y: 52 },
                    { label: 'LG', x: 42, y: 52 },
                    { label: 'C', x: 50, y: 52 },
                    { label: 'RG', x: 58, y: 52 },
                    { label: 'RT', x: 65, y: 52 },
                    { label: 'QB', x: 50, y: 58 },
                    { label: 'WR', x: 55, y: 45 },
                    { label: 'WR', x: 40, y: 58 },
                    { label: 'WR', x: 70, y: 58 },
                    { label: 'WR', x: 55, y: 72 },
                    { label: 'X', x: 10, y: 52 }
                ]
            },
            {
                id: 'diamond_lt',
                name: 'Diamond Lt',
                description: 'Diamond formation left',
                positions: [
                    { label: 'LT', x: 35, y: 52 },
                    { label: 'LG', x: 42, y: 52 },
                    { label: 'C', x: 50, y: 52 },
                    { label: 'RG', x: 58, y: 52 },
                    { label: 'RT', x: 65, y: 52 },
                    { label: 'QB', x: 50, y: 58 },
                    { label: 'WR', x: 45, y: 45 },
                    { label: 'WR', x: 30, y: 58 },
                    { label: 'WR', x: 60, y: 58 },
                    { label: 'WR', x: 45, y: 72 },
                    { label: 'Z', x: 90, y: 52 }
                ]
            },
            {
                id: 'bunch_rt',
                name: 'Bunch Rt',
                description: 'Bunched receivers right',
                positions: [
                    { label: 'LT', x: 35, y: 52 },
                    { label: 'LG', x: 42, y: 52 },
                    { label: 'C', x: 50, y: 52 },
                    { label: 'RG', x: 58, y: 52 },
                    { label: 'RT', x: 65, y: 52 },
                    { label: 'QB', x: 50, y: 58 },
                    { label: 'RB', x: 50, y: 65 },
                    { label: 'X', x: 10, y: 52 },
                    { label: 'WR', x: 78, y: 52 },
                    { label: 'WR', x: 83, y: 52 },
                    { label: 'WR', x: 88, y: 50 }
                ]
            },
            {
                id: 'bunch_lt',
                name: 'Bunch Lt',
                description: 'Bunched receivers left',
                positions: [
                    { label: 'LT', x: 35, y: 52 },
                    { label: 'LG', x: 42, y: 52 },
                    { label: 'C', x: 50, y: 52 },
                    { label: 'RG', x: 58, y: 52 },
                    { label: 'RT', x: 65, y: 52 },
                    { label: 'QB', x: 50, y: 58 },
                    { label: 'RB', x: 50, y: 65 },
                    { label: 'Z', x: 90, y: 52 },
                    { label: 'WR', x: 22, y: 52 },
                    { label: 'WR', x: 17, y: 52 },
                    { label: 'WR', x: 12, y: 50 }
                ]
            },
            {
                id: 'bright',
                name: 'Bright',
                description: 'Tight formation with TE',
                positions: [
                    { label: 'LT', x: 35, y: 52 },
                    { label: 'LG', x: 42, y: 52 },
                    { label: 'C', x: 50, y: 52 },
                    { label: 'RG', x: 58, y: 52 },
                    { label: 'RT', x: 65, y: 52 },
                    { label: 'QB', x: 50, y: 58 },
                    { label: 'RB', x: 50, y: 65 },
                    { label: 'TE', x: 70, y: 52 },
                    { label: 'X', x: 10, y: 52 },
                    { label: 'Z', x: 90, y: 52 },
                    { label: 'A', x: 80, y: 54 }
                ]
            },
            {
                id: 'rip',
                name: 'Rip',
                description: 'Rip formation',
                positions: [
                    { label: 'LT', x: 35, y: 52 },
                    { label: 'LG', x: 42, y: 52 },
                    { label: 'C', x: 50, y: 52 },
                    { label: 'RG', x: 58, y: 52 },
                    { label: 'RT', x: 65, y: 52 },
                    { label: 'QB', x: 50, y: 58 },
                    { label: 'RB', x: 50, y: 65 },
                    { label: 'X', x: 12, y: 52 },
                    { label: 'Z', x: 88, y: 52 },
                    { label: 'A', x: 72, y: 55 },
                    { label: 'Y', x: 28, y: 55 }
                ]
            },
            {
                id: 'gold',
                name: 'Gold',
                description: 'Gold formation',
                positions: [
                    { label: 'LT', x: 35, y: 52 },
                    { label: 'LG', x: 42, y: 52 },
                    { label: 'C', x: 50, y: 52 },
                    { label: 'RG', x: 58, y: 52 },
                    { label: 'RT', x: 65, y: 52 },
                    { label: 'QB', x: 50, y: 58 },
                    { label: 'RB', x: 50, y: 65 },
                    { label: 'X', x: 10, y: 52 },
                    { label: 'Z', x: 90, y: 52 },
                    { label: 'A', x: 75, y: 56 },
                    { label: 'Y', x: 25, y: 56 }
                ]
            }
        ];


        const GradingModal = ({ cell, currentData, onClose, onSave }) => {
            const [grade, setGrade] = useState(currentData?.grade || 2);
            const [criteria, setCriteria] = useState(currentData?.criteria || {
                alignment: false,
                assignment: false,
                getOff: false,
                finish: false
            });
            const [notes, setNotes] = useState(currentData?.notes || '');

            useEffect(() => {
                if (currentData) {
                    setGrade(currentData.grade);
                    setCriteria(currentData.criteria || {});
                    setNotes(currentData.notes || '');
                } else {
                    setGrade(2);
                    setCriteria({ alignment: false, assignment: false, getOff: false, finish: false });
                    setNotes('');
                }
            }, [currentData]);

            return (
                <div style={{
                    position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
                    background: 'rgba(0,0,0,0.8)', display: 'flex', alignItems: 'center', justifyContent: 'center',
                    zIndex: 1000, backdropFilter: 'blur(5px)'
                }}>
                    <div className="card" style={{ width: '500px', maxWidth: '90%', animation: 'slideIn 0.3s' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '1.5rem', borderBottom: '1px solid var(--border)', paddingBottom: '1rem' }}>
                            <div>
                                <h2>Grade: {cell.player.name}</h2>
                                <div style={{ color: 'var(--text-secondary)', fontSize: '0.9rem' }}>
                                    {cell.play.play.name} • {cell.play.situation.down}&{cell.play.situation.distance}
                                </div>
                            </div>
                            <button onClick={onClose} style={{ background: 'none', border: 'none', color: 'var(--text-secondary)', cursor: 'pointer' }}>
                                <Icon name="X" size={24} />
                            </button>
                        </div>

                        <div style={{ marginBottom: '1.5rem' }}>
                            <label className="form-label" style={{ textAlign: 'center', display: 'block' }}>Performance Grade</label>
                            <div style={{ display: 'flex', gap: '0.5rem' }}>
                                {[0, 1, 2, 3, 4].map(g => (
                                    <button
                                        key={g}
                                        onClick={() => setGrade(g)}
                                        className="btn"
                                        style={{
                                            flex: 1,
                                            background: grade === g ? (g >= 3 ? '#10b981' : g < 2 ? '#ef4444' : '#f59e0b') : 'var(--bg-panel)',
                                            color: grade === g ? 'white' : 'var(--text-primary)',
                                            fontWeight: 'bold',
                                            padding: '1rem',
                                            fontSize: '1.5rem',
                                            border: grade === g ? '2px solid rgba(255,255,255,0.2)' : '1px solid var(--border)'
                                        }}
                                    >
                                        {g}
                                    </button>
                                ))}
                            </div>
                            <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.8rem', marginTop: '0.5rem', color: 'var(--text-secondary)', padding: '0 0.5rem' }}>
                                <span>Critical Error</span>
                                <span>Poor</span>
                                <span>Average</span>
                                <span>Good</span>
                                <span>Dominant</span>
                            </div>
                        </div>

                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginBottom: '1.5rem' }}>
                            {Object.keys(criteria).map(key => (
                                <label key={key} style={{ display: 'flex', alignItems: 'center', gap: '0.75rem', padding: '1rem', background: 'var(--bg-panel)', borderRadius: '6px', cursor: 'pointer', border: criteria[key] ? '1px solid var(--accent)' : '1px solid transparent' }}>
                                    <input
                                        type="checkbox"
                                        checked={criteria[key]}
                                        onChange={(e) => setCriteria({ ...criteria, [key]: e.target.checked })}
                                        style={{ width: '20px', height: '20px', accentColor: 'var(--accent)' }}
                                    />
                                    <span style={{ textTransform: 'capitalize', fontWeight: '500' }}>{key.replace(/([A-Z])/g, ' $1').trim()}</span>
                                </label>
                            ))}
                        </div>

                        <div style={{ marginBottom: '2rem' }}>
                            <label className="form-label">Notes</label>
                            <textarea
                                className="form-input"
                                rows="3"
                                value={notes}
                                onChange={(e) => setNotes(e.target.value)}
                                placeholder="Add specific coaching points..."
                            />
                        </div>

                        <div style={{ display: 'flex', gap: '1rem' }}>
                            <button className="btn" onClick={onClose} style={{ flex: 1, background: 'var(--bg-panel)' }}>Cancel</button>
                            <button
                                className="btn btn-primary"
                                style={{ flex: 2 }}
                                onClick={() => {
                                    onSave({ grade, criteria, notes });
                                    onClose();
                                }}
                            >
                                <Icon name="Save" size={18} style={{ marginRight: '8px' }} />
                                Save Grade
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const ManageWeekModal = ({ isOpen, onClose, currentWeek, weeks, onUpdateWeek }) => {
            console.log('ManageWeekModal Render: isOpen=', isOpen, 'currentWeek=', currentWeek?.id);
            if (!isOpen) return null;
            if (!currentWeek) {
                console.error('ManageWeekModal: currentWeek is missing');
                return null;
            }

            const [mode, setMode] = React.useState('import'); // 'import' | 'clear'
            const [sourceWeekId, setSourceWeekId] = React.useState('');
            const [selections, setSelections] = React.useState({
                practicePlans: true,
                gamePlan: true, // Includes Scripts & Layouts
                wristbands: true,
                installs: true,
                depthChart: true,
                zonePhilosophies: true
            });

            // Filter available weeks (exclude current)
            const availableWeeks = (weeks || []).filter(w => w.id !== currentWeek.id);

            const handleToggle = (key) => {
                setSelections(prev => ({ ...prev, [key]: !prev[key] }));
            };

            const handleImport = () => {
                if (!sourceWeekId) return;
                const sourceWeek = weeks.find(w => w.id === sourceWeekId);
                if (!sourceWeek) return;

                const updates = {};

                if (selections.practicePlans) {
                    const newPlans = {};
                    Object.entries(sourceWeek.practicePlans || {}).forEach(([day, plan]) => {
                        newPlans[day] = {
                            ...JSON.parse(JSON.stringify(plan)),
                            id: Date.now().toString() + Math.random().toString(36).substr(2, 5) + day,
                            date: currentWeek.practicePlans[day]?.date || plan.date
                        };
                    });
                    updates.practicePlans = newPlans;
                }

                if (selections.gamePlan) {
                    updates.offensiveGamePlan = JSON.parse(JSON.stringify(sourceWeek.offensiveGamePlan || { sets: [] }));
                    updates.dumbCallSheetData = JSON.parse(JSON.stringify(sourceWeek.dumbCallSheetData || {}));
                }

                if (selections.wristbands) {
                    updates.wristbands = JSON.parse(JSON.stringify(sourceWeek.wristbands));
                }

                if (selections.installs) {
                    updates.installList = [...(sourceWeek.installList || [])];
                }

                if (selections.depthChart) {
                    updates.depthChart = JSON.parse(JSON.stringify(sourceWeek.depthChart));
                }

                if (selections.zonePhilosophies) {
                    updates.zonePhilosophies = JSON.parse(JSON.stringify(sourceWeek.zonePhilosophies));
                }

                if (Object.keys(updates).length > 0) {
                    onUpdateWeek(currentWeek.id, 'bulk_update', updates);
                }
                onClose();
            };

            const handleClear = () => {
                const updates = {};

                if (selections.practicePlans) {
                    const resetPlans = {};
                    ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'].forEach(day => {
                        resetPlans[day] = {
                            id: Date.now().toString() + Math.random().toString(36).substr(2, 5) + day,
                            date: (currentWeek.practicePlans[day]?.date) || new Date().toISOString().split('T')[0],
                            startTime: '15:40',
                            segments: []
                        };
                    });
                    updates.practicePlans = resetPlans;
                }

                if (selections.gamePlan) {
                    updates.offensiveGamePlan = { sets: [] };
                    updates.dumbCallSheetData = {};
                }

                if (selections.wristbands) {
                    updates.wristbands = {
                        card1: { type: 'standard', opp: '', iter: '1', rows: [] },
                        card2: { type: 'standard', opp: '', iter: '1', rows: [] },
                        card3: { type: 'wiz', opp: '', iter: '1', rows: [] },
                        staples: { type: 'staples', opp: '', iter: '1', rows: [] }
                    };
                }

                if (selections.installs) updates.installList = [];
                if (selections.depthChart) updates.depthChart = {};
                if (selections.zonePhilosophies) updates.zonePhilosophies = {};

                if (Object.keys(updates).length > 0) {
                    onUpdateWeek(currentWeek.id, 'bulk_update', updates);
                }
                onClose();
            };

            return (
                <div style={{
                    position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
                    background: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 10000
                }}>
                    <div className="card" style={{ width: '500px', padding: '1.5rem', background: '#1e293b', color: 'white', maxHeight: '90vh', overflowY: 'auto', border: '1px solid #334155' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                            <h2 style={{ margin: 0 }}>Manage Week</h2>
                            <button onClick={onClose} style={{ background: 'none', border: 'none', cursor: 'pointer' }}><Icon name="X" size={24} /></button>
                        </div>

                        <div style={{ display: 'flex', gap: '1rem', marginBottom: '1.5rem' }}>
                            <button
                                onClick={() => setMode('import')}
                                style={{
                                    flex: 1, padding: '0.75rem', borderRadius: '8px', fontWeight: 'bold',
                                    background: mode === 'import' ? 'var(--primary)' : '#334155',
                                    color: mode === 'import' ? 'white' : '#94a3b8',
                                    border: '1px solid #475569'
                                }}
                            >
                                Import from Previous
                            </button>
                            <button
                                onClick={() => setMode('clear')}
                                style={{
                                    flex: 1, padding: '0.75rem', borderRadius: '8px', fontWeight: 'bold',
                                    background: mode === 'clear' ? '#ef4444' : '#334155',
                                    color: mode === 'clear' ? 'white' : '#94a3b8',
                                    border: '1px solid #475569'
                                }}
                            >
                                Start from Scratch
                            </button>
                        </div>

                        {mode === 'import' && (
                            <div>
                                <div style={{ marginBottom: '1rem' }}>
                                    <label style={{ display: 'block', fontWeight: 'bold', marginBottom: '0.5rem' }}>Select Source Week</label>
                                    <select
                                        className="form-input"
                                        style={{ background: '#334155', color: 'white', border: '1px solid #475569' }}
                                        value={sourceWeekId}
                                        onChange={(e) => setSourceWeekId(e.target.value)}
                                    >
                                        <option value="">-- Select Week --</option>
                                        {availableWeeks.map(w => (
                                            <option key={w.id} value={w.id}>Week {w.weekNum} - {w.name} {w.opponent ? `vs ${w.opponent}` : ''}</option>
                                        ))}
                                    </select>
                                </div>

                                {sourceWeekId && (
                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                                        <label style={{ fontWeight: 'bold' }}>Select Data to Import:</label>
                                        {[
                                            { id: 'practicePlans', label: 'Practice Plans' },
                                            { id: 'gamePlan', label: 'Game Plan & Scripts' },
                                            { id: 'wristbands', label: 'Wristbands' },
                                            { id: 'installs', label: 'Install List' },
                                            { id: 'depthChart', label: 'Depth Charts' },
                                            { id: 'zonePhilosophies', label: 'Zone Philosophies' }
                                        ].map(item => (
                                            <label key={item.id} style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', cursor: 'pointer' }}>
                                                <input
                                                    type="checkbox"
                                                    checked={selections[item.id]}
                                                    onChange={() => handleToggle(item.id)}
                                                    style={{ width: '18px', height: '18px' }}
                                                />
                                                {item.label}
                                            </label>
                                        ))}
                                    </div>
                                )}

                                <div style={{ marginTop: '1.5rem', display: 'flex', justifyContent: 'flex-end' }}>
                                    <button
                                        className="btn btn-primary"
                                        disabled={!sourceWeekId}
                                        onClick={handleImport}
                                    >
                                        Import Selected Data
                                    </button>
                                </div>
                            </div>
                        )}

                        {mode === 'clear' && (
                            <div style={{ padding: '1rem' }}>
                                <div style={{ textAlign: 'center', marginBottom: '1.5rem' }}>
                                    <Icon name="AlertTriangle" size={48} color="#ef4444" style={{ marginBottom: '1rem' }} />
                                    <h3 style={{ color: '#ef4444', marginTop: 0 }}>Clear Selected Data</h3>
                                    <p>Select the items you want to reset. <br /><strong>Warning: This action is irreversible.</strong></p>
                                </div>

                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem', marginBottom: '1.5rem' }}>
                                    <label style={{ fontWeight: 'bold' }}>Select Data to Clear:</label>
                                    {[
                                        { id: 'practicePlans', label: 'Practice Plans' },
                                        { id: 'gamePlan', label: 'Game Plan & Scripts' },
                                        { id: 'wristbands', label: 'Wristbands' },
                                        { id: 'installs', label: 'Install List' },
                                        { id: 'depthChart', label: 'Depth Charts' },
                                        { id: 'zonePhilosophies', label: 'Zone Philosophies' }
                                    ].map(item => (
                                        <label key={item.id} style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', cursor: 'pointer' }}>
                                            <input
                                                type="checkbox"
                                                checked={selections[item.id]}
                                                onChange={() => handleToggle(item.id)}
                                                style={{ width: '18px', height: '18px' }}
                                            />
                                            {item.label}
                                        </label>
                                    ))}
                                </div>

                                <button
                                    className="btn"
                                    onClick={handleClear}
                                    style={{ background: '#ef4444', color: 'white', width: '100%', padding: '1rem', fontWeight: 'bold' }}
                                >
                                    Clear Selected Data
                                </button>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const GameWeekOverview = ({ week, weeks, onUpdateWeek, teamLogo, isLocked }) => {

            const [addEventModal, setAddEventModal] = useState(null); // { day: 'monday' } or null
            const [editingEvent, setEditingEvent] = useState(null); // { day, eventId, event } or null
            const [exportMode, setExportMode] = useState(false);

            const overview = week.overview || {};

            // Ensure structure
            if (!overview.dailySchedule) {
                overview.dailySchedule = {
                    monday: { events: [] },
                    tuesday: { events: [] },
                    wednesday: { events: [] },
                    thursday: { events: [] },
                    friday: { events: [] },
                    saturday: { events: [] }
                };
            }

            // Sync practices from practice plans
            useEffect(() => {
                if (!week.practicePlans) return;

                const DAYS = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
                let hasChanges = false;
                const newDailySchedule = JSON.parse(JSON.stringify(overview.dailySchedule));

                DAYS.forEach(day => {
                    const plan = week.practicePlans[day];
                    const autoId = `auto-practice-${day}`;
                    const existingIndex = newDailySchedule[day].events.findIndex(e => e.id === autoId);

                    if (plan && plan.startTime) {
                        // Calculate end time
                        let endTime = '';
                        try {
                            const [h, m] = plan.startTime.split(':').map(Number);
                            let totalMinutes = (h * 60) + m;
                            totalMinutes += parseInt(plan.warmupDuration || 0);
                            if (plan.segments && Array.isArray(plan.segments)) {
                                plan.segments.forEach(s => totalMinutes += parseInt(s.duration || 0));
                            }
                            const endH = Math.floor(totalMinutes / 60);
                            const endM = totalMinutes % 60;
                            endTime = `${endH.toString().padStart(2, '0')}:${endM.toString().padStart(2, '0')}`;
                        } catch (e) { endTime = 'TBD'; }

                        const practiceEvent = {
                            id: autoId,
                            type: 'practice',
                            level: 'Varsity',
                            start: plan.startTime,
                            end: endTime,
                            notes: plan.focus || '',
                            autoPopulated: true
                        };

                        if (existingIndex >= 0) {
                            const existing = newDailySchedule[day].events[existingIndex];
                            if (existing.start !== practiceEvent.start || existing.end !== practiceEvent.end || existing.notes !== practiceEvent.notes) {
                                newDailySchedule[day].events[existingIndex] = practiceEvent;
                                hasChanges = true;
                            }
                        } else {
                            newDailySchedule[day].events.unshift(practiceEvent);
                            hasChanges = true;
                        }
                    } else if (existingIndex >= 0) {
                        // Remove if plan was cleared
                        newDailySchedule[day].events.splice(existingIndex, 1);
                        hasChanges = true;
                    }
                });

                if (hasChanges) {
                    onUpdateWeek(week.id, 'overview', { ...overview, dailySchedule: newDailySchedule });
                }
            }, [week.practicePlans]);

            const DAYS = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
            const DAY_LABELS = { monday: 'Monday', tuesday: 'Tuesday', wednesday: 'Wednesday', thursday: 'Thursday', friday: 'Friday', saturday: 'Saturday' };

            const handleExport = () => {
                setExportMode(true);
                setTimeout(() => {
                    window.print();
                    setExportMode(false);
                }, 500);
            };

            const getEventColor = (type) => {
                if (type === 'practice') return '#3b82f6';
                if (type === 'game') return '#ef4444';
                return '#10b981';
            };

            return (
                <div style={{ padding: '1rem', maxWidth: '1000px', margin: '0 auto' }}>
                    <div className="no-print" style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                        <h1>Week {week.weekNum} Overview</h1>
                        <div style={{ display: 'flex', gap: '1rem' }}>

                            <button className="btn btn-primary" onClick={handleExport}>
                                <Icon name="Printer" size={18} style={{ marginRight: '8px' }} />
                                Export for SportsYou
                            </button>
                        </div>
                    </div>

                    <div id="game-week-print-area">
                        {/* Header Info */}
                        <div style={{ background: '#1e293b', color: 'white', padding: '1.5rem', borderRadius: '12px', marginBottom: '1.5rem', textAlign: 'center' }}>
                            <div style={{ marginBottom: '1.5rem', display: 'flex', justifyContent: 'center', alignItems: 'center', gap: '1rem' }}>
                                <label style={{ color: 'var(--accent)', fontWeight: 'bold' }}>Game Date:</label>
                                <input
                                    type="date"
                                    className="form-input"
                                    style={{ width: 'auto', background: 'rgba(255,255,255,0.1)', color: 'white', border: '1px solid var(--accent)' }}
                                    value={week.date || ''}
                                    onChange={(e) => onUpdateWeek(week.id, 'date', e.target.value)}
                                />
                            </div>
                            <div style={{ fontSize: '0.9rem', textTransform: 'uppercase', letterSpacing: '0.1em', color: 'var(--accent)', fontWeight: '800', marginBottom: '0.5rem' }}>
                                Motivational Focus
                            </div>
                            <div className="no-print">
                                <textarea
                                    className="form-input"
                                    style={{ background: 'rgba(255,255,255,0.1)', color: 'white', border: 'none', textAlign: 'center', fontSize: '1.25rem', fontWeight: 'bold' }}
                                    value={overview.messageOfWeek || ''}
                                    placeholder="Enter Message of the Week..."
                                    onChange={(e) => onUpdateWeek(week.id, 'overview', { ...overview, messageOfWeek: e.target.value })}
                                />
                            </div>
                            <div className="print-only" style={{ fontSize: '1.5rem', fontWeight: 'bold', fontStyle: 'italic' }}>
                                "{overview.messageOfWeek || 'Win The Day'}"
                            </div>
                        </div>

                        {/* Daily Schedule */}
                        <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                            {DAYS.map(day => {
                                const daySchedule = overview.dailySchedule[day];
                                const hasMeal = day === 'thursday' && overview.meal && (overview.meal.host || overview.meal.time);

                                return (
                                    <div key={day} className="card" style={{ padding: '1.25rem', borderLeft: '6px solid var(--accent)' }}>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                            <h2 style={{ margin: 0, fontSize: '1.5rem' }}>{DAY_LABELS[day]}</h2>
                                            <button className="btn no-print" onClick={() => setAddEventModal({ day })} disabled={isLocked}>
                                                <Icon name="Plus" size={16} style={{ marginRight: '6px' }} />
                                                Add Event
                                            </button>
                                        </div>

                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                                            {daySchedule.events.map(event => (
                                                <div key={event.id} style={{
                                                    padding: '1rem',
                                                    background: 'var(--bg-panel)',
                                                    borderRadius: '10px',
                                                    borderLeft: `5px solid ${getEventColor(event.type)}`,
                                                    display: 'flex',
                                                    justifyContent: 'space-between',
                                                    alignItems: 'center'
                                                }}>
                                                    <div>
                                                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '0.25rem' }}>
                                                            <span style={{ fontSize: '0.7rem', fontWeight: '800', textTransform: 'uppercase', background: getEventColor(event.type), color: 'white', padding: '2px 8px', borderRadius: '4px' }}>
                                                                {event.type === 'practice' ? 'Practice' : event.type === 'game' ? `${event.level} Game` : 'Event'}
                                                            </span>
                                                            {event.autoPopulated && <span style={{ fontSize: '0.75em', color: 'var(--text-secondary)', fontStyle: 'italic' }}>(Auto)</span>}
                                                        </div>

                                                        {event.type === 'practice' && (
                                                            <div style={{ fontSize: '1.1rem', fontWeight: '800' }}>
                                                                {event.start} - {event.end} {event.notes && <span style={{ fontWeight: 'normal', color: 'var(--text-secondary)', marginLeft: '0.5rem' }}>| {event.notes}</span>}
                                                            </div>
                                                        )}

                                                        {event.type === 'game' && (
                                                            <div>
                                                                <div style={{ fontSize: '1.1rem', fontWeight: '800' }}>
                                                                    {event.isHome ? '🏠 Home' : '🚌 Away'} vs {event.opponent}
                                                                </div>
                                                                <div style={{ display: 'flex', gap: '1rem', fontSize: '0.9rem', flexWrap: 'wrap', marginTop: '0.25rem' }}>
                                                                    <span>⏱️ Kickoff: <strong>{event.kickoff}</strong></span>
                                                                    {!event.isHome && <span>🚌 Bus: <strong>{event.busTime}</strong></span>}
                                                                    {!event.isHome && event.dismissalTime && <span style={{ color: '#f59e0b', fontWeight: '800' }}>⚠️ Dismiss: {event.dismissalTime}</span>}
                                                                    <span style={{ color: 'var(--text-secondary)' }}>📍 {event.location}</span>
                                                                </div>
                                                                <div style={{ display: 'flex', gap: '0.5rem', marginTop: '0.5rem' }}>
                                                                    <span style={{ fontSize: '0.8rem', background: 'var(--bg-app)', border: '1px solid var(--border)', padding: '2px 8px', borderRadius: '4px' }}>👕 {event.uniforms?.jersey} Jersey</span>
                                                                    <span style={{ fontSize: '0.8rem', background: 'var(--bg-app)', border: '1px solid var(--border)', padding: '2px 8px', borderRadius: '4px' }}>👖 {event.uniforms?.pants} Pants</span>
                                                                </div>
                                                            </div>
                                                        )}

                                                        {event.type === 'custom' && (
                                                            <div>
                                                                <div style={{ fontSize: '1.1rem', fontWeight: '800' }}>{event.title}</div>
                                                                <div style={{ fontSize: '0.9rem', color: 'var(--text-secondary)' }}>
                                                                    ⏰ {event.time} | 📍 {event.location}
                                                                </div>
                                                                {event.notes && <div style={{ fontSize: '0.85rem', marginTop: '0.25rem' }}>{event.notes}</div>}
                                                            </div>
                                                        )}
                                                    </div>

                                                    {!event.autoPopulated && !isLocked && (
                                                        <div className="no-print" style={{ display: 'flex', gap: '0.5rem' }}>
                                                            <button className="btn" onClick={() => setEditingEvent({ day, eventId: event.id, event })} style={{ padding: '4px 8px' }}>
                                                                <Icon name="Edit" size={14} />
                                                            </button>
                                                            <button className="btn" style={{ padding: '4px 8px', color: '#ef4444' }} onClick={() => {
                                                                if (confirm('Delete event?')) {
                                                                    const newSchedule = { ...overview.dailySchedule };
                                                                    newSchedule[day].events = newSchedule[day].events.filter(e => e.id !== event.id);
                                                                    onUpdateWeek(week.id, 'overview', { ...overview, dailySchedule: newSchedule });
                                                                }
                                                            }}>
                                                                <Icon name="Trash2" size={14} />
                                                            </button>
                                                        </div>
                                                    )}
                                                </div>
                                            ))}

                                            {hasMeal && (
                                                <div style={{ padding: '1rem', background: '#fefce8', borderRadius: '10px', borderLeft: '5px solid #eab308' }}>
                                                    <div style={{ fontSize: '0.7rem', fontWeight: '800', textTransform: 'uppercase', background: '#eab308', color: 'white', padding: '2px 8px', borderRadius: '4px', width: 'fit-content', marginBottom: '0.5rem' }}>
                                                        Team Meal
                                                    </div>
                                                    <div style={{ fontSize: '1.1rem', fontWeight: '800' }}>
                                                        🍴 {overview.meal.time} {overview.meal.host && <span style={{ fontWeight: 'normal', color: '#854d0e', marginLeft: '0.5rem' }}>@ {overview.meal.host}</span>}
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>

                    {(addEventModal || editingEvent) && (
                        <EventModal
                            day={addEventModal?.day || editingEvent?.day}
                            event={editingEvent?.event}
                            onClose={() => { setAddEventModal(null); setEditingEvent(null); }}
                            onSave={(data) => {
                                const newSchedule = { ...overview.dailySchedule };
                                if (editingEvent) {
                                    const idx = newSchedule[editingEvent.day].events.findIndex(e => e.id === editingEvent.eventId);
                                    newSchedule[editingEvent.day].events[idx] = { ...data, id: editingEvent.eventId };
                                } else {
                                    newSchedule[addEventModal.day].events.push({ ...data, id: `manual-${Date.now()}` });
                                }
                                onUpdateWeek(week.id, 'overview', { ...overview, dailySchedule: newSchedule });
                                setAddEventModal(null);
                                setEditingEvent(null);
                            }}
                        />
                    )}
                </div>
            );
        };

        const EventModal = ({ day, event, onClose, onSave }) => {
            const [type, setType] = useState(event?.type || 'game');
            const [level, setLevel] = useState(event?.level || 'JV');
            const [isHome, setIsHome] = useState(event?.isHome !== undefined ? event.isHome : true);
            const [opponent, setOpponent] = useState(event?.opponent || '');
            const [kickoff, setKickoff] = useState(event?.kickoff || '');
            const [busTime, setBusTime] = useState(event?.busTime || '');
            const [dismissalTime, setDismissalTime] = useState(event?.dismissalTime || '');
            const [location, setLocation] = useState(event?.location || '');
            const [uniforms, setUniforms] = useState(event?.uniforms || { jersey: 'White', pants: 'Red' });
            const [title, setTitle] = useState(event?.title || '');
            const [time, setTime] = useState(event?.time || '');
            const [notes, setNotes] = useState(event?.notes || '');

            return (
                <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.8)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 2000 }}>
                    <div className="card" style={{ width: '500px', maxWidth: '95%', maxHeight: '90vh', overflowY: 'auto' }}>
                        <h2>{event ? 'Edit' : 'Add'} Event for {day.toUpperCase()}</h2>

                        <div style={{ marginBottom: '1rem' }}>
                            <label className="form-label">Type</label>
                            <div className="btn-group">
                                <button className={`btn ${type === 'game' ? 'btn-primary' : ''}`} onClick={() => setType('game')}>Game</button>
                                <button className={`btn ${type === 'custom' ? 'btn-primary' : ''}`} onClick={() => setType('custom')}>Custom</button>
                            </div>
                        </div>

                        {type === 'game' && (
                            <>
                                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginBottom: '1rem' }}>
                                    <div>
                                        <label className="form-label">Level</label>
                                        <select className="form-select" value={level} onChange={(e) => setLevel(e.target.value)}>
                                            <option>JV</option>
                                            <option>JV2</option>
                                            <option>Varsity</option>
                                            <option>Freshman</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label className="form-label">Location Type</label>
                                        <div className="btn-group">
                                            <button className={`btn ${isHome ? 'btn-primary' : ''}`} onClick={() => setIsHome(true)}>Home</button>
                                            <button className={`btn ${!isHome ? 'btn-primary' : ''}`} onClick={() => setIsHome(false)}>Away</button>
                                        </div>
                                    </div>
                                </div>
                                <div style={{ marginBottom: '1rem' }}>
                                    <label className="form-label">Opponent</label>
                                    <input className="form-input" value={opponent} onChange={(e) => setOpponent(e.target.value)} placeholder="Central High" />
                                </div>
                                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginBottom: '1rem' }}>
                                    <div>
                                        <label className="form-label">Kickoff</label>
                                        <input className="form-input" value={kickoff} onChange={(e) => setKickoff(e.target.value)} placeholder="6:00 PM" />
                                    </div>
                                    <div>
                                        <label className="form-label">Location</label>
                                        <input className="form-input" value={location} onChange={(e) => setLocation(e.target.value)} placeholder="Stadium" />
                                    </div>
                                </div>
                                {!isHome && (
                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginBottom: '1rem' }}>
                                        <div>
                                            <label className="form-label">Bus Departure</label>
                                            <input className="form-input" value={busTime} onChange={(e) => setBusTime(e.target.value)} placeholder="4:30 PM" />
                                        </div>
                                        <div>
                                            <label className="form-label">Dismissal</label>
                                            <input className="form-input" value={dismissalTime} onChange={(e) => setDismissalTime(e.target.value)} placeholder="2:30 PM" />
                                        </div>
                                    </div>
                                )}
                                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginBottom: '1rem' }}>
                                    <div>
                                        <label className="form-label">Jersey</label>
                                        <select className="form-select" value={uniforms.jersey} onChange={(e) => setUniforms({ ...uniforms, jersey: e.target.value })}>
                                            <option>White</option><option>Red</option><option>Black</option><option>Grey</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label className="form-label">Pants</label>
                                        <select className="form-select" value={uniforms.pants} onChange={(e) => setUniforms({ ...uniforms, pants: e.target.value })}>
                                            <option>White</option><option>Red</option><option>Black</option><option>Grey</option>
                                        </select>
                                    </div>
                                </div>
                            </>
                        )}

                        {type === 'custom' && (
                            <>
                                <div style={{ marginBottom: '1rem' }}>
                                    <label className="form-label">Title</label>
                                    <input className="form-input" value={title} onChange={(e) => setTitle(e.target.value)} placeholder="High-Five Friday" />
                                </div>
                                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginBottom: '1rem' }}>
                                    <div>
                                        <label className="form-label">Time</label>
                                        <input className="form-input" value={time} onChange={(e) => setTime(e.target.value)} placeholder="7:30 AM" />
                                    </div>
                                    <div>
                                        <label className="form-label">Location</label>
                                        <input className="form-input" value={location} onChange={(e) => setLocation(e.target.value)} placeholder="Elementary" />
                                    </div>
                                </div>
                                <div style={{ marginBottom: '1rem' }}>
                                    <label className="form-label">Notes</label>
                                    <textarea className="form-input" value={notes} onChange={(e) => setNotes(e.target.value)} />
                                </div>
                            </>
                        )}

                        <div style={{ display: 'flex', gap: '1rem', marginTop: '1rem' }}>
                            <button className="btn" onClick={onClose} style={{ flex: 1 }}>Cancel</button>
                            <button className="btn btn-primary" style={{ flex: 2 }} onClick={() => onSave({ type, level, isHome, opponent, kickoff, busTime, dismissalTime, location, uniforms, title, time, notes })}>Save</button>
                        </div>
                    </div>

                </div>
            );
        };








        const SeasonSetupView = ({ weeks, onUpdateWeek, onAddWeek, onDeleteWeek, mode = 'season' }) => {
            const getWeekNum = (w) => {
                if (w.weekNum !== undefined) return w.weekNum;
                const match = w.name.match(/Week (\d+)/);
                if (match) return parseInt(match[1]);
                if (w.name === "Week 0") return 0;
                return 99;
            };

            const sortedWeeks = weeks.filter(w => {
                if (mode === 'summer') return w.name.includes("Summer");
                if (mode === 'pre-season') return ["Family Week", "Camp Week", "First Week of Practice", "Week 0"].includes(w.name);
                return (w.name.startsWith("Week ") && !w.name.includes("Summer")) || w.name === "First Week with No Game";
            }).sort((a, b) => getWeekNum(a) - getWeekNum(b));

            const handleAutofillDates = () => {
                if (!confirm('This will autofill dates for subsequent weeks based on the first set date (adding 7 days recursively). Existing dates after the start point will be overwritten. Continue?')) return;

                let lastDate = null;
                sortedWeeks.forEach(week => {
                    if (week.date) {
                        const [y, m, d] = week.date.split('-').map(Number);
                        // Note: Month is 0-indexed in Date constructor, but if parsing "2023-08-01",
                        // we want to be careful. Let's use standard Date parsing which works well with YYYY-MM-DD
                        // actually explicit is safer to avoid timezone issues:
                        if (y && m && d) lastDate = new Date(y, m - 1, d);
                    } else if (lastDate) {
                        const nextDate = new Date(lastDate);
                        nextDate.setDate(nextDate.getDate() + 7);
                        lastDate = nextDate; // update reference

                        const y = nextDate.getFullYear();
                        const m = String(nextDate.getMonth() + 1).padStart(2, '0');
                        const d = String(nextDate.getDate()).padStart(2, '0');
                        onUpdateWeek(week.id, 'date', `${y}-${m}-${d}`);
                    }
                });
            };

            const getTitle = () => {
                if (mode === 'summer') return 'Summer Setup';
                if (mode === 'pre-season') return 'Pre-Season Setup';
                return 'Season Setup';
            };

            const getIcon = () => {
                if (mode === 'summer') return 'Sun';
                if (mode === 'pre-season') return 'Zap';
                return 'Calendar';
            };

            return (
                <div style={{ padding: '2rem', maxWidth: '1400px', margin: '0 auto' }}>
                    <div className="card" style={{ padding: '2rem', background: '#1e293b', color: 'white', border: '1px solid #334155' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '2rem', borderBottom: '1px solid #334155', paddingBottom: '1rem' }}>
                            <h2 style={{ display: 'flex', alignItems: 'center', gap: '0.75rem', margin: 0 }}>
                                <Icon name={getIcon()} size={28} color="#60a5fa" />
                                {getTitle()}
                            </h2>
                            <button className="btn btn-secondary" onClick={handleAutofillDates}>
                                <Icon name="RotateCw" size={16} /> Autofill Dates
                            </button>
                        </div>

                        <div style={{ overflowX: 'auto' }}>
                            <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                                <thead>
                                    <tr style={{ background: '#0f172a', textTransform: 'uppercase', fontSize: '0.85rem', letterSpacing: '0.05em' }}>
                                        <th style={{ padding: '1rem', textAlign: 'left', borderBottom: '1px solid #334155' }}>Week</th>
                                        {mode === 'season' && <th style={{ padding: '1rem', textAlign: 'left', borderBottom: '1px solid #334155' }}>Opponent Name</th>}
                                        <th style={{ padding: '1rem', textAlign: 'left', borderBottom: '1px solid #334155' }}>Week of (Monday)</th>
                                        {mode === 'season' && <th style={{ padding: '1rem', textAlign: 'center', borderBottom: '1px solid #334155' }}>Home / Away</th>}
                                        <th style={{ padding: '1rem', textAlign: 'left', borderBottom: '1px solid #334155' }}>Label Preview</th>
                                        <th style={{ padding: '1rem', textAlign: 'center', borderBottom: '1px solid #334155' }}>Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {sortedWeeks.map(week => (
                                        <tr key={week.id} style={{ borderBottom: '1px solid #334155' }}>
                                            <td style={{ padding: '1rem', fontWeight: 'bold', color: '#94a3b8' }}>{week.name}</td>
                                            {mode === 'season' && (
                                                <td style={{ padding: '1rem' }}>
                                                    <input
                                                        type="text"
                                                        className="form-input"
                                                        placeholder="Enter Opponent..."
                                                        value={week.opponent || ''}
                                                        onChange={(e) => onUpdateWeek(week.id, 'opponent', e.target.value)}
                                                        style={{ background: '#334155', color: 'white', border: '1px solid #475569', width: '100%' }}
                                                    />
                                                </td>
                                            )}
                                            <td style={{ padding: '1rem' }}>
                                                <input
                                                    type="date"
                                                    className="form-input"
                                                    value={week.date || ''}
                                                    onChange={(e) => onUpdateWeek(week.id, 'date', e.target.value)}
                                                    style={{ background: '#334155', color: 'white', border: '1px solid #475569', width: '100%' }}
                                                />
                                            </td>
                                            {mode === 'season' && (
                                                <td style={{ padding: '1rem', textAlign: 'center' }}>
                                                    <div style={{ display: 'flex', justifyContent: 'center', gap: '0.5rem' }}>
                                                        <button
                                                            onClick={() => onUpdateWeek(week.id, 'isHome', true)}
                                                            style={{
                                                                padding: '0.5rem 1rem',
                                                                borderRadius: '6px',
                                                                border: '1px solid',
                                                                background: week.isHome ? '#3b82f6' : 'transparent',
                                                                color: week.isHome ? 'white' : '#64748b',
                                                                borderColor: week.isHome ? '#3b82f6' : '#475569',
                                                                cursor: 'pointer', fontWeight: 'bold'
                                                            }}
                                                        >
                                                            Home
                                                        </button>
                                                        <button
                                                            onClick={() => onUpdateWeek(week.id, 'isHome', false)}
                                                            style={{
                                                                padding: '0.5rem 1rem',
                                                                borderRadius: '6px',
                                                                border: '1px solid',
                                                                background: !week.isHome === true && week.isHome !== undefined ? '#ef4444' : (week.isHome === false ? '#ef4444' : 'transparent'),
                                                                color: week.isHome === false ? 'white' : '#64748b',
                                                                borderColor: week.isHome === false ? '#ef4444' : '#475569',
                                                                cursor: 'pointer', fontWeight: 'bold'
                                                            }}
                                                        >
                                                            Away
                                                        </button>
                                                    </div>
                                                </td>
                                            )}
                                            <td style={{ padding: '1rem', color: '#cbd5e1', fontStyle: 'italic' }}>
                                                Week {week.weekNum} {week.opponent ? `- ${week.opponent} (${week.isHome ? 'H' : 'A'})` : ''}
                                            </td>
                                            <td style={{ padding: '1rem', textAlign: 'center' }}>
                                                <button
                                                    onClick={() => onDeleteWeek(week.id)}
                                                    style={{
                                                        background: 'transparent',
                                                        border: 'none',
                                                        color: '#ef4444',
                                                        cursor: 'pointer',
                                                        opacity: 0.7,
                                                        padding: '0.4rem',
                                                        borderRadius: '4px'
                                                    }}
                                                    className="hover-bg-slate-700"
                                                    title="Delete Week"
                                                >
                                                    <Icon name="Trash" size={18} />
                                                </button>
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                        <div style={{ marginTop: '2rem', display: 'flex', justifyContent: 'center' }}>
                            <button className="btn btn-primary" onClick={onAddWeek} style={{ padding: '0.75rem 1.5rem', fontSize: '1rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                <Icon name="Plus" size={18} /> Add Next Week
                            </button>
                        </div>
                    </div>
                </div >
            );
        };

        const SchoolSetupWizard = ({ schoolId, onComplete }) => {
            const [localSchoolName, setLocalSchoolName] = useState('');
            const [localMascot, setLocalMascot] = useState('🦅');
            const [primaryColor, setPrimaryColor] = useState('#0ea5e9'); // Default Blue
            const [isInitializing, setIsInitializing] = useState(false);

            const handleInitialize = async () => {
                if (!localSchoolName) return;

                // Silent Wipe (No Confirm)

                setIsInitializing(true);

                try {
                    const userId = window.auth.currentUser.uid;
                    const userRef = window.db.collection('users').doc(userId);

                    // 1. WIPE LOCAL DATA (Clean Slate)
                    const keysToWipe = [
                        'oc-dashboard-roster', 'oc-dashboard-plays', 'oc-dashboard-staff',
                        'oc-dashboard-depthchart', 'oc-dashboard-master-tasks', 'attendance_log',
                        'oc-dashboard-equipment-inventory', 'oc-dashboard-equipment-checkouts',
                        'formationLayouts', 'oc-dashboard-ratings', 'oc-dashboard-game-grades', 'oc-dashboard-summer-comp',
                        'oc-dashboard-scouting', 'oc-dashboard-equipment-issuance', 'oc-dashboard-equipment-wishlist',
                        'athlete_assessments', 'oc-dashboard-formations', 'oc-dashboard-zone-philosophies',
                        'oc-dashboard-custom-focus', 'oc-dashboard-duties', 'oc-dashboard-metrics',
                        'fatigue-thresholds', 'position-fatigue-values', 'program_budget_data', 'program_onboarding_data',
                        'oc-dashboard-position-names', 'player_daily_connections', 'player_weight_logs', 'staff_role_tasks',
                        'wiz_ol_library', 'oc-dashboard-weeks',
                        'oc-dashboard-game-plans', 'oc-dashboard-scripts',
                        'oc-dashboard-logo', 'oc-dashboard-theme', 'oc-dashboard-accent',
                        'hc_school_billing', 'hc_school_id', 'hc_school_name', 'hc-active-year', 'hc-visible-features'
                    ];

                    keysToWipe.forEach(key => localStorage.removeItem(key));

                    // 2. SET DEFAULTS
                    localStorage.setItem('oc-dashboard-accent', primaryColor);
                    localStorage.setItem('hc_school_id', schoolId); // Bind immediately

                    // 3. UPDATE FIRESTORE (School Doc)
                    const joinCode = Math.random().toString(36).substring(2, 8).toUpperCase();

                    // 4. Create School Document
                    await window.db.collection('schools').doc(schoolId).set({
                        name: localSchoolName,
                        mascot: localMascot,
                        joinCode: joinCode, // NEW: Join Code for onboarding
                        primaryColor: primaryColor,
                        initialized: true,
                        createdAt: new Date().toISOString(),
                        createdBy: window.auth.currentUser.email,
                        roster: [], // Explicit empty
                        staff: [], // Explicit empty
                        plays: [], // Explicit empty
                        billing: {
                            plan: 'trial',
                            status: 'active',
                            trialEndsAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),
                            promoCode: null,
                            subscriptionEndsAt: null,
                            features: {}
                        }
                    });

                    // 4. CRITICAL: UPDATE USER PROFILE & WIPE PERSONAL DATA
                    // This ensures loadUserDataFromFirestore switches to School Mode
                    // and doesn't fall back to old personal data.
                    await userRef.set({
                        schoolId: schoolId, // LINK USER TO SCHOOL
                        // Wipe potential leaky fields from personal doc
                        roster: firebase.firestore.FieldValue.delete(),
                        plays: firebase.firestore.FieldValue.delete(),
                        staff: firebase.firestore.FieldValue.delete(),
                        weeks: firebase.firestore.FieldValue.delete(),
                        inventory: firebase.firestore.FieldValue.delete(),
                        attendance: firebase.firestore.FieldValue.delete(),

                        settings: {
                            activeYear: '2025',
                            theme: 'dark', // Reset theme
                            accentColor: primaryColor
                        }
                    }, { merge: true });

                    // 4b. CREATE MEMBERSHIP (Explicit)
                    await window.db.collection('users').doc(userId).collection('memberships').doc(schoolId).set({
                        role: 'admin',
                        joinedAt: new Date().toISOString(),
                        status: 'active'
                    });

                    // 5. COMPLETE
                    // alert(`Welcome to ${localSchoolName}! Your workspace is ready.`); // Removed explicit alert to be faster
                    onComplete();

                } catch (err) {
                    console.error("Error initializing school:", err);
                    alert("Failed to initialize school: " + err.message);
                    setIsInitializing(false);
                }
            };

            return (
                <div style={{
                    position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
                    background: '#0f172a', color: 'white', zIndex: 9999,
                    display: 'flex', alignItems: 'center', justifyContent: 'center'
                }}>
                    <div style={{
                        background: '#1e293b', padding: '2rem', borderRadius: '12px',
                        maxWidth: '500px', width: '90%', border: '1px solid #334155',
                        boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.5)'
                    }}>
                        <div style={{ textAlign: 'center', marginBottom: '2rem' }}>
                            <div style={{ fontSize: '3rem', marginBottom: '1rem' }}>🎉</div>
                            <h2 style={{ fontSize: '1.8rem', fontWeight: 'bold', marginBottom: '0.5rem' }}>Welcome, Coach!</h2>
                            <p style={{ color: '#94a3b8' }}>Let's set up your new school workspace.</p>
                        </div>

                        <div style={{ display: 'flex', flexDirection: 'column', gap: '1.5rem' }}>
                            <div>
                                <label style={{ display: 'block', fontSize: '0.9rem', marginBottom: '0.5rem', color: '#cbd5e1' }}>School Name</label>
                                <input
                                    type="text"
                                    className="form-input"
                                    placeholder="e.g. Central High School"
                                    value={localSchoolName}
                                    onChange={(e) => setLocalSchoolName(e.target.value)}
                                    style={{ width: '100%', padding: '0.75rem', fontSize: '1.1rem' }}
                                    autoFocus
                                />
                            </div>

                            <div>
                                <label style={{ display: 'block', fontSize: '0.9rem', marginBottom: '0.5rem', color: '#cbd5e1' }}>Primary Color</label>
                                <div style={{ display: 'flex', gap: '0.75rem', flexWrap: 'wrap' }}>
                                    {[
                                        '#0ea5e9', // Sky Blue
                                        '#ef4444', // Red
                                        '#22c55e', // Green
                                        '#eab308', // Yellow
                                        '#f97316', // Orange
                                        '#a855f7', // Purple
                                        '#ec4899', // Pink
                                        '#64748b', // Slate
                                        '#000000', // Black
                                        '#1e1b4b'  // Navy
                                    ].map(color => (
                                        <button
                                            key={color}
                                            onClick={() => setPrimaryColor(color)}
                                            style={{
                                                width: '32px', height: '32px', borderRadius: '50%',
                                                background: color,
                                                border: primaryColor === color ? '3px solid white' : '1px solid rgba(255,255,255,0.2)',
                                                cursor: 'pointer',
                                                transform: primaryColor === color ? 'scale(1.1)' : 'scale(1)',
                                                transition: 'all 0.2s',
                                                boxShadow: primaryColor === color ? `0 0 10px ${color}` : 'none'
                                            }}
                                        />
                                    ))}
                                </div>
                            </div>

                            <button
                                className="btn btn-primary"
                                onClick={handleInitialize}
                                disabled={!localSchoolName || isInitializing}
                                style={{
                                    marginTop: '1rem', padding: '1rem',
                                    fontSize: '1.1rem', justifyContent: 'center',
                                    background: primaryColor,
                                    opacity: (!localSchoolName || isInitializing) ? 0.5 : 1
                                }}
                            >
                                {isInitializing ? 'Setting up...' : 'Create New School'}
                            </button>
                        </div>
                    </div>
                </div>
            );
        };


        const SchoolSwitcher = ({ userId, currentSchoolId }) => {
            const [memberships, setMemberships] = useState([]);
            const [schools, setSchools] = useState({});
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                const fetchMemberships = async () => {
                    if (!userId) return;
                    try {
                        const memSnapshot = await window.db.collection('users').doc(userId).collection('memberships').get();
                        if (memSnapshot.empty) {
                            setLoading(false);
                            return;
                        }

                        const mems = memSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        setMemberships(mems);

                        // Fetch names for these schools
                        const schoolIds = mems.map(m => m.id);
                        // Firestore "in" query limited to 10, split if needed but assuming < 10 for now
                        if (schoolIds.length > 0) {
                            const schoolsMap = {};
                            // Use Promise.all for simplicity over 'in' query limitations if list is small
                            await Promise.all(schoolIds.map(async (sid) => {
                                const doc = await window.db.collection('schools').doc(sid).get();
                                if (doc.exists) schoolsMap[sid] = doc.data().name;
                                else schoolsMap[sid] = "Unknown School";
                            }));
                            setSchools(schoolsMap);
                        }
                    } catch (err) {
                        console.error("Error loading memberships:", err);
                    }
                    setLoading(false);
                };
                fetchMemberships();
            }, [userId]);

            if (loading) return <div style={{ fontSize: '0.8rem', opacity: 0.5 }}>Loading schools...</div>;
            if (memberships.length <= 1) return null; // Only show if multiple schools

            return (
                <div style={{ marginTop: '0.5rem', marginBottom: '1rem' }}>
                    <label style={{ fontSize: '0.7rem', color: 'var(--text-secondary)', textTransform: 'uppercase', letterSpacing: '0.05em' }}>Switch School</label>
                    <select
                        className="form-select"
                        value={currentSchoolId || ''}
                        onChange={(e) => {
                            const newId = e.target.value;
                            if (newId && newId !== currentSchoolId) {
                                if (confirm(`Switch to ${schools[newId]}?`)) {
                                    localStorage.setItem('hc_school_id', newId);
                                    // Ensure clean slate for new context
                                    localStorage.removeItem('oc-dashboard-roster');
                                    localStorage.removeItem('oc-dashboard-plays');
                                    localStorage.removeItem('oc-dashboard-staff');
                                    window.location.reload();
                                }
                            }
                        }}
                        style={{ width: '100%', fontSize: '0.85rem', padding: '0.25rem', marginTop: '0.25rem', background: 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.1)' }}
                    >
                        {memberships.map(m => (
                            <option key={m.id} value={m.id}>
                                {schools[m.id] || m.id} ({m.role})
                            </option>
                        ))}
                    </select>
                </div>
            );
        };

        const getSchoolPlan = (school, user) => {
            if (!school) return 'FREE';

            // 1. Site Admin Bypass
            // Hardcoded for safety across entire app context
            const SITE_ADMINS = ['matthewfinn14@gmail.com'];
            if (user && user.email && SITE_ADMINS.includes(user.email.toLowerCase())) {
                return 'ALL_ACCESS';
            }

            const billing = school.billing || {};

            // Default to 'free' if no plan set, BUT if it is a legacy school without billing,
            // we might want to grandfather them or default to trial? 
            // For now, let's assume default is FREE unless migrated.
            const plan = billing.plan || 'free';
            const now = new Date();

            // 2. Trial Check
            if (plan === 'trial') {
                if (billing.trialEndsAt && new Date(billing.trialEndsAt) > now) {
                    return 'PREMIUM_TRIAL';
                }
                return 'FREE'; // Trial Expired
            }

            // 3. Premium Check
            if (plan === 'premium') {
                // If subscription has an end date (e.g. from promo), check it
                if (billing.subscriptionEndsAt && new Date(billing.subscriptionEndsAt) <= now) {
                    return 'FREE'; // Expired
                }
                return 'PREMIUM';
            }

            // 4. All Access (Configured manually)
            if (plan === 'all_access') return 'ALL_ACCESS';

            return 'FREE';
        };

        const LEGACY_PROGRAM_RECORDS = {
            'Squat': {
                '320+': {
                    'PR': { value: '--', holder: '-', year: '-' }
                },
                '310-319': {
                    '12': { value: '470', holder: 'David Downs', year: '8/20' },
                    'PR': { value: '470', holder: 'David Downs', year: '8/20' }
                },
                '300-309': {
                    '12': { value: '480', holder: 'Tyler Heithoff', year: '7/22' },
                    '11': { value: '465', holder: 'Tyler Heithoff', year: '5/22' },
                    '10': { value: '350', holder: 'Tyler Heithoff', year: '5/21' },
                    '9': { value: '240', holder: 'Patrick Gomez', year: '5/22' },
                    'PR': { value: '480', holder: 'Tyler Heithoff', year: '7/22' }
                },
                '290-299': {
                    '12': { value: '315', holder: 'Colin Hansen', year: '8/21' },
                    '11': { value: '280', holder: 'Colin Hansen', year: '5/21' },
                    '10': { value: '315', holder: 'Tyler Heithoff', year: '2/21' },
                    '9': { value: '220', holder: 'Patrick Gomez', year: '11/21' },
                    'PR': { value: '315', holder: 'C. Hansen / T. Heithoff', year: '2021' }
                },
                '280-289': {
                    '12': { value: '355', holder: 'Carson Barber', year: '7/24' },
                    '11': { value: '455', holder: 'Aaron Peyton', year: '5/23' },
                    '10': { value: '350', holder: 'Carson Barber', year: '5/23' },
                    'PR': { value: '455', holder: 'Aaron Peyton', year: '5/23' }
                },
                '270-279': {
                    '12': { value: '455', holder: 'Aaron Peyton', year: '7/23' },
                    '10': { value: '315', holder: 'Carson Barber', year: '10/22' },
                    '9': { value: '270', holder: 'Carson Barber', year: '5/22' },
                    'PR': { value: '455', holder: 'Aaron Peyton', year: '7/23' }
                },
                '260-269': {
                    '11': { value: '415', holder: 'Aaron Peyton', year: '10/22' },
                    '9': { value: '250', holder: 'Carson Barber', year: '2/22' },
                    'PR': { value: '415', holder: 'Aaron Peyton', year: '10/22' }
                },
                '250-259': {
                    '11': { value: '450', holder: 'Record Holder', year: '5/24' },
                    '10': { value: '365', holder: 'Aaron Peyton', year: '5/22' },
                    '9': { value: '230', holder: 'Carson Barber', year: '11/21' },
                    'PR': { value: '450', holder: 'Record Holder', year: '5/24' }
                },
                '240-249': {
                    '12': { value: '405', holder: 'W. Licht, T. Tjaden, T. Peterson', year: '23/24' },
                    '11': { value: '415', holder: 'Record Holder', year: '7/23' },
                    '10': { value: '380', holder: 'Record Holder', year: '2/23' },
                    '9': { value: '225', holder: 'Jackson Mohr', year: '2/23' },
                    'PR': { value: '415', holder: 'Record Holder', year: '7/23' }
                },
                '230-239': {
                    '12': { value: '400', holder: 'Wes Hansen', year: '7/24' },
                    '11': { value: '425', holder: 'Wes Hansen', year: '5/24' },
                    '10': { value: '335', holder: 'Aaron Peyton', year: '2/22' },
                    'PR': { value: '425', holder: 'Wes Hansen', year: '5/24' }
                },
                '220-229': {
                    '12': { value: '470', holder: 'Zach Twedt', year: '8/20' },
                    '11': { value: '445', holder: 'Charlie Watts', year: '2/24' },
                    '10': { value: '340', holder: 'Wes Hansen', year: '5/23' },
                    '9': { value: '285', holder: 'Blake Nelsen', year: '2/23' },
                    'PR': { value: '470', holder: 'Zach Twedt', year: '8/20' }
                },
                '210-219': {
                    '12': { value: '460', holder: 'Garret Nerem', year: '7/24' },
                    '11': { value: '425', holder: 'Garrett Nerem', year: '5/24' },
                    '10': { value: '335', holder: 'Tristan Peterson', year: '5/23' },
                    '9': { value: '340', holder: 'Jake Rogers', year: '5/23' },
                    'PR': { value: '460', holder: 'Garret Nerem', year: '7/24' }
                },
                '200-209': {
                    '12': { value: '280', holder: 'Parker Watts', year: '8/21' },
                    '11': { value: '415', holder: 'C. Watts / G. Nerem', year: '23/24' },
                    '10': { value: '425', holder: 'Fiston Carlson', year: '7/24' },
                    '9': { value: '335', holder: 'Jake Rogers', year: '2/23' },
                    'PR': { value: '425', holder: 'Fiston Carlson', year: '7/24' }
                },
                '190-199': {
                    '12': { value: '285', holder: 'Logan Schnurr', year: '8/21' },
                    '11': { value: '400', holder: 'Cael Vermeer', year: '7/24' },
                    '10': { value: '350', holder: 'Cael Vermeer', year: '7/23' },
                    '9': { value: '430', holder: 'Fiston Carlson', year: '5/24' },
                    'PR': { value: '430', holder: 'Fiston Carlson', year: '5/24' }
                },
                '180-189': {
                    '12': { value: '380', holder: 'Sam Knoll', year: '7/24' },
                    '11': { value: '440', holder: 'Fiston Carlson', year: '7/25' },
                    '10': { value: '355', holder: 'Ben Licht', year: '7/24' },
                    '9': { value: '360', holder: 'Fiston Carlson', year: '7/23' },
                    'PR': { value: '440', holder: 'Fiston Carlson', year: '7/25' }
                },
                '170-179': {
                    '12': { value: '355', holder: 'D. Lettow / H. Johnson', year: '22/23' },
                    '11': { value: '340', holder: 'Tyler Lambert', year: '7/25' },
                    '10': { value: '350', holder: 'Isaac Miskell', year: '7/24' },
                    '9': { value: '345', holder: 'Isaac Miskell', year: '2/24' },
                    'PR': { value: '355', holder: 'D. Lettow / H. Johnson', year: '22/23' }
                },
                '160-169': {
                    '12': { value: '320', holder: 'Heston McIlrath', year: '7/24' },
                    '11': { value: '350', holder: 'Sam Knoll', year: '7/23' },
                    '10': { value: '335', holder: 'Cooper Triggs', year: '7/24' },
                    '9': { value: '300', holder: 'Ben Licht', year: '10/23' },
                    'PR': { value: '350', holder: 'Sam Knoll', year: '7/23' }
                },
                '150-159': {
                    '12': { value: '315', holder: 'G. Carpenter / C. Long', year: '22/25' },
                    '11': { value: '345', holder: 'Cody Long', year: '7/24' },
                    '10': { value: '330', holder: 'Cody Long', year: '11/23' },
                    '9': { value: '355', holder: 'Ben Mazyck', year: '10/23' },
                    'PR': { value: '355', holder: 'Ben Mazyck', year: '10/23' }
                },
                '140-149': {
                    '12': { value: '290', holder: 'C. Diehl / J. Martin', year: '21/22' },
                    '11': { value: '275', holder: 'Blake Larson', year: '7/24' },
                    '10': { value: '315', holder: 'Cody Long', year: '7/23' },
                    '9': { value: '305', holder: 'Ben Mazyck', year: '7/23' },
                    'PR': { value: '315', holder: 'Cody Long', year: '7/23' }
                },
                '130-139': {
                    '11': { value: '255', holder: 'Jake Knoll', year: '7/25' },
                    '10': { value: '275', holder: 'Jake Knoll', year: '7/24' },
                    '9': { value: '270', holder: 'C. Long / B. Loof', year: '22/23' },
                    'PR': { value: '275', holder: 'Jake Knoll', year: '7/24' }
                },
                '120-129': {
                    '11': { value: '215', holder: 'Noah Healy', year: '7/25' },
                    '9': { value: '260', holder: 'Brady Long', year: '7/24' },
                    'PR': { value: '260', holder: 'Brady Long', year: '7/24' }
                },
                '110-119': {
                    '11': { value: '180', holder: 'Brayden Kilstofte', year: '11/21' },
                    '9': { value: '195', holder: 'B. Larson / M. Dahlsten', year: '23/25' },
                    'PR': { value: '195', holder: 'B. Larson / M. Dahlsten', year: '23/25' }
                },
                '100-109': {
                    '11': { value: '160', holder: 'Brayden Kilstofte', year: '8/21' },
                    '9': { value: '185', holder: 'Blake Larson', year: '10/22' },
                    'PR': { value: '185', holder: 'Blake Larson', year: '10/22' }
                }
            },
            'Bench': {
                '320+': {
                    'PR': { value: '--', holder: '-', year: '-' }
                },
                '310-319': {
                    '12': { value: '295', holder: 'David Downs', year: '8/20' },
                    'PR': { value: '295', holder: 'David Downs', year: '8/20' }
                },
                '300-309': {
                    '12': { value: '250', holder: 'Tyler Heithoff', year: '7/22' },
                    '11': { value: '250', holder: 'Tyler Heithoff', year: '5/22' },
                    '9': { value: '170', holder: 'Patrick Gomez', year: '5/22' },
                    'PR': { value: '250', holder: 'Tyler Heithoff', year: '2022' }
                },
                '290-299': {
                    '12': { value: '175', holder: 'Colin Hansen', year: '8/21' },
                    '11': { value: '165', holder: 'Colin Hansen', year: '5/21' },
                    '10': { value: '185', holder: 'Tyler Heithoff', year: '2/21' },
                    '9': { value: '155', holder: 'Patrick Gomez', year: '11/21' },
                    'PR': { value: '185', holder: 'Tyler Heithoff', year: '2/21' }
                },
                '280-289': {
                    '12': { value: '220', holder: 'Carson Barber', year: '7/24' },
                    '11': { value: '220', holder: 'Carson Barber', year: '7/23' },
                    '10': { value: '215', holder: 'Carson Barber', year: '5/23' },
                    'PR': { value: '220', holder: 'Carson Barber', year: '23/24' }
                },
                '270-279': {
                    '12': { value: '245', holder: 'Aaron Peyton', year: '7/23' },
                    '10': { value: '195', holder: 'Carson Barber', year: '10/22' },
                    '9': { value: '175', holder: 'Carson Barber', year: '5/22' },
                    'PR': { value: '245', holder: 'Aaron Peyton', year: '7/23' }
                },
                '260-269': {
                    '11': { value: '245', holder: 'Aaron Peyton', year: '10/22' },
                    '10': { value: '155', holder: 'Carson Barber', year: '2/22' },
                    'PR': { value: '245', holder: 'Aaron Peyton', year: '10/22' }
                },
                '250-259': {
                    '11': { value: '245', holder: 'Aaron Peyton', year: '7/22' },
                    '10': { value: '245', holder: 'Aaron Peyton', year: '5/22' },
                    '9': { value: '145', holder: 'Carson Barber', year: '11/21' },
                    'PR': { value: '245', holder: 'Aaron Peyton', year: '2022' }
                },
                '240-249': {
                    '12': { value: '280', holder: 'William Licht', year: '7/23' },
                    '11': { value: '255', holder: 'Thomas Tjaden', year: '5/23' },
                    '10': { value: '215', holder: 'Aaron Peyton', year: '11/21' },
                    '9': { value: '170', holder: 'Jackson Mohr', year: '10/22' },
                    'PR': { value: '280', holder: 'William Licht', year: '7/23' }
                },
                '230-239': {
                    '12': { value: '265', holder: 'Blake Nelsen', year: '8/25' },
                    '11': { value: '270', holder: 'William Licht', year: '5/23' },
                    '10': { value: '215', holder: 'Record Holder', year: '10/22' },
                    'PR': { value: '270', holder: 'William Licht', year: '5/23' }
                },
                '220-229': {
                    '12': { value: '315', holder: 'Jimmy Philipsen', year: '8/20' },
                    '11': { value: '280', holder: 'Charlie Watts', year: '2/24' },
                    '10': { value: '190', holder: 'Wes Hansen', year: '5/23' },
                    '9': { value: '185', holder: 'Aaron Peyton', year: '5/21' },
                    'PR': { value: '315', holder: 'Jimmy Philipsen', year: '8/20' }
                },
                '210-219': {
                    '12': { value: '255', holder: 'Garrett Nerem', year: '7/24' },
                    '11': { value: '300', holder: 'Chance Georgius', year: '7/25' },
                    '10': { value: '250', holder: 'William Licht', year: '5/22' },
                    '9': { value: '245', holder: 'Jake Rogers', year: '5/23' },
                    'PR': { value: '300', holder: 'Chance Georgius', year: '7/25' }
                },
                '200-209': {
                    '12': { value: '230', holder: 'Jonovan Wilkinson', year: '7/23' },
                    '11': { value: '270', holder: 'Charlie Watts', year: '7/23' },
                    '10': { value: '235', holder: 'William Licht', year: '2/22' },
                    '9': { value: '225', holder: 'Blake Winecoff', year: '7/25' },
                    'PR': { value: '270', holder: 'Charlie Watts', year: '7/23' }
                },
                '190-199': {
                    '12': { value: '170', holder: 'Logan Schnurr', year: '8/21' },
                    '11': { value: '210', holder: 'Jonovan Wilkinson', year: '10/22' },
                    '10': { value: '270', holder: 'Charlie Watts', year: '5/23' },
                    '9': { value: '305', holder: 'Fiston Carlson', year: '2/24' },
                    'PR': { value: '305', holder: 'Fiston Carlson', year: '2/24' }
                },
                '180-189': {
                    '12': { value: '280', holder: 'Christian Eslick', year: '7/22' },
                    '11': { value: '325', holder: 'Fiston Carlson', year: '7/25' },
                    '10': { value: '215', holder: 'G. Nerem / C. Barber', year: '23/24' },
                    '9': { value: '255', holder: 'Fiston Carlson', year: '7/23' },
                    'PR': { value: '325', holder: 'Fiston Carlson', year: '7/25' }
                },
                '170-179': {
                    '12': { value: '220', holder: 'Jackson Sterle', year: '8/20' },
                    '11': { value: '245', holder: 'Ben Mazyck', year: '7/25' },
                    '10': { value: '215', holder: 'Isaac Miskell', year: '7/24' },
                    '9': { value: '210', holder: 'Ben Licht', year: '2/24' },
                    'PR': { value: '245', holder: 'Ben Mazyck', year: '7/25' }
                },
                '160-169': {
                    '12': { value: '235', holder: 'Heston McIlrath', year: '7/24' },
                    '11': { value: '200', holder: 'Q. Ante / D. Lettow', year: '21/21' },
                    '10': { value: '235', holder: 'Sam Knoll', year: '2/23' },
                    '9': { value: '195', holder: 'S. Knoll / B. Licht', year: '22/23' },
                    'PR': { value: '235', holder: 'H. McIlrath / S. Knoll', year: '23/24' }
                },
                '150-159': {
                    '12': { value: '210', holder: 'Cody Long', year: '7/25' },
                    '11': { value: '205', holder: 'Brady Lettow', year: '7/23' },
                    '10': { value: '235', holder: 'Ben Mazyck', year: '7/24' },
                    '9': { value: '225', holder: 'Ben Mazyck', year: '10/23' },
                    'PR': { value: '235', holder: 'Ben Mazyck', year: '7/24' }
                },
                '140-149': {
                    '12': { value: '185', holder: 'John Martin', year: '7/22' },
                    '11': { value: '190', holder: 'Blake Larson', year: '7/24' },
                    '10': { value: '200', holder: 'Brody Kilstofte', year: '7/25' },
                    '9': { value: '200', holder: 'Ben Mazyck', year: '7/23' },
                    'PR': { value: '200', holder: 'B. Kilstofte / B. Mazyck', year: '23/25' }
                },
                '130-139': {
                    '11': { value: '185', holder: 'Jake Knoll', year: '7/25' },
                    '10': { value: '190', holder: 'Jake Knoll', year: '7/24' },
                    '9': { value: '160', holder: 'Blake Loof', year: '11/23' },
                    'PR': { value: '190', holder: 'Jake Knoll', year: '7/24' }
                },
                '120-129': {
                    '11': { value: '160', holder: 'Noah Healy', year: '7/25' },
                    '10': { value: '185', holder: 'Jake Knoll', year: '7/23' },
                    'PR': { value: '185', holder: 'Jake Knoll', year: '7/23' }
                },
                '110-119': {
                    '11': { value: '120', holder: 'Brayden Kilstofte', year: '11/21' },
                    '10': { value: '160', holder: 'Max Dahlsten', year: '7/25' },
                    'PR': { value: '160', holder: 'Max Dahlsten', year: '7/25' }
                },
                '100-109': {
                    '10': { value: '125', holder: 'Blake Larson', year: '2/23' },
                    'PR': { value: '125', holder: 'Blake Larson', year: '2/23' }
                }
            },
            'Tape Shuttle': {
                '320+': {
                    'PR': { value: '--', holder: '-', year: '-' }
                },
                '310-319': {
                    '12': { value: '59.4', holder: 'David Downs', year: '8/20' },
                    'PR': { value: '59.4', holder: 'David Downs', year: '8/20' }
                },
                '300-309': {
                    '12': { value: '1:05.2', holder: 'Tyler Heithoff', year: '8/22' },
                    '11': { value: '1:08', holder: 'Tyler Heithoff', year: '8/21' },
                    'PR': { value: '1:05.2', holder: 'Tyler Heithoff', year: '8/22' }
                },
                '290-299': {
                    '12': { value: '1:05', holder: 'Colin Hansen', year: '8/21' },
                    '11': { value: '1:05', holder: 'Colin Hansen', year: '8/20' },
                    '10': { value: '68.9', holder: 'Tyler Heithoff', year: '8/20' },
                    'PR': { value: '1:05', holder: 'Colin Hansen', year: '8/21' }
                },
                '280-289': {
                    '12': { value: '59.0', holder: 'Carson Barber', year: '8/24' },
                    'PR': { value: '59.0', holder: 'Carson Barber', year: '8/24' }
                },
                '270-279': {
                    '12': { value: '58.7', holder: 'Jackson Mohr', year: '8/25' },
                    '10': { value: '58.9', holder: 'Carson Barber', year: '8/22' },
                    'PR': { value: '58.7', holder: 'Jackson Mohr', year: '8/25' }
                },
                '260-269': {
                    '11': { value: '59.2', holder: 'Jackson Mohr', year: '8/24' },
                    'PR': { value: '59.2', holder: 'Jackson Mohr', year: '8/24' }
                },
                '250-259': {
                    '11': { value: '51.5', holder: 'Aaron Peyton', year: '8/22' },
                    '10': { value: '1:08', holder: 'Carson Barber', year: '8/21' },
                    'PR': { value: '51.5', holder: 'Aaron Peyton', year: '8/22' }
                },
                '240-249': {
                    '12': { value: '51.6', holder: 'Tristan Peterson', year: '8/24' },
                    '11': { value: '1:00.6', holder: 'Jake Jennings', year: '8/22' },
                    '9': { value: '1:00', holder: 'Jackson Mohr', year: '8/22' },
                    'PR': { value: '51.6', holder: 'Tristan Peterson', year: '8/24' }
                },
                '230-239': {
                    '12': { value: '48.6', holder: 'Blake Nelsen', year: '8/25' },
                    '11': { value: '1:01', holder: 'Nick Stewart', year: '8/21' },
                    '10': { value: '49.4', holder: 'Record Holder', year: '8/22' },
                    'PR': { value: '48.6', holder: 'Blake Nelsen', year: '8/25' }
                },
                '220-229': {
                    '12': { value: '49.3', holder: 'Luke Patton', year: '8/22' },
                    '11': { value: '52.5', holder: 'Blake Nelsen', year: '8/24' },
                    '9': { value: '1:10', holder: 'Aaron Peyton', year: '8/20' },
                    'PR': { value: '49.3', holder: 'Luke Patton', year: '8/22' }
                },
                '210-219': {
                    '11': { value: '49.8', holder: 'Carter Barber', year: '8/25' },
                    '10': { value: '53', holder: 'Luke Patton', year: '8/20' },
                    '9': { value: '1:01', holder: 'B. Nelsen / J. Rogers', year: '8/22' },
                    'PR': { value: '49.8', holder: 'Carter Barber', year: '8/25' }
                },
                '200-209': {
                    '12': { value: '50.1', holder: 'Cael Vermeer', year: '8/25' },
                    '11': { value: '50.8', holder: 'Christian Chelsvig', year: '8/22' },
                    '10': { value: '45.0', holder: 'Fiston Carlson', year: '8/24' },
                    '9': { value: '55.32', holder: 'Blake Winecoff', year: '8/25' },
                    'PR': { value: '45.0', holder: 'Fiston Carlson', year: '8/24' }
                },
                '190-199': {
                    '12': { value: '50.6', holder: 'Logan Schnurr', year: '8/21' },
                    '11': { value: '47.9', holder: 'Cael Vermeer', year: '8/24' },
                    '10': { value: '49.4', holder: 'Nick Butler', year: '8/20' },
                    '9': { value: '1:00.7', holder: 'Jaxson Kadolph', year: '8/20' },
                    'PR': { value: '47.9', holder: 'Cael Vermeer', year: '8/24' }
                },
                '180-189': {
                    '12': { value: '45.4', holder: 'Kale Lande', year: '8/22' },
                    '11': { value: '45.3', holder: 'Cooper Triggs', year: '8/25' },
                    '10': { value: '48.0', holder: 'Carter Barber', year: '8/24' },
                    '9': { value: '52.9', holder: 'Cole Olson', year: '8/20' },
                    'PR': { value: '45.3', holder: 'Cooper Triggs', year: '8/25' }
                },
                '170-179': {
                    '12': { value: '45', holder: 'Will Bunn', year: '8/21' },
                    '11': { value: '44.1', holder: 'Hesston Johnson', year: '8/22' },
                    '10': { value: '46.2', holder: 'Jonovan Wilkinson', year: '8/21' },
                    '9': { value: '47.6', holder: 'Connor Morton', year: '8/21' },
                    'PR': { value: '44.1', holder: 'Hesston Johnson', year: '8/22' }
                },
                '160-169': {
                    '12': { value: '43.8', holder: 'Heston McIlrath', year: '8/24' },
                    '11': { value: '45.9', holder: 'Dillon Lettow', year: '8/21' },
                    '10': { value: '45.5', holder: 'Sam Knoll', year: '8/22' },
                    '9': { value: '51.3', holder: 'Charlie Watts', year: '8/21' },
                    'PR': { value: '43.8', holder: 'Heston McIlrath', year: '8/24' }
                },
                '150-159': {
                    '12': { value: '43.3', holder: 'Cody Long', year: '8/25' },
                    '11': { value: '44.9', holder: 'Gavin Carpenter', year: '8/21' },
                    '10': { value: '44.1', holder: 'Luke Thoreson', year: '8/24' },
                    '9': { value: '46.7', holder: 'Sam Scarrow', year: '8/25' },
                    'PR': { value: '43.3', holder: 'Cody Long', year: '8/25' }
                },
                '140-149': {
                    '12': { value: '45.5', holder: 'Cade Diehl', year: '8/21' },
                    '11': { value: '46.3', holder: 'Blake Larson', year: '8/24' },
                    '10': { value: '46.3', holder: 'Brody Kilstofte', year: '8/25' },
                    '9': { value: '48.1', holder: 'Hesston Johnson', year: '8/20' },
                    'PR': { value: '45.5', holder: 'Cade Diehl', year: '8/21' }
                },
                '130-139': {
                    '11': { value: '45.9', holder: 'Jake Knoll', year: '8/25' },
                    '10': { value: '46.1', holder: 'Brady Long', year: '8/25' },
                    '9': { value: '45.7', holder: 'Myles McIlrath', year: '8/25' },
                    'PR': { value: '45.7', holder: 'Myles McIlrath', year: '8/25' }
                },
                '120-129': {
                    '11': { value: '47.21', holder: 'Noah Healy', year: '8/25' },
                    '10': { value: '45.9', holder: 'Cody Long', year: '8/22' },
                    'PR': { value: '45.9', holder: 'Cody Long', year: '8/22' }
                },
                '110-119': {
                    '10': { value: '50.4', holder: 'Parker Watson', year: '8/25' },
                    'PR': { value: '50.4', holder: 'Parker Watson', year: '8/25' }
                },
                '100-109': {
                    '10': { value: '49.3', holder: 'Brayden Kilstofte', year: '8/21' },
                    '9': { value: '50.2', holder: 'Blake Larson', year: '8/22' },
                    'PR': { value: '49.3', holder: 'Brayden Kilstofte', year: '8/21' }
                }
            },
            '800m': {
                '320+': {
                    'PR': { value: '--', holder: '-', year: '-' }
                },
                '310-319': {
                    '12': { value: '3:53', holder: 'David Downs', year: '8/20' },
                    'PR': { value: '3:53', holder: 'David Downs', year: '8/20' }
                },
                '300-309': {
                    '12': { value: '4:51', holder: 'Tyler Heithoff', year: '8/22' },
                    'PR': { value: '4:51', holder: 'Tyler Heithoff', year: '8/22' }
                },
                '290-299': {
                    '11': { value: '4:18', holder: 'Colin Hansen', year: '8/20' },
                    '10': { value: '4:39', holder: 'Patrick Gomez', year: '8/22' },
                    'PR': { value: '4:18', holder: 'Colin Hansen', year: '8/20' }
                },
                '280-289': {
                    '12': { value: '4:13', holder: 'Ryan Johnson', year: '8/21' },
                    'PR': { value: '4:13', holder: 'Ryan Johnson', year: '8/21' }
                },
                '270-279': {
                    '12': { value: '3:43', holder: 'Jackson Mohr', year: '8/25' },
                    '10': { value: '4:04', holder: 'Carson Barber', year: '8/22' },
                    'PR': { value: '3:43', holder: 'Jackson Mohr', year: '8/25' }
                },
                '260-269': {
                    '11': { value: '4:35', holder: 'Ryan Johnson', year: '8/20' },
                    'PR': { value: '4:35', holder: 'Ryan Johnson', year: '8/20' }
                },
                '250-259': {
                    '11': { value: '3:33', holder: 'Aaron Peyton', year: '8/22' },
                    '10': { value: '3:39', holder: 'Carson Barber', year: '8/21' },
                    'PR': { value: '3:33', holder: 'Aaron Peyton', year: '8/22' }
                },
                '240-249': {
                    '11': { value: '3:40', holder: 'Jake Jennings', year: '8/22' },
                    '10': { value: '4:18', holder: 'Jackson Mohr', year: '8/22' },
                    'PR': { value: '3:40', holder: 'Jake Jennings', year: '8/22' }
                },
                '230-239': {
                    '12': { value: '2:43', holder: 'Blake Nelsen', year: '8/25' },
                    '11': { value: '3:32', holder: 'Nick Stewart', year: '8/21' },
                    '10': { value: '3:27', holder: 'Aaron Peyton', year: '8/21' },
                    'PR': { value: '2:43', holder: 'Blake Nelsen', year: '8/25' }
                },
                '220-229': {
                    '12': { value: '2:25', holder: 'Luke Patton', year: '8/22' },
                    '11': { value: '3:20', holder: 'William Licht', year: '8/22' },
                    '9': { value: '4:36', holder: 'Aaron Peyton', year: '8/20' },
                    'PR': { value: '2:25', holder: 'Luke Patton', year: '8/22' }
                },
                '210-219': {
                    '11': { value: '2:43', holder: 'C. Barber / G. Jeter', year: '8/25' },
                    '10': { value: '2:52', holder: 'Luke Patton', year: '8/20' },
                    '9': { value: '4:05', holder: 'Jake Rogers', year: '8/22' },
                    'PR': { value: '2:43', holder: 'C. Barber / G. Jeter', year: '8/25' }
                },
                '200-209': {
                    '12': { value: '2:34', holder: 'Cael Vermeer', year: '8/25' },
                    '11': { value: '2:54', holder: 'Christian Chelsvig', year: '8/22' },
                    '10': { value: '3:15', holder: 'Nick Stewart', year: '8/21' },
                    '9': { value: '3:35', holder: 'Blake Winecoff', year: '8/25' },
                    'PR': { value: '2:34', holder: 'Cael Vermeer', year: '8/25' }
                },
                '190-199': {
                    '12': { value: '3:08', holder: 'Logan Schnurr', year: '8/21' },
                    '11': { value: '2:40', holder: 'Tucker Hawkins', year: '8/25' },
                    '10': { value: '3:02', holder: 'Nick Butler', year: '8/20' },
                    '9': { value: '3:29', holder: 'Jaxson Kadolph', year: '8/20' },
                    'PR': { value: '2:40', holder: 'Tucker Hawkins', year: '8/25' }
                },
                '180-189': {
                    '12': { value: '2:09', holder: 'Kale Lande', year: '8/22' },
                    '11': { value: '2:31', holder: 'Luke Thoreson', year: '8/25' },
                    '10': { value: '3:02', holder: 'Garrett Nerem', year: '8/22' },
                    '9': { value: '2:52', holder: 'Cael Vermeer', year: '8/22' },
                    'PR': { value: '2:09', holder: 'Kale Lande', year: '8/22' }
                },
                '170-179': {
                    '12': { value: '2:11', holder: 'Dillon Lettow', year: '8/22' },
                    '11': { value: '2:09', holder: 'Kale Lande', year: '8/21' },
                    '10': { value: '2:29', holder: 'Jonovan Wilkinson', year: '8/21' },
                    '9': { value: '2:38', holder: 'Connor Morton', year: '8/21' },
                    'PR': { value: '2:09', holder: 'Kale Lande', year: '8/21' }
                },
                '160-169': {
                    '12': { value: '2:34', holder: 'Matt Phelan', year: '8/21' },
                    '11': { value: '2:19', holder: 'Dillon Lettow', year: '8/21' },
                    '10': { value: '2:15', holder: 'Colin Willis', year: '8/25' },
                    '9': { value: '2:53', holder: 'Garrett Nerem', year: '8/21' },
                    'PR': { value: '2:15', holder: 'Colin Willis', year: '8/25' }
                },
                '150-159': {
                    '12': { value: '2:16', holder: 'Ben Greenfield', year: '8/22' },
                    '11': { value: '2:23', holder: 'Gavin Carpenter', year: '8/21' },
                    '10': { value: '2:20', holder: 'Hesston Johnson', year: '8/21' },
                    '9': { value: '2:45', holder: 'Sam Scarrow', year: '8/25' },
                    'PR': { value: '2:16', holder: 'Ben Greenfield', year: '8/22' }
                },
                '140-149': {
                    '12': { value: '2:15', holder: 'Cade Diehl', year: '8/21' },
                    '11': { value: '2:32', holder: 'Carter Loof', year: '8/20' },
                    '10': { value: '2:30', holder: 'Boaz Clark', year: '8/21' },
                    '9': { value: '2:38', holder: 'Sam Knoll', year: '8/21' },
                    'PR': { value: '2:15', holder: 'Cade Diehl', year: '8/21' }
                },
                '130-139': {
                    '11': { value: '2:26', holder: 'Cade Diehl', year: '8/21' },
                    '10': { value: '2:38', holder: 'Brady Long', year: '8/25' },
                    '9': { value: '2:39', holder: 'Myles McIlrath', year: '8/25' },
                    'PR': { value: '2:26', holder: 'Cade Diehl', year: '8/21' }
                },
                '120-129': {
                    '11': { value: '2:31', holder: 'Noah Healy', year: '8/25' },
                    '10': { value: '2:33', holder: 'Hayden Janssen', year: '8/22' },
                    'PR': { value: '2:31', holder: 'Noah Healy', year: '8/25' }
                },
                '110-119': {
                    '11': { value: '2:43', holder: 'Tristan Anderson', year: '8/21' },
                    '10': { value: '2:42', holder: 'Max Dahlsten', year: '8/25' },
                    'PR': { value: '2:42', holder: 'Max Dahlsten', year: '8/25' }
                },
                '100-109': {
                    '11': { value: '2:28', holder: 'Brayden Kilstofte', year: '8/21' },
                    '9': { value: '2:46', holder: 'Blake Larson', year: '8/22' },
                    'PR': { value: '2:28', holder: 'Brayden Kilstofte', year: '8/21' }
                }
            },
            'Bag Jump': {
                '320+': {
                    'PR': { value: '--', holder: '-', year: '-' }
                },
                '310-319': {
                    '12': { value: '33', holder: 'David Downs', year: '8/20' },
                    'PR': { value: '33', holder: 'David Downs', year: '8/20' }
                },
                '300-309': {
                    '12': { value: '27', holder: 'Tyler Heithoff', year: '8/22' },
                    '11': { value: '27', holder: 'Tyler Heithoff', year: '8/21' },
                    'PR': { value: '27', holder: 'Tyler Heithoff', year: '21/22' }
                },
                '290-299': {
                    '12': { value: '34', holder: 'Colin Hansen', year: '8/21' },
                    '11': { value: '36', holder: 'Colin Hansen', year: '8/20' },
                    '10': { value: '25', holder: 'Tyler Heithoff', year: '8/20' },
                    'PR': { value: '36', holder: 'Colin Hansen', year: '8/20' }
                },
                '280-289': {
                    '12': { value: '43', holder: 'Carson Barber', year: '8/24' },
                    'PR': { value: '43', holder: 'Carson Barber', year: '8/24' }
                },
                '270-279': {
                    '12': { value: '37', holder: 'Jackson Mohr', year: '8/25' },
                    '10': { value: '36', holder: 'Carson Barber', year: '8/22' },
                    'PR': { value: '37', holder: 'Jackson Mohr', year: '8/25' }
                },
                '260-269': {
                    '11': { value: '39', holder: 'Ryan Johnson', year: '8/20' },
                    'PR': { value: '39', holder: 'Ryan Johnson', year: '8/20' }
                },
                '250-259': {
                    '11': { value: '49', holder: 'Aaron Peyton', year: '8/22' },
                    '10': { value: '44', holder: 'Carson Barber', year: '8/21' },
                    'PR': { value: '49', holder: 'Aaron Peyton', year: '8/22' }
                },
                '240-249': {
                    '12': { value: '53', holder: 'Tristan Peterson', year: '8/24' },
                    '11': { value: '44', holder: 'Jake Jennings', year: '8/22' },
                    '9': { value: '38', holder: 'Jackson Mohr', year: '8/22' },
                    'PR': { value: '53', holder: 'Tristan Peterson', year: '8/24' }
                },
                '230-239': {
                    '12': { value: '55', holder: 'Blake Nelsen', year: '8/25' },
                    '11': { value: '44', holder: 'Nick Stewart', year: '8/21' },
                    '10': { value: '50', holder: 'Aaron Peyton', year: '8/21' },
                    'PR': { value: '55', holder: 'Blake Nelsen', year: '8/25' }
                },
                '220-229': {
                    '12': { value: '57', holder: 'Jimmy Philipsen', year: '8/20' },
                    '11': { value: '53', holder: 'Blake Nelsen', year: '8/24' },
                    '9': { value: '43', holder: 'Aaron Peyton', year: '8/20' },
                    'PR': { value: '57', holder: 'Jimmy Philipsen', year: '8/20' }
                },
                '210-219': {
                    '12': { value: '59', holder: 'Garrett Nerem', year: '8/24' },
                    '11': { value: '53', holder: 'C. Barber / C. Georgius', year: '8/25' },
                    '10': { value: '51', holder: 'Luke Patton', year: '8/20' },
                    '9': { value: '52', holder: 'Jake Rogers', year: '8/22' },
                    'PR': { value: '59', holder: 'Garrett Nerem', year: '8/24' }
                },
                '200-209': {
                    '12': { value: '51', holder: 'Parker Watts', year: '8/21' },
                    '11': { value: '55', holder: 'Christian Chelsvig', year: '8/22' },
                    '10': { value: '53', holder: 'Thomas Tjaden', year: '8/21' },
                    '9': { value: '46', holder: 'Blake Winecoff', year: '8/25' },
                    'PR': { value: '55', holder: 'Christian Chelsvig', year: '8/22' }
                },
                '190-199': {
                    '12': { value: '51', holder: 'Logan Schnurr', year: '8/21' },
                    '11': { value: '54', holder: 'Nick Butler', year: '8/21' },
                    '10': { value: '54', holder: 'Charlie Watts', year: '8/22' },
                    '9': { value: '41', holder: 'Jaxson Kadolph', year: '8/20' },
                    'PR': { value: '54', holder: 'N. Butler / C. Watts', year: '21/22' }
                },
                '180-189': {
                    '12': { value: '62', holder: 'Sam Knoll', year: '8/24' },
                    '11': { value: '61', holder: 'Luke Thoreson', year: '8/25' },
                    '10': { value: '56', holder: 'C. Chelsvig / C. Barber', year: '21/24' },
                    '9': { value: '47', holder: 'Cael Vermeer', year: '8/22' },
                    'PR': { value: '62', holder: 'Sam Knoll', year: '8/24' }
                },
                '170-179': {
                    '12': { value: '64', holder: 'Adam McIlrath', year: '8/20' },
                    '11': { value: '63', holder: 'Hesston Johnson', year: '8/22' },
                    '10': { value: '58', holder: 'Jonovan Wilkinson', year: '8/21' },
                    '9': { value: '61', holder: 'Connor Morton', year: '8/21' },
                    'PR': { value: '64', holder: 'Adam McIlrath', year: '8/20' }
                },
                '160-169': {
                    '12': { value: '66', holder: 'Heston McIlrath', year: '8/24' },
                    '11': { value: '64', holder: 'Aiden Frey', year: '8/25' },
                    '10': { value: '56', holder: 'K. Lande / C. Willis', year: '20/25' },
                    '9': { value: '59', holder: 'Charlie Watts', year: '8/21' },
                    'PR': { value: '66', holder: 'Heston McIlrath', year: '8/24' }
                },
                '150-159': {
                    '12': { value: '65', holder: 'Cody Long', year: '8/25' },
                    '11': { value: '62', holder: 'Cody Long', year: '8/24' },
                    '10': { value: '62', holder: 'Hesston Johnson', year: '8/21' },
                    '9': { value: '60', holder: 'Sam Scarrow', year: '8/25' },
                    'PR': { value: '65', holder: 'Cody Long', year: '8/25' }
                },
                '140-149': {
                    '12': { value: '64', holder: 'Cade Diehl', year: '8/22' },
                    '11': { value: '64', holder: 'Riley Larson', year: '8/22' },
                    '10': { value: '62', holder: 'Jake Berggren', year: '8/22' },
                    '9': { value: '60', holder: 'H. McIlrath / H. Johnson', year: '20/21' },
                    'PR': { value: '64', holder: 'C. Diehl / R. Larson', year: '2022' }
                },
                '130-139': {
                    '11': { value: '64', holder: 'Cade Diehl', year: '8/20' },
                    '10': { value: '65', holder: 'Brady Long', year: '8/25' },
                    '9': { value: '61', holder: 'Jake Berggren', year: '8/21' },
                    'PR': { value: '65', holder: 'Brady Long', year: '8/25' }
                },
                '120-129': {
                    '10': { value: '58', holder: 'Riley Larson', year: '8/21' },
                    '9': { value: '66', holder: 'Brady Long', year: '8/24' },
                    'PR': { value: '66', holder: 'Brady Long', year: '8/24' }
                },
                '110-119': {
                    '10': { value: '50', holder: 'Tristan Anderson', year: '8/21' },
                    '9': { value: '54', holder: 'Max Dahlsten', year: '8/25' },
                    'PR': { value: '54', holder: 'Max Dahlsten', year: '8/25' }
                },
                '100-109': {
                    '10': { value: '51', holder: 'Brayden Kilstofte', year: '8/21' },
                    '9': { value: '56', holder: 'Blake Larson', year: '8/22' },
                    'PR': { value: '56', holder: 'Blake Larson', year: '8/22' }
                }
            },
            'Broad Jump': {},
            '10m Fly': {},
            'Pro Agility': {},
            'Deadlift': {}
        };

        // Schedule Modal Component
        const ScheduleModal = ({ scheduleModal, setScheduleModal, updateSchedule }) => {
            const [tempDate, setTempDate] = useState(scheduleModal.item.scheduledDate || new Date().toISOString().split('T')[0]);
            const [tempRecurring, setTempRecurring] = useState(scheduleModal.item.recurring?.enabled || false);
            const [tempPattern, setTempPattern] = useState(scheduleModal.item.recurring?.pattern || 'weekly');
            const [tempDayOfWeek, setTempDayOfWeek] = useState(scheduleModal.item.recurring?.dayOfWeek ?? new Date().getDay());
            const [tempWeekOfMonth, setTempWeekOfMonth] = useState(scheduleModal.item.recurring?.weekOfMonth || 1);
            const [tempMonth, setTempMonth] = useState(scheduleModal.item.recurring?.month || 1);

            return (
                <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000 }} onClick={() => setScheduleModal(null)}>
                    <div className="card" style={{ width: '90%', maxWidth: '500px', padding: '2rem' }} onClick={e => e.stopPropagation()}>
                        <h3 style={{ margin: '0 0 1.5rem 0' }}>Schedule {scheduleModal.type === 'quote' ? 'Quote' : 'Challenge'}</h3>

                        <div style={{ marginBottom: '1.5rem' }}>
                            <label className="form-label">Start Date</label>
                            <input
                                type="date"
                                className="form-input"
                                value={tempDate}
                                onChange={e => setTempDate(e.target.value)}
                            />
                        </div>

                        <div style={{ marginBottom: '1.5rem' }}>
                            <label style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', cursor: 'pointer' }}>
                                <input
                                    type="checkbox"
                                    checked={tempRecurring}
                                    onChange={e => setTempRecurring(e.target.checked)}
                                />
                                <span className="form-label" style={{ margin: 0 }}>Recurring</span>
                            </label>
                        </div>

                        {tempRecurring && (
                            <>
                                <div style={{ marginBottom: '1.5rem' }}>
                                    <label className="form-label">Pattern</label>
                                    <select className="form-input" value={tempPattern} onChange={e => setTempPattern(e.target.value)}>
                                        <option value="weekly">Weekly</option>
                                        <option value="monthly">Monthly</option>
                                        <option value="yearly">Yearly</option>
                                    </select>
                                </div>

                                {tempPattern === 'weekly' && (
                                    <div style={{ marginBottom: '1.5rem' }}>
                                        <label className="form-label">Day of Week</label>
                                        <select className="form-input" value={tempDayOfWeek} onChange={e => setTempDayOfWeek(parseInt(e.target.value))}>
                                            <option value={0}>Sunday</option>
                                            <option value={1}>Monday</option>
                                            <option value={2}>Tuesday</option>
                                            <option value={3}>Wednesday</option>
                                            <option value={4}>Thursday</option>
                                            <option value={5}>Friday</option>
                                            <option value={6}>Saturday</option>
                                        </select>
                                    </div>
                                )}

                                {(tempPattern === 'monthly' || tempPattern === 'yearly') && (
                                    <>
                                        <div style={{ marginBottom: '1.5rem' }}>
                                            <label className="form-label">Week of Month</label>
                                            <select className="form-input" value={tempWeekOfMonth} onChange={e => setTempWeekOfMonth(e.target.value === 'last' ? 'last' : parseInt(e.target.value))}>
                                                <option value={1}>1st</option>
                                                <option value={2}>2nd</option>
                                                <option value={3}>3rd</option>
                                                <option value={4}>4th</option>
                                                <option value="last">Last</option>
                                            </select>
                                        </div>
                                        <div style={{ marginBottom: '1.5rem' }}>
                                            <label className="form-label">Day of Week</label>
                                            <select className="form-input" value={tempDayOfWeek} onChange={e => setTempDayOfWeek(parseInt(e.target.value))}>
                                                <option value={0}>Sunday</option>
                                                <option value={1}>Monday</option>
                                                <option value={2}>Tuesday</option>
                                                <option value={3}>Wednesday</option>
                                                <option value={4}>Thursday</option>
                                                <option value={5}>Friday</option>
                                                <option value={6}>Saturday</option>
                                            </select>
                                        </div>
                                    </>
                                )}

                                {tempPattern === 'yearly' && (
                                    <div style={{ marginBottom: '1.5rem' }}>
                                        <label className="form-label">Month</label>
                                        <select className="form-input" value={tempMonth} onChange={e => setTempMonth(parseInt(e.target.value))}>
                                            <option value={1}>January</option>
                                            <option value={2}>February</option>
                                            <option value={3}>March</option>
                                            <option value={4}>April</option>
                                            <option value={5}>May</option>
                                            <option value={6}>June</option>
                                            <option value={7}>July</option>
                                            <option value={8}>August</option>
                                            <option value={9}>September</option>
                                            <option value={10}>October</option>
                                            <option value={11}>November</option>
                                            <option value={12}>December</option>
                                        </select>
                                    </div>
                                )}
                            </>
                        )}

                        <div style={{ display: 'flex', gap: '1rem', justifyContent: 'flex-end' }}>
                            <button className="btn btn-secondary" onClick={() => setScheduleModal(null)}>Cancel</button>
                            <button
                                className="btn btn-primary"
                                onClick={() => {
                                    updateSchedule(scheduleModal.type, scheduleModal.item.id, {
                                        scheduledDate: tempDate,
                                        recurring: tempRecurring ? {
                                            enabled: true,
                                            pattern: tempPattern,
                                            dayOfWeek: tempDayOfWeek,
                                            weekOfMonth: (tempPattern === 'monthly' || tempPattern === 'yearly') ? tempWeekOfMonth : undefined,
                                            month: tempPattern === 'yearly' ? tempMonth : undefined
                                        } : null
                                    });
                                    setScheduleModal(null);
                                }}
                            >
                                Save Schedule
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // Cultural Calibration Component
        const CulturalCalibration = ({ culturalCalibration, setCulturalCalibration, currentPermissions, authUser }) => {
            const isAdmin = true; // currentPermissions?.organizationAdmin || currentPermissions?.culturalAdmin;
            const [ccMode, setCCMode] = useState(isAdmin ? 'admin' : 'user');
            const [quoteText, setQuoteText] = useState('');
            const [quoteAuthor, setQuoteAuthor] = useState('');
            const [challengeText, setChallengeText] = useState('');
            const [reflection, setReflection] = useState('');
            const [currentScore, setCurrentScore] = useState(5);
            const [desiredScore, setDesiredScore] = useState(8);
            const [feedback, setFeedback] = useState('');
            const [adminTab, setAdminTab] = useState('content'); // 'content' or 'calendar'
            const [scheduleModal, setScheduleModal] = useState(null); // {type: 'quote'|'challenge', item: object}
            const [calendarDate, setCalendarDate] = useState(new Date());

            // Helper: Check if two dates are the same day
            const isSameDay = (date1, date2) => {
                return date1.getFullYear() === date2.getFullYear() &&
                    date1.getMonth() === date2.getMonth() &&
                    date1.getDate() === date2.getDate();
            };

            // Helper: Get the week of month for a date (1-5)
            const getWeekOfMonth = (date) => {
                const firstDay = new Date(date.getFullYear(), date.getMonth(), 1);
                const dayOfMonth = date.getDate();
                return Math.ceil((dayOfMonth + firstDay.getDay()) / 7);
            };

            // Helper: Check if date matches monthly pattern (e.g., "2nd Tuesday")
            const matchesMonthlyPattern = (date, recurring) => {
                if (date.getDay() !== recurring.dayOfWeek) return false;

                const weekOfMonth = getWeekOfMonth(date);
                if (recurring.weekOfMonth === 'last') {
                    // Check if this is the last occurrence of this weekday in the month
                    const nextWeek = new Date(date);
                    nextWeek.setDate(date.getDate() + 7);
                    return nextWeek.getMonth() !== date.getMonth();
                }
                return weekOfMonth === recurring.weekOfMonth;
            };

            // Helper: Check if item is scheduled for target date
            const isScheduledFor = (item, targetDate) => {
                if (!item.scheduledDate) return false;

                const scheduled = new Date(item.scheduledDate);

                if (!item.recurring?.enabled) {
                    // One-time: exact date match
                    return isSameDay(scheduled, targetDate);
                }

                // Must be on or after start date
                if (targetDate < scheduled) return false;

                // Recurring patterns
                switch (item.recurring.pattern) {
                    case 'weekly':
                        return targetDate.getDay() === item.recurring.dayOfWeek;
                    case 'monthly':
                        return matchesMonthlyPattern(targetDate, item.recurring);
                    case 'yearly':
                        return targetDate.getMonth() === item.recurring.month - 1 &&
                            matchesMonthlyPattern(targetDate, item.recurring);
                    default:
                        return false;
                }
            };

            // Helper: Find active item for today (or most recent)
            const findActiveItem = (items) => {
                const today = new Date();
                today.setHours(0, 0, 0, 0);

                // 1. Find items scheduled for today
                const todayItems = items.filter(item => isScheduledFor(item, today));
                if (todayItems.length) return todayItems[0];

                // 2. Fallback: Most recent scheduled item before today
                const pastItems = items
                    .filter(item => item.scheduledDate && new Date(item.scheduledDate) <= today)
                    .sort((a, b) => new Date(b.scheduledDate) - new Date(a.scheduledDate));
                if (pastItems.length) return pastItems[0];

                // 3. Fallback: Most recently added
                const sortedByDate = items.sort((a, b) => new Date(b.dateAdded) - new Date(a.dateAdded));
                return sortedByDate[0] || null;
            };


            const addQuote = () => {
                if (!quoteText.trim()) return;
                const newQuote = {
                    id: Date.now().toString(),
                    text: quoteText,
                    author: quoteAuthor || 'Unknown',
                    dateAdded: new Date().toISOString(),
                    scheduledDate: null,
                    recurring: null
                };
                setCulturalCalibration({
                    ...culturalCalibration,
                    quotes: [...(culturalCalibration.quotes || []), newQuote]
                });
                setQuoteText('');
                setQuoteAuthor('');
            };

            const updateSchedule = (type, itemId, scheduleData) => {
                const key = type === 'quote' ? 'quotes' : 'challenges';
                const updated = (culturalCalibration[key] || []).map(item =>
                    item.id === itemId ? { ...item, ...scheduleData } : item
                );
                setCulturalCalibration({
                    ...culturalCalibration,
                    [key]: updated
                });
            };


            const addChallenge = () => {
                if (!challengeText.trim()) return;
                const newChallenge = {
                    id: Date.now().toString(),
                    text: challengeText,
                    dateAdded: new Date().toISOString(),
                    scheduledDate: null,
                    recurring: null
                };
                setCulturalCalibration({
                    ...culturalCalibration,
                    challenges: [...(culturalCalibration.challenges || []), newChallenge]
                });
                setChallengeText('');
            };

            const setActiveQuote = (id) => {
                setCulturalCalibration({
                    ...culturalCalibration,
                    activeQuote: id
                });
            };

            const setActiveChallenge = (id) => {
                setCulturalCalibration({
                    ...culturalCalibration,
                    activeChallenge: id
                });
            };

            const deleteQuote = (id) => {
                setCulturalCalibration({
                    ...culturalCalibration,
                    quotes: (culturalCalibration.quotes || []).filter(q => q.id !== id),
                    activeQuote: culturalCalibration.activeQuote === id ? null : culturalCalibration.activeQuote
                });
            };

            const deleteChallenge = (id) => {
                setCulturalCalibration({
                    ...culturalCalibration,
                    challenges: (culturalCalibration.challenges || []).filter(c => c.id !== id),
                    activeChallenge: culturalCalibration.activeChallenge === id ? null : culturalCalibration.activeChallenge
                });
            };

            const submitResponse = () => {
                const newResponse = {
                    id: Date.now().toString(),
                    userId: authUser?.uid,
                    userName: authUser?.displayName || authUser?.email,
                    date: new Date().toISOString(),
                    reflection: reflection,
                    currentCultureScore: currentScore,
                    desiredCultureScore: desiredScore,
                    feedback: feedback
                };
                setCulturalCalibration({
                    ...culturalCalibration,
                    responses: [...(culturalCalibration.responses || []), newResponse]
                });
                setReflection('');
                setCurrentScore(5);
                setDesiredScore(8);
                setFeedback('');
                alert('Response submitted successfully!');
            };

            const activeQuoteObj = findActiveItem(culturalCalibration.quotes || []);
            const activeChallengeObj = findActiveItem(culturalCalibration.challenges || []);

            const responses = culturalCalibration.responses || [];
            const avgCurrent = responses.length > 0 ? (responses.reduce((sum, r) => sum + r.currentCultureScore, 0) / responses.length).toFixed(1) : 'N/A';
            const avgDesired = responses.length > 0 ? (responses.reduce((sum, r) => sum + r.desiredCultureScore, 0) / responses.length).toFixed(1) : 'N/A';

            return (
                <div style={{ height: '100%', display: 'flex', flexDirection: 'column', gap: '1rem', overflow: 'auto', padding: '1rem' }}>
                    <div className="card" style={{ padding: '2rem', background: 'linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%)' }}>
                        <h2 style={{ margin: '0 0 1rem 0', color: 'white', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                            <Icon name="Heart" size={28} />
                            Culture Calibration
                        </h2>
                        <p style={{ margin: 0, opacity: 0.9, color: 'white' }}>
                            Daily quotes, challenges, and culture feedback
                        </p>
                        {isAdmin && (
                            <div style={{ marginTop: '1.5rem', display: 'flex', gap: '1rem' }}>
                                <button className={`btn ${ccMode === 'admin' ? 'btn-primary' : 'btn-secondary'}`} onClick={() => setCCMode('admin')} style={{ borderRadius: '20px' }}>Admin View</button>
                                <button className={`btn ${ccMode === 'user' ? 'btn-primary' : 'btn-secondary'}`} onClick={() => setCCMode('user')} style={{ borderRadius: '20px' }}>User View</button>
                            </div>
                        )}
                    </div>
                    {ccMode === 'admin' ? (
                        <>
                            {/* Tabs for Admin View */}
                            <div className="card" style={{ padding: '1rem' }}>
                                <div style={{ display: 'flex', gap: '0.5rem', borderBottom: '2px solid var(--border)' }}>
                                    <button
                                        className={`btn ${adminTab === 'content' ? 'btn-primary' : 'btn-secondary'}`}
                                        onClick={() => setAdminTab('content')}
                                        style={{ borderRadius: '8px 8px 0 0', borderBottom: adminTab === 'content' ? '2px solid var(--accent)' : 'none' }}
                                    >
                                        Manage Content
                                    </button>
                                    <button
                                        className={`btn ${adminTab === 'calendar' ? 'btn-primary' : 'btn-secondary'}`}
                                        onClick={() => setAdminTab('calendar')}
                                        style={{ borderRadius: '8px 8px 0 0', borderBottom: adminTab === 'calendar' ? '2px solid var(--accent)' : 'none' }}
                                    >
                                        Calendar Schedule
                                    </button>
                                </div>
                            </div>

                            {adminTab === 'content' ? (
                                <>
                                    {/* Response Dashboard */}
                                    <div className="card" style={{ padding: '1.5rem' }}>
                                        <h3 style={{ margin: '0 0 1rem 0' }}>Response Dashboard</h3>
                                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1rem' }}>
                                            <div>
                                                <div style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginBottom: '0.5rem' }}>Total Responses</div>
                                                <div style={{ fontSize: '2rem', fontWeight: 'bold', color: 'var(--accent)' }}>{responses.length}</div>
                                            </div>
                                            <div>
                                                <div style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginBottom: '0.5rem' }}>Avg Current Culture</div>
                                                <div style={{ fontSize: '2rem', fontWeight: 'bold', color: '#f97316' }}>{avgCurrent}</div>
                                            </div>
                                            <div>
                                                <div style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginBottom: '0.5rem' }}>Avg Desired Culture</div>
                                                <div style={{ fontSize: '2rem', fontWeight: 'bold', color: '#10b981' }}>{avgDesired}</div>
                                            </div>
                                        </div>
                                    </div>

                                    {/* Daily Quotes */}
                                    <div className="card" style={{ padding: '1.5rem' }}>
                                        <h3 style={{ margin: '0 0 1rem 0' }}>Daily Quotes</h3>
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem', marginBottom: '1.5rem' }}>
                                            <input className="form-input" placeholder="Quote text..." value={quoteText} onChange={e => setQuoteText(e.target.value)} />
                                            <input className="form-input" placeholder="Author (optional)" value={quoteAuthor} onChange={e => setQuoteAuthor(e.target.value)} />
                                            <button className="btn btn-primary" onClick={addQuote} disabled={!quoteText.trim()}>Add Quote</button>
                                        </div>
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                            {(culturalCalibration.quotes || []).map(quote => (
                                                <div key={quote.id} style={{ padding: '1rem', background: 'var(--bg-secondary)', borderRadius: '8px', border: '1px solid var(--border)' }}>
                                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start', marginBottom: '0.5rem' }}>
                                                        <div style={{ flex: 1 }}>
                                                            <div style={{ fontStyle: 'italic', marginBottom: '0.5rem' }}>"{quote.text}"</div>
                                                            <div style={{ fontSize: '0.85rem', color: 'var(--text-secondary)' }}>— {quote.author}</div>
                                                        </div>
                                                        <div style={{ display: 'flex', gap: '0.5rem' }}>
                                                            <button
                                                                className="btn btn-sm btn-secondary"
                                                                onClick={() => setScheduleModal({ type: 'quote', item: quote })}
                                                            >
                                                                <Icon name="Calendar" size={14} /> Schedule
                                                            </button>
                                                            <button className="btn btn-sm btn-danger" onClick={() => deleteQuote(quote.id)}>Delete</button>
                                                        </div>
                                                    </div>
                                                    {quote.scheduledDate && (
                                                        <div style={{ fontSize: '0.75rem', color: 'var(--accent)', marginTop: '0.5rem' }}>
                                                            📅 {quote.recurring?.enabled ? (
                                                                <>Recurring: {
                                                                    quote.recurring.pattern === 'weekly' ? `Every ${['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][quote.recurring.dayOfWeek]}` :
                                                                        quote.recurring.pattern === 'monthly' ? `${['1st', '2nd', '3rd', '4th', 'Last'][quote.recurring.weekOfMonth === 'last' ? 4 : quote.recurring.weekOfMonth - 1]} ${['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][quote.recurring.dayOfWeek]} of month` :
                                                                            quote.recurring.pattern === 'yearly' ? `${['1st', '2nd', '3rd', '4th', 'Last'][quote.recurring.weekOfMonth === 'last' ? 4 : quote.recurring.weekOfMonth - 1]} ${['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][quote.recurring.dayOfWeek]} of ${['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][quote.recurring.month - 1]}` : ''
                                                                }</>
                                                            ) : (
                                                                new Date(quote.scheduledDate).toLocaleDateString()
                                                            )}
                                                        </div>
                                                    )}
                                                </div>
                                            ))}
                                        </div>
                                    </div>

                                    {/* Daily Challenges */}
                                    <div className="card" style={{ padding: '1.5rem' }}>
                                        <h3 style={{ margin: '0 0 1rem 0' }}>Daily Challenges</h3>
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem', marginBottom: '1.5rem' }}>
                                            <textarea className="form-input" rows={3} placeholder="Challenge text..." value={challengeText} onChange={e => setChallengeText(e.target.value)} />
                                            <button className="btn btn-primary" onClick={addChallenge} disabled={!challengeText.trim()}>Add Challenge</button>
                                        </div>
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                            {(culturalCalibration.challenges || []).map(challenge => (
                                                <div key={challenge.id} style={{ padding: '1rem', background: 'var(--bg-secondary)', borderRadius: '8px', border: '1px solid var(--border)' }}>
                                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start', marginBottom: '0.5rem' }}>
                                                        <div style={{ flex: 1 }}>{challenge.text}</div>
                                                        <div style={{ display: 'flex', gap: '0.5rem' }}>
                                                            <button
                                                                className="btn btn-sm btn-secondary"
                                                                onClick={() => setScheduleModal({ type: 'challenge', item: challenge })}
                                                            >
                                                                <Icon name="Calendar" size={14} /> Schedule
                                                            </button>
                                                            <button className="btn btn-sm btn-danger" onClick={() => deleteChallenge(challenge.id)}>Delete</button>
                                                        </div>
                                                    </div>
                                                    {challenge.scheduledDate && (
                                                        <div style={{ fontSize: '0.75rem', color: 'var(--accent)', marginTop: '0.5rem' }}>
                                                            📅 {challenge.recurring?.enabled ? (
                                                                <>Recurring: {
                                                                    challenge.recurring.pattern === 'weekly' ? `Every ${['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][challenge.recurring.dayOfWeek]}` :
                                                                        challenge.recurring.pattern === 'monthly' ? `${['1st', '2nd', '3rd', '4th', 'Last'][challenge.recurring.weekOfMonth === 'last' ? 4 : challenge.recurring.weekOfMonth - 1]} ${['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][challenge.recurring.dayOfWeek]} of month` :
                                                                            challenge.recurring.pattern === 'yearly' ? `${['1st', '2nd', '3rd', '4th', 'Last'][challenge.recurring.weekOfMonth === 'last' ? 4 : challenge.recurring.weekOfMonth - 1]} ${['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][challenge.recurring.dayOfWeek]} of ${['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][challenge.recurring.month - 1]}` : ''
                                                                }</>
                                                            ) : (
                                                                new Date(challenge.scheduledDate).toLocaleDateString()
                                                            )}
                                                        </div>
                                                    )}
                                                </div>
                                            ))}
                                        </div>
                                    </div>

                                    {/* Submitted Responses */}
                                    <div className="card" style={{ padding: '1.5rem' }}>
                                        <h3 style={{ margin: '0 0 1rem 0' }}>Submitted Responses</h3>
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                                            {responses.length === 0 ? (
                                                <div style={{ textAlign: 'center', padding: '2rem', color: 'var(--text-secondary)' }}>No responses yet</div>
                                            ) : (
                                                responses.map(response => (
                                                    <div key={response.id} style={{ padding: '1rem', background: 'var(--bg-secondary)', borderRadius: '8px', border: '1px solid var(--border)' }}>
                                                        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem' }}>
                                                            <div style={{ fontWeight: 'bold' }}>{response.userName}</div>
                                                            <div style={{ fontSize: '0.85rem', color: 'var(--text-secondary)' }}>{new Date(response.date).toLocaleDateString()}</div>
                                                        </div>
                                                        <div style={{ marginBottom: '0.5rem', fontSize: '0.95rem' }}>{response.reflection}</div>
                                                        <div style={{ display: 'flex', gap: '1.5rem', fontSize: '0.85rem' }}>
                                                            <div>Current: <span style={{ fontWeight: 'bold', color: '#f97316' }}>{response.currentCultureScore}/10</span></div>
                                                            <div>Desired: <span style={{ fontWeight: 'bold', color: '#10b981' }}>{response.desiredCultureScore}/10</span></div>
                                                        </div>
                                                        {response.feedback && (
                                                            <div style={{ marginTop: '0.5rem', padding: '0.5rem', background: 'var(--bg-primary)', borderRadius: '4px', fontSize: '0.85rem' }}>
                                                                <strong>Feedback:</strong> {response.feedback}
                                                            </div>
                                                        )}
                                                    </div>
                                                ))
                                            )}
                                        </div>
                                    </div>
                                </>
                            ) : (
                                <div className="card" style={{ padding: '1.5rem' }}>
                                    <h3 style={{ margin: '0 0 1rem 0' }}>Calendar Schedule</h3>
                                    {/* Calendar Controls */}
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                                        <button className="btn btn-secondary" onClick={() => {
                                            const newDate = new Date(calendarDate);
                                            newDate.setMonth(newDate.getMonth() - 1);
                                            setCalendarDate(newDate);
                                        }}>
                                            ← Previous
                                        </button>
                                        <h4 style={{ margin: 0 }}>
                                            {calendarDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}
                                        </h4>
                                        <button className="btn btn-secondary" onClick={() => {
                                            const newDate = new Date(calendarDate);
                                            newDate.setMonth(newDate.getMonth() + 1);
                                            setCalendarDate(newDate);
                                        }}>
                                            Next →
                                        </button>
                                    </div>

                                    {/* Calendar Grid */}
                                    <div style={{
                                        display: 'grid',
                                        gridTemplateColumns: 'repeat(7, 1fr)',
                                        gap: '0.5rem',
                                        marginBottom: '1rem'
                                    }}>
                                        {/* Day Headers */}
                                        {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map(day => (
                                            <div key={day} style={{
                                                padding: '0.5rem',
                                                textAlign: 'center',
                                                fontWeight: 'bold',
                                                color: 'var(--text-secondary)',
                                                fontSize: '0.85rem'
                                            }}>
                                                {day}
                                            </div>
                                        ))}

                                        {(() => {
                                            const year = calendarDate.getFullYear();
                                            const month = calendarDate.getMonth();
                                            const firstDay = new Date(year, month, 1).getDay();
                                            const daysInMonth = new Date(year, month + 1, 0).getDate();
                                            const today = new Date();
                                            today.setHours(0, 0, 0, 0);

                                            const days = [];

                                            // Empty cells for days before month starts
                                            for (let i = 0; i < firstDay; i++) {
                                                days.push(<div key={`empty-${i}`} style={{ padding: '0.5rem' }} />);
                                            }

                                            // Actual days of the month
                                            for (let day = 1; day <= daysInMonth; day++) {
                                                const date = new Date(year, month, day);
                                                const isToday = isSameDay(date, today);

                                                // Find items scheduled for this date
                                                const quotes = (culturalCalibration.quotes || []).filter(q => isScheduledFor(q, date));
                                                const challenges = (culturalCalibration.challenges || []).filter(c => isScheduledFor(c, date));
                                                const hasItems = quotes.length > 0 || challenges.length > 0;

                                                days.push(
                                                    <div
                                                        key={day}
                                                        style={{
                                                            padding: '0.5rem',
                                                            border: '1px solid var(--borde)',
                                                            borderRadius: '4px',
                                                            minHeight: '80px',
                                                            backgroundColor: isToday ? 'rgba(var(--accent-rgb), 0.1)' : 'var(--bg-secondary)',
                                                            borderColor: isToday ? 'var(--accent)' : 'var(--border)',
                                                            cursor: hasItems ? 'pointer' : 'default',
                                                            transition: 'all 0.2s ease'
                                                        }}
                                                        onMouseEnter={(e) => {
                                                            if (hasItems) {
                                                                e.currentTarget.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
                                                                e.currentTarget.style.transform = 'translateY(-2px)';
                                                            }
                                                        }}
                                                        onMouseLeave={(e) => {
                                                            if (hasItems) {
                                                                e.currentTarget.style.boxShadow = 'none';
                                                                e.currentTarget.style.transform = 'translateY(0)';
                                                            }
                                                        }}
                                                    >
                                                        <div style={{
                                                            fontWeight: isToday ? 'bold' : 'normal',
                                                            marginBottom: '0.25rem',
                                                            color: isToday ? 'var(--accent)' : 'var(--text-primary)'
                                                        }}>
                                                            {day}
                                                        </div>

                                                        {/* Display scheduled items */}
                                                        {hasItems && (
                                                            <div style={{ fontSize: '0.75rem', display: 'flex', flexDirection: 'column', gap: '0.25rem' }}>
                                                                {quotes.map((q, idx) => (
                                                                    <div
                                                                        key={`quote-${idx}`}
                                                                        style={{
                                                                            padding: '0.15rem 0.3rem',
                                                                            background: 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)',
                                                                            color: 'white',
                                                                            borderRadius: '3px',
                                                                            overflow: 'hidden',
                                                                            textOverflow: 'ellipsis',
                                                                            whiteSpace: 'nowrap',
                                                                            fontSize: '0.7rem'
                                                                        }}
                                                                        title={`Quote: "${q.text}"`}
                                                                    >
                                                                        💬 {q.recurring?.enabled ? '🔄 ' : ''}Quote
                                                                    </div>
                                                                ))}
                                                                {challenges.map((c, idx) => (
                                                                    <div
                                                                        key={`challenge-${idx}`}
                                                                        style={{
                                                                            padding: '0.15rem 0.3rem',
                                                                            background: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)',
                                                                            color: 'white',
                                                                            borderRadius: '3px',
                                                                            overflow: 'hidden',
                                                                            textOverflow: 'ellipsis',
                                                                            whiteSpace: 'nowrap',
                                                                            fontSize: '0.7rem'
                                                                        }}
                                                                        title={`Challenge: "${c.text}"`}
                                                                    >
                                                                        ⚡ {c.recurring?.enabled ? '🔄 ' : ''}Challenge
                                                                    </div>
                                                                ))}
                                                            </div>
                                                        )}
                                                    </div>
                                                );
                                            }

                                            return days;
                                        })()}
                                    </div>

                                    {/* Legend */}
                                    <div style={{
                                        display: 'flex',
                                        gap: '1.5rem',
                                        justifyContent: 'center',
                                        padding: '1rem',
                                        borderTop: '1px solid var(--border)'
                                    }}>
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', fontSize: '0.85rem' }}>
                                            <div style={{
                                                width: '20px',
                                                height: '20px',
                                                background: 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)',
                                                borderRadius: '3px'
                                            }} />
                                            <span>Quote</span>
                                        </div>
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', fontSize: '0.85rem' }}>
                                            <div style={{
                                                width: '20px',
                                                height: '20px',
                                                background: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)',
                                                borderRadius: '3px'
                                            }} />
                                            <span>Challenge</span>
                                        </div>
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', fontSize: '0.85rem' }}>
                                            <span>🔄</span>
                                            <span>Recurring</span>
                                        </div>
                                    </div>
                                </div>
                            )}

                            {/* Schedule Modal */}
                            {scheduleModal && (
                                <ScheduleModal
                                    scheduleModal={scheduleModal}
                                    setScheduleModal={setScheduleModal}
                                    updateSchedule={updateSchedule}
                                />
                            )}
                        </>
                    ) : (
                        <><div className="card" style={{ padding: '1.5rem' }}><h3 style={{ margin: '0 0 1rem 0' }}>Today's Quote</h3>{activeQuoteObj ? (<div style={{ fontSize: '1.1rem' }}><div style={{ fontStyle: 'italic', marginBottom: '0.75rem' }}>"{activeQuoteObj.text}"</div><div style={{ textAlign: 'right', color: 'var(--text-secondary)' }}>— {activeQuoteObj.author}</div></div>) : (<div style={{ color: 'var(--text-secondary)', fontStyle: 'italic' }}>No active quote for today</div>)}</div><div className="card" style={{ padding: '1.5rem' }}><h3 style={{ margin: '0 0 1rem 0' }}>Today's Challenge</h3>{activeChallengeObj ? (<div style={{ fontSize: '1.05rem' }}>{activeChallengeObj.text}</div>) : (<div style={{ color: 'var(--text-secondary)', fontStyle: 'italic' }}>No active challenge for today</div>)}</div><div className="card" style={{ padding: '1.5rem' }}><h3 style={{ margin: '0 0 1rem 0' }}>Your Feedback</h3><div style={{ marginBottom: '1.5rem' }}><label className="form-label">How are you feeling about our program's culture? What's on your mind?</label><textarea className="form-input" rows={4} placeholder="Share your thoughts, reflections, or concerns..." value={reflection} onChange={e => setReflection(e.target.value)} /></div><div style={{ marginBottom: '1.5rem' }}><label className="form-label">Current Culture Score (1-10)</label><div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}><input type="range" min="1" max="10" value={currentScore} onChange={e => setCurrentScore(parseInt(e.target.value))} style={{ flex: 1 }} /><span style={{ fontSize: '1.25rem', fontWeight: 'bold', minWidth: '3ch', color: '#f97316' }}>{currentScore}</span></div></div><div style={{ marginBottom: '1.5rem' }}><label className="form-label">Desired Culture Score (1-10)</label><div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}><input type="range" min="1" max="10" value={desiredScore} onChange={e => setDesiredScore(parseInt(e.target.value))} style={{ flex: 1 }} /><span style={{ fontSize: '1.25rem', fontWeight: 'bold', minWidth: '3ch', color: '#10b981' }}>{desiredScore}</span></div></div><div style={{ marginBottom: '1.5rem' }}><label className="form-label">Additional Feedback (Optional)</label><textarea className="form-input" rows={3} placeholder="Any suggestions or thoughts on how we can improve?" value={feedback} onChange={e => setFeedback(e.target.value)} /></div><button className="btn btn-primary" onClick={submitResponse} disabled={!reflection.trim()} style={{ width: '100%' }}>Submit Response</button></div></>
                    )}
                </div>
            );
        };

        // --- INSTALL SLIDESHOW COMPONENT ---
        const RenderInstallSlideshow = ({ plays, wizLibrary, positionNames }) => {
            const [currentIndex, setCurrentIndex] = useState(0);

            // Filter plays that have isInstall: true
            const installPlays = useMemo(() => {
                if (!plays) return [];
                return plays.filter(p => p.isInstall === true);
            }, [plays]);

            if (installPlays.length === 0) {
                return (
                    <div style={{ padding: '2rem', textAlign: 'center', color: '#666' }}>
                        <h3>No plays added to Install Slideshow.</h3>
                        <p>Go to "Edit Play" and check "Add to Install Slideshow" to see plays here.</p>
                    </div>
                );
            }

            const currentPlay = installPlays[currentIndex];

            return (
                <div style={{ height: 'calc(100vh - 100px)', display: 'flex', flexDirection: 'column' }}>
                    <div style={{ padding: '1rem', borderBottom: '1px solid #ccc', display: 'flex', justifyContent: 'space-between', alignItems: 'center', background: 'white' }}>
                        <div>
                            <h2 style={{ margin: 0 }}>Install Slideshow</h2>
                            <p style={{ margin: 0, color: '#666' }}>{currentPlay.name} ({currentIndex + 1} of {installPlays.length})</p>
                        </div>
                        <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center' }}>
                            <span style={{ fontSize: '0.9rem', color: '#666', marginRight: '1rem' }}>Click lines to view drills</span>
                            <button className="btn btn-secondary" onClick={() => setCurrentIndex(prev => Math.max(0, prev - 1))} disabled={currentIndex === 0}>Previous</button>
                            <button className="btn btn-secondary" onClick={() => setCurrentIndex(prev => Math.min(installPlays.length - 1, prev + 1))} disabled={currentIndex === installPlays.length - 1}>Next</button>
                        </div>
                    </div>
                    <div style={{ flex: 1, background: '#f0f0f0', position: 'relative' }}>
                        {/* Key: Force re-mount on play change */}
                        <PlayDiagramEditor
                            key={currentPlay.id}
                            initialData={currentPlay.diagramData || { elements: [] }}
                            onSave={() => { }}
                            onCancel={() => { }}
                            mode="standard"
                            readOnly={true}
                            positionNames={positionNames}
                            wizLibrary={wizLibrary}
                        />
                    </div>
                </div>
            );
        };



        const SelfScoutAnalytics = ({ phase }) => {
            // State for Data and Mapping
            const [data, setData] = useLocalStorage(`self-scout-data-${phase}`, []);
            const [rawHeaders, setRawHeaders] = useLocalStorage(`self-scout-headers-${phase}`, []);
            const [columnMapping, setColumnMapping] = useLocalStorage(`self-scout-mapping-${phase}`, {});
            const [activeTab, setActiveTab] = useState('setup'); // 'setup', 'analysis'
            const [columnOrder, setColumnOrder] = useLocalStorage(`self-scout-order-${phase}`, []);
            const [customFields, setCustomFields] = useLocalStorage(`self-scout-custom-fields-${phase}`, []);
            const [showUploader, setShowUploader] = useState(false);

            // Handle File Upload
            const handleFileUpload = (parsedData, headers, metadata) => {
                // 1. Check for duplicate game
                const isDuplicate = data.some(row => row.Week == metadata.week && row.Opponent === metadata.opponent);
                if (isDuplicate) {
                    if (!window.confirm(`Data for Week ${metadata.week} vs ${metadata.opponent} already exists. Do you want to append this data anyway?`)) {
                        return;
                    }
                }

                // 2. Inject Metadata
                const enhancedData = parsedData.map(row => ({
                    ...row,
                    Week: metadata.week,
                    Opponent: metadata.opponent
                }));

                // 3. Append Data
                setData(prev => [...prev, ...enhancedData]);

                // 4. Update Headers (Merge unique)
                setRawHeaders(prev => Array.from(new Set(['Week', 'Opponent', ...prev, ...headers])));

                // 5. Update Column Order
                setColumnOrder(prev => {
                    let newOrder = [...prev];
                    // Ensure Week and Opponent are at the start
                    if (!newOrder.includes('Week')) newOrder.unshift('Week');
                    if (!newOrder.includes('Opponent')) newOrder.splice(1, 0, 'Opponent');

                    // Add new headers
                    headers.forEach(h => {
                        if (!newOrder.includes(h)) newOrder.push(h);
                    });
                    return newOrder;
                });

                // 6. Initialize mapping if empty
                if (Object.keys(columnMapping).length === 0) {
                    const initialMapping = {};
                    const standardFields = ['Week', 'Opponent', 'ODK', 'DN', 'DIST', 'YARD LN', 'HASH', 'PLAY TYPE', 'RESULT', 'GN/LS', 'EFF'];
                    // Combine standard and custom fields for auto-mapping check
                    const allFields = [...standardFields, ...customFields.map(f => f.id)];

                    headers.forEach(h => {
                        const match = allFields.find(f => f.toLowerCase() === h.toLowerCase());
                        if (match) initialMapping[match] = h;
                    });
                    // Force map injected fields
                    initialMapping['Week'] = 'Week';
                    initialMapping['Opponent'] = 'Opponent';

                    setColumnMapping(initialMapping);
                } else {
                    // Update mapping if Week/Opponent not mapped
                    setColumnMapping(prev => ({
                        ...prev,
                        'Week': prev['Week'] || 'Week',
                        'Opponent': prev['Opponent'] || 'Opponent'
                    }));
                }

                setShowUploader(false);
            };

            const deleteGame = (week, opponent) => {
                if (window.confirm(`Delete all data for Week ${week} vs ${opponent}?`)) {
                    setData(prev => prev.filter(row => !(row.Week == week && row.Opponent === opponent)));
                }
            };

            // Get unique loaded games
            const loadedGames = useMemo(() => {
                const games = new Set();
                data.forEach(row => {
                    if (row.Week && row.Opponent) {
                        games.add(`${row.Week}|${row.Opponent}`);
                    }
                });
                return Array.from(games).map(g => {
                    const [week, opponent] = g.split('|');
                    const count = data.filter(r => r.Week == week && r.Opponent === opponent).length;
                    return { week, opponent, count };
                }).sort((a, b) => Number(a.week) - Number(b.week));
            }, [data]);

            const clearData = () => {
                if (window.confirm('Are you sure you want to clear all data? This cannot be undone.')) {
                    setData([]);
                    setRawHeaders([]);
                    setColumnMapping({});
                    setColumnOrder([]);
                }
            };

            return (
                <div style={{ padding: '1.5rem', height: 'calc(100vh - 80px)', display: 'flex', flexDirection: 'column' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                        <div>
                            <h1 style={{ fontSize: '1.8rem', fontWeight: 'bold', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                <Icon name="BarChart2" /> {phase} Self-Scout Analytics
                            </h1>
                            <div style={{ fontSize: '0.9rem', color: 'var(--text-secondary)' }}>
                                {data.length > 0 ? `${data.length} plays loaded` : 'No data loaded'}
                            </div>
                        </div>
                        <div style={{ display: 'flex', gap: '1rem' }}>
                            <div style={{ display: 'flex', background: 'var(--bg-panel)', padding: '4px', borderRadius: '8px' }}>
                                <button
                                    onClick={() => setActiveTab('setup')}
                                    className={`btn ${activeTab === 'setup' ? 'btn-primary' : 'btn-text'}`}
                                    style={{ padding: '0.5rem 1rem' }}
                                >
                                    Setup & Data
                                </button>
                                <button
                                    onClick={() => setActiveTab('analysis')}
                                    className={`btn ${activeTab === 'analysis' ? 'btn-primary' : 'btn-text'}`}
                                    style={{ padding: '0.5rem 1rem' }}
                                >
                                    Analysis Dashboard
                                </button>
                            </div>
                            {data.length > 0 && (
                                <button
                                    className="btn btn-danger"
                                    onClick={() => setData([])}
                                    style={{ padding: '0.4rem 0.8rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}
                                >
                                    <Icon name="Trash2" size={16} /> Clear Data
                                </button>
                            )}
                        </div>
                    </div>

                    {
                        activeTab === 'setup' && (
                            <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem', height: '100%', overflow: 'hidden' }}>

                                {/* Data Management Panel */}
                                <div style={{ padding: '1rem', background: 'var(--surface)', borderRadius: '8px', border: '1px solid var(--border)', flexShrink: 0 }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                        <h3 style={{ fontSize: '1.1rem', fontWeight: 'bold', margin: 0 }}>Data Management</h3>
                                        {data.length > 0 && (
                                            <button
                                                className="btn btn-secondary btn-sm"
                                                onClick={() => setShowUploader(!showUploader)}
                                            >
                                                <Icon name={showUploader ? "X" : "Upload"} size={14} /> {showUploader ? 'Cancel Upload' : 'Upload Another Game'}
                                            </button>
                                        )}
                                    </div>

                                    {loadedGames.length > 0 && (
                                        <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.5rem', marginBottom: showUploader ? '1rem' : 0 }}>
                                            {loadedGames.map(game => (
                                                <div key={`${game.week}-${game.opponent}`} style={{
                                                    display: 'flex', alignItems: 'center', gap: '0.5rem',
                                                    padding: '0.25rem 0.5rem', background: 'var(--bg-main)',
                                                    border: '1px solid var(--border)', borderRadius: '4px', fontSize: '0.85rem'
                                                }}>
                                                    <span style={{ fontWeight: 'bold' }}>Week {game.week}</span> vs {game.opponent}
                                                    <span style={{ color: 'var(--text-secondary)' }}>({game.count} plays)</span>
                                                    <button
                                                        onClick={() => deleteGame(game.week, game.opponent)}
                                                        style={{ background: 'none', border: 'none', cursor: 'pointer', color: '#ef4444', padding: '2px' }}
                                                        title="Delete Game"
                                                    >
                                                        <Icon name="Trash2" size={12} />
                                                    </button>
                                                </div>
                                            ))}
                                        </div>
                                    )}

                                    {(showUploader || data.length === 0) && (
                                        <div style={{ marginTop: loadedGames.length > 0 ? '1rem' : 0 }}>
                                            <CsvUploader onUpload={handleFileUpload} />
                                        </div>
                                    )}
                                </div>

                                {/* Mapper and Table (Only if data exists) */}
                                {data.length > 0 && (
                                    <>
                                        <ColumnMapper
                                            headers={rawHeaders}
                                            mapping={columnMapping}
                                            setMapping={setColumnMapping}
                                            columnOrder={columnOrder}
                                            setColumnOrder={setColumnOrder}
                                            customFields={customFields}
                                            setCustomFields={setCustomFields}
                                        />
                                        <div style={{ overflow: 'auto', background: 'var(--surface)', borderRadius: '8px', border: '1px solid var(--border)', flex: 1 }}>
                                            <table className="w-full text-sm">
                                                <thead>
                                                    <tr style={{ position: 'sticky', top: 0, background: 'var(--surface)', zIndex: 10 }}>
                                                        {columnOrder.map(header => (
                                                            <th key={header} style={{ padding: '0.75rem', textAlign: 'left', borderBottom: '1px solid var(--border)', whiteSpace: 'nowrap' }}>
                                                                {header}
                                                                {Object.entries(columnMapping).find(([sys, csv]) => csv === header) && (
                                                                    <span style={{ marginLeft: '0.5rem', fontSize: '0.7rem', background: 'var(--accent)', color: 'white', padding: '2px 4px', borderRadius: '4px' }}>
                                                                        {Object.entries(columnMapping).find(([sys, csv]) => csv === header)[0]}
                                                                    </span>
                                                                )}
                                                            </th>
                                                        ))}
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    {data.slice(0, 100).map((row, i) => (
                                                        <tr key={i} style={{ borderBottom: '1px solid var(--border-light)' }}>
                                                            {columnOrder.map(header => (
                                                                <td key={header} style={{ padding: '0.5rem 0.75rem', whiteSpace: 'nowrap' }}>
                                                                    {row[header]}
                                                                </td>
                                                            ))}
                                                        </tr>
                                                    ))}
                                                </tbody>
                                            </table>
                                            {data.length > 100 && (
                                                <div style={{ padding: '1rem', textAlign: 'center', color: 'var(--text-secondary)' }}>
                                                    Showing first 100 rows of {data.length}
                                                </div>
                                            )}
                                        </div>
                                    </>
                                )}
                            </div>
                        )
                    }

                    {
                        activeTab === 'analysis' && (
                            data.length > 0 ? (
                                <AnalyticsDashboard data={data} mapping={columnMapping} />
                            ) : (
                                <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', height: '100%', color: 'var(--text-secondary)' }}>
                                    <Icon name="BarChart2" size={48} style={{ marginBottom: '1rem', opacity: 0.5 }} />
                                    <h3 style={{ fontSize: '1.2rem', marginBottom: '0.5rem' }}>No Data Available</h3>
                                    <p style={{ marginBottom: '1.5rem' }}>Please upload data in the Setup tab to view analytics.</p>
                                    <button onClick={() => setActiveTab('setup')} className="btn btn-primary">Go to Setup</button>
                                </div>
                            )
                        )
                    }
                </div >
            );
        };

        const CsvUploader = ({ onUpload }) => {
            const fileInputRef = useRef(null);
            const [error, setError] = useState(null);

            const parseCSV = (text) => {
                const lines = text.split('\n').filter(l => l.trim());
                if (lines.length < 2) return null;

                const headers = lines[0].match(/(".*?"|[^",\s]+)(?=\s*,|\s*$)/g).map(h => h.replace(/^"|"$/g, '').trim());

                const result = [];
                for (let i = 1; i < lines.length; i++) {
                    const row = {};
                    const currentLine = lines[i];
                    const values = currentLine.match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g);

                    if (values) {
                        headers.forEach((header, index) => {
                            let value = values[index] ? values[index].replace(/^"|"$/g, '').trim() : '';
                            row[header] = value;
                        });
                        result.push(row);
                    }
                }
                return { headers, data: result };
            };

            const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const parsed = parseCSV(event.target.result);
                        if (parsed) {
                            onUpload(parsed.data, parsed.headers, { week, opponent });
                        } else {
                            setError('Could not parse CSV file. Please check format.');
                        }
                    } catch (err) {
                        console.error(err);
                        setError('Error parsing file: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };

            const [week, setWeek] = useState('1');
            const [opponent, setOpponent] = useState('');

            return (
                <div style={{
                    display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center',
                    padding: '2rem', border: '2px dashed var(--border)', borderRadius: '12px', background: 'var(--bg-secondary)',
                    maxWidth: '600px', margin: '0 auto'
                }}>
                    <Icon name="UploadCloud" size={48} style={{ color: 'var(--accent)', marginBottom: '1rem' }} />
                    <h3 style={{ fontSize: '1.5rem', fontWeight: 'bold', marginBottom: '0.5rem' }}>Upload Hudl Data</h3>
                    <p style={{ color: 'var(--text-secondary)', marginBottom: '1.5rem', textAlign: 'center' }}>
                        Select the Week and Opponent, then upload your CSV export.
                    </p>

                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 2fr', gap: '1rem', width: '100%', marginBottom: '1.5rem' }}>
                        <div>
                            <label style={{ display: 'block', fontSize: '0.9rem', marginBottom: '0.25rem', fontWeight: 'bold' }}>Week</label>
                            <select className="form-select" value={week} onChange={(e) => setWeek(e.target.value)} style={{ width: '100%' }}>
                                {Array.from({ length: 18 }, (_, i) => i + 1).map(w => (
                                    <option key={w} value={w}>Week {w}</option>
                                ))}
                            </select>
                        </div>
                        <div>
                            <label style={{ display: 'block', fontSize: '0.9rem', marginBottom: '0.25rem', fontWeight: 'bold' }}>Opponent</label>
                            <input
                                type="text"
                                className="form-input"
                                placeholder="e.g. Tigers"
                                value={opponent}
                                onChange={(e) => setOpponent(e.target.value)}
                                style={{ width: '100%' }}
                            />
                        </div>
                    </div>

                    <input
                        type="file"
                        accept=".csv"
                        ref={fileInputRef}
                        onChange={handleFileChange}
                        style={{ display: 'none' }}
                    />
                    <button
                        onClick={() => fileInputRef.current.click()}
                        className="btn btn-primary"
                        style={{ padding: '0.75rem 2rem' }}
                        disabled={!opponent.trim()}
                        title={!opponent.trim() ? "Please enter an opponent name" : ""}
                    >
                        Select CSV File
                    </button>
                    {error && <div style={{ color: '#ef4444', marginTop: '1rem' }}>{error}</div>}
                </div>
            );
        };

        const ColumnMapper = ({ headers, mapping, setMapping, columnOrder, setColumnOrder, customFields, setCustomFields }) => {
            const systemFields = [
                { id: 'Week', label: 'Week', required: true },
                { id: 'Opponent', label: 'Opponent', required: true },
                { id: 'ODK', label: 'ODK', required: true },
                { id: 'DN', label: 'Down', required: true },
                { id: 'DIST', label: 'Distance', required: true },
                { id: 'YARD LN', label: 'Yard Line', required: true },
                { id: 'HASH', label: 'Hash', required: false },
                { id: 'PLAY TYPE', label: 'Play Type', required: true },
                { id: 'RESULT', label: 'Result', required: false },
                { id: 'GN/LS', label: 'Gain/Loss', required: false },
                { id: 'EFF', label: 'Efficiency', required: false },
                ...customFields
            ];

            const handleAddField = () => {
                const name = prompt("Enter new field name (e.g., 'Play Call', 'Target'):");
                if (name && name.trim()) {
                    const id = name.trim();
                    // Prevent duplicates
                    if (systemFields.some(f => f.id.toLowerCase() === id.toLowerCase())) {
                        alert("Field already exists!");
                        return;
                    }
                    const newField = { id, label: name.trim(), required: false, isCustom: true };
                    setCustomFields([...customFields, newField]);
                }
            };

            const moveColumn = (fromIndex, toIndex) => {
                const newOrder = [...columnOrder];
                const [moved] = newOrder.splice(fromIndex, 1);
                newOrder.splice(toIndex, 0, moved);
                setColumnOrder(newOrder);
            };

            return (
                <div style={{ padding: '1rem', background: 'var(--surface)', borderRadius: '8px', border: '1px solid var(--border)', flexShrink: 0 }}>
                    <h3 style={{ fontSize: '1.1rem', fontWeight: 'bold', marginBottom: '1rem' }}>Column Configuration</h3>

                    <div style={{ marginBottom: '1rem' }}>
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '0.5rem' }}>
                            <h4 style={{ fontSize: '0.9rem', color: 'var(--text-secondary)', textTransform: 'uppercase', letterSpacing: '0.05em', margin: 0 }}>Map System Fields</h4>
                            <span style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>Scroll horizontal to see more →</span>
                        </div>
                        <div style={{ display: 'flex', flexDirection: 'row', gap: '1rem', overflowX: 'auto', paddingBottom: '0.5rem' }}>
                            {systemFields.map(field => (
                                <div key={field.id} style={{ minWidth: '200px' }}>
                                    <label style={{ display: 'block', fontSize: '0.85rem', fontWeight: '600', marginBottom: '0.25rem' }}>
                                        {field.label} {field.required && <span style={{ color: '#ef4444' }}>*</span>}
                                    </label>
                                    <select
                                        className="form-select"
                                        value={mapping[field.id] || ''}
                                        onChange={(e) => setMapping({ ...mapping, [field.id]: e.target.value })}
                                        style={{ width: '100%', fontSize: '0.9rem', padding: '0.5rem' }}
                                    >
                                        <option value="">-- Select Column --</option>
                                        {headers.map(h => (
                                            <option key={h} value={h}>{h}</option>
                                        ))}
                                    </select>
                                </div>
                            ))}

                            {/* Add Custom Field Button */}
                            <div style={{ minWidth: '150px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                                <button
                                    onClick={handleAddField}
                                    style={{
                                        background: 'var(--bg-main)',
                                        border: '1px dashed var(--text-secondary)',
                                        color: 'var(--text-secondary)',
                                        padding: '1rem',
                                        borderRadius: '8px',
                                        cursor: 'pointer',
                                        width: '100%',
                                        height: '100%',
                                        display: 'flex',
                                        flexDirection: 'column',
                                        alignItems: 'center',
                                        gap: '0.5rem'
                                    }}
                                >
                                    <span style={{ fontSize: '1.5rem', lineHeight: 1 }}>+</span>
                                    <span style={{ fontSize: '0.9rem' }}>Add Field</span>
                                </button>
                            </div>
                        </div>
                    </div>

                    <div>
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '0.5rem' }}>
                            <h4 style={{ fontSize: '0.9rem', color: 'var(--text-secondary)', textTransform: 'uppercase', letterSpacing: '0.05em', margin: 0 }}>Column Display Order</h4>
                        </div>
                        <div style={{ display: 'flex', flexDirection: 'row', gap: '0.5rem', overflowX: 'auto', paddingBottom: '0.5rem', alignItems: 'center' }}>
                            {columnOrder.map((col, idx) => (
                                <div key={col} style={{
                                    padding: '0.5rem 1rem',
                                    minWidth: 'max-content',
                                    background: 'var(--bg-main)',
                                    border: '1px solid var(--border)',
                                    borderRadius: '20px',
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '0.5rem'
                                }}>
                                    <div style={{ display: 'flex', flexDirection: 'row', gap: '2px' }}>
                                        <button disabled={idx === 0} onClick={() => moveColumn(idx, idx - 1)} style={{ cursor: 'pointer', opacity: idx === 0 ? 0.3 : 1, border: 'none', background: 'none' }}>◄</button>
                                        <button disabled={idx === columnOrder.length - 1} onClick={() => moveColumn(idx, idx + 1)} style={{ cursor: 'pointer', opacity: idx === columnOrder.length - 1 ? 0.3 : 1, border: 'none', background: 'none' }}>►</button>
                                    </div>
                                    <span style={{ fontSize: '0.9rem' }}>{col}</span>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        const AnalyticsDashboard = ({ data, mapping }) => {
            const { PieChart, Pie, Cell, BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip: RechartsTooltip, Legend, ResponsiveContainer } = Recharts;
            const [filters, setFilters] = useState({});
            const [isFilterSidebarOpen, setIsFilterSidebarOpen] = useState(true);

            // Helper: Get unique values for a column
            const getUniqueValues = (column) => {
                const values = new Set(data.map(row => row[column]).filter(Boolean));
                return Array.from(values).sort();
            };

            // Filter Data
            const filteredData = data.filter(row => {
                return Object.entries(filters).every(([key, selectedValues]) => {
                    if (!selectedValues || selectedValues.length === 0) return true;
                    return selectedValues.includes(row[key]);
                });
            });

            // Toggle Filter
            const toggleFilter = (column, value) => {
                setFilters(prev => {
                    const current = prev[column] || [];
                    const updated = current.includes(value)
                        ? current.filter(v => v !== value)
                        : [...current, value];
                    return { ...prev, [column]: updated };
                });
            };

            // -- Chart Data Preparation --

            // 1. Run vs Pass (Pie)
            const playTypeCol = mapping['PLAY TYPE'];
            const runPassData = useMemo(() => {
                if (!playTypeCol) return [];
                const counts = { Run: 0, Pass: 0, Other: 0 };
                filteredData.forEach(row => {
                    const type = (row[playTypeCol] || '').toLowerCase();
                    if (type.includes('run') || type.includes('rush')) counts.Run++;
                    else if (type.includes('pass') || type.includes('throw')) counts.Pass++;
                    else counts.Other++;
                });
                return [
                    { name: 'Run', value: counts.Run },
                    { name: 'Pass', value: counts.Pass }
                ].filter(d => d.value > 0);
            }, [filteredData, playTypeCol]);
            const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042'];

            // 2. Efficiency by Down (Bar)
            const downCol = mapping['DN'];
            const effCol = mapping['EFF'];
            const efficiencyByDown = useMemo(() => {
                if (!downCol || !effCol) return [];
                const stats = { 1: { total: 0, succ: 0 }, 2: { total: 0, succ: 0 }, 3: { total: 0, succ: 0 }, 4: { total: 0, succ: 0 } };
                filteredData.forEach(row => {
                    const down = parseInt(row[downCol]);
                    if (stats[down]) {
                        stats[down].total++;
                        if ((row[effCol] || '').toLowerCase().includes('y')) stats[down].succ++; // Assuming 'Y' or 'Yes' for efficiency
                    }
                });
                return Object.entries(stats).map(([dn, vals]) => ({
                    name: `Down ${dn}`,
                    Efficiency: vals.total ? Math.round((vals.succ / vals.total) * 100) : 0,
                    Plays: vals.total
                }));
            }, [filteredData, downCol, effCol]);

            // 3. Top 5 Results (if Result mapped)
            const resultCol = mapping['RESULT'];
            const resultDistribution = useMemo(() => {
                if (!resultCol) return [];
                const counts = {};
                filteredData.forEach(row => {
                    const res = row[resultCol] || 'Unknown';
                    counts[res] = (counts[res] || 0) + 1;
                });
                return Object.entries(counts)
                    .map(([name, value]) => ({ name, value }))
                    .sort((a, b) => b.value - a.value)
                    .slice(0, 10);
            }, [filteredData, resultCol]);


            return (
                <div style={{ display: 'flex', height: '100%', overflow: 'hidden', gap: '1rem' }}>

                    {/* Filters Sidebar */}
                    <div style={{
                        width: isFilterSidebarOpen ? '250px' : '0px',
                        minWidth: isFilterSidebarOpen ? '250px' : '0px',
                        background: 'var(--surface)',
                        borderRight: '1px solid var(--border)',
                        overflowY: 'auto',
                        transition: 'all 0.3s ease',
                        opacity: isFilterSidebarOpen ? 1 : 0
                    }}>
                        <div style={{ padding: '1rem', borderBottom: '1px solid var(--border)', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <h3 style={{ fontWeight: 'bold' }}>Filters</h3>
                            <button onClick={() => setFilters({})} style={{ fontSize: '0.75rem', color: 'var(--accent)', background: 'none', border: 'none', cursor: 'pointer' }}>Clear All</button>
                        </div>
                        <div style={{ padding: '1rem' }}>
                            {Object.entries(mapping).map(([sysField, csvHeader]) => (
                                <div key={sysField} style={{ marginBottom: '1.5rem' }}>
                                    <div style={{ fontSize: '0.85rem', fontWeight: 'bold', marginBottom: '0.5rem', display: 'flex', alignItems: 'center', gap: '4px' }}>
                                        {sysField} <span style={{ fontSize: '0.7rem', fontWeight: 'normal', color: 'var(--text-secondary)' }}>({csvHeader})</span>
                                    </div>
                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '4px', maxHeight: '150px', overflowY: 'auto' }}>
                                        {getUniqueValues(csvHeader).map(val => (
                                            <label key={val} style={{ display: 'flex', alignItems: 'center', gap: '6px', fontSize: '0.8rem', cursor: 'pointer' }}>
                                                <input
                                                    type="checkbox"
                                                    checked={(filters[csvHeader] || []).includes(val)}
                                                    onChange={() => toggleFilter(csvHeader, val)}
                                                />
                                                <span style={{ whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>{val}</span>
                                            </label>
                                        ))}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>

                    {/* Main Content */}
                    <div style={{ flex: 1, overflowY: 'auto', padding: '1rem' }}>
                        <div style={{ marginBottom: '1rem' }}>
                            <button onClick={() => setIsFilterSidebarOpen(!isFilterSidebarOpen)} className="btn btn-sm btn-secondary">
                                <Icon name="Filter" size={14} /> {isFilterSidebarOpen ? 'Hide Filters' : 'Show Filters'}
                            </button>
                            <span style={{ marginLeft: '1rem', color: 'var(--text-secondary)', fontSize: '0.9rem' }}>
                                Showing {filteredData.length} of {data.length} plays
                            </span>
                        </div>

                        {/* Charts Area */}
                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(400px, 1fr))', gap: '1.5rem', marginBottom: '2rem' }}>

                            {/* Run/Pass Breakdown */}
                            <div className="card" style={{ padding: '1.5rem', background: 'var(--surface)', border: '1px solid var(--border)', borderRadius: '8px' }}>
                                <h3 style={{ fontWeight: 'bold', marginBottom: '1rem', textAlign: 'center' }}>Run / Pass Ratio</h3>
                                <div style={{ height: '300px' }}>
                                    {runPassData.length > 0 ? (
                                        <ResponsiveContainer width="100%" height="100%">
                                            <PieChart>
                                                <Pie
                                                    data={runPassData}
                                                    cx="50%"
                                                    cy="50%"
                                                    labelLine={false}
                                                    label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
                                                    outerRadius={100}
                                                    fill="#8884d8"
                                                    dataKey="value"
                                                >
                                                    {runPassData.map((entry, index) => (
                                                        <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                                                    ))}
                                                </Pie>
                                                <RechartsTooltip />
                                                <Legend />
                                            </PieChart>
                                        </ResponsiveContainer>
                                    ) : (
                                        <div style={{ height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'var(--text-secondary)' }}>
                                            Map "PLAY TYPE" to see this chart
                                        </div>
                                    )}
                                </div>
                            </div>

                            {/* Efficiency by Down */}
                            <div className="card" style={{ padding: '1.5rem', background: 'var(--surface)', border: '1px solid var(--border)', borderRadius: '8px' }}>
                                <h3 style={{ fontWeight: 'bold', marginBottom: '1rem', textAlign: 'center' }}>Efficiency by Down</h3>
                                <div style={{ height: '300px' }}>
                                    {efficiencyByDown.length > 0 ? (
                                        <ResponsiveContainer width="100%" height="100%">
                                            <BarChart data={efficiencyByDown}>
                                                <CartesianGrid strokeDasharray="3 3" stroke="var(--border)" />
                                                <XAxis dataKey="name" stroke="var(--text-secondary)" />
                                                <YAxis stroke="var(--text-secondary)" />
                                                <RechartsTooltip contentStyle={{ backgroundColor: 'var(--bg-panel)', borderColor: 'var(--border)' }} />
                                                <Legend />
                                                <Bar dataKey="Efficiency" fill="#82ca9d" name="Efficiency %" />
                                            </BarChart>
                                        </ResponsiveContainer>
                                    ) : (
                                        <div style={{ height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'var(--text-secondary)' }}>
                                            Map "DN" and "EFF" to see this chart
                                        </div>
                                    )}
                                </div>
                            </div>

                            {/* Result Distribution */}
                            <div className="card" style={{ padding: '1.5rem', background: 'var(--surface)', border: '1px solid var(--border)', borderRadius: '8px' }}>
                                <h3 style={{ fontWeight: 'bold', marginBottom: '1rem', textAlign: 'center' }}>Top Play Results</h3>
                                <div style={{ height: '300px' }}>
                                    {resultDistribution.length > 0 ? (
                                        <ResponsiveContainer width="100%" height="100%">
                                            <BarChart data={resultDistribution} layout="vertical">
                                                <CartesianGrid strokeDasharray="3 3" horizontal={false} stroke="var(--border)" />
                                                <XAxis type="number" stroke="var(--text-secondary)" />
                                                <YAxis dataKey="name" type="category" width={100} stroke="var(--text-secondary)" style={{ fontSize: '0.8rem' }} />
                                                <RechartsTooltip contentStyle={{ backgroundColor: 'var(--bg-panel)', borderColor: 'var(--border)' }} />
                                                <Bar dataKey="value" fill="#8884d8" name="Count" />
                                            </BarChart>
                                        </ResponsiveContainer>
                                    ) : (
                                        <div style={{ height: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'var(--text-secondary)' }}>
                                            Map "RESULT" to see this chart
                                        </div>
                                    )}
                                </div>
                            </div>

                        </div>
                    </div>
                </div>
            );
        };



        // Helper function to get play name with assignment suffix
        const getPlayDisplayName = (play) => {
            if (!play || !play.name) return '';

            let suffix = '';

            // Check for mini script (A or B)
            if (play.isMiniScript && play.wristbandSlot) {
                // Extract letter from wristband slot (e.g., "A" from "A1" or "B" from "B2")
                const letter = play.wristbandSlot.charAt(0);
                if (letter === 'A' || letter === 'B') {
                    suffix = letter;
                }
            }
            // Check for Wiz card
            else if (play.isWiz && play.wristbandSlot) {
                suffix = 'W';
            }
            // Check for Wiz card (Legacy fallback)
            else if ((play.isWiz || play.isRooski) && play.wristbandSlot) {
                suffix = 'W';
            }
            // Traditional wristband - NO SUFFIX ON NAME

            return play.name + suffix;
        };

        const getWristbandLabel = (play) => {
            if (!play || !play.wristbandSlot) return null;
            let suffix = 'T'; // Default Traditional
            if (play.isWiz || play.isRooski) suffix = 'W';
            else if (play.isMiniScript) {
                // Logic for MiniScript suffix if needed, or rely on slot content
                const first = play.wristbandSlot.charAt(0).toUpperCase();
                if (first === 'A' || first === 'B') suffix = '';
                else suffix = 'A'; // Default to A if ambiguous
                if (/[a-zA-Z]/.test(play.wristbandSlot)) suffix = '';
            }

            // Allow override: if user explicitly sets "101T", don't add another T
            if (play.wristbandSlot.trim().toUpperCase().endsWith(suffix)) return play.wristbandSlot;

            return play.wristbandSlot + suffix;
        };

        const PracticeReportView = ({ weeks, plays, playSyntax = [], parsePlayName }) => {
            const [selectedWeekIds, setSelectedWeekIds] = useState(['all']); // 'all' or array of IDs
            const [filterTerm, setFilterTerm] = useState('');

            // Helper to get selected weeks
            const getSelectedWeeks = () => {
                if (selectedWeekIds.includes('all')) return weeks;
                return weeks.filter(w => selectedWeekIds.includes(w.id));
            };

            // Aggregation Logic
            const reportData = useMemo(() => {
                const activeWeeks = getSelectedWeeks();
                const data = {
                    totalPlays: 0,
                    byPlayName: {}, // { name: count }
                    byFormation: {},
                    byTag: {},
                    syntaxBreakdown: {} // { fieldId: { value: count } }
                };

                // Initialize syntax breakdown
                playSyntax.forEach(field => {
                    data.syntaxBreakdown[field.id] = {};
                });

                activeWeeks.forEach(week => {
                    if (!Array.isArray(week.practicePlans)) return;
                    week.practicePlans.forEach(plan => {
                        if (!plan.segments) return;
                        plan.segments.forEach(seg => {
                            if (seg.items) {
                                seg.items.forEach(item => {
                                    // Detect if item is likely a play script item
                                    const rawName = item.playName || item.text || item.name || '';
                                    if (!rawName) return;

                                    data.totalPlays++;

                                    // 1. Play Name Count
                                    data.byPlayName[rawName] = (data.byPlayName[rawName] || 0) + 1;

                                    // 2. Syntax Breakdown
                                    let playParts = {};

                                    // Strategy A: Use Play ID lookup
                                    if (item.playId && plays) {
                                        const masterPlay = plays.find(p => p.id === item.playId);
                                        if (masterPlay && masterPlay.syntaxValues) {
                                            playParts = masterPlay.syntaxValues;
                                        }
                                    }

                                    // Strategy B: Fallback to Parser (if empty parts)
                                    if (Object.keys(playParts).length === 0) {
                                        // Use parsePlayName (L4400)
                                        const parsed = parsePlayName(rawName);
                                        // Map hardcoded results to syntax fields if possible
                                        if (parsed.formations.length) playParts['formation'] = parsed.formations[0];
                                    }

                                    // Count parts
                                    playSyntax.forEach(field => {
                                        const val = playParts[field.id];
                                        if (val) {
                                            if (!data.syntaxBreakdown[field.id]) data.syntaxBreakdown[field.id] = {};
                                            data.syntaxBreakdown[field.id][val] = (data.syntaxBreakdown[field.id][val] || 0) + 1;

                                            // Special buckets for top-level stats
                                            if (field.label.toLowerCase().includes('formation')) {
                                                data.byFormation[val] = (data.byFormation[val] || 0) + 1;
                                            }
                                        }
                                    });
                                });
                            }
                        });
                    });
                });

                return data;
            }, [selectedWeekIds, weeks, plays, playSyntax]);

            return (
                <div style={{ height: '100%', display: 'flex', flexDirection: 'column', gap: '1rem', padding: '1rem', overflow: 'hidden' }}>
                    {/* Header & Filters */}
                    <div className="card" style={{ padding: '1.5rem' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                            <h2 style={{ margin: 0, display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                <Icon name="FileBarChart" size={24} />
                                Practice Reps Report
                            </h2>
                            <div style={{ display: 'flex', gap: '0.5rem' }}>
                                <select
                                    className="form-input"
                                    value={selectedWeekIds.includes('all') ? 'all' : selectedWeekIds[0]} // Simplified for single select UI, but logic supports multi
                                    onChange={(e) => setSelectedWeekIds(e.target.value === 'all' ? ['all'] : [e.target.value])}
                                >
                                    <option value="all">All Weeks</option>
                                    {weeks.map(w => (
                                        <option key={w.id} value={w.id}>{w.name}</option>
                                    ))}
                                </select>
                            </div>
                        </div>

                        {/* Summary Stats */}
                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))', gap: '1rem' }}>
                            <div style={{ background: 'var(--surface)', padding: '1rem', borderRadius: '8px', border: '1px solid var(--border)' }}>
                                <div style={{ fontSize: '0.9rem', opacity: 0.8 }}>Total Reps</div>
                                <div style={{ fontSize: '1.5rem', fontWeight: 'bold' }}>{reportData.totalPlays}</div>
                            </div>
                            <div style={{ background: 'var(--surface)', padding: '1rem', borderRadius: '8px', border: '1px solid var(--border)' }}>
                                <div style={{ fontSize: '0.9rem', opacity: 0.8 }}>Unique Plays</div>
                                <div style={{ fontSize: '1.5rem', fontWeight: 'bold' }}>{Object.keys(reportData.byPlayName).length}</div>
                            </div>
                        </div>
                    </div>

                    {/* Report Body */}
                    <div style={{ display: 'flex', gap: '1rem', flex: 1, overflow: 'hidden' }}>
                        {/* Column 1: Syntax Breakdown */}
                        <div className="card" style={{ width: '300px', display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
                            <div style={{ padding: '1rem', borderBottom: '1px solid var(--border)', fontWeight: 'bold' }}>By Concept / Tag</div>
                            <div style={{ overflowY: 'auto', padding: '1rem' }}>
                                {playSyntax.map(field => {
                                    const counts = reportData.syntaxBreakdown[field.id] || {};
                                    const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);
                                    if (sorted.length === 0) return null;

                                    return (
                                        <div key={field.id} style={{ marginBottom: '1.5rem' }}>
                                            <div style={{ fontSize: '0.85rem', fontWeight: 'bold', textTransform: 'uppercase', color: 'var(--accent)', marginBottom: '0.5rem' }}>
                                                {field.label}
                                            </div>
                                            {sorted.map(([val, count]) => (
                                                <div key={val} style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.9rem', marginBottom: '0.25rem' }}>
                                                    <span>{val}</span>
                                                    <span style={{ fontWeight: 'bold', background: 'rgba(0,0,0,0.05)', padding: '0 6px', borderRadius: '4px' }}>{count}</span>
                                                </div>
                                            ))}
                                        </div>
                                    );
                                })}
                            </div>
                        </div>

                        {/* Column 2: Play List */}
                        <div className="card" style={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
                            <div style={{ padding: '1rem', borderBottom: '1px solid var(--border)', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                <span style={{ fontWeight: 'bold' }}>Play Volume</span>
                                <input
                                    className="form-input"
                                    placeholder="Search..."
                                    value={filterTerm}
                                    onChange={e => setFilterTerm(e.target.value)}
                                    style={{ width: '200px', fontSize: '0.9rem', padding: '0.4rem' }}
                                />
                            </div>
                            <div style={{ overflowY: 'auto' }}>
                                <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                                    <thead>
                                        <tr style={{ borderBottom: '2px solid var(--border)', background: 'var(--background)' }}>
                                            <th style={{ textAlign: 'left', padding: '0.75rem', position: 'sticky', top: 0, background: 'var(--background)' }}>Play Call</th>
                                            {playSyntax.map(f => (
                                                <th key={f.id} style={{ textAlign: 'left', padding: '0.75rem', fontSize: '0.8rem', position: 'sticky', top: 0, background: 'var(--background)' }}>{f.label}</th>
                                            ))}
                                            <th style={{ textAlign: 'center', padding: '0.75rem', width: '60px', position: 'sticky', top: 0, background: 'var(--background)' }}>Reps</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {Object.entries(reportData.byPlayName)
                                            .sort((a, b) => b[1] - a[1])
                                            .filter(([name]) => name.toLowerCase().includes(filterTerm.toLowerCase()))
                                            .map(([name, count]) => {
                                                // Try to resolve play parts for display row (just grab from Master if possible, otherwise parsed)
                                                let displayParts = {};
                                                // Find ANY play with this name?
                                                let matchedPlay = plays ? plays.find(p => p.name === name) : null;
                                                if (matchedPlay && matchedPlay.syntaxValues) {
                                                    displayParts = matchedPlay.syntaxValues;
                                                } else {
                                                    // Fallback parse
                                                    const p = parsePlayName(name);
                                                    if (p.formations.length) displayParts['formation'] = p.formations[0];
                                                }

                                                return (
                                                    <tr key={name} style={{ borderBottom: '1px solid var(--border)' }}>
                                                        <td style={{ padding: '0.75rem', fontWeight: '500' }}>{name}</td>
                                                        {playSyntax.map(f => (
                                                            <td key={f.id} style={{ padding: '0.75rem', fontSize: '0.85rem', color: 'var(--text-secondary)' }}>
                                                                {displayParts[f.id] || '-'}
                                                            </td>
                                                        ))}
                                                        <td style={{ padding: '0.75rem', textAlign: 'center', fontWeight: 'bold' }}>{count}</td>
                                                    </tr>
                                                );
                                            })
                                        }
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- HIERARCHY EDITOR COMPONENT ---
        const HierarchyEditor = ({ segmentTypes, focusItems, settings, onUpdateSettings, onAddSegment, onAddFocus, onRenameSegment, onRenameFocus, deleteConfirmation, setDeleteConfirmation, onDeleteSegment, onDeleteFocus }) => {
            const [selectedSegment, setSelectedSegment] = useState(null);

            // Filter focus items based on link checkboxes
            const isFocusAllowed = (seg, focus) => {
                const segSettings = settings[seg] || {};
                // If no specific allowed list exists, EVERYTHING is allowed (default behavior)
                if (!segSettings.allowedFocusItems || segSettings.allowedFocusItems.length === 0) return true;
                return segSettings.allowedFocusItems.includes(focus);
            };

            const toggleFocusLink = (seg, focus) => {
                const segSettings = settings[seg] || { showHash: true, showDefense: true };
                let currentAllowed = segSettings.allowedFocusItems || [];

                // If currently "All Allowed" (empty), and we click one, we must first "Exclude All Others". 
                // Wait, if I start checking boxes, it implies "Only these are allowed".
                // So if currentAllowed is empty, and I click 'A', then 'A' is the ONLY one allowed.

                if (!currentAllowed.includes(focus)) {
                    // ADDING
                    // Logic: If I add one, and it was empty, then effectively I just switched from "All" to "One".
                    const newAllowed = [...currentAllowed, focus];
                    onUpdateSettings({
                        ...settings,
                        [seg]: { ...segSettings, allowedFocusItems: newAllowed }
                    });
                } else {
                    // REMOVING
                    const newAllowed = currentAllowed.filter(f => f !== focus);
                    onUpdateSettings({
                        ...settings,
                        [seg]: { ...segSettings, allowedFocusItems: newAllowed }
                    });
                }
            };

            // Helper to check if a segment has ANY restrictions
            const hasRestrictions = (seg) => {
                const segSettings = settings[seg] || {};
                return segSettings.allowedFocusItems && segSettings.allowedFocusItems.length > 0;
            };

            return (
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '2rem', height: '100%', minHeight: 0 }}>
                    {/* LEFT: Segment Types */}
                    <div style={{ background: 'var(--bg-main)', padding: '1rem', borderRadius: '8px', border: '1px solid var(--border)', display: 'flex', flexDirection: 'column' }}>
                        <h4 style={{ marginTop: 0, marginBottom: '1rem', borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem' }}>
                            Segment Types
                        </h4>

                        <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '1rem' }}>
                            <input
                                id="new-segment-type"
                                className="form-input"
                                placeholder="New Segment..."
                            />
                            <button className="btn btn-primary" onClick={() => {
                                const val = document.getElementById('new-segment-type').value.trim();
                                if (val) {
                                    onAddSegment(val);
                                    document.getElementById('new-segment-type').value = '';
                                }
                            }}>Add</button>
                        </div>

                        <div style={{ flex: 1, overflowY: 'auto', display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                            {segmentTypes.map(item => {
                                const segSettings = settings[item] || { showHash: true, showDefense: true };
                                const isSelected = selectedSegment === item;
                                const restrictedCount = segSettings.allowedFocusItems?.length || 0;

                                return (
                                    <div
                                        key={item}
                                        onClick={() => setSelectedSegment(item)}
                                        style={{
                                            display: 'flex', justifyContent: 'space-between', alignItems: 'center',
                                            padding: '0.5rem',
                                            background: isSelected ? 'var(--primary)' : 'var(--bg-panel)',
                                            color: isSelected ? 'white' : 'inherit',
                                            borderRadius: '4px',
                                            cursor: 'pointer',
                                            border: isSelected ? '1px solid var(--primary-dark)' : '1px solid transparent'
                                        }}
                                    >
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '2px' }}>
                                            <input
                                                type="text"
                                                value={item}
                                                onChange={(e) => {
                                                    const newName = e.target.value;
                                                    if (newName && newName !== item && !segmentTypes.includes(newName)) {
                                                        onRenameSegment(item, newName);
                                                    }
                                                }}
                                                onBlur={(e) => {
                                                    const newName = e.target.value.trim();
                                                    if (!newName || newName === item) {
                                                        e.target.value = item;
                                                    } else if (segmentTypes.includes(newName)) {
                                                        e.target.value = item;
                                                    }
                                                }}
                                                onKeyDown={(e) => {
                                                    if (e.key === 'Enter') {
                                                        e.target.blur();
                                                    }
                                                }}
                                                onClick={(e) => e.stopPropagation()}
                                                style={{
                                                    background: 'transparent',
                                                    border: 'none',
                                                    color: 'inherit',
                                                    fontWeight: '600',
                                                    fontSize: 'inherit',
                                                    padding: 0,
                                                    outline: 'none',
                                                    width: '100%',
                                                    cursor: 'text'
                                                }}
                                            />
                                            <div style={{ display: 'flex', gap: '12px', fontSize: '0.75rem', color: isSelected ? 'rgba(255,255,255,0.8)' : 'var(--text-secondary)' }}>
                                                <label onClick={e => e.stopPropagation()} style={{ display: 'flex', alignItems: 'center', gap: '4px', cursor: 'pointer' }}>
                                                    <input
                                                        type="checkbox"
                                                        checked={segSettings.showHash !== false}
                                                        onChange={(e) => {
                                                            onUpdateSettings({
                                                                ...settings,
                                                                [item]: { ...segSettings, showHash: e.target.checked }
                                                            });
                                                        }}
                                                    /> Hash
                                                </label>
                                                <label onClick={e => e.stopPropagation()} style={{ display: 'flex', alignItems: 'center', gap: '4px', cursor: 'pointer' }}>
                                                    <input
                                                        type="checkbox"
                                                        checked={segSettings.showDefense !== false}
                                                        onChange={(e) => {
                                                            onUpdateSettings({
                                                                ...settings,
                                                                [item]: { ...segSettings, showDefense: e.target.checked }
                                                            });
                                                        }}
                                                    /> Def
                                                </label>
                                            </div>
                                            {restrictedCount > 0 && (
                                                <span style={{ fontSize: '0.7rem', fontStyle: 'italic', opacity: 0.8 }}>
                                                    {restrictedCount} focus items allowed
                                                </span>
                                            )}
                                        </div>
                                        {deleteConfirmation?.list === 'segments' && deleteConfirmation?.item === item ? (
                                            <div style={{ display: 'flex', gap: '4px' }}>
                                                <button className="btn btn-icon" style={{ color: 'var(--success)' }} onClick={(e) => { e.stopPropagation(); onDeleteSegment(item); }}>
                                                    <Icon name="Check" size={14} />
                                                </button>
                                                <button className="btn btn-icon" style={{ color: 'var(--text-secondary)' }} onClick={(e) => { e.stopPropagation(); setDeleteConfirmation(null); }}>
                                                    <Icon name="X" size={14} />
                                                </button>
                                            </div>
                                        ) : (
                                            <button className="btn btn-icon" style={{ color: isSelected ? 'white' : 'var(--danger)', opacity: 0.7 }} onClick={(e) => { e.stopPropagation(); setDeleteConfirmation({ list: 'segments', item }); }}>
                                                <Icon name="Trash" size={14} />
                                            </button>
                                        )}
                                    </div>
                                );
                            })}
                        </div>
                    </div>

                    {/* RIGHT: Focus Items */}
                    <div style={{ background: 'var(--bg-main)', padding: '1rem', borderRadius: '8px', border: '1px solid var(--border)', display: 'flex', flexDirection: 'column' }}>
                        <h4 style={{ marginTop: 0, marginBottom: '1rem', borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem' }}>
                            {selectedSegment ? `Allowed Focus for "${selectedSegment}"` : 'Focus Items (Master List)'}
                        </h4>

                        {selectedSegment && (
                            <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginBottom: '1rem', background: 'var(--bg-panel)', padding: '0.5rem', borderRadius: '4px' }}>
                                Check items to restrict dropdown options. If <b>none</b> are checked, <b>all</b> items will be available.
                            </div>
                        )}

                        <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '1rem' }}>
                            <input
                                id="new-focus-item"
                                className="form-input"
                                placeholder="New Focus..."
                            />
                            <button className="btn btn-primary" onClick={() => {
                                const val = document.getElementById('new-focus-item').value.trim();
                                if (val) {
                                    onAddFocus(val);
                                    document.getElementById('new-focus-item').value = '';
                                }
                            }}>Add</button>
                        </div>

                        <div style={{ flex: 1, overflowY: 'auto', display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                            {focusItems.map(item => {
                                const isLinked = selectedSegment ? isFocusAllowed(selectedSegment, item) && hasRestrictions(selectedSegment) : false;

                                return (
                                    <div key={item} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '0.5rem', background: 'var(--bg-panel)', borderRadius: '4px' }}>
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                                            {selectedSegment && (
                                                <input
                                                    type="checkbox"
                                                    checked={isLinked}
                                                    onChange={() => toggleFocusLink(selectedSegment, item)}
                                                />
                                            )}
                                            <input
                                                type="text"
                                                value={item}
                                                onChange={(e) => {
                                                    const newName = e.target.value;
                                                    if (newName && newName !== item && !focusItems.includes(newName)) {
                                                        onRenameFocus(item, newName);
                                                    }
                                                }}
                                                onBlur={(e) => {
                                                    const newName = e.target.value.trim();
                                                    if (!newName || newName === item) {
                                                        e.target.value = item;
                                                    } else if (focusItems.includes(newName)) {
                                                        e.target.value = item;
                                                    }
                                                }}
                                                onKeyDown={(e) => {
                                                    if (e.key === 'Enter') {
                                                        e.target.blur();
                                                    }
                                                }}
                                                style={{
                                                    background: 'transparent',
                                                    border: 'none',
                                                    color: 'inherit',
                                                    fontSize: 'inherit',
                                                    padding: 0,
                                                    outline: 'none',
                                                    flex: 1,
                                                    cursor: 'text'
                                                }}
                                            />
                                        </div>
                                        {deleteConfirmation?.list === 'focus' && deleteConfirmation?.item === item ? (
                                            <div style={{ display: 'flex', gap: '4px' }}>
                                                <button className="btn btn-icon" style={{ color: 'var(--success)' }} onClick={() => onDeleteFocus(item)}>
                                                    <Icon name="Check" size={14} />
                                                </button>
                                                <button className="btn btn-icon" style={{ color: 'var(--text-secondary)' }} onClick={() => setDeleteConfirmation(null)}>
                                                    <Icon name="X" size={14} />
                                                </button>
                                            </div>
                                        ) : (
                                            <button className="btn btn-icon" style={{ color: 'var(--danger)', opacity: 0.7 }} onClick={() => setDeleteConfirmation({ list: 'focus', item })}>
                                                <Icon name="Trash" size={14} />
                                            </button>
                                        )}
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                </div>
            );
        };

        const DEFAULT_PLAY_BUCKETS = [
            { id: 'run', label: 'Run', color: '#10b981', textColor: '#ffffff' },
            { id: 'pass', label: 'Pass', color: '#3b82f6', textColor: '#ffffff' },
            { id: 'screen', label: 'Screen', color: '#8b5cf6', textColor: '#ffffff' }
        ];



        /* -------------------------------------------------------------------------- */
        /*                                  ANALYTICS                                  */
        /* -------------------------------------------------------------------------- */

        const PLAY_PROTOCOLS = [
            { id: 'REGULAR', color: '#3b82f6', label: 'Regular', code: 'R' },
            { id: 'SCRAMBLE', color: '#eab308', label: 'Scramble', code: 'SC' },
            { id: 'SUGAR', color: '#a855f7', label: 'Sugar Huddle', code: 'SH' },
            { id: 'INDY', color: '#22c55e', label: 'Indy', code: 'IN' },
            { id: 'LOW_RZ', color: '#ef4444', label: 'Low Red Zone', code: 'LR' },
            { id: 'HIGH_RZ', color: '#f97316', label: 'High Red Zone', code: 'HR' },
            { id: 'BACKED_UP', color: '#6366f1', label: 'Backed Up', code: 'BU' },
            { id: 'TWO_MIN', color: '#ec4899', label: 'Two Minute', code: '2M' },
            { id: 'FOUR_MIN', color: '#14b8a6', label: 'Four Minute', code: '4M' },
            { id: 'GOAL_LINE', color: '#8b5cf6', label: 'Goal Line', code: 'GL' },
            { id: 'SHORT_YD', color: '#06b6d4', label: 'Short Yardage', code: 'SY' }
        ];

        const WeeklyAnalytics = ({ currentWeek, plays, practicePlans }) => {
            const [viewMode, setViewMode] = React.useState('overall'); // 'overall', 'daily', 'usage', 'unassigned'
            const printRef = React.useRef();

            const analytics = React.useMemo(() => {
                const results = {
                    totalReps: 0,
                    concepts: { overall: {}, daily: {} },
                    unassigned: [],
                    leaderboard: [],
                    gamePlanUsage: []
                };

                if (!currentWeek || !practicePlans) return results;

                // 1. Build Play Map
                const playMap = new Map((plays || []).map(p => [p.id, p]));
                const playCounts = new Map();
                const practiceScriptPlays = new Set();

                // 2. Process Practice Plans
                Object.values(practicePlans).forEach(plan => {
                    if (plan.weekId !== currentWeek.id) return;

                    plan.periods?.forEach(period => {
                        period.scripts?.forEach(script => {
                            results.totalReps++;

                            // Track PLAYS
                            const playId = script.playId; // Assuming script has playId, or matched by name? 
                            // Based on previous code, script might be the play object itself or have a reference.
                            // Let's assume script has playId or is the play. 
                            // Wait, previous code used script.playId if it existed, or looked up by name?
                            // Let's look at how it counts.
                            // "const pid = s.playId || s.id;"

                            const pid = script.playId || script.id;
                            if (pid) {
                                practiceScriptPlays.add(pid);
                                playCounts.set(pid, (playCounts.get(pid) || 0) + 1);

                                const play = playMap.get(pid);
                                if (play) {
                                    // Count Concept
                                    const family = play.conceptFamily || 'Unclassified';
                                    results.concepts.overall[family] = (results.concepts.overall[family] || 0) + 1;

                                    // Daily
                                    const day = plan.date ? new Date(plan.date).toLocaleDateString('en-US', { weekday: 'long' }) : 'Unknown';
                                    if (!results.concepts.daily[day]) results.concepts.daily[day] = {};
                                    results.concepts.daily[day][family] = (results.concepts.daily[day][family] || 0) + 1;
                                }
                            }
                        });
                    });
                });

                // 3. Unassigned Game Plan Plays (Plays in InstallList but NOT in any script)
                if (currentWeek.installList) {
                    currentWeek.installList.forEach(item => {
                        // item is { id: playId, ... } or just playId?
                        // usually installList is array of play IDs or objects with id.
                        // let's assume objects { id: ... } based on usage.
                        const pid = item.id || item;
                        if (!practiceScriptPlays.has(pid)) {
                            const play = playMap.get(pid);
                            if (play) results.unassigned.push(play);
                        }
                    });
                }

                // 4. Game Plan Usage
                if (currentWeek.installList) {
                    results.gamePlanUsage = currentWeek.installList.map(item => {
                        const pid = item.id || item;
                        const play = playMap.get(pid);
                        return {
                            id: pid,
                            play: play,
                            count: playCounts.get(pid) || 0
                        };
                    }).sort((a, b) => b.count - a.count);
                }

                // 5. Leaderboard (Top 50)
                results.leaderboard = Array.from(playCounts.entries())
                    .map(([id, count]) => ({ play: playMap.get(id), count }))
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 50);

                return results;
            }, [currentWeek, plays, practicePlans]);

            const cardStyle = {
                background: 'var(--surface)',
                border: '1px solid var(--border)',
                borderRadius: '8px',
                padding: '1.5rem',
                marginBottom: '1.5rem',
                boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
            };

            return (
                <div className="analytics-dashboard">
                    {/* Header / Tabs */}
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                        <h3 style={{ margin: 0, display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                            <Icon name="BarChart2" /> Practice Analytics
                        </h3>
                        <div style={{ display: 'flex', gap: '0.5rem', background: 'var(--bg-input)', padding: '0.25rem', borderRadius: '6px' }}>
                            {['overall', 'daily', 'usage', 'unassigned'].map(mode => (
                                <button
                                    key={mode}
                                    onClick={() => setViewMode(mode)}
                                    style={{
                                        padding: '0.5rem 1rem',
                                        borderRadius: '4px',
                                        border: 'none',
                                        background: viewMode === mode ? 'var(--surface)' : 'transparent',
                                        color: viewMode === mode ? 'var(--text-primary)' : 'var(--text-tertiary)',
                                        fontWeight: viewMode === mode ? 600 : 400,
                                        cursor: 'pointer',
                                        textTransform: 'capitalize',
                                        boxShadow: viewMode === mode ? '0 1px 2px rgba(0,0,0,0.1)' : 'none'
                                    }}
                                >
                                    {mode === 'usage' ? 'Game Plan Usage' : mode}
                                </button>
                            ))}
                        </div>
                    </div>

                    {/* Content Area */}
                    <div ref={printRef}>
                        {viewMode === 'overall' && (
                            <div style={cardStyle}>
                                <h4 style={{ marginTop: 0 }}>Concept Breakdown (Overall)</h4>
                                <table style={{ width: '100%', borderCollapse: 'collapse', marginTop: '1rem' }}>
                                    <thead>
                                        <tr style={{ borderBottom: '1px solid var(--border)' }}>
                                            <th style={{ textAlign: 'left', padding: '0.5rem' }}>Concept Family</th>
                                            <th style={{ textAlign: 'right', padding: '0.5rem' }}>Reps</th>
                                            <th style={{ textAlign: 'right', padding: '0.5rem' }}>% Total</th>
                                            <th style={{ width: '100px', padding: '0.5rem' }}></th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {Object.entries(analytics.concepts.overall)
                                            .sort(([, a], [, b]) => b - a)
                                            .map(([concept, count]) => (
                                                <tr key={concept} style={{ borderBottom: '1px solid var(--border-light)' }}>
                                                    <td style={{ padding: '0.5rem' }}>{concept}</td>
                                                    <td style={{ textAlign: 'right', padding: '0.5rem' }}>{count}</td>
                                                    <td style={{ textAlign: 'right', padding: '0.5rem' }}>
                                                        {Math.round((count / analytics.totalReps) * 100)}%
                                                    </td>
                                                    <td style={{ padding: '0.5rem' }}>
                                                        <div style={{ height: '8px', background: 'var(--bg-input)', borderRadius: '4px', overflow: 'hidden' }}>
                                                            <div style={{ height: '100%', width: `${(count / analytics.totalReps) * 100}%`, background: 'var(--primary)' }}></div>
                                                        </div>
                                                    </td>
                                                </tr>
                                            ))}
                                    </tbody>
                                </table>
                            </div>
                        )}

                        {viewMode === 'daily' && (
                            <div style={cardStyle}>
                                <h4 style={{ marginTop: 0 }}>Daily Concept Breakdown</h4>
                                <table style={{ width: '100%', borderCollapse: 'collapse', marginTop: '1rem' }}>
                                    <thead>
                                        <tr style={{ borderBottom: '1px solid var(--border)' }}>
                                            <th style={{ textAlign: 'left', padding: '0.5rem' }}>Concept Family</th>
                                            {['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'].map(d => (
                                                <th key={d} style={{ textAlign: 'center', padding: '0.5rem' }}>{d.substr(0, 3)}</th>
                                            ))}
                                            <th style={{ textAlign: 'right', padding: '0.5rem' }}>Total</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {Object.keys(analytics.concepts.overall).map(concept => (
                                            <tr key={concept} style={{ borderBottom: '1px solid var(--border-light)' }}>
                                                <td style={{ padding: '0.5rem', fontWeight: 'bold' }}>{concept}</td>
                                                {['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'].map(day => (
                                                    <td key={day} style={{ textAlign: 'center', padding: '0.5rem', color: analytics.concepts.daily[day]?.[concept] > 0 ? 'inherit' : 'var(--text-tertiary)' }}>
                                                        {analytics.concepts.daily[day]?.[concept] || 0}
                                                    </td>
                                                ))}
                                                <td style={{ textAlign: 'right', padding: '0.5rem', fontWeight: 'bold' }}>{analytics.concepts.overall[concept]}</td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        )}

                        {viewMode === 'usage' && (
                            <div style={cardStyle}>
                                <h3 style={{ marginBottom: '1rem' }}>Game Plan Usage</h3>
                                <table style={{ width: '100%', borderCollapse: 'collapse', marginTop: '1rem' }}>
                                    <thead>
                                        <tr style={{ borderBottom: '1px solid var(--border)' }}>
                                            <th style={{ textAlign: 'left', padding: '0.5rem' }}>Play</th>
                                            <th style={{ textAlign: 'center', padding: '0.5rem' }}>Reps</th>
                                            <th style={{ textAlign: 'left', padding: '0.5rem' }}>Status</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {analytics.gamePlanUsage.map((item, idx) => (
                                            <tr key={item.playId || idx} style={{
                                                borderBottom: '1px solid var(--border-light)',
                                                background: item.count === 0 ? 'rgba(239, 68, 68, 0.05)' : 'transparent'
                                            }}>
                                                <td style={{ padding: '0.5rem' }}>
                                                    <div style={{ fontWeight: 'bold' }}>{item.play?.name || 'Unknown Play'}</div>
                                                    <div style={{ fontSize: '0.8rem', color: 'var(--text-tertiary)' }}>{item.play?.conceptFamily || 'No Concept'}</div>
                                                </td>
                                                <td style={{ textAlign: 'center', padding: '0.5rem', fontWeight: 'bold', color: item.count === 0 ? 'var(--danger)' : 'inherit' }}>
                                                    {item.count}
                                                </td>
                                                <td style={{ padding: '0.5rem' }}>
                                                    {item.count === 0 ? (
                                                        <span style={{ color: 'var(--danger)', fontSize: '0.8rem', display: 'flex', alignItems: 'center', gap: '4px' }}>
                                                            <Icon name="AlertCircle" size={14} />
                                                            Not Practiced
                                                        </span>
                                                    ) : (
                                                        <span style={{ color: 'var(--success)', fontSize: '0.8rem', display: 'flex', alignItems: 'center', gap: '4px' }}>
                                                            <Icon name="CheckCircle" size={14} />
                                                            In Practice
                                                        </span>
                                                    )}
                                                </td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        )}

                        {
                            viewMode === 'unassigned' && (
                                <div style={cardStyle}>
                                    <h3 style={{ marginBottom: '1rem' }}>Unassigned Game Plan Plays</h3>
                                    <p style={{ color: 'var(--text-secondary)', marginBottom: '1.5rem' }}>
                                        The following plays are in the Weekly Install List but have not been assigned to any practice script.
                                    </p>

                                    {analytics.unassigned.length === 0 ? (
                                        <div style={{
                                            padding: '2rem', textAlign: 'center', color: 'var(--success)',
                                            background: 'rgba(34, 197, 94, 0.1)', borderRadius: '8px',
                                            border: '1px solid rgba(34, 197, 94, 0.3)'
                                        }}>
                                            <Icon name="CheckCircle" size={24} style={{ marginBottom: '0.5rem' }} />
                                            <div style={{ fontWeight: 'bold' }}>All installed plays have been assigned!</div>
                                        </div>
                                    ) : (
                                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))', gap: '1rem' }}>
                                            {analytics.unassigned.map(play => (
                                                <div key={play?.id} style={{ padding: '0.75rem', background: 'var(--bg-panel)', border: '1px solid var(--border)', borderRadius: '6px', boxShadow: '0 1px 2px rgba(0, 0, 0, 0.1)' }}>
                                                    <div style={{ fontWeight: 'bold', marginBottom: '0.25rem' }}>{play?.name || 'Unknown Play'}</div>
                                                    <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>
                                                        {play?.formation} • {play?.conceptFamily || 'No Concept'}
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            )
                        }
                    </div>

                    {/* Leaderboard Section - Always Visible or part of Overall? */}
                    {/* Let's put Leaderboard at bottom if ViewMode is matching or just always. 
                Previous design seemed to have it separate. Let's include it in 'overall' or separate.
                The previous code had it in 'overall' I think? Or separate? 
                Let's make it a separate card below content area, visible in 'overall' mode */}

                    {
                        viewMode === 'overall' && (
                            <div style={cardStyle}>
                                <h3 style={{ marginBottom: '1rem' }}>Most Practiced Plays (Top 50)</h3>
                                <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                                    <thead>
                                        <tr style={{ borderBottom: '1px solid var(--border)' }}>
                                            <th style={{ textAlign: 'left', padding: '0.5rem' }}>Play Name</th>
                                            <th style={{ textAlign: 'left', padding: '0.5rem' }}>Concept</th>
                                            <th style={{ textAlign: 'right', padding: '0.5rem' }}>Reps</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {analytics.leaderboard.map(({ play, count }, idx) => (
                                            <tr key={idx} style={{ borderBottom: '1px solid var(--border-light)', background: idx < 3 ? 'rgba(234, 179, 8, 0.05)' : 'transparent' }}>
                                                <td style={{ padding: '0.5rem' }}>
                                                    <div style={{ fontWeight: 'bold' }}>{play?.name || 'Unknown'}</div>
                                                </td>
                                                <td style={{ padding: '0.5rem', color: 'var(--text-secondary)' }}>{play?.conceptFamily}</td>
                                                <td style={{ textAlign: 'right', padding: '0.5rem', fontWeight: 'bold' }}>{count}</td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        )
                    }
                </div >
            );
        };


        const DEPTH_CHART_TYPES = [
            { id: 'OFFENSE', label: 'Offense' },
            { id: 'DEFENSE', label: 'Defense' },
            { id: 'KICKOFF', label: 'Kickoff' },
            { id: 'KICK_RETURN', label: 'Kick Return' },
            { id: 'PUNT', label: 'Punt' },
            { id: 'PUNT_RETURN', label: 'Punt Return' },
            { id: 'PAT_BLOCK', label: 'PAT/FG Block' },
            { id: 'SCOUT_OFFENSE', label: 'Scout Offense' },
            { id: 'SCOUT_DEFENSE', label: 'Scout Defense' }
        ];

        const App = () => {
            // Custom Hook for Auto-Sync to prevent initial-load overwrites
            const useAutoSync = (authUser, key, data, debounceMs = 2000, isEnabled = true) => {
                const isFirstRun = useRef(true);
                useEffect(() => {
                    // Always skip the very first run (mount)
                    if (isFirstRun.current) {
                        isFirstRun.current = false;
                        return;
                    }

                    // Only run if:
                    // 1. User is logged in
                    // 2. Global "isLoaded" flag is true (prevents overwriting cloud data with initial empty state)
                    if (authUser && window.db && isEnabled) {
                        const timer = setTimeout(() => {
                            syncToFirestore(authUser.uid, key, data);
                        }, debounceMs);
                        return () => clearTimeout(timer);
                    }
                }, [data, authUser, key, debounceMs, isEnabled]);
            };
            const { currentUser: authUser, logout } = useAuth();
            // Auth check moved to end of component to prevent hook mismatch errors


            const [showLogoutConfirm, setShowLogoutConfirm] = useState(false);
            const [view, setView] = useState('practice-report'); // Default to Practice Report
            const [showManageWeekModal, setShowManageWeekModal] = useState(false);
            const [sidebarCollapsed, setSidebarCollapsed] = useLocalStorage('hc-sidebar-collapsed', false);
            const closeSideMenuRef = useRef(null); // Ref for child components to register side menu close callback
            const [editingPlay, setEditingPlay] = useState(null);
            const [quickEditModalState, setQuickEditModalState] = useState(null);

            // -- PLAY DETAILS MODAL (Root-Level for PlayChip context) --
            const [playDetailsModalState, setPlayDetailsModalState] = useState({ isOpen: false, playId: null });
            const openPlayDetails = (playId) => setPlayDetailsModalState({ isOpen: true, playId });
            const closePlayDetails = () => setPlayDetailsModalState({ isOpen: false, playId: null });

            // -- SCHOOL INITIALIZATION CHECK --
            const [schoolSetupData, setSchoolSetupData] = useState({ showWizard: false, schoolId: null });
            const [inviteData, setInviteData] = useState(null); // NEW: Invite State
            const [isViewingAll, setIsViewingAll] = useState(false);
            const [selectedCharts, setSelectedCharts] = useState(DEPTH_CHART_TYPES.map(t => t.id));

            // -- PROGRAM RECORDS MIGRATION --
            const [programRecords, setProgramRecords] = useLocalStorage('hc-program-records', {});

            // Sync Program Records to Firestore
            useAutoSync(authUser, 'program_records', programRecords);

            // -- CULTURAL CALIBRATION --
            const [culturalCalibration, setCulturalCalibration] = useLocalStorage('hc-cultural-calibration', {
                quotes: [],
                challenges: [],
                activeQuote: null,
                activeChallenge: null,
                responses: []
            });

            // Sync Cultural Calibration to Firestore
            useAutoSync(authUser, 'cultural_calibration', culturalCalibration);


            // -- DRILL LIBRARY STATE --
            const [drills, setDrills] = useLocalStorage('hc-drills', INITIAL_DRILL_DATA);

            // Sync Drills to Firestore
            useAutoSync(authUser, 'drills', drills);

            const handleAddDrill = (newDrill) => {
                setDrills(prev => [...prev, { ...newDrill, id: 'drill_' + Date.now() }]);
            };

            // -- DEPTH CHART STATE --
            const [depthCharts, setDepthCharts] = useLocalStorage('hc-depth-charts', {});
            const [depthChartLayouts, setDepthChartLayouts] = useLocalStorage('hc-depth-chart-layouts', {});

            const handleUpdateDepthLayout = (chartType, id, x, y) => {
                setDepthChartLayouts(prev => ({
                    ...prev,
                    [chartType]: {
                        ...(prev[chartType] || {}),
                        [id]: { x, y }
                    }
                }));
            };

            const handleResetDepthLayout = (chartType) => {
                if (window.confirm('Reset layout positions for ' + chartType + '?')) {
                    const newLayouts = { ...depthChartLayouts };
                    delete newLayouts[chartType];
                    setDepthChartLayouts(newLayouts);
                }
            };
            // Sync Depth Charts to Firestore
            useAutoSync(authUser, 'depth_charts', depthCharts);

            // Migration Effect
            useEffect(() => {
                const MIGRATION_KEY = 'program_records_migrated_v1';
                // Check for specific user email to load legacy data once
                if (authUser && authUser.email === 'mfinn@roland-story.k12.ia.us') {
                    const hasMigrated = localStorage.getItem(MIGRATION_KEY);
                    if (!hasMigrated && typeof LEGACY_PROGRAM_RECORDS !== 'undefined') {
                        console.log("Migrating legacy program records for mfinn...");
                        setProgramRecords(LEGACY_PROGRAM_RECORDS);
                        localStorage.setItem(MIGRATION_KEY, 'true');
                    }
                }
            }, [authUser, setProgramRecords]);

            useEffect(() => {
                const checkSchoolInit = async () => {
                    if (!authUser) return;

                    try {
                        // 1. CHECK FOR PENDING INVITES
                        console.log("Checking for invites for:", authUser.email);
                        const inviteQuery = await window.db.collection('invites')
                            .where('email', '==', authUser.email.toLowerCase())
                            .where('status', '==', 'pending')
                            .get();

                        if (!inviteQuery.empty) {
                            const inviteDoc = inviteQuery.docs[0];
                            console.log("Found invite:", inviteDoc.id);
                            setInviteData({ id: inviteDoc.id, ...inviteDoc.data() });
                            return; // Stop processing to show invite modal
                        }

                        // 1b. CHECK FOR CLAIMED DOMAINS (Auto-Join)
                        const emailDomain = authUser.email.split('@')[1];
                        if (emailDomain) {
                            const domainQuery = await window.db.collection('schools')
                                .where('domains', 'array-contains', emailDomain.toLowerCase())
                                .limit(1)
                                .get();

                            if (!domainQuery.empty) {
                                const sDoc = domainQuery.docs[0];
                                const sData = sDoc.data();
                                // Check if already a member
                                const memCheck = await window.db.collection('users').doc(authUser.uid).collection('memberships').doc(sDoc.id).get();
                                if (!memCheck.exists) {
                                    setInviteData({
                                        schoolId: sDoc.id,
                                        schoolName: sData.name,
                                        role: 'viewer', // Default to viewer for safety
                                        type: 'domain_match'
                                    });
                                    return;
                                }
                            }
                        }

                        // 1c. PRIMARY SETUP CHECK: DO I HAVE A MEMBERSHIP?
                        // If user has ANY membership, they are setup. We skip legacy/creation wizard.
                        // FIX: Ensure User Document actually exists! (Subcollections persist after parent deletion)
                        const userDocCall = await window.db.collection('users').doc(authUser.uid).get();

                        console.log("DEBUG: Checking memberships for user:", authUser.uid);
                        const memberships = await window.db.collection('users').doc(authUser.uid).collection('memberships').get();
                        console.log("DEBUG: Membership count:", memberships.size);

                        // Only respect memberships if the user profile is intact
                        if (!memberships.empty && userDocCall.exists) {
                            console.log("User has active memberships. Skipping wizard.");
                            return;
                        }

                        // 2. CHECK LEGACY / EXISTING ACCESS
                        // Force Server Fetch to avoid stale cache loop (Wrapped in Try/Catch for robustness)
                        let accessDoc;
                        try {
                            accessDoc = await window.db.collection('config').doc('access').get({ source: 'server' });
                        } catch (e) {
                            console.warn("Access config server fetch failed, fallback to cache", e);
                            accessDoc = await window.db.collection('config').doc('access').get();
                        }

                        const accessData = accessDoc.exists ? accessDoc.data() : {};
                        const userValues = Object.values(accessData.userSchools || {});

                        const isPaying = accessData.payingAdmins && accessData.payingAdmins.includes(authUser.email.toLowerCase());

                        // Check if user has a school ID assigned in config OR on their profile
                        let schoolId = accessData.userSchools ? accessData.userSchools[authUser.email.toLowerCase()] : null;

                        if (!schoolId) {
                            const userDoc = await window.db.collection('users').doc(authUser.uid).get();
                            if (userDoc.exists && userDoc.data().schoolId) {
                                schoolId = userDoc.data().schoolId;
                            }
                        }

                        // 3. CHECK FOR ZERO MEMBERSHIPS (Orphaned User -> Create New School)
                        // If no invites, no domain match, and no legacy school ID, check strict memberships
                        if (!inviteData && !schoolId) {
                            console.log("User has no memberships and no legacy setup. Triggering School Creation Wizard.");
                            const newSchoolId = 'school_' + Date.now();
                            setSchoolSetupData({ showWizard: true, schoolId: newSchoolId });
                            return;
                        }

                        // If Paying Admin + Has School ID + School Not Initialized -> Show Wizard
                        // (Keep existing legacy check for now)
                        if (isPaying && schoolId) {
                            let schoolDoc;
                            try {
                                schoolDoc = await window.db.collection('schools').doc(schoolId).get({ source: 'server' });
                            } catch (e) {
                                console.warn("School doc server fetch failed, using cache", e);
                                schoolDoc = await window.db.collection('schools').doc(schoolId).get();
                            }

                            if (schoolDoc.exists && !schoolDoc.data().initialized) {
                                console.log("School not initialized, showing wizard.");
                                setSchoolSetupData({ showWizard: true, schoolId: schoolId });
                            }
                        }
                    } catch (err) {
                        console.error("Error checking school init:", err);
                    }
                };
                checkSchoolInit();
            }, [authUser]);

            // INVITE ACCEPTANCE HANDLER
            const handleAcceptInvite = async () => {
                if (!inviteData) return;
                try {
                    // 1. Create Membership
                    await window.db.collection('users').doc(authUser.uid).collection('memberships').doc(inviteData.schoolId).set({
                        role: inviteData.role,
                        joinedAt: new Date().toISOString(),
                        status: 'active'
                    });

                    // 2. Add to School Member List
                    const newMember = {
                        uid: authUser.uid,
                        email: authUser.email,
                        role: inviteData.role,
                        joinedAt: new Date().toISOString()
                    };
                    await window.db.collection('schools').doc(inviteData.schoolId).update({
                        memberList: firebase.firestore.FieldValue.arrayUnion(newMember)
                    });

                    // 3. Mark Invite Accepted (If valid invite)
                    if (inviteData.id && inviteData.type !== 'domain_match') {
                        await window.db.collection('invites').doc(inviteData.id).update({
                            status: 'accepted',
                            acceptedAt: new Date().toISOString(),
                            acceptedBy: authUser.uid
                        });
                    }

                    // 4. Set Local Context & Reload
                    localStorage.setItem('hc_school_id', inviteData.schoolId);
                    localStorage.setItem('hc_school_name', inviteData.schoolName);

                    // Force clean slate for new school
                    localStorage.removeItem('oc-dashboard-roster');
                    localStorage.removeItem('oc-dashboard-plays');
                    localStorage.removeItem('oc-dashboard-staff');

                    alert("Welcome to the team!");
                    window.location.reload();

                } catch (err) {
                    console.error("Error accepting invite:", err);
                    alert("Failed to join. Please try again.");
                }
            };




            // Settings State
            const [searchTerm, setSearchTerm] = useState('');


            const [activeYear, setActiveYear] = useState(() => {
                return localStorage.getItem('hc-active-year') || '2025';
            });

            useEffect(() => {
                localStorage.setItem('hc-active-year', activeYear);
                // Cloud Sync
                if (currentUser && window.db) {
                    syncToFirestore(currentUser.uid, 'settings', { activeYear });
                }
            }, [activeYear, currentUser]);

            // Football 101 Data
            const [football101Data, setFootball101Data] = useLocalStorage('hc-football-101', {
                rules: [],
                offense: { terms: [], fundamentals: [] },
                defense: { terms: [], fundamentals: [] },
                specialTeams: { terms: [], fundamentals: [] }
            });

            const [visibleFeatures, setVisibleFeatures] = useState(() => {
                const saved = localStorage.getItem('hc-visible-features-v2');
                const DEFAULT_FEATURES = {
                    staffMeeting: {
                        enabled: true,
                        items: {
                            meetingHome: true,
                            scouting: true,
                            weekOverview: true,
                            practice: true,
                            pregame: true,
                            grading: true
                        }
                    },
                    gameWeek: { // Now "Offense, Defense & Special Teams"
                        enabled: true,
                        items: {
                            offenseSetup: true,
                            defenseSetup: true,
                            stSetup: true,
                            depthCharts: true,
                            playbook: true,
                            formations: true,
                            glossary: true,
                            drillLibrary: true,
                            gamePlan: true,
                            addPlay: true,
                            wristband: true,
                            practiceScripts: true,
                            dumbCallsheet: true,

                        }
                    },
                    program: {
                        enabled: true,
                        items: {
                            roster: true,
                            taskAssigner: true,
                            calendar: true,
                            budget: true,
                            culturalCalibration: true,
                            onboarding: true,
                            equipmentCheckout: true,
                            jerseyLottery: true,
                            equipmentInventory: true,
                            equipmentWishlist: true
                        }
                    },
                    apps: {
                        enabled: true,
                        items: {
                            playerApp: true,
                            attendanceApp: true,
                            coachApp: true,
                            callsheet: true,
                            smartCallsheet: true,
                            simulator: true,
                            pressbox: true,
                            specialTeams: true
                        }
                    },
                    development: {
                        enabled: true,
                        items: {
                            testing: true,
                            ironman: true,
                            ratings: true,
                            summerComp: true,

                            testingRecords: true,
                            selfAssessment: true,
                            multiSport: true
                        }
                    }
                };

                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);

                        // MIGRATION LOGIC:
                        // 1. If 'scheme' exists, migrate its items to 'gameWeek' if not already there
                        // 2. Ensure ALL keys from DEFAULT_FEATURES exist in the result (deep merge)

                        const merged = { ...DEFAULT_FEATURES };
                        // Force enable ratings per user request
                        if (parsed.development && parsed.development.items) {
                            parsed.development.items.ratings = true;
                        }

                        // Helper to safely merge category
                        const mergeCategory = (catName, legacySource = null) => {
                            const parsedCat = parsed[catName] || {};
                            const defaultCat = DEFAULT_FEATURES[catName];

                            // If user explicitly disabled the category in parsed, keep it disabled.
                            // However, if it was undefined (new category), default to enabled (true).
                            const isEnabled = parsedCat.enabled !== undefined ? parsedCat.enabled : defaultCat.enabled;

                            const mergedItems = { ...defaultCat.items };

                            // Merge existing items from parsed
                            if (parsedCat.items) {
                                Object.keys(parsedCat.items).forEach(key => {
                                    mergedItems[key] = parsedCat.items[key];
                                });
                            }

                            // Migrate legacy items if applicable
                            if (legacySource && parsed[legacySource] && parsed[legacySource].items) {
                                // Specific migration for scheme -> gameWeek
                                if (catName === 'gameWeek') {
                                    // Map scheme items to new keys if needed, or just copy if names match
                                    if (parsed[legacySource].items.playbook !== undefined) mergedItems.playbook = parsed[legacySource].items.playbook;
                                    if (parsed[legacySource].items.formations !== undefined) mergedItems.formations = parsed[legacySource].items.formations;
                                    if (parsed[legacySource].items.drillLibrary !== undefined) mergedItems.drillLibrary = parsed[legacySource].items.drillLibrary;
                                    // Glossary was not tracked in scheme permissions previously? If so, default true is fine.
                                }
                            }

                            return {
                                enabled: isEnabled,
                                items: mergedItems
                            };
                        };

                        return {
                            staffMeeting: mergeCategory('staffMeeting'), // New category
                            gameWeek: mergeCategory('gameWeek', 'scheme'), // Merge scheme into gameWeek
                            program: mergeCategory('program'),
                            apps: mergeCategory('apps'),
                            development: mergeCategory('development')
                        };

                    } catch (e) {
                        console.error("Error parsing visible features, resetting to default", e);
                        return DEFAULT_FEATURES;
                    }
                }

                return DEFAULT_FEATURES;
            });

            useEffect(() => {
                localStorage.setItem('hc-visible-features', JSON.stringify(visibleFeatures));
            }, [visibleFeatures]);

            // --- LIFTED STATE FOR FULL SYNC COMPATIBILITY ---
            const [positionFatigue, setPositionFatigue] = useState(() => {
                const saved = localStorage.getItem('position-fatigue-values');
                if (saved) return JSON.parse(saved);
                return {
                    // Offense
                    'QB': 2, 'RB': 3, 'WR': 2, 'TE': 2,
                    'LT': 2, 'LG': 2, 'C': 2, 'RG': 2, 'RT': 2,
                    'X': 2, 'Y': 2, 'Z': 2, 'A': 2,
                    // Defense
                    'DE': 3, 'DT': 3, 'NT': 3, 'LDE': 3, 'RDE': 3, 'LDT': 3, 'RDT': 3,
                    'Will': 3, 'Mike': 3, 'WLB': 3, 'MLB': 3, 'SLB': 3,
                    'CB': 2, 'LCB': 2, 'RCB': 2, 'FS': 2, 'SS': 2, 'Nickel': 2, 'Nick': 2,
                    // Special Teams
                    'K': 1, 'P': 1, 'LS': 1, 'PP': 1,
                    'KR': 3, 'Ret': 3, 'R': 3, 'R1': 3, 'R2': 3,
                    'Gunner': 3, 'G1': 3, 'G2': 3,
                    'L1': 2, 'L2': 2, 'L3': 2, 'L4': 2, 'L5': 2,
                    'R1': 2, 'R2': 2, 'R3': 2, 'R4': 2, 'R5': 2,
                    'Rush': 2, 'Jam': 2, 'Front': 2, 'Mid': 2, 'Back': 2, 'Deep': 2,
                    'Wing': 2, 'Off': 1,
                    'DEFAULT': 1
                };
            });

            const [dailyConnections, setDailyConnections] = useState(() => {
                const saved = localStorage.getItem('player_daily_connections');
                return saved ? JSON.parse(saved) : {};
            });

            // Initialize Wiz Library from LocalStorage (or Rooski legacy)
            const [wizLibrary, setWizLibrary] = useState(() => {
                const saved = localStorage.getItem('wiz_ol_library') || localStorage.getItem('rooski_ol_library');
                return saved ? JSON.parse(saved) : [];
            });

            // Multi-Card Wristband Settings
            const [wbSettings, setWbSettings] = useState(() => {
                const defaultSettings = {
                    card1: { type: 'standard', opp: '', iter: '1', rows: [] },
                    card2: { type: 'standard', opp: '', iter: '1', rows: [] },
                    card3: { type: 'wiz', opp: '', iter: '1', rows: [] },
                    staples: { type: 'staples', opp: '', iter: '1', rows: [] }
                };
                const saved = localStorage.getItem('hc_wb_settings_v3');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Ensure staples exists and fill other defaults
                    return { ...defaultSettings, ...parsed };
                }

                // Migration from legacy flat keys
                return {
                    card1: {
                        type: 'standard',
                        opp: localStorage.getItem('hc_wb1_opponent') || '',
                        iter: localStorage.getItem('hc_wb1_iteration') || '',
                        rows: []
                    },
                    card2: {
                        type: 'standard',
                        opp: localStorage.getItem('hc_wb2_opponent') || '',
                        iter: localStorage.getItem('hc_wb2_iteration') || '',
                        rows: []
                    },
                    card3: {
                        type: 'wiz',
                        opp: '',
                        iter: '',
                        rows: []
                    },
                    staples: {
                        type: 'staples',
                        opp: localStorage.getItem('hc_staples_opponent') || '',
                        iter: localStorage.getItem('hc_staples_iteration') || '',
                        rows: []
                    }
                };
            });

            // Sync WB Settings changes
            useEffect(() => {
                localStorage.setItem('hc_wb_settings_v3', JSON.stringify(wbSettings));

                // Maintain legacy keys for external consumption if any
                localStorage.setItem('hc_wb1_opponent', wbSettings.card1.opp);
                localStorage.setItem('hc_wb1_iteration', wbSettings.card1.iter);
                localStorage.setItem('hc_wb2_opponent', wbSettings.card2.opp);
                localStorage.setItem('hc_wb2_iteration', wbSettings.card2.iter);
                if (wbSettings.staples) {
                    localStorage.setItem('hc_staples_opponent', wbSettings.staples.opp);
                    localStorage.setItem('hc_staples_iteration', wbSettings.staples.iter);
                }

                if (authUser) {
                    syncToFirestore(authUser.uid, 'wbSettingsV3', {
                        ...wbSettings,
                        sheetUrl: localStorage.getItem('hc_wristband_sheet_url')
                    });
                }
            }, [wbSettings, authUser]);
            const [plays, setPlays] = useState(() => {
                try {
                    const saved = localStorage.getItem('oc-dashboard-plays');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        return Array.isArray(parsed) ? parsed : INITIAL_PLAYS;
                    }
                    return INITIAL_PLAYS;
                } catch (error) {
                    console.error('Error loading plays from localStorage:', error);
                    return INITIAL_PLAYS;
                }
            });

            useEffect(() => {
                localStorage.setItem('position-fatigue-values', JSON.stringify(positionFatigue));
                if (authUser) syncToFirestore(authUser.uid, 'positionFatigue', positionFatigue);
            }, [positionFatigue]);

            // --- CRITICAL DATA SYNC (FINAL AUDIT) ---
            useEffect(() => {
                localStorage.setItem('program_onboarding_data', JSON.stringify(onboardingData));
                if (authUser) syncToFirestore(authUser.uid, 'onboarding', onboardingData);
            }, [onboardingData]);

            useEffect(() => {
                localStorage.setItem('oc-dashboard-position-names', JSON.stringify(positionNames));
                if (authUser) syncToFirestore(authUser.uid, 'positionNames', positionNames);
            }, [positionNames]);

            useEffect(() => {
                localStorage.setItem('player_daily_connections', JSON.stringify(dailyConnections));
                if (authUser) syncToFirestore(authUser.uid, 'dailyConnections', dailyConnections);
            }, [dailyConnections]);

            useEffect(() => {
                localStorage.setItem('player_weight_logs', JSON.stringify(weightLogs));
                if (authUser) syncToFirestore(authUser.uid, 'weightLogs', weightLogs);
            }, [weightLogs]);

            useEffect(() => {
                localStorage.setItem('wiz_ol_library', JSON.stringify(wizLibrary));
                localStorage.setItem('rooski_ol_library', JSON.stringify(wizLibrary)); // Legacy backup
                if (authUser) syncToFirestore(authUser.uid, 'wizLib', wizLibrary);
            }, [wizLibrary]);


            useEffect(() => {
                localStorage.setItem('oc-dashboard-plays', JSON.stringify(plays));

                // Auto-sync to Firestore (debounced)
                const timer = setTimeout(() => {
                    if (authUser && window.db) { // Check for authUser and db here
                        if (authUser) syncToFirestore(authUser.uid, 'plays', plays);
                    }
                }, 2000); // Debounce playbook sync
                return () => clearTimeout(timer);
            }, [plays, authUser]); // Changed currentUser to authUser to match existing context

            // Sync Weeks (Practice Plans) to Firestore
            useEffect(() => {
                const timer = setTimeout(() => {
                    if (authUser) syncToFirestore(authUser.uid, 'weeks', weeks); // Changed currentUser to authUser
                }, 3000); // 3s debounce for large plan objects
                return () => clearTimeout(timer);
            }, [weeks, authUser]); // Changed currentUser to authUser

            // Sync Attendance to Firestore
            useEffect(() => {
                const timer = setTimeout(() => {
                    if (authUser) syncToFirestore(authUser.uid, 'attendance', attendance); // Changed currentUser to authUser
                }, 1500);
                return () => clearTimeout(timer);
            }, [attendance, authUser]); // Changed currentUser to authUser


            // --- LOADING STATE & SAFETY LOCK ---
            // 'dataLoaded' prevents the app from auto-syncing "empty" initial state back to the cloud.
            // It remains false until loadUserDataFromFirestore is finished or fails.
            const [dataLoaded, setDataLoaded] = useState(false);

            useEffect(() => {
                const initUser = async () => {
                    if (authUser) {
                        try {
                            const result = await loadUserDataFromFirestore(authUser.uid);
                            if (result && result.wiped) {
                                console.log("User data wiped (New/Deleted User). Forcing School Setup.");
                                // Force Wizard to appear
                                setSchoolSetupData({ showWizard: true, schoolId: null });
                                // Clear Invite Data just in case
                                setInviteData(null);
                                // Optional: You could reset other states here if needed, but Wizard hides them.
                            }
                        } catch (e) {
                            console.error("Critical Load Error", e);
                        } finally {
                            // Unlock the sync mechanism now that we have attempted to load content
                            setDataLoaded(true);
                        }
                    }
                };
                initUser();
            }, [authUser]);

            // --- AUTO SYNC HOOK IMPLEMENTATION ---
            // Replaces individual useEffects to prevent "Race Condition" where stale local data overwrites cloud on boot.
            // Now gated by 'dataLoaded' so we NEVER sync before we have loaded.
            useAutoSync(authUser, 'formationLayouts', formationLayouts, 2000, dataLoaded);
            useAutoSync(authUser, 'ratings', ratings, 2000, dataLoaded);

            useAutoSync(authUser, 'summerComp', summerCompData, 2000, dataLoaded);

            useAutoSync(authUser, 'roster', roster, 2000, dataLoaded);
            useAutoSync(authUser, 'weeks', weeks, 3000, dataLoaded);
            useAutoSync(authUser, 'plays', plays, 2000, dataLoaded);
            useAutoSync(authUser, 'staff', staff, 2000, dataLoaded);
            useAutoSync(authUser, 'metrics', metrics, 2000, dataLoaded);
            useAutoSync(authUser, 'weightLogs', weightLogs, 2000, dataLoaded);

            // Formation Database
            const [formations, setFormations] = useState(() => {
                const saved = localStorage.getItem('oc-dashboard-formations');
                return saved ? JSON.parse(saved) : DEFAULT_FORMATIONS;
            });

            useEffect(() => {
                localStorage.setItem('oc-dashboard-formations', JSON.stringify(formations));
            }, [formations]);

            // Zone Philosophies
            const [zonePhilosophies, setZonePhilosophies] = useState(() => {
                const saved = localStorage.getItem('oc-dashboard-zone-philosophies');
                return saved ? JSON.parse(saved) : {
                    backed_up: '',
                    coming_out: '',
                    open_field: '',
                    fringe: 'Take one shot, be ready to convert on 4th',
                    high_red: '',
                    low_red: '',
                    goal_line: ''
                };
            });

            useEffect(() => {
                localStorage.setItem('oc-dashboard-zone-philosophies', JSON.stringify(zonePhilosophies));
            }, [zonePhilosophies]);

            const handleUpdateFormations = (newFormations) => {
                setFormations(newFormations);
            };

            const handleAddFormation = (formation) => {
                setFormations([...formations, { ...formation, id: formation.id || Date.now().toString() }]);
            };

            const handleDeleteFormation = (formationId) => {
                setFormations(formations.filter(f => f.id !== formationId));
            };

            const handleUpdateFormation = (formationId, updatedFormation) => {
                setFormations(formations.map(f => f.id === formationId ? updatedFormation : f));
            };

            // Quick add play from game plan (creates incomplete play)
            const handleQuickAddPlay = (playNameOrObj) => {
                let newPlay;
                if (typeof playNameOrObj === 'object' && playNameOrObj !== null) {
                    newPlay = { ...playNameOrObj };
                    if (newPlay.name) newPlay.name = newPlay.name.toUpperCase();
                } else {
                    const rawName = typeof playNameOrObj === 'string' ? playNameOrObj.trim() : (playNameOrObj || '');
                    newPlay = {
                        id: `play_${Date.now()}`,
                        name: rawName.toUpperCase(),
                        wristbandSlot: '',
                        staplesSlot: '', // [NEW] Staples Wristband Slot (10-89)
                        formation: '',
                        tags: [],
                        incomplete: true, // Mark as incomplete
                        type: '' // No default type (goes to Uncategorized)
                    };
                }
                setPlays(prev => [...prev, newPlay]);
                return newPlay;
            };

            // Determine current season based on month
            const getCurrentSeason = () => {
                const month = new Date().getMonth() + 1; // 1-12
                if (month >= 8 && month <= 11) return 'in-season'; // A === 12 || month === 1) return 'postseason'; // Dec-Jan
                if (month >= 2 && month <= 4) return 'offseason'; // Feb-Apr
                if (month >= 5 && month <= 7) return 'summer'; // May-Jul
                return 'offseason';
            };

            const renderWeeklyTools = (weekId) => {
                const isActive = currentWeekId === weekId;
                const currentSeason = getCurrentSeason();
                const isOffseason = currentSeason === 'offseason';

                return (
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '0.15rem', padding: '0.25rem 0 0.5rem 0' }}>



                        <button className={`nav-item ${isActive && view === 'practice' ? 'active' : ''}`}
                            onClick={() => { setCurrentWeekId(weekId); setView('practice'); }}
                            style={{ paddingLeft: '1.25rem', width: '100%', textAlign: 'left', border: 'none', background: 'none', fontSize: '0.75rem', display: 'flex', alignItems: 'center', gap: '0.5rem', opacity: 0.85 }}>
                            <Icon name="Megaphone" size={12} /> Practice Plans
                        </button>
                        <button className={`nav-item ${isActive && view === 'install-manager' ? 'active' : ''}`}
                            onClick={() => { setCurrentWeekId(weekId); setView('install-manager'); }}
                            style={{ paddingLeft: '1.25rem', width: '100%', textAlign: 'left', border: 'none', background: 'none', fontSize: '0.75rem', display: 'flex', alignItems: 'center', gap: '0.5rem', opacity: 0.85 }}>
                            <Icon name="Layers" size={12} /> Install
                        </button>
                        {/* Expanded Depth Charts */}
                        <button className={`nav-item ${isActive && view === 'depth' ? 'active' : ''}`}
                            onClick={() => { setCurrentWeekId(weekId); setView('depth'); setDepthChartType('OFFENSE'); }}
                            style={{ paddingLeft: '1.25rem', width: '100%', textAlign: 'left', border: 'none', background: 'none', fontSize: '0.75rem', display: 'flex', alignItems: 'center', gap: '0.5rem', opacity: 0.85 }}>
                            <Icon name="Users" size={12} /> Depth Charts
                        </button>
                        <button className={`nav-item ${isActive && view === 'game-plan' ? 'active' : ''}`}
                            onClick={() => { setCurrentWeekId(weekId); setView('game-plan'); }}
                            style={{ paddingLeft: '1.25rem', width: '100%', textAlign: 'left', border: 'none', background: 'none', fontSize: '0.75rem', display: 'flex', alignItems: 'center', gap: '0.5rem', opacity: 0.85 }}>
                            <Icon name="Clipboard" size={12} /> Game Planner
                        </button>
                        <button className={`nav-item ${isActive && view === 'wristband' ? 'active' : ''}`}
                            onClick={() => { setCurrentWeekId(weekId); setView('wristband'); }}
                            style={{ paddingLeft: '1.25rem', width: '100%', textAlign: 'left', border: 'none', background: 'none', fontSize: '0.75rem', display: 'flex', alignItems: 'center', gap: '0.5rem', opacity: 0.85 }}>
                            <Icon name="Watch" size={12} /> Wristband Builder
                        </button>
                        <button className={`nav-item ${isActive && view === 'practice-scripts' ? 'active' : ''}`}
                            onClick={() => { setCurrentWeekId(weekId); setView('practice-scripts'); }}
                            style={{ paddingLeft: '1.25rem', width: '100%', textAlign: 'left', border: 'none', background: 'none', fontSize: '0.75rem', display: 'flex', alignItems: 'center', gap: '0.5rem', opacity: 0.85 }}>
                            <Icon name="FileText" size={12} /> Practice Scripts
                        </button>


                        <button className={`nav-item ${isActive && view === 'pregame' ? 'active' : ''}`}
                            onClick={() => { setCurrentWeekId(weekId); setView('pregame'); }}
                            style={{ paddingLeft: '1.25rem', width: '100%', textAlign: 'left', border: 'none', background: 'none', fontSize: '0.75rem', display: 'flex', alignItems: 'center', gap: '0.5rem', opacity: 0.85 }}>
                            <Icon name="Clock" size={12} /> Pre-Game Timeline
                        </button>
                    </div>
                );
            };

            const checkWristbandConflict = (slot) => {
                const numSlot = parseInt(slot, 10);
                if (isNaN(numSlot)) return false;

                let collision = false;
                Object.keys(wbSettings || {}).forEach(cardId => {
                    if (collision) return;
                    const card = wbSettings[cardId];
                    if (card.type === 'mini-scripts') {
                        const startMap = { card1: 101, card2: 201, card3: 301, card4: 401, card5: 501, card6: 601 };
                        let current = startMap[cardId] || 101;
                        (card.rows || []).forEach(row => {
                            if (row.type !== 'header') {
                                if (current === numSlot) collision = true;
                                current++;
                            }
                        });
                    }
                });
                return collision;
            };

            const handlePatchPlay = (arg1, arg2) => {
                if (Array.isArray(arg1)) {
                    // Bulk Update (Array of objects)
                    const updatesMap = new Map();
                    arg1.forEach(p => {
                        if (p && p.id) updatesMap.set(p.id, p);
                    });
                    setPlays(prev => prev.map(p => updatesMap.has(p.id) ? { ...p, ...updatesMap.get(p.id) } : p));
                } else if (typeof arg1 === 'object' && arg1 !== null && arg1.id) {
                    // Single Object (Update or Create)
                    const updatedPlay = arg1;
                    if (updatedPlay.wristbandSlot && checkWristbandConflict(updatedPlay.wristbandSlot)) {
                        alert(`Wristband slot ${updatedPlay.wristbandSlot} is already assigned to a Mini-Script position. Please choose another number.`);
                        return;
                    }
                    setPlays(prev => {
                        const exists = prev.some(p => p.id === updatedPlay.id);
                        if (exists) {
                            return prev.map(p => p.id === updatedPlay.id ? { ...p, ...updatedPlay } : p);
                        } else {
                            // Verify it's not a zombie play (has name)
                            if (!updatedPlay.name) return prev;
                            return [...prev, updatedPlay];
                        }
                    });
                } else {
                    // Standard (id, updates)
                    if (arg2 && arg2.wristbandSlot && checkWristbandConflict(arg2.wristbandSlot)) {
                        alert(`Wristband slot ${arg2.wristbandSlot} is already assigned to a Mini-Script position. Please choose another number.`);
                        return;
                    }
                    setPlays(prev => prev.map(p => p.id === arg1 ? { ...p, ...arg2 } : p));
                }
            };

            // RBAC State
            // Refactored to be User-Centric
            // We default to the first user (Matt Finn) or finding 's1'
            const [currentUserId, setCurrentUserId] = useState('s1');
            const [permissions, setPermissions] = useLocalStorage('oc-dashboard-permissions', DEFAULT_PERMISSIONS);



            // --- SITE ADMIN LOGIC ---
            // Hardcoded Safety Fallback
            const SUPER_ADMIN_EMAIL = 'matthewfinn14@gmail.com';

            const [siteAdmins, setSiteAdmins] = useState([]);
            const [isSiteAdmin, setIsSiteAdmin] = useState(false);

            // Fetch Site Admins from Firestore
            useEffect(() => {
                let unsubscribe = () => { };
                if (window.db && authUser) {
                    try {
                        unsubscribe = window.db.collection('config').doc('access')
                            .onSnapshot((doc) => {
                                if (doc.exists) {
                                    const data = doc.data();
                                    const admins = data.siteAdmins || [];
                                    setSiteAdmins(admins);

                                    // Determine if current user is Site Admin
                                    const email = authUser.email.toLowerCase();
                                    const isSuper = email === SUPER_ADMIN_EMAIL.toLowerCase();
                                    const isListed = admins.includes(email);
                                    setIsSiteAdmin(isSuper || isListed);
                                } else {
                                    // Fallback if doc doesn't exist yet
                                    setIsSiteAdmin(authUser.email.toLowerCase() === SUPER_ADMIN_EMAIL.toLowerCase());
                                }
                            }, (error) => {
                                console.error("Error fetching admin config:", error);
                            });
                    } catch (err) {
                        console.error("Setup admin listener failed:", err);
                    }
                }
                return () => unsubscribe();
            }, [authUser]);

            // Ensure permissions structure integrity on load (if new roles added later)
            useEffect(() => {
                const newPerms = { ...permissions };
                let changed = false;
                ROLES.forEach(role => {
                    if (!newPerms[role]) {
                        newPerms[role] = DEFAULT_PERMISSIONS[role];
                        changed = true;
                    }
                });
                if (changed) setPermissions(newPerms);
            }, []);

            // helper to get current staff member
            // We need to access 'staff' state, but it is defined below. 
            // So we will move the staff state definition UP above RBAC or access it inside derived logic.
            // Let's defer currentPermissions calculation until after staff is defined.

            // --- Weeks & Season Management ---

            // Helper to create default plans
            const createDefaultPracticePlans = () => {
                const defaults = {};
                ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'].forEach(day => {
                    defaults[day] = {
                        id: Date.now().toString() + Math.random().toString(36).substr(2, 9) + day,
                        date: new Date().toISOString().split('T')[0],
                        startTime: '15:40',
                        segments: []
                    };
                });
                return defaults;
            };

            // --- SCOPING MIGRATION HELPERS ---
            // 1. Wristband Defaults
            const getGlobalWbSettings = () => {
                const defaultSettings = {
                    card1: { type: 'standard', opp: '', iter: '1', rows: [] },
                    card2: { type: 'standard', opp: '', iter: '1', rows: [] },
                    card3: { type: 'wiz', opp: '', iter: '1', rows: [] },
                    staples: { type: 'staples', opp: '', iter: '1', rows: [] }
                };
                try {
                    const saved = localStorage.getItem('hc_wb_settings_v3');
                    return saved ? { ...defaultSettings, ...JSON.parse(saved) } : defaultSettings;
                } catch (e) { return defaultSettings; }
            };

            // 2. Depth Chart Defaults
            const getGlobalDepthCharts = () => {
                try {
                    const saved = localStorage.getItem('hc-depth-charts');
                    return saved ? JSON.parse(saved) : {};
                } catch (e) { return {}; }
            };

            // 3. Zone Philosophies Defaults
            const getGlobalZonePhilosophies = () => {
                const defaultPhilosophies = {
                    backed_up: '',
                    coming_out: '',
                    open_field: '',
                    fringe: 'Take one shot, be ready to convert on 4th',
                    high_red: '',
                    low_red: '',
                    goal_line: ''
                };
                try {
                    const saved = localStorage.getItem('oc-dashboard-zone-philosophies');
                    return saved ? { ...defaultPhilosophies, ...JSON.parse(saved) } : defaultPhilosophies;
                } catch (e) { return defaultPhilosophies; }
            };

            const [weeks, setWeeks] = useState(() => {
                const saved = localStorage.getItem('oc-dashboard-weeks');
                let existingWeeks = [];
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        existingWeeks = Array.isArray(parsed) ? parsed : [parsed];
                    } catch (e) {
                        console.error("Error parsing saved weeks", e);
                    }
                }



                const currentGlobalWb = getGlobalWbSettings();
                const currentGlobalDepth = getGlobalDepthCharts();
                const currentGlobalZone = getGlobalZonePhilosophies();
                // ---------------------------------

                // Migrate/Populate from OPS_CALENDAR
                const mergedWeeks = OPS_CALENDAR.map((phase, index) => {
                    const existing = existingWeeks.find(w => w.name === phase || w.id === phase);

                    // Scoping Migration: Ensure existing weeks have the new scoped properties
                    if (existing) {
                        // Backfill weekNum if missing (Migration Fix)
                        let finalWeekNum = existing.weekNum;
                        if (finalWeekNum === undefined || finalWeekNum === null) {
                            const match = (existing.name || phase).match(/Week (\d+)$/);
                            if (match) {
                                finalWeekNum = parseInt(match[1]);
                            }
                        }

                        return {
                            ...existing,
                            weekNum: finalWeekNum,
                            wristbands: existing.wristbands || JSON.parse(JSON.stringify(currentGlobalWb)),
                            depthChart: existing.depthChart || JSON.parse(JSON.stringify(currentGlobalDepth)),
                            zonePhilosophies: existing.zonePhilosophies || JSON.parse(JSON.stringify(currentGlobalZone)),
                            gamePlanLayouts: existing.gamePlanLayouts || JSON.parse(JSON.stringify(GAME_PLAN_LAYOUTS))
                        };
                    }

                    // New Week (Default) if not found
                    return {
                        id: phase,
                        name: phase,
                        date: '',
                        opponent: '',
                        isLocked: false,
                        practicePlans: createDefaultPracticePlans(),
                        offensiveGamePlan: { sets: [], miniScripts: [] },
                        dumbCallSheetData: {},
                        pregamePlan: {
                            // Default pregame plan
                        },
                        wristbands: JSON.parse(JSON.stringify(currentGlobalWb)),
                        depthChart: JSON.parse(JSON.stringify(currentGlobalDepth)),
                        zonePhilosophies: JSON.parse(JSON.stringify(currentGlobalZone)),
                        gamePlanLayouts: JSON.parse(JSON.stringify(GAME_PLAN_LAYOUTS))
                    };
                });

                // Also migrate custom weeks (those not in OPS_CALENDAR)
                const phaseSet = new Set(OPS_CALENDAR);
                const customWeeks = existingWeeks.filter(w => !phaseSet.has(w.name));
                const migratedCustomWeeks = customWeeks.map(w => ({
                    ...w,
                    wristbands: w.wristbands || JSON.parse(JSON.stringify(currentGlobalWb)),
                    depthChart: w.depthChart || JSON.parse(JSON.stringify(currentGlobalDepth)),
                    zonePhilosophies: w.zonePhilosophies || JSON.parse(JSON.stringify(currentGlobalZone)),
                    gamePlanLayouts: w.gamePlanLayouts || JSON.parse(JSON.stringify(GAME_PLAN_LAYOUTS))
                }));

                return [...mergedWeeks, ...migratedCustomWeeks];
            });

            const [currentWeekId, setCurrentWeekId] = useState(() => {
                // Determine current month phase
                const currentMonth = new Date().toLocaleString('default', { month: 'long' });
                const currentMonthIndex = OPS_CALENDAR.indexOf(currentMonth);
                const currentMonthPhaseId = currentMonthIndex !== -1 ? `phase-${currentMonthIndex}` : null;

                // Priority: Saved selection (most recently used) -> Current Month -> Last Week -> Week 1
                const savedWeeks = localStorage.getItem('oc-dashboard-weeks');
                // Note: We are deliberating NOT using 'oc-dashboard-weeks' to persist 'last selected', 
                // but rather if we want to default to "today", we should probably prioritize the current date match on initial load if no specific "last selected week" was saved.
                // However, the existing code looked at the LAST item in the weeks array.

                // Let's check for a specific "last viewed week" pref if we had one (we don't currently save one separately).
                // Or we can just default to the current month if available.

                if (currentMonthPhaseId) {
                    return currentMonthPhaseId;
                }

                if (savedWeeks) {
                    const parsed = JSON.parse(savedWeeks);
                    return parsed[parsed.length - 1].id;
                }
                return 'week-1';
            });

            // Duty Draft State
            const [dutyAssignments, setDutyAssignments] = useState(() => {
                try {
                    const saved = localStorage.getItem('oc-dashboard-duties');
                    return (saved && saved !== "null") ? JSON.parse(saved) : {};
                } catch (e) { return {}; }
            });

            // Save duties to localStorage
            useEffect(() => {
                localStorage.setItem('oc-dashboard-duties', JSON.stringify(dutyAssignments));
            }, [dutyAssignments]);

            // Custom Focus Items State
            // Custom Focus Items State - MIGRATED TO FULL LISTS
            // We'll keep the storage key to migrate old data if needed, but primarily use practiceFocusItems

            const [deleteConfirmation, setDeleteConfirmation] = useState(null); // {list: 'segments'|'focus', item: 'name' }


            const [practiceSegmentTypes, setPracticeSegmentTypes] = useState(() => {
                const saved = localStorage.getItem('oc-dashboard-segment-types');
                const defaultList = ['Competition', 'Take-Off', 'Fundi', '7-on-7', 'Inside Run', 'Team', 'Team Stationary', 'Circuit', 'Specials', 'Conditioning', 'Ghost Script', 'One-on-Ones', 'Goal Line', 'Short Yardage', 'O FUNDI', 'Team O'];

                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        if (Array.isArray(parsed)) {
                            // Migration: Return object with legacy array for all phases
                            return { OFFENSE: parsed, DEFENSE: parsed, SPECIAL_TEAMS: parsed };
                        }
                        return parsed;
                    } catch (e) { console.error("Error parsing segment types", e); }
                }

                // Default List (Phase Specific Defaults could be added here later, for now sharing global default)
                return { OFFENSE: defaultList, DEFENSE: defaultList, SPECIAL_TEAMS: defaultList };
            });

            const [practiceSegmentSettings, setPracticeSegmentSettings] = useState(() => {
                const saved = localStorage.getItem('oc-dashboard-segment-settings');
                if (saved) return JSON.parse(saved);
                return CALENDAR_CONSTANTS.SEGMENT_TYPE_SETTINGS || {};
            });

            useEffect(() => {
                localStorage.setItem('oc-dashboard-segment-settings', JSON.stringify(practiceSegmentSettings));
            }, [practiceSegmentSettings]);

            const [practiceFocusItems, setPracticeFocusItems] = useState(() => {
                const saved = localStorage.getItem('oc-dashboard-focus-items');

                // Migrate legacy custom items if found and not yet saved to new list
                let initialList = ['Base Downs', 'Convert Downs', 'Red Zone', 'Gold Zone', 'Fringe', 'Goalline/Short YDG', 'Play Action', 'Motion', 'Tackling', 'Turnover', 'Pursuit', 'Board drill', 'Joust', 'Kickoff', 'Kick Return', 'Punt', 'Punt Return', 'Field Goal', 'Onside', 'Hands Team'];

                let legacyData = null;
                if (saved) {
                    try {
                        legacyData = JSON.parse(saved);
                    } catch (e) { }
                } else {
                    // One-time migration for very old "custom-focus" key
                    const legacyCustom = localStorage.getItem('oc-dashboard-custom-focus');
                    if (legacyCustom) {
                        try {
                            const parsedLegacy = JSON.parse(legacyCustom);
                            if (Array.isArray(parsedLegacy) && parsedLegacy.length > 0) {
                                // Add unique deprecated items
                                parsedLegacy.forEach(item => {
                                    if (!initialList.includes(item)) initialList.push(item);
                                });
                            }
                        } catch (e) { }
                    }
                    legacyData = initialList;
                }

                if (Array.isArray(legacyData)) {
                    return { OFFENSE: legacyData, DEFENSE: legacyData, SPECIAL_TEAMS: legacyData };
                }
                return legacyData || { OFFENSE: initialList, DEFENSE: initialList, SPECIAL_TEAMS: initialList };
            });

            // Helpers to get merged lists for dropdowns (maintaining backward compatibility for scripts)
            const getAllSegments = () => {
                const all = new Set([
                    ...(practiceSegmentTypes.OFFENSE || []),
                    ...(practiceSegmentTypes.DEFENSE || []),
                    ...(practiceSegmentTypes.SPECIAL_TEAMS || [])
                ]);
                return Array.from(all).sort();
            };

            const getAllFocusItems = () => {
                const all = new Set([
                    ...(practiceFocusItems.OFFENSE || []),
                    ...(practiceFocusItems.DEFENSE || []),
                    ...(practiceFocusItems.SPECIAL_TEAMS || [])
                ]);
                return Array.from(all).sort();
            };

            useEffect(() => {
                localStorage.setItem('oc-dashboard-segment-types', JSON.stringify(practiceSegmentTypes));
            }, [practiceSegmentTypes]);

            useEffect(() => {
                localStorage.setItem('oc-dashboard-focus-items', JSON.stringify(practiceFocusItems));
            }, [practiceFocusItems]);

            // Kept for backward compat in signature but unused
            const addCustomFocusItem = (item) => {
                const targetPhase = 'OFFENSE';
                const allItems = getAllFocusItems();
                if (item && !allItems.includes(item)) {
                    const currentList = practiceFocusItems[targetPhase] || [];
                    setPracticeFocusItems({ ...practiceFocusItems, [targetPhase]: [...currentList, item] });
                }
            };


            // Helper to get current week data
            const currentWeek = weeks.find(w => w.id === currentWeekId) || weeks[0];

            // In-Game State
            const [activePlay, setActivePlay] = useState(null); // The play currently selected by OC



            // Situation State (Derived/Managed via Week)
            const situation = currentWeek.situation || { down: 1, distance: 10, yardLine: 25, driveNumber: 1, hash: 'M' };

            const setSituation = (newSituation) => {
                if (currentWeek.isLocked) return;
                setWeeks(weeks.map(w => w.id === currentWeekId ? { ...w, situation: newSituation } : w));
            };

            // Derived state setters for compatibility with existing components
            const setPracticePlans = (newPlans) => {
                if (currentWeek.isLocked) return;
                setWeeks(weeks.map(w => w.id === currentWeekId ? { ...w, practicePlans: newPlans } : w));
            };

            const setPregamePlan = (newPlan) => {
                if (currentWeek.isLocked) return;
                setWeeks(weeks.map(w => w.id === currentWeekId ? { ...w, pregamePlan: newPlan } : w));
            };

            const setGameLog = (newLog) => {
                if (currentWeek.isLocked) return;
                setWeeks(weeks.map(w => w.id === currentWeekId ? { ...w, gameLog: newLog } : w));
            };

            const setGamePlan = (newPlan) => {
                if (currentWeek.isLocked) return;
                setWeeks(weeks.map(w => w.id === currentWeekId ? { ...w, offensiveGamePlan: newPlan } : w));
            };

            const handleAddWeek = () => {
                // Find highest week number
                let maxWeek = 0;
                weeks.forEach(w => {
                    const match = w.name.match(/Week (\d+)$/); // Strict end match to avoid "Week 1 of Summer"
                    if (match) {
                        const num = parseInt(match[1]);
                        if (num > maxWeek) maxWeek = num;
                    }
                });

                const nextNum = maxWeek + 1;
                const newWeekId = `week-${nextNum}`; // helper ID
                const prevWeek = weeks[weeks.length - 1]; // Use last week for data cloning

                // Carryover Logic
                const newWeek = {
                    id: `custom-week-${Date.now()}`, // Unique ID to avoid any potential collision
                    name: `Week ${nextNum}`,
                    weekNum: nextNum, // Explicitly set weekNum
                    date: '',
                    opponent: '',
                    scoutingReport: '',
                    isLocked: false,
                    // Independent Week Initialization (Blank Slate)
                    practicePlans: createDefaultPracticePlans(),
                    pregamePlan: { script: [] },
                    offensiveGamePlan: { sets: [] },
                    dumbCallSheetData: {},
                    newInstallIds: [], // Start with no installs

                    // Scoped Data Defaults (Global Fallbacks)
                    wristbands: JSON.parse(JSON.stringify(getGlobalWbSettings())),
                    depthChart: JSON.parse(JSON.stringify(getGlobalDepthCharts())),
                    zonePhilosophies: JSON.parse(JSON.stringify(getGlobalZonePhilosophies())),
                    gamePlanLayouts: JSON.parse(JSON.stringify(GAME_PLAN_LAYOUTS)),

                    gameLog: []
                };

                setWeeks([...weeks, newWeek]);
                setCurrentWeekId(newWeek.id);
            };

            const handleDeleteWeek = (weekId) => {
                if (!window.confirm("Are you sure you want to permanently delete this week?")) return;

                const newWeeks = weeks.filter(w => w.id !== weekId);
                setWeeks(newWeeks);

                if (currentWeekId === weekId) {
                    const fallback = newWeeks.length > 0 ? newWeeks[0].id : null;
                    if (fallback) setCurrentWeekId(fallback); // fixed implicit check
                }
            };

            const toggleWeekLock = () => {
                setWeeks(weeks.map(w => w.id === currentWeekId ? { ...w, isLocked: !w.isLocked } : w));
            };

            const handleUpdateWeek = (id, field, value) => {
                setWeeks(prevWeeks => {
                    if (field === 'bulk_update' && typeof value === 'object') {
                        return prevWeeks.map(w => w.id === id ? { ...w, ...value } : w);
                    } else {
                        return prevWeeks.map(w => w.id === id ? { ...w, [field]: value } : w);
                    }
                });
            };

            const handleUpdateGameLog = (newLog) => {
                if (currentWeek.isLocked) return;
                setWeeks(weeks.map(w => w.id === currentWeekId ? { ...w, gameLog: newLog } : w));
            };

            const handleUpdateGamePlan = (newPlan) => {
                handleUpdateWeek(currentWeekId, 'offensiveGamePlan', newPlan);
            };

            // --- SCOPED UPDATE HANDLERS ---
            const handleUpdateWristbands = (newSettings) => {
                if (currentWeek.isLocked) return;
                // Support functional updates like standard setState
                const resolvedSettings = typeof newSettings === 'function'
                    ? newSettings(currentWeek.wristbands)
                    : newSettings;

                setWeeks(weeks.map(w => w.id === currentWeekId ? { ...w, wristbands: resolvedSettings } : w));
            };

            const handleUpdateDepthChart = (newChart) => {
                if (currentWeek.isLocked) return;
                const resolvedChart = typeof newChart === 'function' ? newChart(currentWeek.depthChart) : newChart;
                setWeeks(weeks.map(w => w.id === currentWeekId ? { ...w, depthChart: resolvedChart } : w));
            };

            const handleUpdateZonePhilosophies = (newPhilosophies) => {
                if (currentWeek.isLocked) return;
                const resolvedPhils = typeof newPhilosophies === 'function' ? newPhilosophies(currentWeek.zonePhilosophies) : newPhilosophies;
                setWeeks(weeks.map(w => w.id === currentWeekId ? { ...w, zonePhilosophies: resolvedPhils } : w));
            };
            // ------------------------------

            const [globalWeekTemplates, setGlobalWeekTemplates] = useState([]);

            // Fetch Week Templates from Firestore
            useEffect(() => {
                if (window.db && authUser) {
                    const fetchTemplates = async () => {
                        try {
                            const snapshot = await window.db.collection('global_week_templates').get();
                            const templates = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                            setGlobalWeekTemplates(templates);
                        } catch (err) {
                            console.error("Error fetching week templates:", err);
                        }
                    };
                    fetchTemplates();
                }
            }, [authUser]);

            const handleSaveWeekToTemplates = async (name) => {
                if (!name.trim()) return;
                const templateData = {
                    name: name.trim(),
                    practicePlans: JSON.parse(JSON.stringify(currentWeek.practicePlans)),
                    offensiveGamePlan: JSON.parse(JSON.stringify(currentWeek.offensiveGamePlan)),
                    dumbCallSheetData: JSON.parse(JSON.stringify(currentWeek.dumbCallSheetData || {})),
                    pregamePlan: currentWeek.pregamePlan ? JSON.parse(JSON.stringify(currentWeek.pregamePlan)) : null,

                    // Add new scoped data to templates
                    wristbands: currentWeek.wristbands ? JSON.parse(JSON.stringify(currentWeek.wristbands)) : null,
                    depthChart: currentWeek.depthChart ? JSON.parse(JSON.stringify(currentWeek.depthChart)) : null,
                    zonePhilosophies: currentWeek.zonePhilosophies ? JSON.parse(JSON.stringify(currentWeek.zonePhilosophies)) : null,

                    createdAt: new Date().toISOString(),
                    createdBy: authUser.uid
                };

                try {
                    const docRef = await window.db.collection('global_week_templates').add(templateData);
                    setGlobalWeekTemplates([...globalWeekTemplates, { id: docRef.id, ...templateData }]);
                    alert("Week saved as template!");
                } catch (err) {
                    console.error("Error saving week template:", err);
                    alert("Failed to save template.");
                }
            };

            const handleLoadWeekFromTemplate = (templateId) => {
                if (currentWeek.isLocked) {
                    alert("Current week is locked. Unlock it to apply a template.");
                    return;
                }
                const template = globalWeekTemplates.find(t => t.id === templateId);
                if (!template) return;

                if (confirm(`Apply template "${template.name}" to the current week? This will overwrite your current plans.`)) {
                    setWeeks(weeks.map(w => w.id === currentWeekId ? {
                        ...w,
                        practicePlans: JSON.parse(JSON.stringify(template.practicePlans)),
                        offensiveGamePlan: JSON.parse(JSON.stringify(template.offensiveGamePlan)),
                        dumbCallSheetData: JSON.parse(JSON.stringify(template.dumbCallSheetData || {})),
                        pregamePlan: template.pregamePlan ? JSON.parse(JSON.stringify(template.pregamePlan)) : w.pregamePlan
                    } : w));
                }
            };

            // Persistence for Weeks
            useEffect(() => {
                localStorage.setItem('oc-dashboard-weeks', JSON.stringify(weeks));
            }, [weeks]);

            // --- End Weeks Management ---

            const [roster, setRoster] = useState(() => {
                try {
                    const saved = localStorage.getItem('oc-dashboard-roster');
                    let loadedRoster = [];

                    if (!saved || saved === "null" || saved === "[]") {
                        loadedRoster = DEFAULT_ROSTER_2025;
                    } else {
                        loadedRoster = JSON.parse(saved);
                    }

                    // Migration / Initialization
                    return loadedRoster.map(p => {
                        let updated = { ...p };

                        // Ensure Position Split
                        if (!updated.offPosition || !updated.defPosition) {
                            const parts = (updated.position || '').split('/');
                            updated.offPosition = updated.offPosition || parts[0] || 'NA';
                            updated.defPosition = updated.defPosition || parts[1] || 'NA';
                        }

                        // Ensure Profile Structure
                        if (!updated.profile) {
                            updated.profile = {
                                favorites: { nfl: '', nba: '', mlb: '', musicians: '', food: '', movie: '', hobbies: '' },
                                family: '',
                                goals: { postHS: '', job: '', colleges: '' }
                            };
                        }

                        // Ensure Metrics Structure
                        if (!updated.metrics) {
                            updated.metrics = {
                                attendanceStreak: 0,
                                longestStreak: 0,
                                awards: [],
                                warriorDialLogs: []
                            };
                        } else if (!updated.metrics.warriorDialLogs) {
                            updated.metrics.warriorDialLogs = [];
                        }

                        // DATA NORMALIZATION: Ensure 'number' and 'name' are primary
                        if (!updated.number && updated.jersey) updated.number = updated.jersey;
                        if (!updated.name) {
                            if (updated.firstName && updated.lastName) {
                                updated.name = `${updated.firstName} ${updated.lastName}`;
                            } else if (updated.firstName) {
                                updated.name = updated.firstName;
                            }
                        }

                        // Ensure 'archived' flag exists
                        if (updated.archived === undefined) updated.archived = false;

                        return updated;
                    });

                } catch (e) { return DEFAULT_ROSTER_2025; }
            });
            const [depthChart, setDepthChart] = useState(() => {
                try {
                    const saved = localStorage.getItem('oc-dashboard-depthchart');
                    return (saved && saved !== "null") ? JSON.parse(saved) : {};
                } catch (e) { return {}; }
            });
            const [staff, setStaff] = useState(() => {
                try {
                    const saved = localStorage.getItem('oc-dashboard-staff');
                    if (!saved || saved === "null" || saved === "[]") return DEFAULT_STAFF_2025;

                    const loaded = JSON.parse(saved);
                    // Migration: Ensure 'roles' array exists.
                    // If old 'role' string exists, convert to array.
                    return loaded.map(s => {
                        if (s.role && !s.roles) {
                            // Map legacy string roles to new array. 
                            // 'Assistant Coach' -> 'Position Coach' mapping if needed, 
                            // but explicit mapping is safer.
                            let mappedRole = s.role;
                            if (s.role === 'Assistant Coach') mappedRole = 'Position Coach';
                            return { ...s, roles: [mappedRole], role: undefined };
                        }
                        if (!s.roles) {
                            return { ...s, roles: ['Position Coach'] };
                        }
                        return s;
                    });
                } catch (e) { return DEFAULT_STAFF_2025; }
            });

            // Weight Logs State
            const [weightLogs, setWeightLogs] = useState(() => {
                try {
                    const saved = localStorage.getItem('player_weight_logs');
                    return saved ? JSON.parse(saved) : {};
                } catch (e) { return {}; }
            });

            // Save weight logs to localStorage whenever they change
            useEffect(() => {
                localStorage.setItem('player_weight_logs', JSON.stringify(weightLogs));
            }, [weightLogs]);

            // Weight log helper functions
            const getPlayerWeightLogs = (playerId) => {
                return (weightLogs[playerId] || []).sort((a, b) => new Date(b.date) - new Date(a.date));
            };

            const addWeightLog = (playerId, weight) => {
                const newLog = {
                    id: Date.now().toString(),
                    date: new Date().toISOString().split('T')[0],
                    weight: parseFloat(weight),
                    timestamp: Date.now()
                };
                setWeightLogs(prev => ({
                    ...prev,
                    [playerId]: [...(prev[playerId] || []), newLog]
                }));
            };

            const updateWeightLog = (playerId, logId, weight) => {
                setWeightLogs(prev => ({
                    ...prev,
                    [playerId]: (prev[playerId] || []).map(log =>
                        log.id === logId ? { ...log, weight: parseFloat(weight) } : log
                    )
                }));
            };

            const deleteWeightLog = (playerId, logId) => {
                setWeightLogs(prev => ({
                    ...prev,
                    [playerId]: (prev[playerId] || []).filter(log => log.id !== logId)
                }));
            };

            // Calculate Permissions based on Current User's Roles
            const currentUser = staff.find(s => s.id === currentUserId) || staff[0] || DEFAULT_STAFF_2025[0];

            const currentPermissions = useMemo(() => {
                const userRoles = currentUser?.roles || [];

                // SUPER OVERRIDE: Admin Flag or Head Coach Role
                if (currentUser?.isAdmin || userRoles.includes('Head Coach')) {
                    // Start with 'Head Coach' permissions (Full Access)
                    return JSON.parse(JSON.stringify(DEFAULT_PERMISSIONS['Head Coach']));
                }

                // Default to first role or generic
                if (userRoles.length === 0) return DEFAULT_PERMISSIONS['Assistant'];

                // Merge Permissions: If ANY role has 'true', specific permission is true.
                const merged = JSON.parse(JSON.stringify(DEFAULT_PERMISSIONS['Assistant'])); // Start with base restricted

                userRoles.forEach(role => {
                    const rolePerms = permissions[role] || DEFAULT_PERMISSIONS[role];
                    if (!rolePerms) return;

                    Object.keys(rolePerms).forEach(feature => {
                        if (!merged[feature]) merged[feature] = { view: false, edit: false };
                        if (rolePerms[feature].view) merged[feature].view = true;
                        if (rolePerms[feature].edit) merged[feature].edit = true;
                    });
                });
                return merged;
            }, [currentUser, permissions]);

            const [teamLogo, setTeamLogo] = useState(() => {
                return localStorage.getItem('oc-dashboard-logo') || null; // Default null for new users
            });
            const [schoolName, setSchoolName] = useState(() => {
                return localStorage.getItem('hc_school_name') || '';
            });

            // Access Config for Permissions (Paying Admin Check)
            const [appAccessConfig, setAppAccessConfig] = useState({});
            useEffect(() => {
                const fetchAccess = async () => {
                    try {
                        if (!window.db) return;
                        const doc = await window.db.collection('config').doc('access').get();
                        if (doc.exists) {
                            setAppAccessConfig(doc.data());
                        }
                    } catch (e) { console.error("Error fetching access config", e); }
                };
                fetchAccess();
            }, []); // Run once on mount
            const [accentColor, setAccentColor] = useState(() => {
                return localStorage.getItem('oc-dashboard-accent') || '#38bdf8';
            });
            const handleUpdateAccentColor = setAccentColor;

            // UI Theme State
            const [theme, setTheme] = useState(() => {
                return localStorage.getItem('oc-dashboard-theme') || 'navy';
            });

            useEffect(() => {
                localStorage.setItem('oc-dashboard-theme', theme);
                document.body.className = `theme-${theme}`;
                // Cloud Sync
                if (currentUser && window.db) {
                    syncToFirestore(currentUser.uid, 'settings', { theme });
                }
            }, [theme, currentUser]);

            const [positionNames, setPositionNames] = useState(() => {
                const saved = localStorage.getItem('oc-dashboard-position-names');
                return saved ? JSON.parse(saved) : {
                    X: 'X', Z: 'Z', A: 'A', Y: 'Y',
                    QB: 'QB', RB: 'RB',
                    LT: 'LT', LG: 'LG', C: 'C', RG: 'RG', RT: 'RT'
                };
            });
            const [depthChartType, setDepthChartType] = useState('OFFENSE');
            const [selectedLevel, setSelectedLevel] = useState('ALL'); // 'ALL', 'Varsity', 'JV', 'JV2'
            const [programLevels, setProgramLevels] = useLocalStorage('oc-dashboard-levels', ['Varsity', 'JV', 'JV2']);

            // Offense Setup State
            const [customPositions, setCustomPositions] = useLocalStorage('oc-dashboard-custom-positions', { OFFENSE: [], DEFENSE: [], SPECIAL_TEAMS: [] });
            const [hiddenPositions, setHiddenPositions] = useLocalStorage('oc-dashboard-hidden-positions', { OFFENSE: [], DEFENSE: [], SPECIAL_TEAMS: [] });
            const [positionDescriptions, setPositionDescriptions] = useLocalStorage('oc-dashboard-position-descriptions', {});
            const [playSyntax, setPlaySyntax] = useLocalStorage('oc-dashboard-play-syntax', [
                { id: 'pres_form', label: 'Formation', type: 'text' },
                { id: 'pres_conc', label: 'Concept', type: 'text' }
            ]);
            const [defensePlaySyntax, setDefensePlaySyntax] = useLocalStorage('oc-dashboard-play-syntax-defense', []);
            const [stPlaySyntax, setStPlaySyntax] = useLocalStorage('oc-dashboard-play-syntax-st', []);
            const [termLibrary, setTermLibrary] = useLocalStorage('oc-dashboard-term-library', {});

            const [defenseTermLibrary, setDefenseTermLibrary] = useLocalStorage('oc-dashboard-term-library-defense', {});
            const [stTermLibrary, setStTermLibrary] = useLocalStorage('oc-dashboard-term-library-st', {});

            // O-Line Schemes State (Pass Protections and Run Blocking)
            const [passProtections, setPassProtections] = useLocalStorage('oc-dashboard-pass-protections', [
                { id: 'brown', name: 'BROWN', slideDirection: 'right', manSide: 'left', callText: 'Slide R – Man L', notes: '' },
                { id: 'gold', name: 'GOLD', slideDirection: 'left', manSide: 'right', callText: 'Slide L – Man R', notes: '' }
            ]);
            const [runBlocking, setRunBlocking] = useLocalStorage('oc-dashboard-run-blocking', [
                { id: 'zone', name: 'ZONE', type: 'zone', callText: 'Zone blocking scheme', notes: '' },
                { id: 'gap', name: 'GAP', type: 'gap', callText: 'Gap/Power blocking scheme', notes: '' }
            ]);

            const [setupTab, setSetupTab] = useState('positions');
            const [setupCategory, setSetupCategory] = useState(null);
            const [selectedBucketCategory, setSelectedBucketCategory] = useState(null);
            // Legacy: Keep playCategories for backward compatibility during transition
            const [playCategories, setPlayCategories] = useLocalStorage('oc-dashboard-play-categories', []);
            const [playBuckets, setPlayBuckets] = useLocalStorage('oc-dashboard-play-buckets', DEFAULT_PLAY_BUCKETS);

            // Ensure default buckets exist (Run, Pass, Screen)
            useEffect(() => {
                if (!playBuckets || playBuckets.length === 0) {
                    setPlayBuckets(DEFAULT_PLAY_BUCKETS);
                }
            }, [playBuckets, setPlayBuckets]);

            // AUTO-MIGRATION: Assign bucketId to plays based on their type
            useEffect(() => {
                const needsMigration = plays.some(p => p.type && !p.bucketId && p.type !== 'GAP' && p.type !== 'note');

                if (needsMigration) {
                    console.log('Migrating plays from categories to buckets...');

                    // Map old category types to new bucket IDs
                    const typeToBucketMap = {
                        'Run': 'run',
                        'RPO': 'run',
                        'Pass': 'pass',
                        'Play Action': 'pass',
                        'Screen': 'screen',
                        'GADGET': 'screen',
                        'Gadget': 'screen'
                    };

                    plays.forEach(play => {
                        if (play.type && !play.bucketId && play.type !== 'GAP' && play.type !== 'note') {
                            const bucketId = typeToBucketMap[play.type] || 'run';
                            handlePatchPlay(play.id, { bucketId });
                        }
                    });

                    console.log('Migration complete!');
                }
            }, [plays]);


            // Script Presets (Dynamic Script Templates)
            const [scriptPresets, setScriptPresets] = useLocalStorage('oc-dashboard-script-presets', [
                {
                    id: 'preset_takeoff',
                    name: 'Take-Off',
                    useYardLine: true,
                    items: [
                        { yardLine: '-30', hash: 'L' },
                        { yardLine: '-40', hash: 'M' },
                        { yardLine: '50', hash: 'R' },
                        { yardLine: '40', hash: 'L' },
                        { yardLine: '30', hash: 'M' },
                        { yardLine: '20', hash: 'R' },
                        { yardLine: '10', hash: 'L' },
                        { yardLine: '5', hash: 'M' }
                    ]
                }
            ]);





            // Layout Persistence

            const [gamePlanLayouts, setGamePlanLayouts] = useLocalStorage('gamePlanLayouts', GAME_PLAN_LAYOUTS);
            const [layoutVersions, setLayoutVersions] = useLocalStorage('gamePlanLayoutVersions', {});

            const saveLayoutVersion = (name) => {
                if (!name) return;
                const newVersions = { ...layoutVersions, [name]: gamePlanLayouts };
                setLayoutVersions(newVersions);
                alert(`Layout version "${name}" saved!`);
            };

            const deleteLayoutVersion = (name) => {
                const newVersions = { ...layoutVersions };
                delete newVersions[name];
                setLayoutVersions(newVersions);
            };

            const loadLayoutVersion = (name) => {
                const version = layoutVersions[name];
                if (!version) return;
                setGamePlanLayouts(version);
            };

            // Force update layout cols if they don't match constant (Migration for 4-col change)
            useEffect(() => {
                if (gamePlanLayouts?.CALL_SHEET) {
                    let changed = false;
                    const sections = gamePlanLayouts.CALL_SHEET.sections;
                    // Check Scripts (index 0)
                    if (sections[0] && sections[0].cols !== 4) {
                        const newSections = [...sections];
                        newSections[0] = { ...newSections[0], cols: 4 };
                        // Also check D&D (index 1) which should be 4
                        if (newSections[1] && newSections[1].cols !== 4) {
                            newSections[1] = { ...newSections[1], cols: 4 };
                        }
                        setGamePlanLayouts({ ...gamePlanLayouts, CALL_SHEET: { ...gamePlanLayouts.CALL_SHEET, sections: newSections } });
                        changed = true;
                    }
                    else if (sections[1] && sections[1].cols !== 4) {
                        // Just D&D needs update
                        const newSections = [...sections];
                        newSections[1] = { ...newSections[1], cols: 4 };
                        setGamePlanLayouts({ ...gamePlanLayouts, CALL_SHEET: { ...gamePlanLayouts.CALL_SHEET, sections: newSections } });
                        changed = true;
                    }
                }
            }, []);
            const [formationLayouts, setFormationLayouts] = useLocalStorage('formationLayouts', {});

            const updateFormationLayout = (chartType, posId, x, y) => {
                setFormationLayouts(prev => ({
                    ...prev,
                    [chartType]: {
                        ...(prev[chartType] || {}),
                        [posId]: { x, y }
                    }
                }));
            };

            const resetFormationLayout = (chartType) => {
                setFormationLayouts(prev => {
                    const next = { ...prev };
                    delete next[chartType];
                    return next;
                });
            };

            const [ratings, setRatings] = useLocalStorage('oc-dashboard-ratings', {});

            const [summerCompData, setSummerCompData] = useLocalStorage('oc-dashboard-summer-comp', null);
            const [attendance, setAttendance] = useLocalStorage('oc-dashboard-attendance', []);

            // REMOVED: Budget Data State (~25 lines) - check git history

            // Onboarding Data State - now stores only completion status, keyed by person ID
            const [onboardingData, setOnboardingData] = useState(() => {
                try {
                    const saved = localStorage.getItem('program_onboarding_data');
                    return saved ? JSON.parse(saved) : {};
                } catch (e) {
                    return {};
                }
            });

            // Save onboarding data to localStorage
            useEffect(() => {
                localStorage.setItem('program_onboarding_data', JSON.stringify(onboardingData));
            }, [onboardingData]);

            // Onboarding view state (must be at top level for React hooks)
            const [onboardingRoleFilter, setOnboardingRoleFilter] = useState('All');
            const [onboardingSelectedPerson, setOnboardingSelectedPerson] = useState(null);

            // Onboarding helper functions (at top level)
            const getRequiredItems = (role) => {
                const commonItems = ['hudlLogin', 'sportsYouLogin', 'boundRegistration'];
                if (role === 'Player') {
                    return [...commonItems, 'campRegistration', 'playerAppCompleted', 'programExpectations', 'travelMealOrder'];
                } else if (role === 'Coach') {
                    return [...commonItems, 'coachingExpectations'];
                } else if (role === 'Manager') {
                    return [...commonItems, 'programExpectations'];
                }
                return commonItems;
            };

            const getItemLabel = (itemKey) => {
                const labels = {
                    hudlLogin: 'Hudl Login',
                    sportsYouLogin: 'SportsYou Login',
                    boundRegistration: 'Bound Registration',
                    campRegistration: 'Camp Registration',
                    playerAppCompleted: 'Player App Downloaded and Completed',
                    programExpectations: 'Program Expectations',
                    travelMealOrder: 'Travel Meal Order Completed',
                    coachingExpectations: 'Coaching Expectations'
                };
                return labels[itemKey] || itemKey;
            };

            // Build combined list of all people from roster and staff
            const allPeople = [
                ...roster.map(player => ({ id: `player_${player.id}`, name: player.name, role: 'Player' })),
                ...staff.map(staffMember => ({
                    id: `staff_${staffMember.id}`,
                    name: staffMember.name,
                    role: staffMember.role === 'Manager' ? 'Manager' : 'Coach'
                }))
            ];

            const getPersonOnboardingData = (personId, role) => {
                if (!onboardingData[personId]) {
                    // Initialize with all items uncompleted
                    const requiredItems = getRequiredItems(role);
                    const items = {};
                    requiredItems.forEach(item => {
                        items[item] = { completed: false, dateCompleted: null, notes: '' };
                    });
                    return items;
                }
                return onboardingData[personId];
            };

            const getCompletionStats = (person) => {
                const requiredItems = getRequiredItems(person.role);
                const personData = getPersonOnboardingData(person.id, person.role);
                const completed = requiredItems.filter(item => personData[item]?.completed).length;
                const total = requiredItems.length;
                const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
                return { completed, total, percentage };
            };

            // Filter people by role
            const filteredPeople = onboardingRoleFilter === 'All'
                ? allPeople
                : allPeople.filter(p => p.role === onboardingRoleFilter);

            // Overall statistics
            const totalPeople = allPeople.length;
            const fullyCompleted = allPeople.filter(p => getCompletionStats(p).percentage === 100).length;
            const inProgress = allPeople.filter(p => {
                const pct = getCompletionStats(p).percentage;
                return pct > 0 && pct < 100;
            }).length;
            const notStarted = allPeople.filter(p => getCompletionStats(p).percentage === 0).length;

            const updatePersonItem = (personId, role, itemKey, field, value) => {
                const personData = getPersonOnboardingData(personId, role);
                const updatedPersonData = {
                    ...personData,
                    [itemKey]: {
                        ...personData[itemKey],
                        [field]: value,
                        ...(field === 'completed' && value ? { dateCompleted: new Date().toISOString().split('T')[0] } : {})
                    }
                };
                setOnboardingData({ ...onboardingData, [personId]: updatedPersonData });
            };

            const [metrics, setMetrics] = useState(() => {
                try {
                    const saved = localStorage.getItem('oc-dashboard-metrics');
                    return (saved && saved !== "null") ? JSON.parse(saved) : {};
                } catch (e) { return {}; }
            });






            // Save plays to localStorage whenever it changes
            useEffect(() => {
                localStorage.setItem('oc-dashboard-plays', JSON.stringify(plays));
            }, [plays]);

            // Save roster to localStorage whenever it changes
            useEffect(() => {
                localStorage.setItem('oc-dashboard-roster', JSON.stringify(roster));
                // Cloud Sync
                if (currentUser && window.db) {
                    syncToFirestore(currentUser.uid, 'roster', roster);
                }
            }, [roster, currentUser]);

            // Save depth chart to localStorage whenever it changes
            useEffect(() => {
                localStorage.setItem('oc-dashboard-depthchart', JSON.stringify(depthChart));
                // Cloud Sync
                if (currentUser && window.db) {
                    syncToFirestore(currentUser.uid, 'depthChart', depthChart);
                }
            }, [depthChart, currentUser]);

            // Save staff to localStorage whenever it changes
            useEffect(() => {
                localStorage.setItem('oc-dashboard-staff', JSON.stringify(staff));
                // Cloud Sync
                if (currentUser && window.db) {
                    syncToFirestore(currentUser.uid, 'staff', staff);
                }
            }, [staff, currentUser]);

            // Save team logo to localStorage whenever it changes
            useEffect(() => {
                if (teamLogo) {
                    localStorage.setItem('oc-dashboard-logo', teamLogo);
                } else {
                    localStorage.removeItem('oc-dashboard-logo');
                }
                // Cloud Sync
                if (currentUser && window.db) {
                    syncToFirestore(currentUser.uid, 'settings', { teamLogo });
                }
            }, [teamLogo, currentUser]);

            // Apply and Save Accent Color
            useEffect(() => {
                if (accentColor) {
                    document.documentElement.style.setProperty('--accent', accentColor);
                    localStorage.setItem('oc-dashboard-accent', accentColor);

                    // Persist to School Data (Cloud) if possible
                    const currentSchoolId = localStorage.getItem('hc_school_id');
                    if (currentSchoolId && window.db) {
                        try {
                            const schoolRef = window.db.collection('schools').doc(currentSchoolId);
                            // Only update if specifically changed (debounce could be added but this is simple)
                            schoolRef.set({
                                settings: { accentColor: accentColor }
                            }, { merge: true }).catch(err => console.error("Error saving color to cloud:", err));
                        } catch (e) {
                            console.warn("Could not save color to cloud:", e);
                        }
                    }
                }
            }, [accentColor]);

            // Save position names to localStorage
            useEffect(() => {
                localStorage.setItem('oc-dashboard-position-names', JSON.stringify(positionNames));
                // Cloud Sync
                if (currentUser && window.db) {
                    syncToFirestore(currentUser.uid, 'settings', { positionNames });
                }
            }, [positionNames, currentUser]);

            // Save ratings to localStorage whenever they change
            useEffect(() => {
                localStorage.setItem('oc-dashboard-ratings', JSON.stringify(ratings));
            }, [ratings]);

            // Save metrics to localStorage whenever they change
            useEffect(() => {
                localStorage.setItem('oc-dashboard-metrics', JSON.stringify(metrics));
            }, [metrics]);

            const toggleTag = (tag) => {
                // ... (logic handled in PlayInput)
            };

            const handleSavePlay = (playData) => {
                const { assignedScriptIds, ...savedPlayData } = playData;
                if (savedPlayData.name) savedPlayData.name = savedPlayData.name.toUpperCase();

                // Sync Mini Script Assignments
                if (assignedScriptIds !== undefined) {
                    const currentGamePlan = currentWeek.offensiveGamePlan || { sets: [], miniScripts: [] };
                    const newMiniScripts = (currentGamePlan.miniScripts || []).map(script => {
                        const isAssigned = assignedScriptIds.includes(script.id);
                        const hasPlay = script.playIds.includes(savedPlayData.id);

                        if (isAssigned && !hasPlay) {
                            return { ...script, playIds: [...script.playIds, savedPlayData.id] };
                        } else if (!isAssigned && hasPlay) {
                            return { ...script, playIds: script.playIds.filter(id => id !== savedPlayData.id) };
                        }
                        return script;
                    });

                    // Only update gamePlan if changes occured
                    if (JSON.stringify(newMiniScripts) !== JSON.stringify(currentGamePlan.miniScripts)) {
                        setGamePlan({ ...currentGamePlan, miniScripts: newMiniScripts });
                    }
                }

                // Sync Bucket Assignment (Play Family)
                if (savedPlayData.bucketId !== undefined) {
                    const oldBucketId = editingPlay?.bucketId;
                    const newBucketId = savedPlayData.bucketId;

                    // Only update if bucket assignment changed
                    if (oldBucketId !== newBucketId) {
                        const updatedBuckets = playBuckets.map(bucket => {
                            const currentPlays = bucket.plays || [];

                            // Remove from old bucket
                            if (bucket.id === oldBucketId && currentPlays.includes(savedPlayData.id)) {
                                return { ...bucket, plays: currentPlays.filter(id => id !== savedPlayData.id) };
                            }

                            // Add to new bucket
                            if (bucket.id === newBucketId && !currentPlays.includes(savedPlayData.id)) {
                                return { ...bucket, plays: [...currentPlays, savedPlayData.id] };
                            }

                            return bucket;
                        });

                        // Only update if changes occurred
                        if (JSON.stringify(updatedBuckets) !== JSON.stringify(playBuckets)) {
                            setPlayBuckets(updatedBuckets);
                        }
                    }
                }

                if (editingPlay) {
                    setPlays(plays.map(p => p.id === savedPlayData.id ? savedPlayData : p));
                    setEditingPlay(null);
                } else {
                    setPlays([savedPlayData, ...plays]);
                }
                setView('playbook');
            };

            // ...

            // RENDER LOGIC UPDATE
            {
                view === 'new-play' && (
                    <PlayInput
                        onSave={handleSavePlay}
                        onCancel={() => { setEditingPlay(null); setView('playbook'); }}
                        onDelete={handleDeletePlay}
                        initialData={editingPlay}
                        availableMiniScripts={currentWeek.offensiveGamePlan?.miniScripts || []}
                        initialAssignedScriptIds={editingPlay ? (currentWeek.offensiveGamePlan?.miniScripts || []).filter(s => s.playIds.includes(editingPlay.id)).map(s => s.id) : []}
                        formations={formations}
                        wizLibrary={wizLibrary}
                        setWizLibrary={setWizLibrary}
                        positionNames={positionNames}
                        playBuckets={playBuckets}
                        playCategories={playCategories}
                        onAddFormation={handleAddFormation}
                    />
                )
            }

            const handleEditPlay = (play) => {
                setEditingPlay(play);
                setView('new-play');
            };

            const handleUpdatePlay = (arg1, arg2) => {
                if (typeof arg1 === 'string' || typeof arg1 === 'number') {
                    // (id, updates) signature - used by InstallSortableColumn checkboxes
                    const id = arg1;
                    const updates = { ...arg2 };
                    if (updates.name) updates.name = updates.name.toUpperCase();
                    setPlays(prev => prev.map(p => p.id === id ? { ...p, ...updates } : p));
                } else {
                    // (updatedPlay) signature - full object replacement
                    const updatedPlay = arg1;
                    if (Array.isArray(updatedPlay)) {
                        // Batch update
                        const uppercased = updatedPlay.map(p => p.name ? { ...p, name: p.name.toUpperCase() } : p);
                        const updateMap = new Map(uppercased.map(p => [p.id, p]));
                        setPlays(prev => prev.map(p => updateMap.has(p.id) ? updateMap.get(p.id) : p));
                    } else {
                        // Single update
                        const finalPlay = { ...updatedPlay };
                        if (finalPlay.name) finalPlay.name = finalPlay.name.toUpperCase();
                        setPlays(prev => prev.map(p => p.id === finalPlay.id ? finalPlay : p));
                    }
                }
            };

            const handleDeletePlay = (playId) => {
                setPlays(plays.filter(p => p.id !== playId));
                setEditingPlay(null);
                setView('playbook');
            };

            // Filter Logic for Playbook View
            const [playbookFilters, setPlaybookFilters] = useState({
                formation: '',
                playCategory: '', // Bucket
                bucketId: '', // Family
                tag: '',
                situation: ''
            });

            // Batch Delete State
            const [selectedPlays, setSelectedPlays] = useState([]);
            const [lastSelectedPlayId, setLastSelectedPlayId] = useState(null);

            // Batch Import State
            const [isBatchImportOpen, setIsBatchImportOpen] = useState(false);
            const [importData, setImportData] = useState('');
            const [parsedImport, setParsedImport] = useState([]);
            const [columnMapping, setColumnMapping] = useState({});

            const handleProgressSeason = () => {
                const gradeProgression = {
                    'Freshman': 'Sophomore',
                    'Sophomore': 'Junior',
                    'Junior': 'Senior',
                    'Senior': 'Graduated'
                };

                const updatedRoster = roster
                    .map(player => ({
                        ...player,
                        year: gradeProgression[player.year] || player.year
                    }))
                    .filter(player => player.year !== 'Graduated'); // Remove graduated seniors

                const graduatedCount = roster.filter(p => p.year === 'Senior').length;

                setRoster(updatedRoster);
                alert(`✅ Season Advanced!\n\n${updatedRoster.length} players progressed to next grade.\n${graduatedCount} seniors graduated and removed from roster.`);
            };

            const handleRegressSeason = () => {
                const gradeRegression = {
                    'Senior': 'Junior',
                    'Junior': 'Sophomore',
                    'Sophomore': 'Freshman',
                    'Freshman': 'Freshman' // Can't go lower
                };

                const updatedRoster = roster.map(player => ({
                    ...player,
                    year: gradeRegression[player.year] || player.year
                }));

                setRoster(updatedRoster);
                alert(`✅ Season Regressed!\n\n${updatedRoster.length} players moved back one grade.\n\nNote: Graduated seniors were NOT restored.`);
            };

            const togglePlaySelection = (playId, isShift) => {
                const currentFiltered = getFilteredPlaybook();
                setLastSelectedPlayId(playId);

                if (isShift && lastSelectedPlayId) {
                    const currentIndex = currentFiltered.findIndex(p => p.id === playId);
                    const lastIndex = currentFiltered.findIndex(p => p.id === lastSelectedPlayId);

                    if (currentIndex !== -1 && lastIndex !== -1) {
                        const start = Math.min(currentIndex, lastIndex);
                        const end = Math.max(currentIndex, lastIndex);
                        const idsInRange = currentFiltered.slice(start, end + 1).map(p => p.id);

                        setSelectedPlays(prev => {
                            const newSet = new Set([...prev, ...idsInRange]);
                            return Array.from(newSet);
                        });
                        return;
                    }
                }

                setSelectedPlays(prev =>
                    prev.includes(playId)
                        ? prev.filter(id => id !== playId)
                        : [...prev, playId]
                );
            };

            const handleToggleSelect = (playId) => {
                setSelectedPlays(prev =>
                    prev.includes(playId)
                        ? prev.filter(id => id !== playId)
                        : [...prev, playId]
                );
            };

            const handleDeleteSelected = (e) => {
                // Prevent event bubbling and default action to avoid conflicts with other handlers
                if (e) {
                    e.preventDefault();
                    e.stopPropagation();
                }

                // Small timeout to allow the UI to stabilize/event loop to clear before showing the blocking alert
                setTimeout(() => {
                    if (window.confirm(`Are you sure you want to delete ${selectedPlays.length} plays? This cannot be undone.`)) {
                        setPlays(prevPlays => prevPlays.filter(p => !selectedPlays.includes(p.id)));
                        setSelectedPlays([]);
                    }
                }, 50);
            };

            // Batch Import Handlers
            const handleParseImport = () => {
                if (!importData.trim()) return;
                const rows = importData.split('\n').filter(r => r.trim());
                if (rows.length === 0) return;

                const firstRow = rows[0];
                const delimiter = firstRow.includes('\t') ? '\t' : (firstRow.includes(',') ? ',' : ' ');

                const parsed = rows.map(row => {
                    return row.split(delimiter).map(cell => cell.trim());
                });

                setParsedImport(parsed);
                setColumnMapping({});
            };

            const handleBatchCreate = (addToInstall = false) => {
                const newPlays = parsedImport.map(row => {
                    let playNameParts = [];
                    let formation = '';
                    let type = '';

                    Object.entries(columnMapping).forEach(([colIdx, fieldId]) => {
                        const value = row[parseInt(colIdx)];
                        if (!value) return;

                        if (fieldId === 'name_override') {
                            playNameParts = [value];
                        } else if (fieldId === 'formation') {
                            formation = value;
                        } else if (fieldId === 'type') {
                            type = value;
                        } else {
                            const field = playSyntax.find(f => f.id === fieldId);
                            if (field) {
                                playNameParts.push(value);
                            }
                        }
                    });

                    const finalName = playNameParts.join(' ').trim() || row[0];
                    return { name: finalName, formation, type: type || '' };
                });

                newPlays.forEach(playData => {
                    const newPlay = handleQuickAddPlay(playData.name);
                    if (newPlay && playData.formation) {
                        handleUpdatePlay(newPlay.id, { formation: playData.formation, type: playData.type });
                    }
                    if (addToInstall && newPlay && currentWeek) {
                        const installList = currentWeek.installList || [];
                        if (!installList.includes(newPlay.id)) {
                            handleUpdateWeek(currentWeek.id, 'installList', [...installList, newPlay.id]);
                        }
                    }
                });

                setIsBatchImportOpen(false);
                setParsedImport([]);
                setImportData('');
                setColumnMapping({});
            };

            const getFilteredPlaybook = () => {
                if (!Array.isArray(plays)) {
                    console.error('plays is not an array:', plays);
                    return [];
                }
                return plays.filter(play => {
                    const matchFormation = !playbookFilters.formation || play.formation === playbookFilters.formation;
                    const matchPlayCategory = !playbookFilters.playCategory || play.playCategory === playbookFilters.playCategory;
                    const matchBucketId = !playbookFilters.bucketId || play.bucketId === playbookFilters.bucketId;
                    const matchTag = !playbookFilters.tag || play.tags.includes(playbookFilters.tag) || play.tag1 === playbookFilters.tag || play.tag2 === playbookFilters.tag;

                    // Situation filter checks against specific categories
                    const matchSituation = !playbookFilters.situation || play.tags.includes(playbookFilters.situation) ||
                        (TAG_CATEGORIES["Situation"] && TAG_CATEGORIES["Situation"].includes(playbookFilters.situation) && play.tags.includes(playbookFilters.situation)) ||
                        (TAG_CATEGORIES["Field Position"] && TAG_CATEGORIES["Field Position"].includes(playbookFilters.situation) && play.tags.includes(playbookFilters.situation)) ||
                        (TAG_CATEGORIES["Down & Distance"] && TAG_CATEGORIES["Down & Distance"].includes(playbookFilters.situation) && play.tags.includes(playbookFilters.situation));

                    return matchFormation && matchPlayCategory && matchBucketId && matchTag && matchSituation;
                });
            };

            const filteredPlaybook = getFilteredPlaybook();

            // Extract unique values for Playbook filters
            const uniqueFormations = [...new Set(plays.map(p => p.formation).filter(Boolean))].sort();
            const uniqueConcepts = [...new Set(plays.map(p => p.concept).filter(Boolean))].sort();
            const allTags = [...new Set(plays.flatMap(p => [p.tag1, p.tag2, ...(p.tags || [])]))].filter(Boolean).sort();
            const situationTags = [...(TAG_CATEGORIES["Field Position"] || []), ...(TAG_CATEGORIES["Down & Distance"] || [])];


            // Sync status state


            const renderDataSyncManager = () => {
                const getLocal = (key, defaultVal = null) => {
                    const saved = localStorage.getItem(key);
                    return saved ? JSON.parse(saved) : defaultVal;
                };

                const dataTypes = [
                    { id: 'roster', label: 'Roster', data: getLocal('oc-dashboard-roster', []) },
                    { id: 'plays', label: 'Playbook', data: getLocal('oc-dashboard-plays', []) },
                    { id: 'staff', label: 'Staff', data: getLocal('oc-dashboard-staff', []) },
                    { id: 'weeks', label: 'Game Planner & Scripts', data: getLocal('oc-dashboard-weeks', []) },

                    { id: 'attendance', label: 'Attendance', data: getLocal('attendance_log', []) },
                    { id: 'formationLayouts', label: 'Formation Maps', data: getLocal('formationLayouts', {}) },
                    { id: 'ratings', label: 'Player Ratings', data: getLocal('oc-dashboard-ratings', {}) },

                    { id: 'summerComp', label: 'Summer Competition', data: getLocal('oc-dashboard-summer-comp', null) },
                    { id: 'athleteAssessments', label: 'Athlete Assessments', data: getLocal('athlete_assessments', {}) },
                    { id: 'formations', label: 'Formations', data: getLocal('oc-dashboard-formations', {}) },
                    { id: 'zonePhilosophies', label: 'Zone Philosophies', data: getLocal('oc-dashboard-zone-philosophies', {}) },
                    { id: 'customFocus', label: 'Custom Focus Areas', data: getLocal('oc-dashboard-custom-focus', []) },
                    { id: 'duties', label: 'Staff Duties', data: getLocal('oc-dashboard-duties', []) },
                    { id: 'metrics', label: 'Key Performance Metrics', data: getLocal('oc-dashboard-metrics', []) },
                    { id: 'fatigueThresholds', label: 'Fatigue Settings', data: getLocal('fatigue-thresholds', {}) },
                    { id: 'positionFatigue', label: 'Position Fatigue', data: getLocal('position-fatigue-values', {}) },
                    { id: 'onboarding', label: 'Onboarding Status', data: getLocal('program_onboarding_data', {}) },
                    { id: 'positionNames', label: 'Position Names', data: getLocal('oc-dashboard-position-names', {}) },
                    { id: 'dailyConnections', label: 'Daily Connections', data: getLocal('player_daily_connections', []) },
                    { id: 'weightLogs', label: 'Weight Logs', data: getLocal('player_weight_logs', {}) },
                    { id: 'roleTasks', label: 'Role Specific Tasks', data: getLocal('staff_role_tasks', []) },
                    { id: 'wizLib', label: 'Wiz Library', data: getLocal('wiz_ol_library', {}) },
                    {
                        id: 'wbSettings', label: 'Wristband Settings', data: {
                            wb1Opp: localStorage.getItem('hc_wb1_opponent'),
                            wb1Iter: localStorage.getItem('hc_wb1_iteration'),
                            wb2Opp: localStorage.getItem('hc_wb2_opponent'),
                            wb2Iter: localStorage.getItem('hc_wb2_iteration'),
                            sheetUrl: localStorage.getItem('hc_wristband_sheet_url')
                        }
                    }
                ];

                const handleSyncOne = (typeId, data) => {
                    if (!authUser) return alert("You must be logged in to sync.");
                    if (confirm(`Force PUSH '${typeId}' to cloud? This will overwrite cloud data.`)) {
                        syncToFirestore(authUser.uid, typeId, data)
                            .then(res => {
                                if (res.success) alert(`Successfully pushed ${typeId}!`);
                                else alert(`Error syncing ${typeId}: ${res.error}`);
                            });
                    }
                };

                const handlePullOne = (typeId) => {
                    if (!authUser) return alert("You must be logged in to sync.");
                    if (confirm(`Force PULL '${typeId}' from cloud? This will overwrite local data.`)) {
                        // We use loadUserDataFromFirestore but it loads ALL data.
                        // Ideally we want to load just ONE item, but our function is monolithic.
                        // However, loadUserDataFromFirestore is safe to run.
                        // But to be precise, let's just use the doc ref directly here for speed/clarity?
                        // No, let's allow a full refresh or just reuse the logic.
                        // Actually, let's just call loadUserDataFromFirestore and alert the user.
                        // Wait, loadUserDataFromFirestore replaces LOCAL STORAGE. It does NOT update React State immediately unless we reload.
                        // So we must Reload after pulling.

                        loadUserDataFromFirestore(authUser.uid).then(result => {
                            if (result.success) {
                                alert(`Successfully pulled latest data! The page will now reload.`);
                                window.location.reload();
                            } else {
                                alert("Failed to pull data.");
                            }
                        });
                    }
                };

                const handleSyncAll = () => {
                    if (!authUser) return alert("You must be logged in to sync.");
                    if (confirm("WARNING: This will overwrite ALL cloud data with the data from THIS computer. Are you sure?")) {
                        let successCount = 0;
                        let failCount = 0;

                        Promise.all(dataTypes.map(item => {
                            return syncToFirestore(authUser.uid, item.id, item.data)
                                .then(res => res.success ? successCount++ : failCount++);
                        })).then(() => {
                            alert(`Sync Complete!\nSuccess: ${successCount}\nFailed: ${failCount}`);
                        });
                    }
                };

                return (
                    <div className="card" style={{ maxWidth: '800px', margin: '2rem auto' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem', borderBottom: '1px solid var(--border)', paddingBottom: '1rem' }}>
                            <div>
                                <h1>Master Cloud Sync</h1>
                                <p style={{ opacity: 0.7 }}>Push local data to cloud or reset local data from cloud.</p>
                            </div>
                            <div style={{ display: 'flex', gap: '1rem' }}>
                                <button
                                    className="btn btn-danger"
                                    onClick={() => {
                                        if (window.confirm("NUCLEAR OPTION: This will DELETE all data on THIS computer and force a re-download from the Cloud.\n\nKey Safety Rules:\n1. Only do this if the Cloud data is GOOD.\n2. Do not do this if you have unsaved work on this computer.\n\nAre you sure?")) {
                                            localStorage.clear();
                                            window.location.reload();
                                        }
                                    }}
                                    style={{ border: '2px solid #ef4444', backgroundColor: '#7f1d1d' }}
                                >
                                    ⚠️ Hard Reset
                                </button>
                                <button className="btn btn-primary" onClick={handleSyncAll}>
                                    Push ALL to Cloud
                                </button>
                            </div>

                        </div>

                        <div style={{ display: 'grid', gridTemplateColumns: '1fr', gap: '0.5rem' }}>
                            {dataTypes.map((item, idx) => (
                                <div key={item.id} style={{
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center',
                                    padding: '1rem',
                                    background: idx % 2 === 0 ? 'var(--bg-main)' : 'var(--bg-panel)',
                                    borderRadius: '4px',
                                    border: '1px solid var(--border)'
                                }}>
                                    <div>
                                        <div style={{ fontWeight: 'bold' }}>{item.label}</div>
                                        <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', fontFamily: 'monospace' }}>
                                            {Array.isArray(item.data)
                                                ? `${item.data.length} items`
                                                : item.data && typeof item.data === 'object'
                                                    ? `${Object.keys(item.data).length} keys`
                                                    : 'Data Object'
                                            } • Key: {item.id}
                                        </div>
                                    </div>
                                    <div style={{ display: 'flex', gap: '0.5rem' }}>
                                        <button className="btn btn-sm"
                                            style={{ backgroundColor: '#10b981', color: 'white', border: 'none' }}
                                            onClick={() => handlePullOne(item.id)}>
                                            Pull (Get)
                                        </button>
                                        <button className="btn btn-secondary btn-sm" onClick={() => handleSyncOne(item.id, item.data)}>
                                            Push
                                        </button>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                );
            };

            const GlossaryView = ({ phase = 'OFFENSE' }) => {
                const isOffense = phase === 'OFFENSE';
                const isDefense = phase === 'DEFENSE';
                const isST = phase === 'SPECIAL_TEAMS';

                let currentSyntax, currentTermLibrary;

                if (isDefense) {
                    currentSyntax = defensePlaySyntax;
                    currentTermLibrary = defenseTermLibrary;
                } else if (isST) {
                    currentSyntax = stPlaySyntax;
                    currentTermLibrary = stTermLibrary;
                } else {
                    currentSyntax = playSyntax;
                    currentTermLibrary = termLibrary;
                }

                return (
                    <div className="animate-fade-in" style={{ padding: '2rem', height: '100%', overflowY: 'auto' }}>
                        <div style={{ marginBottom: '2rem', borderBottom: '1px solid var(--border)', paddingBottom: '1rem' }}>
                            <h1 style={{ margin: 0 }}>
                                {isOffense ? 'Offense' : isDefense ? 'Defense' : 'Special Teams'} <span style={{ color: 'var(--accent)' }}>Glossary</span>
                            </h1>
                            <p style={{ marginTop: '0.5rem', opacity: 0.7 }}>
                                Master terminology for {phase === 'SPECIAL_TEAMS' ? 'Special Teams' : phase.toLowerCase()}.
                            </p>
                        </div>

                        {currentSyntax.length === 0 ? (
                            <div className="alert alert-info">
                                <Icon name="Info" size={18} />
                                No play syntax defined yet. Go to <button className="btn-link" onClick={() => setView('setup-' + (isOffense ? 'offense' : isDefense ? 'defense' : 'st'))}>Setup</button> to configure your language.
                            </div>
                        ) : (
                            <div style={{ display: 'masonry', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '2rem' }}>
                                {/* Note: Masonry isn't standard CSS Grid yet (except Firefox), fallback to columns or grid */}
                                <div style={{ columnCount: 3, columnGap: '2rem' }}>
                                    {currentSyntax.map(cat => (
                                        <div key={cat.id} style={{ breakInside: 'avoid', marginBottom: '2rem', background: 'var(--bg-panel)', borderRadius: '12px', padding: '1.5rem', border: '1px solid var(--border)' }}>
                                            <h3 style={{ marginTop: 0, marginBottom: '1rem', color: 'var(--accent)', borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem', fontSize: '1.1rem' }}>
                                                {cat.label}
                                            </h3>
                                            <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.5rem' }}>
                                                {(currentTermLibrary[cat.id] || []).length > 0 ? (
                                                    (currentTermLibrary[cat.id] || []).map(term => (
                                                        <span key={term.id} style={{ background: 'var(--bg-main)', padding: '4px 10px', borderRadius: '4px', fontSize: '0.9rem', border: '1px solid var(--border)' }}>
                                                            {term.label}
                                                        </span>
                                                    ))
                                                ) : (
                                                    <span style={{ fontStyle: 'italic', opacity: 0.5, fontSize: '0.9rem' }}>No terms added.</span>
                                                )}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div >
                        )}
                    </div >
                );
            };

            const ScriptPresetsManager = () => {
                const [editingPreset, setEditingPreset] = useState(null);

                const handleSave = () => {
                    if (!editingPreset.name) return alert('Name is required');
                    setScriptPresets(prev => {
                        const exists = prev.find(p => p.id === editingPreset.id);
                        if (exists) {
                            return prev.map(p => p.id === editingPreset.id ? editingPreset : p);
                        } else {
                            return [...prev, editingPreset];
                        }
                    });
                    setEditingPreset(null);
                };

                const handleDelete = (id) => {
                    if (confirm('Delete this preset?')) {
                        setScriptPresets(prev => prev.filter(p => p.id !== id));
                    }
                };

                const handleItemChange = (idx, field, val) => {
                    const newItems = [...editingPreset.items];
                    newItems[idx] = { ...newItems[idx], [field]: val };
                    setEditingPreset({ ...editingPreset, items: newItems });
                };

                if (editingPreset) {
                    return (
                        <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                            <div style={{ display: 'flex', alignItems: 'center', marginBottom: '1rem', borderBottom: '1px solid var(--border)', paddingBottom: '1rem' }}>
                                <button className="btn-ghost" onClick={() => setEditingPreset(null)} style={{ marginRight: '1rem' }}>
                                    <Icon name="ArrowLeft" size={16} /> Back
                                </button>
                                <h3 style={{ margin: 0 }}>{editingPreset.id ? 'Edit Preset' : 'New Preset'}</h3>
                                <div style={{ flex: 1 }}></div>
                                <button className="btn-primary" onClick={handleSave}>
                                    <Icon name="Save" size={16} /> Save Preset
                                </button>
                            </div>

                            <div style={{ display: 'grid', gridTemplateColumns: 'minmax(200px, 1fr) 2fr', gap: '2rem', flex: 1, minHeight: 0 }}>
                                <div style={{ background: 'var(--bg-panel)', padding: '1.5rem', borderRadius: '8px', border: '1px solid var(--border)', height: 'fit-content' }}>
                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginBottom: '1.5rem' }}>
                                        <div>
                                            <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: 'bold' }}>Segment Type</label>
                                            <select
                                                className="form-input"
                                                value={editingPreset.type || ''}
                                                onChange={e => setEditingPreset({ ...editingPreset, type: e.target.value })}
                                                style={{ width: '100%' }}
                                            >
                                                <option value="">- Generic / None -</option>
                                                {Object.values(practiceSegmentTypes).flat().map(t => <option key={t} value={t}>{t}</option>)}
                                            </select>
                                        </div>
                                        <div>
                                            <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: 'bold' }}>Focus / Situation</label>
                                            <select
                                                className="form-input"
                                                value={editingPreset.focus || ''}
                                                onChange={e => setEditingPreset({ ...editingPreset, focus: e.target.value })}
                                                style={{ width: '100%' }}
                                            >
                                                <option value="">- Any / None -</option>
                                                {practiceFocusItems.map(f => <option key={f} value={f}>{f}</option>)}
                                            </select>
                                        </div>
                                    </div>
                                    <div style={{ marginBottom: '1.5rem' }}>
                                        <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: 'bold' }}>Preset Name</label>
                                        <input
                                            className="form-input"
                                            value={editingPreset.name}
                                            onChange={e => setEditingPreset({ ...editingPreset, name: e.target.value })}
                                            placeholder="e.g. Take-Off, Red Zone"
                                        />
                                    </div>
                                    <div style={{ marginBottom: '1.5rem' }}>
                                        <label style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', cursor: 'pointer' }}>
                                            <input
                                                type="checkbox"
                                                checked={editingPreset.useYardLine}
                                                onChange={e => setEditingPreset({ ...editingPreset, useYardLine: e.target.checked })}
                                            />
                                            <span style={{ fontWeight: 'bold' }}>Use Yard Line & Dn/Dist</span>
                                        </label>
                                        <p style={{ fontSize: '0.8rem', opacity: 0.7, marginLeft: '1.5rem', marginTop: '0.25rem' }}>
                                            If unchecked, uses "Situation" text field instead.
                                        </p>
                                    </div>
                                </div>

                                <div style={{ display: 'flex', flexDirection: 'column', background: 'var(--bg-panel)', padding: '1.5rem', borderRadius: '8px', border: '1px solid var(--border)' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                        <h4 style={{ margin: 0 }}>Script Sequence</h4>
                                        <button className="btn-secondary btn-sm" onClick={() => setEditingPreset({ ...editingPreset, items: [...editingPreset.items, {}] })}>
                                            <Icon name="Plus" size={14} /> Add Row
                                        </button>
                                    </div>
                                    <div style={{ flex: 1, overflowY: 'auto' }}>
                                        <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                                            <thead>
                                                <tr style={{ borderBottom: '2px solid var(--border)', textAlign: 'left' }}>
                                                    <th style={{ padding: '0.5rem', width: '40px' }}>#</th>
                                                    {editingPreset.useYardLine ? (
                                                        <>
                                                            <th style={{ padding: '0.5rem' }}>Yard Line</th>
                                                            <th style={{ padding: '0.5rem' }}>Hash</th>
                                                            <th style={{ padding: '0.5rem' }}>Dn/Dist</th>
                                                        </>
                                                    ) : (
                                                        <th style={{ padding: '0.5rem' }}>Situation</th>
                                                    )}
                                                    <th style={{ padding: '0.5rem', width: '40px' }}></th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {editingPreset.items.map((item, idx) => (
                                                    <tr key={idx} style={{ borderBottom: '1px solid var(--border)' }}>
                                                        <td style={{ padding: '0.5rem', opacity: 0.5 }}>{idx + 1}</td>
                                                        {editingPreset.useYardLine ? (
                                                            <>
                                                                <td style={{ padding: '0.5rem' }}>
                                                                    <input className="form-input" style={{ padding: '4px 8px' }} value={item.yardLine || ''} onChange={e => handleItemChange(idx, 'yardLine', e.target.value)} placeholder="-30" />
                                                                </td>
                                                                <td style={{ padding: '0.5rem' }}>
                                                                    <select className="form-input" style={{ padding: '4px 8px' }} value={item.hash || ''} onChange={e => handleItemChange(idx, 'hash', e.target.value)}>
                                                                        <option value="">-</option>
                                                                        <option value="L">L</option>
                                                                        <option value="M">M</option>
                                                                        <option value="R">R</option>
                                                                    </select>
                                                                </td>
                                                                <td style={{ padding: '0.5rem' }}>
                                                                    <input className="form-input" style={{ padding: '4px 8px' }} value={item.down || ''} onChange={e => handleItemChange(idx, 'down', e.target.value)} placeholder="1st & 10" />
                                                                </td>
                                                            </>
                                                        ) : (
                                                            <td style={{ padding: '0.5rem' }}>
                                                                <input className="form-input" style={{ padding: '4px 8px', width: '100%' }} value={item.situation || ''} onChange={e => handleItemChange(idx, 'situation', e.target.value)} placeholder="Goal Line..." />
                                                            </td>
                                                        )}
                                                        <td style={{ padding: '0.5rem' }}>
                                                            <button className="btn-icon" style={{ color: 'var(--danger)', opacity: 0.7 }} onClick={() => {
                                                                const newItems = editingPreset.items.filter((_, i) => i !== idx);
                                                                setEditingPreset({ ...editingPreset, items: newItems });
                                                            }}>
                                                                <Icon name="Trash" size={14} />
                                                            </button>
                                                        </td>
                                                    </tr>
                                                ))}
                                                {editingPreset.items.length === 0 && (
                                                    <tr>
                                                        <td colSpan={editingPreset.useYardLine ? 5 : 3} style={{ padding: '2rem', textAlign: 'center', opacity: 0.5 }}>
                                                            No items. Click "Add Row" to start.
                                                        </td>
                                                    </tr>
                                                )}
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            </div>
                        </div >
                    );
                }

                return (
                    <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                        <div style={{ marginBottom: '1.5rem', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <div>
                                <h3 style={{ margin: 0 }}>Script Presets</h3>
                                <p style={{ margin: '0.25rem 0 0 0', opacity: 0.7 }}>Manage standard script templates for different practice periods.</p>
                            </div>
                            <button className="btn-primary" onClick={() => setEditingPreset({ id: Date.now().toString(), name: 'New Preset', type: '', focus: '', useYardLine: true, items: [] })}>
                                <Icon name="Plus" size={16} /> New Preset
                            </button>
                        </div>

                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '1rem', alignContent: 'start' }}>
                            {scriptPresets.map(preset => (
                                <div key={preset.id} className="card" style={{ padding: '1.5rem', display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                                        <h4 style={{ margin: 0, fontSize: '1.1rem' }}>{preset.name}</h4>
                                        <div style={{ display: 'flex', gap: '0.5rem' }}>
                                            <button className="btn-icon" onClick={() => setEditingPreset({ ...preset, items: [...preset.items] })} title="Edit">
                                                <Icon name="Edit" size={16} />
                                            </button>
                                            <button className="btn-icon" style={{ color: 'var(--danger)' }} onClick={() => handleDelete(preset.id)} title="Delete">
                                                <Icon name="Trash" size={16} />
                                            </button>
                                        </div>
                                    </div>
                                    <div style={{ fontSize: '0.9rem', opacity: 0.7 }}>
                                        {preset.items.length} items • {preset.useYardLine ? 'Yard/Hash' : 'Situation'}
                                    </div>
                                    {(preset.type || preset.focus) && (
                                        <div style={{ marginTop: '0.25rem', fontSize: '0.8rem', color: 'var(--accent)', fontWeight: '500' }}>
                                            {preset.type && <span style={{ marginRight: '0.5rem' }}>[{preset.type}]</span>}
                                            {preset.focus && <span>({preset.focus})</span>}
                                        </div>
                                    )}
                                    <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginTop: 'auto' }}>
                                        {preset.items.slice(0, 3).map((item, i) => (
                                            <span key={i} style={{ background: 'var(--bg-main)', padding: '2px 6px', borderRadius: '4px', fontSize: '0.8rem', border: '1px solid var(--border)' }}>
                                                {preset.useYardLine ? (item.yardLine || '-') + (item.hash ? ` ${item.hash}` : '') : (item.situation || 'Item')}
                                            </span>
                                        ))}
                                        {preset.items.length > 3 && (
                                            <span style={{ fontSize: '0.8rem', opacity: 0.5, alignSelf: 'center' }}>+{preset.items.length - 3} more</span>
                                        )}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                );
            };

            const renderSetup = (phase) => {
                const isOffense = phase === 'OFFENSE';
                const isDefense = phase === 'DEFENSE';
                const isST = phase === 'SPECIAL_TEAMS';

                let currentSyntax, setSyntax, defaultPositions;

                if (isDefense) {
                    currentSyntax = defensePlaySyntax;
                    setSyntax = setDefensePlaySyntax;
                    defaultPositions = [
                        { key: 'DE', default: 'DE', description: 'Defensive End' },
                        { key: 'DT', default: 'DT', description: 'Defensive Tackle' },
                        { key: 'NT', default: 'NT', description: 'Nose Tackle' },
                        { key: 'LB', default: 'LB', description: 'Linebacker' },
                        { key: 'CB', default: 'CB', description: 'Cornerback' },
                        { key: 'S', default: 'S', description: 'Safety' },
                        { key: 'NB', default: 'NB', description: 'Nickelback' },
                        { key: 'DL', default: 'DL', description: 'Defensive Line' },
                        { key: 'DB', default: 'DB', description: 'Defensive Back' }
                    ];
                } else if (isST) {
                    currentSyntax = stPlaySyntax;
                    setSyntax = setStPlaySyntax;
                    defaultPositions = [
                        { key: 'K', default: 'K', description: 'Kicker' },
                        { key: 'P', default: 'P', description: 'Punter' },
                        { key: 'LS', default: 'LS', description: 'Long Snapper' },
                        { key: 'H', default: 'H', description: 'Holder' },
                        { key: 'KR', default: 'KR', description: 'Kick Returner' },
                        { key: 'PR', default: 'PR', description: 'Punt Returner' },
                        { key: 'G', default: 'G', description: 'Gunner' },
                        { key: 'W', default: 'W', description: 'Wing' },
                        { key: 'PP', default: 'PP', description: 'Personal Protector' },
                        { key: 'L1', default: 'L1', description: 'KO Left 1' },
                        { key: 'R1', default: 'R1', description: 'KO Right 1' }
                    ];
                } else {
                    currentSyntax = playSyntax;
                    setSyntax = setPlaySyntax;
                    defaultPositions = [
                        { key: 'X', default: 'X', description: 'Left WR' },
                        { key: 'Z', default: 'Z', description: 'Right WR' },
                        { key: 'A', default: 'A', description: 'Slot WR' },
                        { key: 'Y', default: 'Y', description: 'Tight End' },
                        { key: 'QB', default: 'QB', description: 'Quarterback' },
                        { key: 'RB', default: 'RB', description: 'Running Back' },
                        { key: 'LT', default: 'LT', description: 'Left Tackle' },
                        { key: 'LG', default: 'LG', description: 'Left Guard' },
                        { key: 'C', default: 'C', description: 'Center' },
                        { key: 'RG', default: 'RG', description: 'Right Guard' },
                        { key: 'RT', default: 'RT', description: 'Right Tackle' },
                    ];
                }

                let currentTermLibrary, setCurrentTermLibrary;
                if (isDefense) {
                    currentTermLibrary = defenseTermLibrary;
                    setCurrentTermLibrary = setDefenseTermLibrary;
                } else if (isST) {
                    currentTermLibrary = stTermLibrary;
                    setCurrentTermLibrary = setStTermLibrary;
                } else {
                    currentTermLibrary = termLibrary;
                    setCurrentTermLibrary = setTermLibrary;
                }

                const getTerms = (catId) => currentTermLibrary[catId] || [];
                const addTerm = (catId) => {
                    const term = prompt("Enter new term:");
                    if (term) {
                        const newTerms = [...getTerms(catId), { id: Date.now().toString(), label: term }];
                        setCurrentTermLibrary({ ...currentTermLibrary, [catId]: newTerms });
                    }
                };
                const deleteTerm = (catId, termId) => {
                    if (confirm("Delete this term?")) {
                        const newTerms = getTerms(catId).filter(t => t.id !== termId);
                        setCurrentTermLibrary({ ...currentTermLibrary, [catId]: newTerms });
                    }
                };

                const phaseTitle = isDefense ? 'Defense' : isST ? 'Special Teams' : 'Offense';

                return (
                    <div className="card" style={{ maxWidth: '1200px', margin: '2rem auto', padding: '0', minHeight: '600px', display: 'flex', flexDirection: 'column' }}>
                        <div style={{ padding: '1.5rem', borderBottom: '1px solid var(--border)' }}>
                            <h1 style={{ margin: 0 }}>{phaseTitle} Setup</h1>
                            <p style={{ opacity: 0.7, margin: '0.5rem 0 0 0' }}>Configure your {phaseTitle.toLowerCase()} language, positions, and terminology.</p>
                        </div>

                        <div style={{ display: 'flex', borderBottom: '1px solid var(--border)', background: '#1e293b' }}>
                            <button
                                className={`btn-ghost`}
                                style={{
                                    borderRadius: 0,
                                    padding: '1rem 1.5rem',
                                    borderBottom: setupTab === 'positions' ? '3px solid var(--accent)' : '3px solid transparent',
                                    fontWeight: setupTab === 'positions' ? 'bold' : 'normal',
                                    color: setupTab === 'positions' ? 'var(--text-primary)' : 'var(--text-secondary)',
                                    background: 'transparent',
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '0.5rem'
                                }}
                                onClick={() => setSetupTab('positions')}
                            >
                                <Icon name="Users" size={16} /> Positions
                            </button>
                            <button
                                className={`btn-ghost`}
                                style={{
                                    borderRadius: 0,
                                    padding: '1rem 1.5rem',
                                    borderBottom: setupTab === 'syntax' ? '3px solid var(--accent)' : '3px solid transparent',
                                    fontWeight: setupTab === 'syntax' ? 'bold' : 'normal',
                                    color: setupTab === 'syntax' ? 'var(--text-primary)' : 'var(--text-secondary)',
                                    background: 'transparent',
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '0.5rem'
                                }}
                                onClick={() => setSetupTab('syntax')}
                            >
                                <Icon name="Code" size={16} /> Playcall Chain
                            </button>
                            <button
                                className={`btn-ghost`}
                                style={{
                                    borderRadius: 0,
                                    padding: '1rem 1.5rem',
                                    borderBottom: setupTab === 'terms' ? '3px solid var(--accent)' : '3px solid transparent',
                                    fontWeight: setupTab === 'terms' ? 'bold' : 'normal',
                                    color: setupTab === 'terms' ? 'var(--text-primary)' : 'var(--text-secondary)',
                                    background: 'transparent',
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '0.5rem'
                                }}
                                onClick={() => setSetupTab('terms')}
                            >
                                <Icon name="BookOpen" size={16} /> Term Library
                            </button>
                            <button
                                className={`btn-ghost`}
                                style={{
                                    borderRadius: 0,
                                    padding: '1rem 1.5rem',
                                    borderBottom: setupTab === 'categories' ? '3px solid var(--accent)' : '3px solid transparent',
                                    fontWeight: setupTab === 'categories' ? 'bold' : 'normal',
                                    color: setupTab === 'categories' ? 'var(--text-primary)' : 'var(--text-secondary)',
                                    background: 'transparent',
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '0.5rem'
                                }}
                                onClick={() => setSetupTab('categories')}
                            >
                                <Icon name="Tag" size={16} /> Play Buckets
                            </button>
                            <button
                                className={`btn-ghost`}
                                style={{
                                    borderRadius: 0,
                                    padding: '1rem 1.5rem',
                                    borderBottom: setupTab === 'buckets' ? '3px solid var(--accent)' : '3px solid transparent',
                                    fontWeight: setupTab === 'buckets' ? 'bold' : 'normal',
                                    color: setupTab === 'buckets' ? 'var(--text-primary)' : 'var(--text-secondary)',
                                    background: 'transparent',
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '0.5rem'
                                }}
                                onClick={() => setSetupTab('buckets')}
                            >
                                <Icon name="Grid" size={16} /> Concept Families
                            </button>
                            <button
                                className={`btn-ghost`}
                                style={{
                                    borderRadius: 0,
                                    padding: '1rem 1.5rem',
                                    borderBottom: setupTab === 'practice-lists' ? '3px solid var(--accent)' : '3px solid transparent',
                                    fontWeight: setupTab === 'practice-lists' ? 'bold' : 'normal',
                                    color: setupTab === 'practice-lists' ? 'var(--text-primary)' : 'var(--text-secondary)',
                                    background: 'transparent',
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '0.5rem'
                                }}
                                onClick={() => setSetupTab('practice-lists')}
                            >
                                <Icon name="List" size={16} /> Practice Lists
                            </button>
                            {isOffense && (
                                <button
                                    className={`btn-ghost`}
                                    style={{
                                        borderRadius: 0,
                                        padding: '1rem 1.5rem',
                                        borderBottom: setupTab === 'script-presets' ? '3px solid var(--accent)' : '3px solid transparent',
                                        fontWeight: setupTab === 'script-presets' ? 'bold' : 'normal',
                                        color: setupTab === 'script-presets' ? 'var(--text-primary)' : 'var(--text-secondary)',
                                        background: 'transparent',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '0.5rem'
                                    }}
                                    onClick={() => setSetupTab('script-presets')}
                                >
                                    <Icon name="FileText" size={16} /> Script Presets
                                </button>
                            )}
                            {isOffense && (
                                <button
                                    className={`btn-ghost`}
                                    style={{
                                        borderRadius: 0,
                                        padding: '1rem 1.5rem',
                                        borderBottom: setupTab === 'oline-schemes' ? '3px solid var(--accent)' : '3px solid transparent',
                                        fontWeight: setupTab === 'oline-schemes' ? 'bold' : 'normal',
                                        color: setupTab === 'oline-schemes' ? 'var(--text-primary)' : 'var(--text-secondary)',
                                        background: 'transparent',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '0.5rem'
                                    }}
                                    onClick={() => setSetupTab('oline-schemes')}
                                >
                                    <Icon name="Shield" size={16} /> O-Line Schemes
                                </button>
                            )}
                        </div>

                        <div style={{ padding: '1.5rem', flex: 1 }}>
                            {setupTab === 'categories' && (
                                <div>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                        <h3 style={{ margin: 0 }}>Play Buckets</h3>
                                        <button className="btn btn-primary" onClick={() => {
                                            const label = prompt("New Category Label:");
                                            if (label) {
                                                const id = label.toLowerCase().replace(/[^a-z0-9]/g, '');
                                                if (playCategories.some(c => c.id === id)) {
                                                    alert("Bucket ID already exists.");
                                                    return;
                                                }
                                                setPlayCategories([...playCategories, { id, label, color: 'gray' }]);
                                            }
                                        }}>
                                            <Icon name="Plus" size={16} /> Add Bucket
                                        </button>
                                    </div>
                                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '1rem' }}>
                                        {playCategories.map((cat, idx) => (
                                            <div key={cat.id} className="card" style={{ padding: '1rem' }}>
                                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.75rem' }}>
                                                    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', flex: 1 }}>
                                                        <div style={{ width: 16, height: 16, borderRadius: '50%', background: cat.color === 'gray' ? '#94a3b8' : cat.color, flexShrink: 0 }}></div>
                                                        <input
                                                            type="text"
                                                            value={cat.label}
                                                            onChange={(e) => {
                                                                const newCategories = [...playCategories];
                                                                newCategories[idx] = { ...cat, label: e.target.value };
                                                                setPlayCategories(newCategories);
                                                            }}
                                                            style={{
                                                                fontWeight: 'bold',
                                                                fontSize: '1rem',
                                                                padding: '0.25rem 0.5rem',
                                                                border: '1px solid var(--border)',
                                                                borderRadius: '4px',
                                                                background: 'var(--bg-main)',
                                                                color: 'var(--text-main)',
                                                                flex: 1
                                                            }}
                                                        />
                                                        <span style={{ fontSize: '0.8rem', opacity: 0.5, flexShrink: 0 }}>({cat.id})</span>
                                                    </div>
                                                    <button className="btn-icon" style={{ color: '#ef4444' }} onClick={() => {
                                                        if (confirm(`Delete bucket "${cat.label}"?`)) {
                                                            setPlayCategories(playCategories.filter(c => c.id !== cat.id));
                                                        }
                                                    }}>
                                                        <Icon name="Trash" size={16} />
                                                    </button>
                                                </div>
                                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                    <label style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', minWidth: '40px' }}>Color:</label>
                                                    <input
                                                        type="color"
                                                        value={cat.color === 'gray' ? '#94a3b8' : cat.color}
                                                        onChange={(e) => {
                                                            const newCategories = [...playCategories];
                                                            newCategories[idx] = { ...cat, color: e.target.value };
                                                            setPlayCategories(newCategories);
                                                        }}
                                                        style={{
                                                            width: '50px',
                                                            height: '32px',
                                                            border: '1px solid var(--border)',
                                                            borderRadius: '4px',
                                                            cursor: 'pointer'
                                                        }}
                                                    />
                                                    <span style={{ fontSize: '0.8rem', opacity: 0.6, fontFamily: 'monospace' }}>{cat.color === 'gray' ? '#94a3b8' : cat.color}</span>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                    <div style={{ marginTop: '2rem', padding: '1rem', background: '#f8fafc', borderRadius: '8px', fontSize: '0.9rem', color: '#64748b' }}>
                                        <p style={{ margin: 0 }}><strong>Note:</strong> These buckets define the high-level organization (e.g. Run, Pass, RPO).</p>
                                    </div>
                                </div>
                            )}

                            {setupTab === 'buckets' && (
                                <div style={{ padding: '2rem' }}>
                                    <div style={{ marginBottom: '2rem' }}>
                                        <h3 style={{ margin: 0 }}>Concept Families</h3>
                                        <p style={{ color: 'var(--text-secondary)', marginTop: '0.5rem' }}>
                                            Manage your concept families within each bucket.
                                        </p>
                                    </div>

                                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '1rem' }}>
                                        {playCategories.map(bucket => {
                                            // Derive families from plays in this bucket
                                            // Ensure we match using bucketId OR categoryId, preferring bucketId if it matches the bucket's ID
                                            const bucketPlays = plays.filter(p => p.bucketId === bucket.id);
                                            const derivedFamilies = [...new Set(bucketPlays.map(p => p.conceptFamily).filter(Boolean))];    // Also include any explicitly defined families (if we decide to store them on the bucket object later)
                                            // For now, we'll just use the derived ones + any purely "custom" ones if we added that feature.
                                            // But since we can't persist custom ones without a backend change or state change, we'll stick to derived + "add via dummy" or just "manage derived".
                                            // Wait, user wants to ADD. If I add a family, I can't just leave it floating.
                                            // I'll add a 'families' array to playCategories in state to persist "unused" families.
                                            const explicitFamilies = bucket.families || [];
                                            const allFamilies = [...new Set([...derivedFamilies, ...explicitFamilies])].sort();

                                            return (
                                                <div key={bucket.id} className="card" style={{ padding: '1.5rem', display: 'flex', flexDirection: 'column' }}>
                                                    <div style={{ borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem', marginBottom: '1rem', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                            <div style={{ width: 12, height: 12, borderRadius: '50%', background: bucket.color === 'gray' ? '#94a3b8' : bucket.color }}></div>
                                                            <h4 style={{ margin: 0 }}>{bucket.label}</h4>
                                                        </div>
                                                        <button
                                                            className="btn-icon"
                                                            title="Add Family"
                                                            onClick={() => {
                                                                const name = prompt("New Concept Family Name:");
                                                                if (name) {
                                                                    // Add to bucket's explicit families list
                                                                    const newCategories = playCategories.map(c => {
                                                                        if (c.id === bucket.id) {
                                                                            return { ...c, families: [...(c.families || []), name] };
                                                                        }
                                                                        return c;
                                                                    });
                                                                    setPlayCategories(newCategories);
                                                                }
                                                            }}
                                                        >
                                                            <Icon name="Plus" size={16} />
                                                        </button>
                                                    </div>

                                                    {allFamilies.length === 0 ? (
                                                        <div style={{ fontSize: '0.875rem', color: 'var(--text-secondary)', fontStyle: 'italic', padding: '1rem', textAlign: 'center', border: '1px dashed var(--border)', borderRadius: '4px' }}>
                                                            No families defined.
                                                        </div>
                                                    ) : (
                                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                                            {allFamilies.map(family => (
                                                                <div key={family} style={{
                                                                    display: 'flex',
                                                                    justifyContent: 'space-between',
                                                                    alignItems: 'center',
                                                                    padding: '0.5rem 0.75rem',
                                                                    background: 'var(--bg-main)',
                                                                    borderRadius: '4px',
                                                                    border: '1px solid var(--border)'
                                                                }}>
                                                                    <span style={{ fontSize: '0.9rem', fontWeight: '500' }}>{family}</span>
                                                                    <div style={{ display: 'flex', gap: '0.25rem' }}>
                                                                        <button
                                                                            className="btn-icon" title="Rename Family" onClick={() => {
                                                                                const newName = prompt("Rename Concept Family:", family);
                                                                                if (newName && newName !== family) {
                                                                                    // 1. Update plays
                                                                                    const playsToUpdate = bucketPlays.filter(p => p.conceptFamily === family);
                                                                                    if (playsToUpdate.length > 0) {
                                                                                        const updates = playsToUpdate.map(p => ({ id: p.id, conceptFamily: newName }));
                                                                                        handlePatchPlay(updates);
                                                                                    }

                                                                                    // 2. Update explicit families
                                                                                    if ((bucket.families || []).includes(family)) {
                                                                                        const newCategories = playCategories.map(c => {
                                                                                            if (c.id === bucket.id) {
                                                                                                const newFamilies = c.families.map(f => f === family ? newName : f);
                                                                                                return { ...c, families: newFamilies };
                                                                                            }
                                                                                            return c;
                                                                                        });
                                                                                        setPlayCategories(newCategories);
                                                                                    }
                                                                                }
                                                                            }}
                                                                        >
                                                                            <Icon name="Edit" size={14} />
                                                                        </button>
                                                                        <button
                                                                            className="btn-icon"
                                                                            style={{ color: '#ef4444' }}
                                                                            title="Delete Family"
                                                                            onClick={() => {
                                                                                if (confirm(`Delete family "${family}"? This will remove it from all plays in this bucket.`)) {
                                                                                    // 1. Unassign from plays
                                                                                    const playsToUpdate = bucketPlays.filter(p => p.conceptFamily === family);
                                                                                    if (playsToUpdate.length > 0) {
                                                                                        const updates = playsToUpdate.map(p => ({ id: p.id, conceptFamily: null }));
                                                                                        handlePatchPlay(updates);
                                                                                    }

                                                                                    // 2. Remove from explicit list
                                                                                    if ((bucket.families || []).includes(family)) {
                                                                                        const newCategories = playCategories.map(c => {
                                                                                            if (c.id === bucket.id) {
                                                                                                return { ...c, families: c.families.filter(f => f !== family) };
                                                                                            }
                                                                                            return c;
                                                                                        });
                                                                                        setPlayCategories(newCategories);
                                                                                    }
                                                                                }
                                                                            }}
                                                                        >
                                                                            <Icon name="Trash" size={14} />
                                                                        </button>
                                                                    </div>
                                                                </div>
                                                            ))}
                                                        </div>
                                                    )}
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            )}

                            {setupTab === 'positions' && (
                                <div>
                                    <h3 style={{ marginBottom: '1rem' }}>Position Names</h3>

                                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(180px, 1fr))', gap: '1rem' }}>
                                        {[...defaultPositions.filter(p => !(hiddenPositions[phase] || []).includes(p.key)), ...(customPositions[phase] || [])].map(pos => (
                                            <div key={pos.key} style={{ background: 'var(--bg-main)', padding: '1rem', borderRadius: '8px', border: '1px solid var(--border)', position: 'relative' }}>
                                                {pos.isCustom && (
                                                    <button
                                                        onClick={() => {
                                                            if (confirm(`Permanently delete custom position ${pos.default}?`)) {
                                                                const newCustom = (customPositions[phase] || []).filter(p => p.key !== pos.key);
                                                                setCustomPositions({ ...customPositions, [phase]: newCustom });
                                                            }
                                                        }}
                                                        style={{
                                                            position: 'absolute',
                                                            top: '4px',
                                                            right: '4px',
                                                            background: 'none',
                                                            border: 'none',
                                                            color: '#ef4444',
                                                            cursor: 'pointer',
                                                            opacity: 0.6,
                                                            padding: '4px'
                                                        }}
                                                        onMouseOver={e => e.currentTarget.style.opacity = '1'}
                                                        onMouseOut={e => e.currentTarget.style.opacity = '0.6'}
                                                        title="Delete Position"
                                                    >
                                                        <Icon name="X" size={14} />
                                                    </button>
                                                )}
                                                <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem', paddingRight: pos.isCustom ? '1rem' : '0', alignItems: 'center' }}>
                                                    <label className="form-label" style={{ fontSize: '0.75rem', fontWeight: 'bold' }}>{positionNames[pos.key] || pos.default}</label>
                                                    <input
                                                        type="text"
                                                        value={positionDescriptions[pos.key] !== undefined ? positionDescriptions[pos.key] : pos.description}
                                                        onChange={(e) => setPositionDescriptions({ ...positionDescriptions, [pos.key]: e.target.value })}
                                                        placeholder={pos.description}
                                                        style={{
                                                            fontSize: '0.8rem',
                                                            color: 'var(--text-primary)',
                                                            borderBottom: '1px dashed var(--accent)',
                                                            background: 'transparent',
                                                            textAlign: 'right',
                                                            width: '140px',
                                                            outline: 'none',
                                                            cursor: 'text',
                                                            paddingRight: '2px',
                                                            fontWeight: '500'
                                                        }}
                                                        onFocus={(e) => {
                                                            e.target.style.background = 'var(--bg-panel)';
                                                            e.target.style.borderBottom = '1px solid var(--accent)';
                                                        }}
                                                        onBlur={(e) => {
                                                            e.target.style.background = 'transparent';
                                                            e.target.style.borderBottom = '1px dashed var(--accent)';
                                                        }}
                                                    />
                                                </div>
                                                <input
                                                    type="text"
                                                    className="form-input"
                                                    value={positionNames[pos.key] || pos.default}
                                                    onChange={(e) => setPositionNames({ ...positionNames, [pos.key]: e.target.value.toUpperCase().slice(0, 3) })}
                                                    placeholder={pos.default}
                                                    maxLength="3"
                                                    style={{ padding: '0.5rem', fontSize: '1rem', fontWeight: 'bold', textAlign: 'center', border: '1px solid var(--border)', borderRadius: '4px', width: '100%', marginTop: '0.5rem' }}
                                                    title={`Customize ${pos.description} label`}
                                                />
                                            </div>
                                        ))}

                                        {/* Add Position Button */}
                                        <button
                                            onClick={() => {
                                                const key = prompt("Enter Position Key (1-3 letters, e.g., 'F' or 'S2'):");
                                                if (!key) return;

                                                const cleanKey = key.toUpperCase().trim().slice(0, 3);
                                                if (!cleanKey) return;

                                                // Check for duplicates
                                                const allKeys = [...defaultPositions, ...(customPositions[phase] || [])].map(p => p.key);
                                                if (allKeys.includes(cleanKey)) {
                                                    alert("That position key already exists!");
                                                    return;
                                                }

                                                const desc = prompt("Enter Description (e.g., 'Flex Tight End'):") || cleanKey;

                                                const newPos = {
                                                    key: cleanKey,
                                                    default: cleanKey,
                                                    description: desc,
                                                    isCustom: true
                                                };

                                                setCustomPositions({
                                                    ...customPositions,
                                                    [phase]: [...(customPositions[phase] || []), newPos]
                                                });
                                            }}
                                            style={{
                                                background: 'var(--surface)',
                                                border: '2px dashed var(--border)',
                                                borderRadius: '8px',
                                                display: 'flex',
                                                flexDirection: 'column',
                                                alignItems: 'center',
                                                justifyContent: 'center',
                                                cursor: 'pointer',
                                                padding: '1rem',
                                                minHeight: '100px',
                                                color: 'var(--text-secondary)',
                                                transition: 'all 0.2s'
                                            }}
                                            onMouseOver={e => { e.currentTarget.style.borderColor = 'var(--accent)'; e.currentTarget.style.color = 'var(--accent)'; }}
                                            onMouseOut={e => { e.currentTarget.style.borderColor = 'var(--border)'; e.currentTarget.style.color = 'var(--text-secondary)'; }}
                                        >
                                            <Icon name="Plus" size={24} style={{ marginBottom: '0.5rem' }} />
                                            <span style={{ fontWeight: '600' }}>Add Position</span>
                                        </button>
                                    </div>

                                    {(hiddenPositions[phase] || []).length > 0 && (
                                        <div style={{ marginTop: '2rem', padding: '1rem', border: '1px dashed var(--border)', borderRadius: '8px', opacity: 0.8 }}>
                                            <h4 style={{ margin: '0 0 1rem 0', fontSize: '0.9rem', color: 'var(--text-secondary)' }}>Hidden Default Positions</h4>
                                            <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                                                {(hiddenPositions[phase] || []).map(hiddenKey => {
                                                    const original = defaultPositions.find(p => p.key === hiddenKey);
                                                    if (!original) return null;
                                                    return (
                                                        <div key={hiddenKey} style={{
                                                            display: 'flex',
                                                            alignItems: 'center',
                                                            gap: '0.5rem',
                                                            padding: '0.5rem 1rem',
                                                            background: 'var(--bg-panel)',
                                                            borderRadius: '4px',
                                                            border: '1px solid var(--border)',
                                                            fontSize: '0.85rem'
                                                        }}>
                                                            <span>{original.default} <span style={{ opacity: 0.5 }}>({original.description})</span></span>
                                                            <button
                                                                onClick={() => {
                                                                    const newHidden = (hiddenPositions[phase] || []).filter(h => h !== hiddenKey);
                                                                    setHiddenPositions({ ...hiddenPositions, [phase]: newHidden });
                                                                }}
                                                                className="btn-sm"
                                                                style={{ color: 'var(--accent)', border: 'none', background: 'none', padding: '0', marginLeft: '4px', fontWeight: 'bold', cursor: 'pointer' }}
                                                            >
                                                                Restore
                                                            </button>
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            )}

                            {setupTab === 'syntax' && (
                                <div style={{ maxWidth: '800px' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '1.5rem', alignItems: 'center' }}>
                                        <div>
                                            <h3 style={{ margin: 0 }}>Play Call Structure</h3>
                                            <p style={{ margin: '0.25rem 0 0 0', opacity: 0.7 }}>Define the order and components of a play call.</p>
                                        </div>
                                        <button className="btn btn-primary" onClick={() => {
                                            const newId = Date.now().toString();
                                            setSyntax([...currentSyntax, { id: newId, label: 'New Component', type: 'text' }]);
                                        }}>
                                            <Icon name="Plus" size={16} style={{ marginRight: '6px' }} /> Add Component
                                        </button>
                                    </div>

                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                                        {currentSyntax.map((item, idx) => (
                                            <div key={item.id} style={{ display: 'flex', gap: '1rem', alignItems: 'center', padding: '1rem', border: '1px solid var(--border)', borderRadius: '8px', background: 'var(--bg-main)' }}>
                                                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', width: '32px', height: '32px', background: 'var(--bg-panel)', borderRadius: '50%', fontWeight: 'bold', color: 'var(--text-secondary)' }}>
                                                    {idx + 1}
                                                </div>
                                                <div style={{ flex: 1, display: 'grid', gridTemplateColumns: '1fr 80px 80px', gap: '1rem' }}>
                                                    <div>
                                                        <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', display: 'block', marginBottom: '0.25rem' }}>Component Name</label>
                                                        <input
                                                            type="text"
                                                            className="form-input"
                                                            value={item.label}
                                                            onChange={(e) => {
                                                                const newSyntax = [...currentSyntax];
                                                                newSyntax[idx].label = e.target.value;
                                                                setSyntax(newSyntax);
                                                            }}
                                                            placeholder="e.g. Formation"
                                                        />
                                                    </div>
                                                    <div>
                                                        <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', display: 'block', marginBottom: '0.25rem' }}>Prefix</label>
                                                        <input
                                                            type="text"
                                                            className="form-input"
                                                            value={item.prefix || ''}
                                                            onChange={(e) => {
                                                                const newSyntax = [...currentSyntax];
                                                                newSyntax[idx].prefix = e.target.value;
                                                                setSyntax(newSyntax);
                                                            }}
                                                            placeholder='"'
                                                            style={{ textAlign: 'center' }}
                                                        />
                                                    </div>
                                                    <div>
                                                        <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', display: 'block', marginBottom: '0.25rem' }}>Suffix</label>
                                                        <input
                                                            type="text"
                                                            className="form-input"
                                                            value={item.suffix || ''}
                                                            onChange={(e) => {
                                                                const newSyntax = [...currentSyntax];
                                                                newSyntax[idx].suffix = e.target.value;
                                                                setSyntax(newSyntax);
                                                            }}
                                                            placeholder='"'
                                                            style={{ textAlign: 'center' }}
                                                        />
                                                    </div>
                                                </div>
                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '2px' }}>
                                                    <button className="btn btn-ghost btn-sm" onClick={() => {
                                                        if (idx === 0) return;
                                                        const newSyntax = [...currentSyntax];
                                                        [newSyntax[idx - 1], newSyntax[idx]] = [newSyntax[idx], newSyntax[idx - 1]];
                                                        setSyntax(newSyntax);
                                                    }} disabled={idx === 0} style={{ padding: '2px' }}><Icon name="ChevronUp" size={16} /></button>
                                                    <button className="btn btn-ghost btn-sm" onClick={() => {
                                                        if (idx === currentSyntax.length - 1) return;
                                                        const newSyntax = [...currentSyntax];
                                                        [newSyntax[idx + 1], newSyntax[idx]] = [newSyntax[idx], newSyntax[idx + 1]];
                                                        setSyntax(newSyntax);
                                                    }} disabled={idx === currentSyntax.length - 1} style={{ padding: '2px' }}><Icon name="ChevronDown" size={16} /></button>
                                                </div>
                                                <button className="btn btn-ghost" style={{ color: 'var(--danger)' }} onClick={() => {
                                                    if (confirm('Delete this syntax component? All associated terms will be hidden.')) {
                                                        const newSyntax = currentSyntax.filter((_, i) => i !== idx);
                                                        setSyntax(newSyntax);
                                                    }
                                                }}>
                                                    <Icon name="Trash" size={18} />
                                                </button>
                                            </div>
                                        ))}
                                        {currentSyntax.length === 0 && (
                                            <div style={{ textAlign: 'center', padding: '3rem', border: '2px dashed var(--border)', borderRadius: '8px', opacity: 0.6 }}>
                                                <Icon name="Code" size={48} style={{ marginBottom: '1rem' }} />
                                                <p>No play components defined.</p>
                                                <p>Click "Add Component" to start building your play call structure.</p>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            )}

                            {setupTab === 'terms' && (
                                <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                                    <div style={{ marginBottom: '1.5rem' }}>
                                        <h3 style={{ margin: 0 }}>Term Library</h3>
                                        <p style={{ margin: '0.25rem 0 0 0', opacity: 0.7 }}>Manage vocabulary for your play components.</p>
                                    </div>

                                    {currentSyntax.length === 0 ? (
                                        <div className="alert alert-warning">
                                            <Icon name="AlertTriangle" size={18} />
                                            Please define your Play Call Structure in the Syntax tab first.
                                        </div>
                                    ) : (
                                        <div style={{ display: 'flex', gap: '2rem', flex: 1, minHeight: '0' }}>
                                            <div style={{ width: '250px', borderRight: '1px solid var(--border)', paddingRight: '1rem', overflowY: 'auto' }}>
                                                <div style={{ fontSize: '0.75rem', fontWeight: 'bold', marginBottom: '0.5rem', color: 'var(--text-secondary)', letterSpacing: '0.05em' }}>COMPONENTS</div>
                                                {currentSyntax.map(cat => (
                                                    <button
                                                        key={cat.id}
                                                        onClick={() => setSetupCategory(cat.id)}
                                                        style={{
                                                            display: 'block',
                                                            width: '100%',
                                                            textAlign: 'left',
                                                            padding: '0.75rem 1rem',
                                                            background: setupCategory === cat.id ? 'var(--bg-main)' : 'none',
                                                            border: 'none',
                                                            borderRadius: '6px',
                                                            fontWeight: setupCategory === cat.id ? 'bold' : 'normal',
                                                            color: setupCategory === cat.id ? 'var(--accent)' : 'var(--text-primary)',
                                                            marginBottom: '2px',
                                                            transition: 'all 0.2s'
                                                        }}
                                                    >
                                                        {cat.label}
                                                    </button>
                                                ))}
                                            </div>
                                            <div style={{ flex: 1, overflowY: 'auto' }}>
                                                {!setupCategory ? (
                                                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100%', opacity: 0.5, flexDirection: 'column' }}>
                                                        <Icon name="ArrowLeft" size={24} style={{ marginBottom: '1rem' }} />
                                                        Select a component to manage terms
                                                    </div>
                                                ) : (
                                                    <div>
                                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                                            <h4 style={{ margin: 0 }}>
                                                                {currentSyntax.find(s => s.id === setupCategory)?.label} Terms
                                                            </h4>
                                                            <button className="btn btn-sm btn-primary" onClick={() => addTerm(setupCategory)}>
                                                                + Add Term
                                                            </button>
                                                        </div>
                                                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))', gap: '0.75rem' }}>
                                                            {getTerms(setupCategory).map(term => (
                                                                <div key={term.id} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '0.75rem', background: 'var(--bg-main)', borderRadius: '6px', border: '1px solid var(--border)' }}>
                                                                    <span style={{ fontWeight: '500' }}>{term.label}</span>
                                                                    <button className="btn-icon" style={{ color: 'var(--text-secondary)' }} onClick={() => deleteTerm(setupCategory, term.id)}>
                                                                        <Icon name="X" size={14} />
                                                                    </button>
                                                                </div>
                                                            ))}
                                                            {getTerms(setupCategory).length === 0 && (
                                                                <div style={{ gridColumn: '1 / -1', padding: '2rem', textAlign: 'center', opacity: 0.6, border: '1px dashed var(--border)', borderRadius: '6px' }}>
                                                                    No terms added yet.
                                                                </div>
                                                            )}
                                                        </div>
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            )}

                            {setupTab === 'practice-lists' && (
                                <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                                    <div style={{ marginBottom: '1.5rem' }}>
                                        <h3 style={{ margin: 0 }}>Practice Lists</h3>
                                        <p style={{ margin: '0.25rem 0 0 0', opacity: 0.7 }}>Customize standard dropdown options for practice plans.</p>
                                    </div>

                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '2rem' }}>
                                        <HierarchyEditor
                                            segmentTypes={practiceSegmentTypes[phase] || []}
                                            focusItems={practiceFocusItems[phase] || []}
                                            settings={practiceSegmentSettings}
                                            onUpdateSettings={setPracticeSegmentSettings}
                                            onAddSegment={(val) => {
                                                const currentList = practiceSegmentTypes[phase] || [];
                                                if (!currentList.includes(val)) {
                                                    setPracticeSegmentTypes({ ...practiceSegmentTypes, [phase]: [...currentList, val] });
                                                }
                                            }}
                                            onAddFocus={(val) => {
                                                const currentList = practiceFocusItems[phase] || [];
                                                if (!currentList.includes(val)) {
                                                    setPracticeFocusItems({ ...practiceFocusItems, [phase]: [...currentList, val] });
                                                }
                                            }}
                                            onRenameSegment={(oldName, newName) => {
                                                const currentList = practiceSegmentTypes[phase] || [];
                                                const updatedList = currentList.map(item => item === oldName ? newName : item);
                                                setPracticeSegmentTypes({ ...practiceSegmentTypes, [phase]: updatedList });

                                                // Update settings to use new name as key
                                                if (practiceSegmentSettings[oldName]) {
                                                    const updatedSettings = { ...practiceSegmentSettings };
                                                    updatedSettings[newName] = updatedSettings[oldName];
                                                    delete updatedSettings[oldName];
                                                    setPracticeSegmentSettings(updatedSettings);
                                                }
                                            }}
                                            onRenameFocus={(oldName, newName) => {
                                                const currentList = practiceFocusItems[phase] || [];
                                                const updatedList = currentList.map(item => item === oldName ? newName : item);
                                                setPracticeFocusItems({ ...practiceFocusItems, [phase]: updatedList });

                                                // Update any allowedFocusItems arrays that reference the old name
                                                const updatedSettings = { ...practiceSegmentSettings };
                                                Object.keys(updatedSettings).forEach(segKey => {
                                                    if (updatedSettings[segKey].allowedFocusItems) {
                                                        updatedSettings[segKey] = {
                                                            ...updatedSettings[segKey],
                                                            allowedFocusItems: updatedSettings[segKey].allowedFocusItems.map(
                                                                item => item === oldName ? newName : item
                                                            )
                                                        };
                                                    }
                                                });
                                                setPracticeSegmentSettings(updatedSettings);
                                            }}
                                            deleteConfirmation={deleteConfirmation}
                                            setDeleteConfirmation={setDeleteConfirmation}
                                            onDeleteSegment={(item) => {
                                                const currentList = practiceSegmentTypes[phase] || [];
                                                setPracticeSegmentTypes({ ...practiceSegmentTypes, [phase]: currentList.filter(t => t !== item) });
                                                setDeleteConfirmation(null);
                                            }}
                                            onDeleteFocus={(item) => {
                                                const currentList = practiceFocusItems[phase] || [];
                                                setPracticeFocusItems({ ...practiceFocusItems, [phase]: currentList.filter(t => t !== item) });
                                                setDeleteConfirmation(null);
                                            }}
                                        />
                                    </div>
                                </div>
                            )}


                            {
                                setupTab === 'script-presets' && (
                                    <ScriptPresetsManager />
                                )
                            }

                            {setupTab === 'oline-schemes' && (
                                <div>
                                    <h3 style={{ marginBottom: '1.5rem' }}>O-Line Schemes</h3>

                                    {/* Pass Protections Section */}
                                    <div style={{ marginBottom: '2rem' }}>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                            <div>
                                                <h4 style={{ margin: 0 }}>Pass Protections</h4>
                                                <p style={{ margin: '0.25rem 0 0 0', opacity: 0.7, fontSize: '0.85rem' }}>Define your pass protection calls (e.g., BROWN, GOLD)</p>
                                            </div>
                                            <button className="btn btn-primary" onClick={() => {
                                                const name = prompt("Protection Name (e.g., BROWN):");
                                                if (name) {
                                                    setPassProtections([...passProtections, {
                                                        id: Date.now().toString(),
                                                        name: name.toUpperCase(),
                                                        slideDirection: 'right',
                                                        manSide: 'left',
                                                        callText: '',
                                                        notes: ''
                                                    }]);
                                                }
                                            }}>
                                                <Icon name="Plus" size={16} style={{ marginRight: '6px' }} /> Add Protection
                                            </button>
                                        </div>
                                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(350px, 1fr))', gap: '1rem' }}>
                                            {passProtections.map((prot, idx) => (
                                                <div key={prot.id} className="card" style={{ padding: '1rem' }}>
                                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.75rem' }}>
                                                        <input
                                                            type="text"
                                                            value={prot.name}
                                                            onChange={(e) => {
                                                                const updated = [...passProtections];
                                                                updated[idx] = { ...prot, name: e.target.value.toUpperCase() };
                                                                setPassProtections(updated);
                                                            }}
                                                            style={{ fontWeight: 'bold', fontSize: '1.1rem', background: 'transparent', border: 'none', color: 'var(--text-primary)', width: '120px' }}
                                                        />
                                                        <button
                                                            className="btn btn-ghost btn-sm"
                                                            onClick={() => {
                                                                if (confirm(`Delete ${prot.name}?`)) {
                                                                    setPassProtections(passProtections.filter(p => p.id !== prot.id));
                                                                }
                                                            }}
                                                            style={{ color: '#ef4444' }}
                                                        >
                                                            <Icon name="Trash2" size={14} />
                                                        </button>
                                                    </div>
                                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '0.75rem', marginBottom: '0.75rem' }}>
                                                        <div>
                                                            <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', display: 'block', marginBottom: '0.25rem' }}>Slide Direction</label>
                                                            <select
                                                                className="form-input"
                                                                value={prot.slideDirection}
                                                                onChange={(e) => {
                                                                    const updated = [...passProtections];
                                                                    updated[idx] = { ...prot, slideDirection: e.target.value };
                                                                    setPassProtections(updated);
                                                                }}
                                                            >
                                                                <option value="left">← Slide Left</option>
                                                                <option value="right">Slide Right →</option>
                                                                <option value="none">No Slide</option>
                                                            </select>
                                                        </div>
                                                        <div>
                                                            <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', display: 'block', marginBottom: '0.25rem' }}>Man Side</label>
                                                            <select
                                                                className="form-input"
                                                                value={prot.manSide}
                                                                onChange={(e) => {
                                                                    const updated = [...passProtections];
                                                                    updated[idx] = { ...prot, manSide: e.target.value };
                                                                    setPassProtections(updated);
                                                                }}
                                                            >
                                                                <option value="left">Man Left</option>
                                                                <option value="right">Man Right</option>
                                                                <option value="none">N/A</option>
                                                            </select>
                                                        </div>
                                                    </div>
                                                    <div style={{ marginBottom: '0.5rem' }}>
                                                        <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', display: 'block', marginBottom: '0.25rem' }}>Call Text (shown on WIZ card)</label>
                                                        <input
                                                            type="text"
                                                            className="form-input"
                                                            value={prot.callText}
                                                            onChange={(e) => {
                                                                const updated = [...passProtections];
                                                                updated[idx] = { ...prot, callText: e.target.value };
                                                                setPassProtections(updated);
                                                            }}
                                                            placeholder="e.g., Slide R – Man L"
                                                        />
                                                    </div>
                                                    <div>
                                                        <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', display: 'block', marginBottom: '0.25rem' }}>Notes</label>
                                                        <textarea
                                                            className="form-input"
                                                            value={prot.notes}
                                                            onChange={(e) => {
                                                                const updated = [...passProtections];
                                                                updated[idx] = { ...prot, notes: e.target.value };
                                                                setPassProtections(updated);
                                                            }}
                                                            placeholder="Optional notes..."
                                                            rows={2}
                                                            style={{ resize: 'vertical' }}
                                                        />
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>

                                    {/* Run Blocking Section */}
                                    <div>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                            <div>
                                                <h4 style={{ margin: 0 }}>Run Blocking Schemes</h4>
                                                <p style={{ margin: '0.25rem 0 0 0', opacity: 0.7, fontSize: '0.85rem' }}>Define your run blocking schemes (e.g., Zone, Gap, Power)</p>
                                            </div>
                                            <button className="btn btn-primary" onClick={() => {
                                                const name = prompt("Blocking Scheme Name (e.g., ZONE, POWER):");
                                                if (name) {
                                                    setRunBlocking([...runBlocking, {
                                                        id: Date.now().toString(),
                                                        name: name.toUpperCase(),
                                                        type: 'zone',
                                                        callText: '',
                                                        notes: ''
                                                    }]);
                                                }
                                            }}>
                                                <Icon name="Plus" size={16} style={{ marginRight: '6px' }} /> Add Scheme
                                            </button>
                                        </div>
                                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(350px, 1fr))', gap: '1rem' }}>
                                            {runBlocking.map((scheme, idx) => (
                                                <div key={scheme.id} className="card" style={{ padding: '1rem' }}>
                                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.75rem' }}>
                                                        <input
                                                            type="text"
                                                            value={scheme.name}
                                                            onChange={(e) => {
                                                                const updated = [...runBlocking];
                                                                updated[idx] = { ...scheme, name: e.target.value.toUpperCase() };
                                                                setRunBlocking(updated);
                                                            }}
                                                            style={{ fontWeight: 'bold', fontSize: '1.1rem', background: 'transparent', border: 'none', color: 'var(--text-primary)', width: '120px' }}
                                                        />
                                                        <button
                                                            className="btn btn-ghost btn-sm"
                                                            onClick={() => {
                                                                if (confirm(`Delete ${scheme.name}?`)) {
                                                                    setRunBlocking(runBlocking.filter(s => s.id !== scheme.id));
                                                                }
                                                            }}
                                                            style={{ color: '#ef4444' }}
                                                        >
                                                            <Icon name="Trash2" size={14} />
                                                        </button>
                                                    </div>
                                                    <div style={{ marginBottom: '0.75rem' }}>
                                                        <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', display: 'block', marginBottom: '0.25rem' }}>Scheme Type</label>
                                                        <select
                                                            className="form-input"
                                                            value={scheme.type}
                                                            onChange={(e) => {
                                                                const updated = [...runBlocking];
                                                                updated[idx] = { ...scheme, type: e.target.value };
                                                                setRunBlocking(updated);
                                                            }}
                                                        >
                                                            <option value="zone">Zone</option>
                                                            <option value="gap">Gap / Man</option>
                                                            <option value="power">Power</option>
                                                            <option value="counter">Counter</option>
                                                            <option value="trap">Trap</option>
                                                            <option value="iso">Iso</option>
                                                            <option value="other">Other</option>
                                                        </select>
                                                    </div>
                                                    <div style={{ marginBottom: '0.5rem' }}>
                                                        <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', display: 'block', marginBottom: '0.25rem' }}>Call Text (shown on WIZ card)</label>
                                                        <input
                                                            type="text"
                                                            className="form-input"
                                                            value={scheme.callText}
                                                            onChange={(e) => {
                                                                const updated = [...runBlocking];
                                                                updated[idx] = { ...scheme, callText: e.target.value };
                                                                setRunBlocking(updated);
                                                            }}
                                                            placeholder="e.g., Inside Zone Left"
                                                        />
                                                    </div>
                                                    <div>
                                                        <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', display: 'block', marginBottom: '0.25rem' }}>Notes</label>
                                                        <textarea
                                                            className="form-input"
                                                            value={scheme.notes}
                                                            onChange={(e) => {
                                                                const updated = [...runBlocking];
                                                                updated[idx] = { ...scheme, notes: e.target.value };
                                                                setRunBlocking(updated);
                                                            }}
                                                            placeholder="Optional notes..."
                                                            rows={2}
                                                            style={{ resize: 'vertical' }}
                                                        />
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div >
                    </div >
                );
            };



            if (!authUser) return <LoginScreen />;

            return (
                <PlayDetailsModalContext.Provider value={{ openPlayDetails }}>
                    <div className="app-container">
                        {schoolSetupData.showWizard && (
                            <div className="onboarding-wizard-wrapper">
                                <SchoolOnboardingWizard
                                    user={authUser}
                                    onComplete={async (schoolId) => {
                                        console.log("Onboarding Complete. Fetching new data...");
                                        setSchoolSetupData({ showWizard: false, schoolId: null });
                                        // Fetch fresh data immediately to populate Dashboard without reload
                                        await loadUserDataFromFirestore(authUser.uid);
                                        // Ensure School ID is set in local state (in case loader didn't catch it yet)
                                        localStorage.setItem('hc_school_id', schoolId);
                                    }}
                                />
                            </div>
                        )}


                        <div className="sidebar" style={{
                            width: sidebarCollapsed ? '60px' : '280px',
                            transition: 'width 0.3s ease',
                            overflow: 'hidden',
                            zIndex: 2200000000, // Stay above modals
                            position: 'relative'
                        }}>
                            <div style={{ marginBottom: '2rem', paddingLeft: '0.5rem', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                                {!sidebarCollapsed && (
                                    <h1 style={{ fontSize: '1.8rem', fontWeight: 'bold', color: 'var(--accent)', marginBottom: '1rem', letterSpacing: '-1px' }}>DoFO</h1>
                                )}
                                <button
                                    onClick={() => {
                                        const willExpand = sidebarCollapsed;
                                        setSidebarCollapsed(!sidebarCollapsed);
                                        // When expanding sidebar, close any open side menus
                                        if (willExpand && closeSideMenuRef.current) {
                                            closeSideMenuRef.current();
                                        }
                                    }}
                                    style={{
                                        background: 'rgba(56, 189, 248, 0.1)',
                                        border: '1px solid rgba(56, 189, 248, 0.3)',
                                        borderRadius: '4px',
                                        padding: '0.5rem',
                                        cursor: 'pointer',
                                        color: 'var(--accent)',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        marginLeft: sidebarCollapsed ? '0' : 'auto',
                                        marginBottom: sidebarCollapsed ? '0' : '1rem'
                                    }}
                                    title={sidebarCollapsed ? 'Expand sidebar' : 'Collapse sidebar'}
                                >
                                    {sidebarCollapsed ? '→' : '←'}
                                </button>
                            </div>

                            <div style={{ padding: sidebarCollapsed ? '0 0.25rem' : '0 0.5rem', display: 'flex', flexDirection: 'column', gap: '0.25rem', marginBottom: '1rem' }}>
                                {!sidebarCollapsed && (
                                    <>
                                        {schoolName && (
                                            <div style={{ animation: 'fadeIn 0.5s ease', marginBottom: '1rem', display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                                {teamLogo && (
                                                    <img
                                                        src={teamLogo}
                                                        alt="School Logo"
                                                        style={{ maxHeight: '60px', maxWidth: '100%', objectFit: 'contain', borderRadius: '4px', alignSelf: 'flex-start' }}
                                                    />
                                                )}
                                                <h2 style={{ fontSize: '1.2rem', fontWeight: '700', lineHeight: '1.2', color: 'var(--text-primary)' }}>
                                                    {schoolName}
                                                </h2>
                                            </div>
                                        )}

                                        {/* School Switcher */}
                                        <SchoolSwitcher userId={authUser.uid} currentSchoolId={localStorage.getItem('hc_school_id')} />

                                        {/* Active Season Display (Moved to Top/Sticky) */}
                                        <div style={{ marginTop: '1rem' }}>
                                            <label style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', textTransform: 'uppercase', letterSpacing: '0.05em', marginBottom: '0rem', display: 'block' }}>
                                                Active Season
                                            </label>
                                            <div style={{ fontSize: '1.1rem', fontWeight: 'bold', color: 'var(--text-primary)', letterSpacing: '0.05em' }}>
                                                {activeYear || '2024'}
                                            </div>
                                        </div>

                                        {/* Level Filter (Moved to Top/Sticky) */}
                                        <div style={{ marginTop: '0.5rem', marginBottom: '0.5rem' }}>
                                            <label style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', textTransform: 'uppercase', letterSpacing: '0.05em', marginBottom: '0.15rem', display: 'block' }}>
                                                Level Filter
                                            </label>
                                            <select
                                                className="form-select"
                                                value={selectedLevel}
                                                onChange={(e) => setSelectedLevel(e.target.value)}
                                                style={{ width: '100%', padding: '0.25rem', fontSize: '0.9rem', backgroundColor: 'rgba(0,0,0,0.2)' }}
                                            >
                                                <option value="ALL">All Levels</option>
                                                {programLevels && programLevels.length > 0 && programLevels.map((level) => (
                                                    <option key={level} value={level}>{level}</option>
                                                ))}
                                            </select>
                                        </div>

                                        {/* Week Template Actions (Moved to Top/Sticky) */}
                                        <div style={{ marginBottom: '1rem', display: 'flex', flexDirection: 'column', gap: '0.25rem' }}>
                                            {globalWeekTemplates.length > 0 && (
                                                <select
                                                    className="form-select"
                                                    style={{ width: '100%', padding: '0.25rem 0.5rem', fontSize: '0.8rem', backgroundColor: 'rgba(0,0,0,0.1)', border: '1px dashed rgba(255,255,255,0.2)' }}
                                                    onChange={(e) => {
                                                        if (e.target.value) {
                                                            handleLoadWeekFromTemplate(e.target.value);
                                                            e.target.value = '';
                                                        }
                                                    }}
                                                    value=""
                                                >
                                                    <option value="" disabled>Apply Week Template...</option>
                                                    {globalWeekTemplates.map(t => (
                                                        <option key={t.id} value={t.id}>📋 {t.name}</option>
                                                    ))}
                                                </select>
                                            )}
                                        </div>
                                    </>
                                )}

                                {/* Core Navigation Buttons (Dashboard/Reports - Moved to Top/Sticky) */}



                                {currentPermissions.dashboard.view && (
                                    <button
                                        className={`nav-item ${view === 'practice-report' ? 'active' : ''}`}
                                        onClick={() => setView('practice-report')}
                                        style={{
                                            width: '100%',
                                            textAlign: 'left',
                                            border: 'none',
                                            background: 'none',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: sidebarCollapsed ? 'center' : 'flex-start',
                                            gap: '0.5rem',
                                            padding: sidebarCollapsed ? '0.75rem 0' : '0.5rem 0.75rem',
                                            marginBottom: '0.25rem'
                                        }}
                                    >
                                        <Icon name="Activity" size={18} color="var(--accent)" />
                                        {!sidebarCollapsed && <span style={{ fontWeight: '600' }}>PRACTICE REPORT</span>}
                                    </button>
                                )}

                                {!sidebarCollapsed && isSiteAdmin && (
                                    <div style={{ marginTop: '0.25rem' }}>
                                        <select
                                            className="form-select"
                                            value={currentUserId}
                                            onChange={(e) => {
                                                setCurrentUserId(e.target.value);
                                                setView('landing');
                                            }}
                                            style={{
                                                width: '100%',
                                                fontSize: '0.8rem',
                                                padding: '0.4rem',
                                                background: 'rgba(255,255,255,0.05)',
                                                border: '1px solid rgba(255,255,255,0.1)',
                                                color: 'var(--accent)'
                                            }}
                                        >
                                            {staff.map(s => (
                                                <option key={s.id} value={s.id}>View as: {s.name}</option>
                                            ))}
                                        </select>
                                    </div>
                                )}

                                {!sidebarCollapsed && <div style={{ borderBottom: '1px solid rgba(255,255,255,0.1)', marginTop: '0.5rem', marginBottom: '0.5rem' }}></div>}
                            </div>
                            <nav style={{ flex: 1, overflowY: 'auto' }}>

                                {/* Week Selector Section (Phase Breakdown) */}
                                {!sidebarCollapsed && (
                                    <>
                                        <div style={{ padding: '0 0.5rem 1.5rem 0.5rem', borderBottom: '1px solid rgba(255,255,255,0.1)', marginBottom: '1rem' }}>
                                            <div style={{ marginBottom: '1rem' }}>
                                                <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', textTransform: 'uppercase', letterSpacing: '0.05em', marginBottom: '0.5rem', display: 'block' }}>
                                                    Phases / Weeks
                                                </label>
                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.25rem' }}>
                                                    {/* Offseason Phase */}
                                                    <CollapsibleCategory title="OFFSEASON" icon="Calendar" defaultOpen={false}>
                                                        {weeks.filter(w => ["November", "December", "January", "February", "March", "April", "May"].includes(w.name)).map(w => (
                                                            <CollapsibleCategory
                                                                key={w.id}
                                                                title={w.name}
                                                                icon={w.isLocked ? "Lock" : "Calendar"}
                                                                defaultOpen={currentWeekId === w.id}
                                                                nested={true}
                                                                onTitleClick={() => { setCurrentWeekId(w.id); setView('staff-meeting'); setShowManageWeekModal(false); }}
                                                            >
                                                                {renderWeeklyTools(w.id)}
                                                            </CollapsibleCategory>
                                                        ))}
                                                    </CollapsibleCategory>

                                                    {/* Summer Phase */}
                                                    <CollapsibleCategory title="SUMMER" icon="Sun" defaultOpen={false} onTitleClick={() => setView('summer-setup')}>
                                                        {weeks.filter(w => w.name.includes("Summer")).map(w => (
                                                            <CollapsibleCategory
                                                                key={w.id}
                                                                title={w.name}
                                                                icon={w.isLocked ? "Lock" : "Sun"}
                                                                defaultOpen={currentWeekId === w.id}
                                                                nested={true}
                                                                onTitleClick={() => { setCurrentWeekId(w.id); setView('staff-meeting'); setShowManageWeekModal(false); }}
                                                            >
                                                                {renderWeeklyTools(w.id)}
                                                            </CollapsibleCategory>
                                                        ))}
                                                    </CollapsibleCategory>

                                                    {/* Pre-Season Phase */}
                                                    <CollapsibleCategory title="PRE-SEASON" icon="Zap" defaultOpen={false} onTitleClick={() => setView('pre-season-setup')}>
                                                        {weeks.filter(w => ["Family Week", "Camp Week", "First Week of Practice", "Week 0"].includes(w.name)).map(w => (
                                                            <CollapsibleCategory
                                                                key={w.id}
                                                                title={`${w.name}${w.opponent ? ` - ${w.opponent}` : ''}${w.opponent && w.isHome !== undefined ? (w.isHome ? ' (H)' : ' (A)') : ''}`}
                                                                icon={w.isLocked ? "Lock" : "Zap"}
                                                                defaultOpen={currentWeekId === w.id}
                                                                nested={true}
                                                                onTitleClick={() => { setCurrentWeekId(w.id); setView('staff-meeting'); setShowManageWeekModal(false); }}
                                                            >
                                                                {renderWeeklyTools(w.id)}
                                                            </CollapsibleCategory>
                                                        ))}
                                                    </CollapsibleCategory>

                                                    {/* Season Setup */}
                                                    {/* Regular Season Phase */}
                                                    <CollapsibleCategory title="SEASON" icon="Trophy" defaultOpen={false} onTitleClick={() => setView('season-setup')}>
                                                        {weeks.filter(w => (w.name.startsWith("Week ") && !w.name.includes("Summer") && w.name !== "Week 0") || w.name === "First Week with No Game")
                                                            .sort((a, b) => {
                                                                const getNum = (item) => {
                                                                    if (item.weekNum !== undefined) return item.weekNum;
                                                                    const match = item.name.match(/Week (\d+)/);
                                                                    return match ? parseInt(match[1]) : 99;
                                                                };
                                                                return getNum(a) - getNum(b);
                                                            })
                                                            .map(w => (
                                                                <CollapsibleCategory
                                                                    key={w.id}
                                                                    title={`${w.name}${w.opponent ? ` - ${w.opponent}` : ''}${w.opponent && w.isHome !== undefined ? (w.isHome ? ' (H)' : ' (A)') : ''}`}
                                                                    icon={w.isLocked ? "Lock" : "Trophy"}
                                                                    defaultOpen={currentWeekId === w.id}
                                                                    nested={true}
                                                                    onTitleClick={() => { setCurrentWeekId(w.id); setView('staff-meeting'); setShowManageWeekModal(false); }}
                                                                >
                                                                    {renderWeeklyTools(w.id)}
                                                                </CollapsibleCategory>
                                                            ))}
                                                    </CollapsibleCategory>
                                                </div>
                                            </div>



                                            {/* GAME WEEK CATEGORY */}
                                            {visibleFeatures.gameWeek?.enabled && (
                                                <CollapsibleCategory title={`${activeYear || 'MASTER'} OFFENSE`} icon="Zap" defaultOpen={false}>
                                                    {visibleFeatures.gameWeek?.items?.offenseSetup && (
                                                        <button className={`nav-item ${view === 'offense-setup' ? 'active' : ''}`} onClick={() => setView('offense-setup')} style={{ paddingLeft: '2rem', width: '100%', textAlign: 'left', border: 'none', background: 'none' }}>
                                                            <Icon name="Settings" size={16} style={{ marginRight: '8px' }} /> Offense Setup
                                                        </button>
                                                    )}
                                                    {visibleFeatures.gameWeek?.items?.playbook && (
                                                        <button className={`nav-item ${view === 'playbook' ? 'active' : ''}`} onClick={() => setView('playbook')} style={{ paddingLeft: '2rem', width: '100%', textAlign: 'left', border: 'none', background: 'none' }}>
                                                            <Icon name="Book" size={16} style={{ marginRight: '8px' }} /> Master Playbook
                                                        </button>
                                                    )}
                                                    {visibleFeatures.gameWeek?.items?.formations && (
                                                        <button className={`nav-item ${view === 'formations-offense' ? 'active' : ''}`} onClick={() => setView('formations-offense')} style={{ paddingLeft: '2rem', width: '100%', textAlign: 'left', border: 'none', background: 'none' }}>
                                                            <Icon name="LayoutGrid" size={16} style={{ marginRight: '8px' }} /> Formations
                                                        </button>
                                                    )}
                                                    {visibleFeatures.gameWeek?.items?.glossary && (
                                                        <button className={`nav-item ${view === 'glossary-offense' ? 'active' : ''}`} onClick={() => setView('glossary-offense')} style={{ paddingLeft: '2rem', width: '100%', textAlign: 'left', border: 'none', background: 'none' }}>
                                                            <Icon name="BookOpen" size={16} style={{ marginRight: '8px' }} /> Glossary
                                                        </button>
                                                    )}
                                                    {visibleFeatures.gameWeek?.items?.drillLibrary && (
                                                        <button className={`nav-item ${view === 'drill-library-offense' ? 'active' : ''}`} onClick={() => setView('drill-library-offense')} style={{ paddingLeft: '2rem', width: '100%', textAlign: 'left', border: 'none', background: 'none' }}>
                                                            <Icon name="List" size={16} style={{ marginRight: '8px' }} /> Drill Library
                                                        </button>
                                                    )}
                                                    <button className={`nav-item ${view === 'self-scout-offense' ? 'active' : ''}`} onClick={() => setView('self-scout-offense')} style={{ paddingLeft: '2rem', width: '100%', textAlign: 'left', border: 'none', background: 'none' }}>
                                                        <Icon name="FileBarChart" size={16} style={{ marginRight: '8px' }} /> Offense Self-Scout
                                                    </button>

                                                </CollapsibleCategory>
                                            )}



                                            {/* DEFENSE CATEGORY */}
                                            {visibleFeatures.gameWeek?.enabled && (
                                                <CollapsibleCategory title={`${activeYear || 'MASTER'} DEFENSE`} icon="Shield" defaultOpen={false}>
                                                    {visibleFeatures.gameWeek?.items?.defenseSetup && (
                                                        <button className={`nav-item ${view === 'defense-setup' ? 'active' : ''}`} onClick={() => setView('defense-setup')} style={{ paddingLeft: '2rem', width: '100%', textAlign: 'left', border: 'none', background: 'none' }}>
                                                            <Icon name="Settings" size={16} style={{ marginRight: '8px' }} /> Defense Setup
                                                        </button>
                                                    )}

                                                    {/* Weekly Depth Charts moved to Week selector above */}

                                                    {visibleFeatures.gameWeek?.items?.formations && (
                                                        <button className={`nav-item ${view === 'formations-defense' ? 'active' : ''}`} onClick={() => setView('formations-defense')} style={{ paddingLeft: '2rem', width: '100%', textAlign: 'left', border: 'none', background: 'none' }}>
                                                            <Icon name="LayoutGrid" size={16} style={{ marginRight: '8px' }} /> Formations
                                                        </button>
                                                    )}
                                                    {visibleFeatures.gameWeek?.items?.glossary && (
                                                        <button className={`nav-item ${view === 'glossary-defense' ? 'active' : ''}`} onClick={() => setView('glossary-defense')} style={{ paddingLeft: '2rem', width: '100%', textAlign: 'left', border: 'none', background: 'none' }}>
                                                            <Icon name="BookOpen" size={16} style={{ marginRight: '8px' }} /> Glossary
                                                        </button>
                                                    )}
                                                    {visibleFeatures.gameWeek?.items?.drillLibrary && (
                                                        <button className={`nav-item ${view === 'drill-library-defense' ? 'active' : ''}`} onClick={() => setView('drill-library-defense')} style={{ paddingLeft: '2rem', width: '100%', textAlign: 'left', border: 'none', background: 'none' }}>
                                                            <Icon name="List" size={16} style={{ marginRight: '8px' }} /> Drill Library
                                                        </button>
                                                    )}
                                                    <button className={`nav-item ${view === 'self-scout-defense' ? 'active' : ''}`} onClick={() => setView('self-scout-defense')} style={{ paddingLeft: '2rem', width: '100%', textAlign: 'left', border: 'none', background: 'none' }}>
                                                        <Icon name="FileBarChart" size={16} style={{ marginRight: '8px' }} /> Defense Self-Scout
                                                    </button>

                                                </CollapsibleCategory>
                                            )}


                                            {/* SPECIAL TEAMS CATEGORY */}
                                            {visibleFeatures.gameWeek?.enabled && (
                                                <CollapsibleCategory title={`${activeYear || 'MASTER'} SPECIAL TEAMS`} icon="Compass" defaultOpen={false}>
                                                    {visibleFeatures.gameWeek?.items?.stSetup && (
                                                        <button className={`nav-item ${view === 'st-setup' ? 'active' : ''}`} onClick={() => setView('st-setup')} style={{ paddingLeft: '2rem', width: '100%', textAlign: 'left', border: 'none', background: 'none' }}>
                                                            <Icon name="Settings" size={16} style={{ marginRight: '8px' }} /> Special Teams Setup
                                                        </button>
                                                    )}

                                                    {/* Weekly Depth Charts moved to Week selector above */}

                                                    {visibleFeatures.gameWeek?.items?.formations && (
                                                        <button className={`nav-item ${view === 'formations-st' ? 'active' : ''}`} onClick={() => setView('formations-st')} style={{ paddingLeft: '2rem', width: '100%', textAlign: 'left', border: 'none', background: 'none' }}>
                                                            <Icon name="LayoutGrid" size={16} style={{ marginRight: '8px' }} /> Formations
                                                        </button>
                                                    )}
                                                    {visibleFeatures.gameWeek?.items?.glossary && (
                                                        <button className={`nav-item ${view === 'glossary-st' ? 'active' : ''}`} onClick={() => setView('glossary-st')} style={{ paddingLeft: '2rem', width: '100%', textAlign: 'left', border: 'none', background: 'none' }}>
                                                            <Icon name="BookOpen" size={16} style={{ marginRight: '8px' }} /> Glossary
                                                        </button>
                                                    )}
                                                    {visibleFeatures.gameWeek?.items?.drillLibrary && (
                                                        <button className={`nav-item ${view === 'drill-library-st' ? 'active' : ''}`} onClick={() => setView('drill-library-st')} style={{ paddingLeft: '2rem', width: '100%', textAlign: 'left', border: 'none', background: 'none' }}>
                                                            <Icon name="List" size={16} style={{ marginRight: '8px' }} /> Drill Library
                                                        </button>
                                                    )}
                                                    <button className={`nav-item ${view === 'self-scout-special-teams' ? 'active' : ''}`} onClick={() => setView('self-scout-special-teams')} style={{ paddingLeft: '2rem', width: '100%', textAlign: 'left', border: 'none', background: 'none' }}>
                                                        <Icon name="FileBarChart" size={16} style={{ marginRight: '8px' }} /> Special Teams Self-Scout
                                                    </button>

                                                </CollapsibleCategory>
                                            )}



                                            {/* PERSONNEL CATEGORY (Moved from top) */}
                                            {currentPermissions.staff.view && (
                                                <CollapsibleCategory title="Personnel" icon="Users" defaultOpen={false}>
                                                    <button className={`nav-item ${view === 'staff-roster' ? 'active' : ''}`} onClick={() => setView('staff-roster')} style={{ paddingLeft: '2rem', width: '100%', textAlign: 'left', border: 'none', background: 'none' }}>
                                                        <Icon name="UserCog" size={16} style={{ marginRight: '8px' }} /> Staff & Roles
                                                    </button>
                                                    {/* Player Profiles moved to top level */}
                                                    <button className={`nav-item ${view === 'roster' ? 'active' : ''}`} onClick={() => setView('roster')} style={{ paddingLeft: '2rem', width: '100%', textAlign: 'left', border: 'none', background: 'none' }}>
                                                        <Icon name="Users" size={16} style={{ marginRight: '8px' }} /> Manage Roster
                                                    </button>
                                                    <button className={`nav-item ${view === 'archive' ? 'active' : ''}`} onClick={() => setView('archive')} style={{ paddingLeft: '2rem', width: '100%', textAlign: 'left', border: 'none', background: 'none' }}>
                                                        <Icon name="Archive" size={16} style={{ marginRight: '8px' }} /> Archive
                                                    </button>

                                                </CollapsibleCategory>
                                            )}





                                            {currentPermissions.dashboard.view && (
                                                <button
                                                    className={`nav-item ${view === 'print-hub' ? 'active' : ''}`}
                                                    onClick={() => setView('print-hub')}
                                                    style={{
                                                        width: '100%',
                                                        textAlign: 'left',
                                                        border: 'none',
                                                        background: 'none',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        justifyContent: sidebarCollapsed ? 'center' : 'flex-start',
                                                        gap: '0.75rem',
                                                        padding: sidebarCollapsed ? '0.75rem 0' : '0.75rem 1rem',
                                                        marginBottom: '0.5rem'
                                                    }}
                                                >
                                                    <Icon name="Printer" size={18} color="var(--accent)" />
                                                    {!sidebarCollapsed && <span style={{ fontWeight: '600' }}>PRINT CENTER</span>}
                                                </button>
                                            )}

                                        </div>
                                    </>
                                )}

                                {/* EQUIPMENT CATEGORY */}


                                <div style={{ marginTop: 'auto', paddingTop: '1rem', borderTop: '1px solid rgba(255,255,255,0.1)', display: 'flex', flexDirection: 'column', gap: '0.25rem' }}>
                                    {(currentUser?.roles?.includes('Head Coach') || currentUser?.roles?.includes('Team Admin')) && (
                                        <button
                                            className={`nav-item ${view === 'settings' ? 'active' : ''}`}
                                            onClick={() => setView('settings')}
                                            style={{ width: '100%', textAlign: 'left', border: 'none', background: 'none', display: 'flex', alignItems: 'center', justifyContent: sidebarCollapsed ? 'center' : 'flex-start', padding: sidebarCollapsed ? '0.75rem 0' : '0.5rem 1rem' }}
                                        >
                                            <Icon name="Settings" size={16} />
                                            {!sidebarCollapsed && <span style={{ marginLeft: '8px' }}>Settings</span>}
                                        </button>
                                    )}
                                    {currentUser && currentUser.roles && currentUser.roles.includes('Head Coach') && (
                                        <button
                                            className={`nav-item ${view === 'permissions' ? 'active' : ''}`}
                                            onClick={() => setView('permissions')}
                                            style={{ width: '100%', textAlign: 'left', border: 'none', background: 'none', display: 'flex', alignItems: 'center', justifyContent: sidebarCollapsed ? 'center' : 'flex-start', padding: sidebarCollapsed ? '0.75rem 0' : '0.5rem 1rem', color: 'var(--text-secondary)' }}
                                        >
                                            <Icon name="Lock" size={16} />
                                            {!sidebarCollapsed && <span style={{ marginLeft: '8px' }}>Permissions</span>}
                                        </button>
                                    )}
                                    <button
                                        className={`nav-item ${view === 'help' ? 'active' : ''}`}
                                        onClick={() => setView('help')}
                                        style={{ width: '100%', textAlign: 'left', border: 'none', background: 'none', display: 'flex', alignItems: 'center', justifyContent: sidebarCollapsed ? 'center' : 'flex-start', padding: sidebarCollapsed ? '0.75rem 0' : '0.5rem 1rem' }}
                                    >
                                        <Icon name="HelpCircle" size={16} />
                                        {!sidebarCollapsed && <span style={{ marginLeft: '8px' }}>How to Use</span>}
                                    </button>
                                    <button
                                        className="nav-item"
                                        onClick={() => setShowLogoutConfirm(true)}
                                        style={{
                                            width: '100%',
                                            textAlign: 'left',
                                            border: 'none',
                                            background: 'none',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: sidebarCollapsed ? 'center' : 'flex-start',
                                            padding: sidebarCollapsed ? '0.75rem 0' : '0.5rem 1rem',
                                            color: 'var(--danger)',
                                            opacity: 0.8
                                        }}
                                        onMouseOver={(e) => e.currentTarget.style.opacity = '1'}
                                        onMouseOut={(e) => e.currentTarget.style.opacity = '0.8'}
                                    >
                                        <Icon name="LogOut" size={16} />
                                        {!sidebarCollapsed && <span style={{ marginLeft: '8px' }}>Log Out</span>}
                                    </button>
                                </div>
                            </nav>
                        </div >

                        <main className="main-content">
                            {view === 'staff-meeting' && (
                                <div style={{ height: '100%', display: 'flex', flexDirection: 'column', gap: '1rem', overflow: 'auto', padding: '1rem' }}>
                                    {/* Header */}
                                    <div className="card" style={{ padding: '2rem', background: 'linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%)', color: 'white' }}>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                                            <h2 style={{ margin: 0, display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                <Icon name="LayoutDashboard" size={28} />
                                                {currentWeek.name} Dashboard
                                            </h2>
                                            <button
                                                className="btn"
                                                onClick={() => setShowManageWeekModal(true)}
                                                style={{ background: 'rgba(255,255,255,0.2)', color: 'white', border: '1px solid rgba(255,255,255,0.4)', display: 'flex', alignItems: 'center', gap: '8px' }}
                                            >
                                                <Icon name="Settings" size={18} />
                                                Manage Week
                                            </button>
                                        </div>
                                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1.5rem' }}>
                                            <div>
                                                <div style={{ fontSize: '0.9rem', opacity: 0.9, marginBottom: '0.5rem' }}>Week</div>
                                                <div style={{ fontSize: '2rem', fontWeight: 'bold' }}>{currentWeek.name}</div>
                                            </div>
                                            {currentWeek.opponent && (
                                                <div>
                                                    <div style={{ fontSize: '0.9rem', opacity: 0.9, marginBottom: '0.5rem' }}>Opponent</div>
                                                    <div style={{ fontSize: '2rem', fontWeight: 'bold' }}>{currentWeek.opponent}</div>
                                                </div>
                                            )}
                                            <div>
                                                <div style={{ fontSize: '0.9rem', opacity: 0.9, marginBottom: '0.5rem' }}>Practice Plans</div>
                                                <div style={{ fontSize: '2rem', fontWeight: 'bold' }}>{currentWeek.practicePlans?.length || 0}</div>
                                            </div>
                                            <div>
                                                <div style={{ fontSize: '0.9rem', opacity: 0.9, marginBottom: '0.5rem' }}>Active Players</div>
                                                <div style={{ fontSize: '2rem', fontWeight: 'bold' }}>{roster.filter(p => p.status === 'Active').length}</div>
                                            </div>
                                        </div>
                                    </div>


                                    {/* Weekly Analytics Dashboard */}
                                    {view === 'staff-meeting' && (
                                        <WeeklyAnalytics
                                            currentWeek={currentWeek}
                                            plays={plays}
                                            practicePlans={currentWeek.practicePlans || {}}
                                        />
                                    )}


                                    {/* Quick Links */}
                                    <div className="card" style={{ padding: '1.5rem' }}>
                                        <h3 style={{ margin: '0 0 1rem 0', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                            <Icon name="Zap" size={20} />
                                            Quick Links
                                        </h3>
                                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '1rem' }}>
                                            <button onClick={() => setView('practice')} className="card" style={{ padding: '1rem', background: 'var(--surface)', border: '1px solid var(--border)', borderRadius: '8px', cursor: 'pointer', textAlign: 'left', transition: 'transform 0.2s' }}>
                                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '0.5rem' }}>
                                                    <Icon name="Megaphone" size={18} style={{ color: 'var(--text-primary)' }} />
                                                    <span style={{ fontWeight: 'bold', color: 'var(--text-primary)', lineHeight: '1' }}>Practice Plans</span>
                                                </div>
                                                <div style={{ fontSize: '0.85rem', color: 'var(--text-secondary)' }}>View and edit practice schedules</div>
                                            </button>
                                            <button onClick={() => setView('install-manager')} className="card" style={{ padding: '1rem', background: 'var(--surface)', border: '1px solid var(--border)', borderRadius: '8px', cursor: 'pointer', textAlign: 'left', transition: 'transform 0.2s' }}>
                                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '0.5rem' }}>
                                                    <Icon name="Layers" size={18} style={{ color: 'var(--text-primary)' }} />
                                                    <span style={{ fontWeight: 'bold', color: 'var(--text-primary)', lineHeight: '1' }}>Install Manager</span>
                                                </div>
                                                <div style={{ fontSize: '0.85rem', color: 'var(--text-secondary)' }}>Manage weekly installations</div>
                                            </button>
                                            <button onClick={() => setView('scouting')} className="card" style={{ padding: '1rem', background: 'var(--surface)', border: '1px solid var(--border)', borderRadius: '8px', cursor: 'pointer', textAlign: 'left', transition: 'transform 0.2s' }}>
                                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '0.5rem' }}>
                                                    <Icon name="Search" size={18} style={{ color: 'var(--text-primary)' }} />
                                                    <span style={{ fontWeight: 'bold', color: 'var(--text-primary)', lineHeight: '1' }}>Scouting</span>
                                                </div>
                                                <div style={{ fontSize: '0.85rem', color: 'var(--text-secondary)' }}>Scout opponent tendencies</div>
                                            </button>
                                            <button onClick={() => { setView('depth'); setDepthChartType('OFFENSE'); }} className="card" style={{ padding: '1rem', background: 'var(--surface)', border: '1px solid var(--border)', borderRadius: '8px', cursor: 'pointer', textAlign: 'left', transition: 'transform 0.2s' }}>
                                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '0.5rem' }}>
                                                    <Icon name="Users" size={18} style={{ color: 'var(--text-primary)' }} />
                                                    <span style={{ fontWeight: 'bold', color: 'var(--text-primary)', lineHeight: '1' }}>Depth Charts</span>
                                                </div>
                                                <div style={{ fontSize: '0.85rem', color: 'var(--text-secondary)' }}>Manage player positions</div>
                                            </button>
                                        </div>
                                    </div>

                                </div>
                            )}
                            {view === 'director-ops' && <DirectorOpsView dutyAssignments={dutyAssignments} staff={staff} currentWeek={currentWeek} currentUser={currentUser} positionFatigue={positionFatigue} setPositionFatigue={setPositionFatigue} />}

                            {view === 'print-hub' && <PrintHubView roster={roster} staff={staff} gamePlans={currentWeek.offensiveGamePlan} depthChart={currentWeek.depthChart || depthChart} practicePlans={currentWeek.practicePlans} attendance={attendance} wbSettings={currentWeek.wristbands || wbSettings} setWbSettings={handleUpdateWristbands} plays={plays} drills={drills} />}
                            {view === 'drill-library-offense' && <DrillLibraryView phase="OFFENSE" drills={drills} onAddDrill={handleAddDrill} />}
                            {view === 'drill-library-defense' && <DrillLibraryView phase="DEFENSE" drills={drills} onAddDrill={handleAddDrill} />}
                            {view === 'drill-library-st' && <DrillLibraryView phase="SPECIAL_TEAMS" drills={drills} onAddDrill={handleAddDrill} />}

                            {view === 'permissions' && <PermissionsView permissions={permissions} onUpdatePermissions={setPermissions} onResetDefaults={() => setPermissions(DEFAULT_PERMISSIONS)} />}


                            {view === 'glossary-offense' && <GlossaryView phase="OFFENSE" />}
                            {view === 'glossary-defense' && <GlossaryView phase="DEFENSE" />}
                            {view === 'glossary-st' && <GlossaryView phase="SPECIAL_TEAMS" />}
                            {view === 'dashboard' && <GamedayDashboard plays={plays} />}

                            {view === 'season-setup' && <SeasonSetupView weeks={weeks} onUpdateWeek={handleUpdateWeek} onAddWeek={handleAddWeek} onDeleteWeek={handleDeleteWeek} mode="season" />}
                            {view === 'pre-season-setup' && <SeasonSetupView weeks={weeks} onUpdateWeek={handleUpdateWeek} onAddWeek={handleAddWeek} onDeleteWeek={handleDeleteWeek} mode="pre-season" />}
                            {view === 'summer-setup' && <SeasonSetupView weeks={weeks} onUpdateWeek={handleUpdateWeek} onAddWeek={handleAddWeek} onDeleteWeek={handleDeleteWeek} mode="summer" />}
                            {/* REMOVED: Budget view (~182 lines) - check git history */}

                            {view === 'culturalCalibration' && (
                                <CulturalCalibration
                                    culturalCalibration={culturalCalibration}
                                    setCulturalCalibration={setCulturalCalibration}
                                    currentPermissions={currentPermissions}
                                    authUser={authUser}
                                />
                            )}

                            {
                                view === 'onboarding' && (
                                    <div style={{ height: '100%', display: 'flex', flexDirection: 'column', gap: '1rem', overflow: 'auto', padding: '1rem' }}>
                                        {/* Header */}
                                        <div className="card" style={{ padding: '2rem', background: 'linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%)', color: 'white' }}>
                                            <h2 style={{ margin: '0 0 1.5rem 0', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                <Icon name="UserPlus" size={28} />
                                                Onboarding Dashboard
                                            </h2>
                                            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))', gap: '1.5rem' }}>
                                                <div>
                                                    <div style={{ fontSize: '0.9rem', opacity: 0.9, marginBottom: '0.5rem' }}>Total People</div>
                                                    <div style={{ fontSize: '2rem', fontWeight: 'bold' }}>{totalPeople}</div>
                                                </div>
                                                <div>
                                                    <div style={{ fontSize: '0.9rem', opacity: 0.9, marginBottom: '0.5rem' }}>Fully Complete</div>
                                                    <div style={{ fontSize: '2rem', fontWeight: 'bold', color: '#86efac' }}>{fullyCompleted}</div>
                                                </div>
                                                <div>
                                                    <div style={{ fontSize: '0.9rem', opacity: 0.9, marginBottom: '0.5rem' }}>In Progress</div>
                                                    <div style={{ fontSize: '2rem', fontWeight: 'bold', color: '#fcd34d' }}>{inProgress}</div>
                                                </div>
                                                <div>
                                                    <div style={{ fontSize: '0.9rem', opacity: 0.9, marginBottom: '0.5rem' }}>Not Started</div>
                                                    <div style={{ fontSize: '2rem', fontWeight: 'bold', color: '#fca5a5' }}>{notStarted}</div>
                                                </div>
                                            </div>
                                        </div>

                                        {/* Filter */}
                                        <div style={{ display: 'flex', gap: '0.5rem', padding: '0.5rem 0' }}>
                                            <span style={{ fontWeight: 'bold', marginRight: '0.5rem' }}>Filter:</span>
                                            {['All', 'Player', 'Coach', 'Manager'].map(role => (
                                                <button key={role} onClick={() => setOnboardingRoleFilter(role)} style={{ padding: '0.5rem 1rem', border: 'none', background: onboardingRoleFilter === role ? 'var(--primary)' : 'var(--surface)', color: onboardingRoleFilter === role ? 'white' : 'var(--text)', borderRadius: '6px', cursor: 'pointer', fontWeight: onboardingRoleFilter === role ? 'bold' : 'normal' }}>
                                                    {role}
                                                </button>
                                            ))}
                                        </div>

                                        {/* People List */}
                                        <div className="card" style={{ padding: '1.5rem' }}>
                                            <h3 style={{ margin: '0 0 1rem 0' }}>People ({filteredPeople.length})</h3>
                                            {filteredPeople.length === 0 ? (
                                                <div style={{ padding: '2rem', textAlign: 'center', color: 'var(--text-secondary)', fontStyle: 'italic' }}>
                                                    No people found. Add players to your roster or staff members to see them here.
                                                </div>
                                            ) : (
                                                <div style={{ display: 'grid', gap: '1rem' }}>
                                                    {filteredPeople.map(person => {
                                                        const stats = getCompletionStats(person);
                                                        const statusColor = stats.percentage === 100 ? '#10b981' : stats.percentage > 0 ? '#f59e0b' : '#6b7280';
                                                        return (
                                                            <div key={person.id} className="card" style={{ padding: '1rem', background: 'var(--surface)', cursor: 'pointer', transition: 'transform 0.2s' }} onClick={() => setOnboardingSelectedPerson(person)}>
                                                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.75rem' }}>
                                                                    <div>
                                                                        <div style={{ fontWeight: 'bold', fontSize: '1.1rem' }}>{person.name}</div>
                                                                        <div style={{ fontSize: '0.9rem', color: 'var(--text-secondary)' }}>{person.role}</div>
                                                                    </div>
                                                                    <div style={{ textAlign: 'right' }}>
                                                                        <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: statusColor }}>{stats.percentage}%</div>
                                                                        <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>{stats.completed}/{stats.total} complete</div>
                                                                    </div>
                                                                </div>
                                                                <div style={{ background: 'var(--background)', borderRadius: '999px', height: '8px', overflow: 'hidden' }}>
                                                                    <div style={{ width: `${stats.percentage}%`, height: '100%', background: statusColor, transition: 'width 0.3s' }}></div>
                                                                </div>
                                                            </div>
                                                        );
                                                    })}
                                                </div>
                                            )}
                                        </div>

                                        {/* Detail Modal */}
                                        {onboardingSelectedPerson && (() => {
                                            const personData = getPersonOnboardingData(onboardingSelectedPerson.id, onboardingSelectedPerson.role);
                                            return (
                                                <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000 }} onClick={() => setOnboardingSelectedPerson(null)}>
                                                    <div className="card" style={{ width: '90%', maxWidth: '600px', maxHeight: '80vh', overflow: 'auto', padding: '2rem', background: 'var(--background)' }} onClick={(e) => e.stopPropagation()}>
                                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                                                            <div>
                                                                <h2 style={{ margin: 0 }}>{onboardingSelectedPerson.name}</h2>
                                                                <div style={{ color: 'var(--text-secondary)' }}>{onboardingSelectedPerson.role}</div>
                                                            </div>
                                                            <button onClick={() => setOnboardingSelectedPerson(null)} style={{ padding: '0.5rem', background: 'var(--surface)', border: 'none', borderRadius: '6px', cursor: 'pointer' }}>
                                                                <Icon name="X" size={20} />
                                                            </button>
                                                        </div>

                                                        <div style={{ marginBottom: '1.5rem' }}>
                                                            <div style={{ fontSize: '2rem', fontWeight: 'bold', color: getCompletionStats(onboardingSelectedPerson).percentage === 100 ? '#10b981' : '#f59e0b' }}>
                                                                {getCompletionStats(onboardingSelectedPerson).percentage}% Complete
                                                            </div>
                                                            <div style={{ fontSize: '0.9rem', color: 'var(--text-secondary)' }}>
                                                                {getCompletionStats(onboardingSelectedPerson).completed} of {getCompletionStats(onboardingSelectedPerson).total} items completed
                                                            </div>
                                                        </div>

                                                        <h3 style={{ marginBottom: '1rem' }}>Onboarding Checklist</h3>
                                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                                                            {getRequiredItems(onboardingSelectedPerson.role).map(itemKey => {
                                                                const item = personData[itemKey] || { completed: false, dateCompleted: null, notes: '' };
                                                                return (
                                                                    <div key={itemKey} className="card" style={{ padding: '1rem', background: item.completed ? 'rgba(16, 185, 129, 0.1)' : 'var(--surface)' }}>
                                                                        <div style={{ display: 'flex', alignItems: 'flex-start', gap: '0.75rem' }}>
                                                                            <input type="checkbox" checked={item.completed} onChange={(e) => updatePersonItem(onboardingSelectedPerson.id, onboardingSelectedPerson.role, itemKey, 'completed', e.target.checked)} style={{ marginTop: '0.25rem', width: '20px', height: '20px', cursor: 'pointer' }} />
                                                                            <div style={{ flex: 1 }}>
                                                                                <div style={{ fontWeight: 'bold', marginBottom: '0.5rem', textDecoration: item.completed ? 'line-through' : 'none' }}>
                                                                                    {getItemLabel(itemKey)}
                                                                                </div>
                                                                                {item.completed && item.dateCompleted && (
                                                                                    <div style={{ fontSize: '0.85rem', color: '#10b981', marginBottom: '0.5rem' }}>
                                                                                        ✓ Completed on {new Date(item.dateCompleted).toLocaleDateString()}
                                                                                    </div>
                                                                                )}
                                                                                <input className="form-input" placeholder="Notes (optional)" value={item.notes} onChange={(e) => updatePersonItem(onboardingSelectedPerson.id, onboardingSelectedPerson.role, itemKey, 'notes', e.target.value)} style={{ fontSize: '0.9rem', marginTop: '0.5rem' }} />
                                                                            </div>
                                                                        </div>
                                                                    </div>
                                                                );
                                                            })}
                                                        </div>

                                                        <div style={{ marginTop: '1.5rem' }}>
                                                            <button className="btn-primary" onClick={() => setOnboardingSelectedPerson(null)} style={{ width: '100%' }}>Close</button>
                                                        </div>
                                                    </div>
                                                </div>
                                            );
                                        })()}
                                    </div>
                                )
                            }



                            {view === 'offense-setup' && renderSetup('OFFENSE')}
                            {view === 'defense-setup' && renderSetup('DEFENSE')}
                            {view === 'st-setup' && renderSetup('SPECIAL_TEAMS')}

                            {
                                view === 'new-play' && (
                                    <PlayInput
                                        onSave={handleSavePlay}
                                        onCancel={() => { setEditingPlay(null); setView('playbook'); }}
                                        onDelete={handleDeletePlay}
                                        initialData={editingPlay}
                                        wizLibrary={wizLibrary}
                                        setWizLibrary={setWizLibrary}
                                        positionNames={positionNames}
                                        formations={formations}
                                        playSyntax={playSyntax}
                                        termLibrary={termLibrary}
                                        programLevels={programLevels}
                                        drills={drills}
                                        playCategories={playCategories}
                                        playBuckets={playBuckets}
                                        onAddFormation={handleAddFormation}
                                    />
                                )
                            }

                            {view === 'install-manager' && <InstallManagerView plays={plays} week={currentWeek} weeks={weeks} currentWeekId={currentWeekId} onUpdateWeek={handleUpdateWeek} gamePlan={currentWeek.offensiveGamePlan} practicePlans={currentWeek.practicePlans} wbSettings={currentWeek.wristbands || wbSettings} drills={drills} onQuickAddPlay={handleQuickAddPlay} playSyntax={playSyntax} onUpdatePlay={handlePatchPlay} gamePlanLayouts={currentWeek.gamePlanLayouts || gamePlanLayouts} defaultWbSettings={getGlobalWbSettings()} defaultDepthChart={getGlobalDepthCharts()} defaultZonePhilosophies={getGlobalZonePhilosophies()} playCategories={playCategories} playBuckets={playBuckets} />}
                            {view === 'practice-report' && <PracticeReportView weeks={weeks} plays={plays} playSyntax={playSyntax} parsePlayName={parsePlayName} />}
                            {view === 'game-plan' && <OffensiveGamePlan
                                plays={plays}
                                weekDate={currentWeek.date}
                                gamePlan={currentWeek.offensiveGamePlan}
                                practicePlans={currentWeek.practicePlans}
                                onUpdateGamePlan={(updated) => handleUpdateWeek(currentWeek.id, 'offensiveGamePlan', updated)}
                                onQuickAddPlay={handleQuickAddPlay}
                                onUpdatePlay={handlePatchPlay}
                                gamePlanLayouts={currentWeek.gamePlanLayouts || gamePlanLayouts}
                                weeks={weeks}
                                currentWeek={currentWeek}
                                onUpdateLayouts={(newLayouts) => {
                                    // Update WEEK specific layout
                                    handleUpdateWeek(currentWeek.id, 'gamePlanLayouts', newLayouts);
                                }}
                                isLocked={currentWeek.isLocked}
                                layoutVersions={layoutVersions}
                                onSaveLayoutVersion={saveLayoutVersion}
                                onDeleteLayoutVersion={deleteLayoutVersion}
                                onLoadLayoutVersion={loadLayoutVersion}
                                wbSettings={currentWeek.wristbands || wbSettings}
                                drills={drills}
                                newInstallIds={currentWeek.newInstallIds}
                                onUpdateWeek={handleUpdateWeek}
                                playCategories={playCategories}
                                playBuckets={playBuckets}
                                setAppSidebarCollapsed={setSidebarCollapsed}
                                appSidebarCollapsed={sidebarCollapsed}
                            />}

                            {
                                view === 'playbook' && (
                                    <div>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                            <h2>Master Playbook ({filteredPlaybook.length} / {plays.length})</h2>
                                            <div style={{ display: 'flex', gap: '1rem' }}>
                                                {selectedPlays.length > 0 && (
                                                    <button className="btn" style={{ backgroundColor: '#ef4444', color: 'white' }} onClick={handleDeleteSelected}>
                                                        <Icon name="Trash2" /> Delete Selected ({selectedPlays.length})
                                                    </button>
                                                )}
                                                <button className="btn" style={{ backgroundColor: '#10b981', color: 'white' }} onClick={() => setIsBatchImportOpen(true)}>
                                                    <Icon name="FileText" /> Batch Add Plays
                                                </button>
                                                <button className="btn btn-primary" onClick={() => { setEditingPlay(null); setView('new-play'); }}>
                                                    <Icon name="PlusCircle" /> New Play
                                                </button>
                                            </div>
                                        </div>

                                        <div style={{
                                            marginBottom: '2rem',
                                            padding: '1.5rem',
                                            background: 'var(--bg-panel)',
                                            border: '1px solid var(--border)',
                                            borderRadius: '12px'
                                        }}>
                                            <div style={{
                                                display: 'flex',
                                                justifyContent: 'space-between',
                                                alignItems: 'center',
                                                marginBottom: '1.25rem',
                                                paddingBottom: '0.75rem',
                                                borderBottom: '1px solid var(--border)'
                                            }}>
                                                <h4 style={{
                                                    margin: 0,
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    gap: '0.5rem',
                                                    fontSize: '0.85rem',
                                                    fontWeight: 'bold',
                                                    textTransform: 'uppercase',
                                                    letterSpacing: '0.05em',
                                                    color: 'var(--text-secondary)'
                                                }}>
                                                    <Icon name="Filter" size={14} style={{ color: 'var(--accent)' }} />
                                                    Search & Filter Playbook
                                                </h4>
                                                <div style={{ display: 'flex', gap: '0.75rem' }}>
                                                    {selectedPlays.length > 0 && (
                                                        <button
                                                            className="btn"
                                                            style={{
                                                                fontSize: '0.8rem',
                                                                padding: '0.4rem 0.8rem',
                                                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                                                color: '#ef4444',
                                                                border: '1px solid rgba(239, 68, 68, 0.2)'
                                                            }}
                                                            onClick={() => setSelectedPlays([])}
                                                        >
                                                            Clear Selection ({selectedPlays.length})
                                                        </button>
                                                    )}
                                                    <button
                                                        className="btn"
                                                        style={{
                                                            fontSize: '0.8rem',
                                                            padding: '0.4rem 0.8rem',
                                                            color: 'var(--accent)',
                                                            background: 'rgba(var(--accent-rgb), 0.1)',
                                                            border: '1px solid rgba(var(--accent-rgb), 0.2)'
                                                        }}
                                                        onClick={() => setPlaybookFilters({ formation: '', playCategory: '', bucketId: '', situation: '', tag: '' })}
                                                    >
                                                        <Icon name="FilterX" size={14} style={{ marginRight: '4px' }} />
                                                        Clear Filters
                                                    </button>
                                                </div>
                                            </div>

                                            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1.25rem' }}>
                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                                    <label style={{ fontSize: '0.75rem', fontWeight: 'bold', color: 'var(--text-secondary)', textTransform: 'uppercase' }}>Search Plays</label>
                                                    <div style={{ position: 'relative' }}>
                                                        <Icon name="Search" size={14} style={{ position: 'absolute', left: '0.75rem', top: '50%', transform: 'translateY(-50%)', color: 'var(--text-muted)' }} />
                                                        <input
                                                            className="form-input"
                                                            placeholder="Name or formation..."
                                                            value={searchTerm}
                                                            onChange={e => setSearchTerm(e.target.value)}
                                                            style={{ paddingLeft: '2.25rem', width: '100%' }}
                                                        />
                                                    </div>
                                                </div>

                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                                    <label style={{ fontSize: '0.75rem', fontWeight: 'bold', color: 'var(--text-secondary)', textTransform: 'uppercase' }}>Formation</label>
                                                    <select
                                                        className="form-input"
                                                        value={playbookFilters.formation}
                                                        onChange={e => setPlaybookFilters({ ...playbookFilters, formation: e.target.value })}
                                                    >
                                                        <option value="">All Formations</option>
                                                        {Array.from(new Set(plays.map(p => p.formation).filter(Boolean))).sort().map(f => (
                                                            <option key={f} value={f}>{f}</option>
                                                        ))}
                                                    </select>
                                                </div>

                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                                    <label style={{ fontSize: '0.75rem', fontWeight: 'bold', color: 'var(--text-secondary)', textTransform: 'uppercase' }}>Play Bucket</label>
                                                    <select
                                                        className="form-input"
                                                        value={playbookFilters.playCategory}
                                                        onChange={e => setPlaybookFilters({ ...playbookFilters, playCategory: e.target.value })}
                                                    >
                                                        <option value="">All Buckets</option>
                                                        {playCategories.map(cat => (
                                                            <option key={cat.id} value={cat.id}>{cat.label}</option>
                                                        ))}
                                                    </select>
                                                </div>

                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                                    <label style={{ fontSize: '0.75rem', fontWeight: 'bold', color: 'var(--text-secondary)', textTransform: 'uppercase' }}>Play Family</label>
                                                    <select
                                                        className="form-input"
                                                        value={playbookFilters.bucketId}
                                                        onChange={e => setPlaybookFilters({ ...playbookFilters, bucketId: e.target.value })}
                                                    >
                                                        <option value="">All Families</option>
                                                        {playBuckets
                                                            .filter(bucket => !playbookFilters.playCategory || bucket.categoryId === playbookFilters.playCategory)
                                                            .map(bucket => (
                                                                <option key={bucket.id} value={bucket.id}>{bucket.label}</option>
                                                            ))}
                                                    </select>
                                                </div>

                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                                    <label style={{ fontSize: '0.75rem', fontWeight: 'bold', color: 'var(--text-secondary)', textTransform: 'uppercase' }}>Situation</label>
                                                    <select
                                                        className="form-input"
                                                        value={playbookFilters.situation}
                                                        onChange={e => setPlaybookFilters({ ...playbookFilters, situation: e.target.value })}
                                                    >
                                                        <option value="">All Situations</option>
                                                        {Object.keys(TAG_CATEGORIES).filter(cat => ["Situation", "Field Position", "Down & Distance"].includes(cat)).map(cat => (
                                                            <optgroup key={cat} label={cat}>
                                                                {TAG_CATEGORIES[cat].map(tag => (
                                                                    <option key={tag} value={tag}>{tag}</option>
                                                                ))}
                                                            </optgroup>
                                                        ))}
                                                    </select>
                                                </div>

                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                                    <label style={{ fontSize: '0.75rem', fontWeight: 'bold', color: 'var(--text-secondary)', textTransform: 'uppercase' }}>Tag</label>
                                                    <select
                                                        className="form-input"
                                                        value={playbookFilters.tag}
                                                        onChange={e => setPlaybookFilters({ ...playbookFilters, tag: e.target.value })}
                                                    >
                                                        <option value="">All Tags</option>
                                                        {allTags.map(t => (
                                                            <option key={t} value={t}>{t}</option>
                                                        ))}
                                                    </select>
                                                </div>
                                            </div>
                                        </div>

                                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(280px, 1fr))', gap: '1rem' }}>
                                            {filteredPlaybook.map(play => (
                                                <PlayCard
                                                    key={play.id}
                                                    play={play}
                                                    isSelected={selectedPlays.includes(play.id)}
                                                    onToggleSelect={(playId, e) => togglePlaySelection(playId, e?.shiftKey)}
                                                    onEdit={() => { setEditingPlay(play); setView('new-play'); }}
                                                    onQuickEdit={(play, x, y) => setQuickEditModalState({ playId: play.id, x, y })}
                                                />
                                            ))}
                                        </div>
                                        {quickEditModalState && (() => {
                                            const { playId, x, y } = quickEditModalState;
                                            const play = filteredPlaybook.find(p => p.id === playId);
                                            return (
                                                <PlayDetailsModal
                                                    play={play}
                                                    plays={plays}
                                                    gamePlanLayouts={gamePlanLayouts}
                                                    gamePlan={currentWeek?.offensiveGamePlan}
                                                    week={currentWeek}
                                                    onUpdatePlay={handleUpdatePlay}
                                                    onUpdateWeek={handleUpdateWeek}
                                                    onClose={() => setQuickEditModalState(null)}
                                                    position={{ x, y }}
                                                    playCategories={playCategories}
                                                />
                                            );
                                        })()}

                                    </div>
                                )
                            }





                            {view === 'formations-defense' && <div>Formation Management (Coming Soon)</div>}
                            {view === 'roster' && <RosterManager roster={roster} onUpdateRoster={setRoster} depthChart={depthChart} />}

                            {view === 'staff-roster' && <StaffManager view="roster" currentUser={currentUser} staff={staff} onUpdateStaff={setStaff} dutyAssignments={dutyAssignments} onUpdateDuties={setDutyAssignments} teamLogo={teamLogo} />}

                            {view === 'archive' && <ArchiveManager roster={roster} staff={staff} onUpdateRoster={setRoster} onUpdateStaff={setStaff} />}
                            {view === 'depth' && (
                                <div className="depth-view-container" style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                                    {/* Hide top bar when printing all */}
                                    {!isViewingAll && (
                                        <div style={{
                                            display: 'flex',
                                            gap: '0.5rem',
                                            padding: '1rem',
                                            background: 'var(--surface)',
                                            borderBottom: '1px solid var(--border)',
                                            alignItems: 'center',
                                            overflowX: 'auto'
                                        }}>
                                            {DEPTH_CHART_TYPES.map(tab => (
                                                <button
                                                    key={tab.id}
                                                    onClick={() => setDepthChartType(tab.id)}
                                                    className={`btn ${depthChartType === tab.id ? 'btn-primary' : 'btn-secondary'}`}
                                                    style={{
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        gap: '0.5rem',
                                                        whiteSpace: 'nowrap',
                                                        minWidth: '100px'
                                                    }}
                                                >
                                                    {tab.label}
                                                </button>
                                            ))}
                                            <div style={{ flex: 1 }} />
                                            <button
                                                className="btn btn-secondary"
                                                onClick={() => window.print()}
                                                style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', fontWeight: 'bold' }}
                                            >
                                                <Icon name="Printer" size={16} /> Print
                                            </button>
                                            <button
                                                className="btn btn-secondary"
                                                onClick={() => setIsViewingAll(true)}
                                                style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', fontWeight: 'bold' }}
                                            >
                                                <Icon name="Eye" size={16} /> See All
                                            </button>
                                        </div>
                                    )}

                                    <div className="depth-content-wrapper" style={{ flex: 1, overflow: isViewingAll ? 'visible' : 'auto' }}>
                                        {isViewingAll ? (
                                            // CONSOLIDATED VIEW WITH CHECKBOXES
                                            <div style={{ padding: '2rem' }}>
                                                {/* Header and Controls */}
                                                <div style={{ marginBottom: '2rem', borderBottom: '2px solid var(--border)', paddingBottom: '1rem' }}>
                                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                                        <h2 style={{ margin: 0 }}>Depth Charts - All Units</h2>
                                                        <div style={{ display: 'flex', gap: '1rem' }}>
                                                            <button
                                                                className="btn btn-secondary"
                                                                onClick={() => setIsViewingAll(false)}
                                                                style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}
                                                            >
                                                                <Icon name="ArrowLeft" size={16} /> Back
                                                            </button>
                                                            <button
                                                                className="btn btn-primary"
                                                                onClick={() => window.print()}
                                                                style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}
                                                            >
                                                                <Icon name="Printer" size={16} /> Print Selected
                                                            </button>
                                                        </div>
                                                    </div>

                                                    {/* Checkboxes */}
                                                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: '1rem' }}>
                                                        {DEPTH_CHART_TYPES.map(chartTypeObj => (
                                                            <label key={chartTypeObj.id} style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', cursor: 'pointer' }}>
                                                                <input
                                                                    type="checkbox"
                                                                    checked={selectedCharts.includes(chartTypeObj.id)}
                                                                    onChange={(e) => {
                                                                        if (e.target.checked) {
                                                                            setSelectedCharts([...selectedCharts, chartTypeObj.id]);
                                                                        } else {
                                                                            setSelectedCharts(selectedCharts.filter(id => id !== chartTypeObj.id));
                                                                        }
                                                                    }}
                                                                    style={{ width: '18px', height: '18px', cursor: 'pointer' }}
                                                                />
                                                                <span style={{ fontWeight: '500' }}>{chartTypeObj.label}</span>
                                                            </label>
                                                        ))}
                                                    </div>
                                                </div>

                                                {/* Render Selected Charts */}
                                                <div>
                                                    {DEPTH_CHART_TYPES.filter(ct => selectedCharts.includes(ct.id)).map((chartTypeObj, index) => (
                                                        <div
                                                            key={chartTypeObj.id}
                                                            className="depth-chart-print-section"
                                                            style={{
                                                                pageBreakAfter: 'always',
                                                                marginBottom: '2rem',
                                                                display: selectedCharts.includes(chartTypeObj.id) ? 'block' : 'none'
                                                            }}
                                                        >
                                                            <DepthChart
                                                                roster={roster}
                                                                depthChart={(currentWeek.depthChart && currentWeek.depthChart[chartTypeObj.id]) || {}}
                                                                onUpdateDepthChart={(updated) => handleUpdateDepthChart(prev => ({ ...prev, [chartTypeObj.id]: updated }))}
                                                                chartType={chartTypeObj.id}
                                                                positionNames={positionNames}
                                                                customPositions={customPositions}
                                                                hiddenPositions={hiddenPositions}
                                                                savedLayout={depthChartLayouts[chartTypeObj.id] || {}}
                                                                onUpdateLayout={(id, x, y) => handleUpdateDepthLayout(chartTypeObj.id, id, x, y)}
                                                                onResetLayout={() => handleResetDepthLayout(chartTypeObj.id)}
                                                                forcePrintView={true}
                                                            />
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        ) : (
                                            // RENDER SINGLE DEPTH CHART
                                            <DepthChart
                                                roster={roster}
                                                depthChart={(currentWeek.depthChart && currentWeek.depthChart[depthChartType]) || {}}
                                                onUpdateDepthChart={(updated) => handleUpdateDepthChart(prev => ({ ...prev, [depthChartType]: updated }))}
                                                chartType={depthChartType}
                                                positionNames={positionNames}
                                                customPositions={customPositions}
                                                hiddenPositions={hiddenPositions}
                                                savedLayout={depthChartLayouts[depthChartType] || {}}
                                                onUpdateLayout={(id, x, y) => handleUpdateDepthLayout(depthChartType, id, x, y)}
                                                onResetLayout={() => handleResetDepthLayout(depthChartType)}
                                            />
                                        )}
                                    </div>
                                </div>
                            )}
                            {view === 'wristband' && <WristbandBuilder plays={plays} weeks={weeks} currentWeek={currentWeek} gamePlan={currentWeek.offensiveGamePlan} onUpdatePlay={handlePatchPlay} onUpdateWeek={handleUpdateWeek} wbSettings={currentWeek.wristbands || {}} setWbSettings={handleUpdateWristbands} onNavigate={setView} installList={currentWeek?.installList || []} seasonOpponent={currentWeek.opponent} playCategories={playCategories} onQuickAddPlay={handleQuickAddPlay} />}


                            {
                                view === 'settings' && (
                                    <Settings
                                        teamLogo={teamLogo}
                                        onUpdateLogo={setTeamLogo}
                                        accentColor={accentColor}
                                        onUpdateAccentColor={handleUpdateAccentColor}
                                        theme={theme}
                                        onUpdateTheme={setTheme}
                                        positionNames={positionNames}
                                        onUpdatePositionNames={setPositionNames}
                                        activeYear={activeYear}
                                        onUpdateActiveYear={setActiveYear}
                                        visibleFeatures={visibleFeatures}
                                        onUpdateVisibleFeatures={setVisibleFeatures}
                                        isAdmin={isSiteAdmin}
                                        siteAdmins={siteAdmins}
                                        schoolData={{ id: localStorage.getItem('hc_school_id') }}
                                        currentSchoolId={localStorage.getItem('hc_school_id')}
                                        programLevels={programLevels}
                                        onUpdateProgramLevels={setProgramLevels}
                                    />
                                )
                            }

                            {view === 'pressbox' && <Pressbox plays={plays} gameLog={gameLog} onUpdateGameLog={handleUpdateGameLog} currentWeek={currentWeek} teamLogo={teamLogo} opponentLogo={currentWeek.opponentData?.logo || ''} gameStart={currentWeek.gameStart || {}} situation={currentWeek.situation} onUpdateSituation={handleUpdateSituation} formations={formations} activePlay={activePlay} onUpdateActivePlay={setActivePlay} />}


                            {view === 'player-app' && <PlayerApp roster={roster} attendance={attendance} setAttendance={setAttendance} getPlayerWeightLogs={getPlayerWeightLogs} addWeightLog={addWeightLog} dailyConnections={dailyConnections} setDailyConnections={setDailyConnections} currentWeek={currentWeek} culturalCalibration={culturalCalibration} depthCharts={depthCharts} positionNames={positionNames} />}
                            {view === 'attendance-app' && <MobileAttendanceApp roster={roster} attendance={attendance} setAttendance={setAttendance} />}
                            {view === 'practice' && (
                                <PracticeScriptBuilder
                                    mode="plan"
                                    plays={plays}
                                    plans={currentWeek.practicePlans || {}}
                                    onUpdatePlans={(updated) => handleUpdateWeek(currentWeek.id, 'practicePlans', updated)}
                                    onUpdateGamePlan={(updated) => handleUpdateWeek(currentWeek.id, 'offensiveGamePlan', updated)}
                                    onUpdatePlay={handlePatchPlay}
                                    staff={staff}
                                    addCustomFocusItem={addCustomFocusItem}
                                    user={currentUser}
                                    isLocked={currentWeek.isLocked}
                                    isSiteAdmin={false}
                                    segmentTypes={getAllSegments()}
                                    focusItems={getAllFocusItems()}
                                    segmentTypesMap={practiceSegmentTypes}
                                    focusItemsMap={practiceFocusItems}
                                    segmentSettings={practiceSegmentSettings}
                                    scriptPresets={scriptPresets}
                                    gamePlan={currentWeek.offensiveGamePlan}
                                    gamePlanLayouts={(currentWeek.gamePlanLayouts && currentWeek.gamePlanLayouts.CALL_SHEET) ? currentWeek.gamePlanLayouts : GAME_PLAN_LAYOUTS}
                                    playBuckets={playBuckets}
                                    playCategories={playCategories}
                                    setAppSidebarCollapsed={setSidebarCollapsed}
                                    appSidebarCollapsed={sidebarCollapsed}
                                    closeSideMenuRef={closeSideMenuRef}
                                    roster={roster}
                                    drills={drills}
                                    teamLogo={teamLogo}
                                    currentWeek={currentWeek}
                                    onQuickAddPlay={handleQuickAddPlay}
                                />
                            )}
                            {view === 'pregame' && (
                                <PregameTimeline
                                    plan={currentWeek.pregamePlan || { kickoffTime: '19:00', segments: [] }}
                                    onUpdatePlan={(updated) => handleUpdateWeek(currentWeek.id, 'pregamePlan', updated)}
                                    teamLogo={teamLogo}
                                    staff={staff}
                                    user={currentUser}
                                    isLocked={currentWeek.isLocked}
                                />
                            )}
                            {view === 'game-week-overview' && (
                                <GameWeekOverview
                                    week={currentWeek}
                                    onUpdateWeek={handleUpdateWeek}
                                    teamLogo={teamLogo}
                                    weeks={this.state.weeks}
                                    isLocked={currentWeek.isLocked}
                                />
                            )}
                            {view === 'practice-scripts' && (
                                <PracticeScriptBuilder
                                    mode="script"
                                    plays={plays}
                                    plans={currentWeek.practicePlans || {}}
                                    onUpdatePlans={(updated) => handleUpdateWeek(currentWeek.id, 'practicePlans', updated)}
                                    onUpdateGamePlan={(updated) => handleUpdateWeek(currentWeek.id, 'offensiveGamePlan', updated)}
                                    onUpdatePlay={handlePatchPlay}
                                    staff={staff}
                                    addCustomFocusItem={addCustomFocusItem}
                                    user={currentUser}
                                    isLocked={currentWeek.isLocked}
                                    isSiteAdmin={false}
                                    segmentTypes={getAllSegments()}
                                    focusItems={getAllFocusItems()}
                                    segmentSettings={practiceSegmentSettings}
                                    scriptPresets={scriptPresets}
                                    gamePlan={currentWeek.offensiveGamePlan}
                                    gamePlanLayouts={(currentWeek.gamePlanLayouts && currentWeek.gamePlanLayouts.CALL_SHEET) ? currentWeek.gamePlanLayouts : GAME_PLAN_LAYOUTS}
                                    onQuickAddPlay={handleQuickAddPlay}
                                    playBuckets={playBuckets}
                                    playCategories={playCategories}
                                    setAppSidebarCollapsed={setSidebarCollapsed}
                                    appSidebarCollapsed={sidebarCollapsed}
                                    closeSideMenuRef={closeSideMenuRef}
                                    roster={roster}
                                    drills={drills}
                                    teamLogo={teamLogo}
                                    currentWeek={currentWeek}
                                />
                            )}
                            {view === 'coach-app' && <PracticeCoachApp roster={roster} plans={currentWeek.practicePlans || {}} plays={plays} drills={drills} weeks={weeks} currentWeek={currentWeek} />}

                            {view === 'smart-call-sheet' && <SmartCallSheet gamePlan={currentWeek.offensiveGamePlan} situation={currentWeek.situation} playSyntax={playSyntax} formations={formations} positionNames={positionNames} zonePhilosophies={currentWeek.zonePhilosophies || {}} onUpdatePhilosophy={handleUpdateZonePhilosophies} onUpdateGamePlan={handleUpdateGamePlan} weeks={weeks} currentWeek={currentWeek} practicePlans={currentWeek.practicePlans || {}} />}
                            {/* Legacy DumbCallSheet removed from here */}
                            {view === 'play-call-simulator' && <PlayCallSimulator plays={plays} gamePlan={currentWeek.offensiveGamePlan} />}
                            {view === 'special-teams-setup' && renderSetup('SPECIAL_TEAMS')}
                            {view === 'formations-offense' && <FormationManager formations={formations} onAddFormation={handleAddFormation} onUpdateFormation={handleUpdateFormation} onDeleteFormation={handleDeleteFormation} formationLayouts={formationLayouts} onUpdateFormationLayout={(chartType, posId, x, y) => updateFormationLayout(chartType, posId, x, y)} onResetLayout={(chartType, formation) => resetFormationLayout(chartType, formation)} positionNames={positionNames} phase="OFFENSE" />}
                            {view === 'formations-defense' && <FormationManager formations={formations} onAddFormation={handleAddFormation} onUpdateFormation={handleUpdateFormation} onDeleteFormation={handleDeleteFormation} formationLayouts={formationLayouts} onUpdateFormationLayout={(chartType, posId, x, y) => updateFormationLayout(chartType, posId, x, y)} onResetLayout={(chartType, formation) => resetFormationLayout(chartType, formation)} positionNames={positionNames} phase="DEFENSE" />}
                            {view === 'formations-st' && <FormationManager formations={formations} onAddFormation={handleAddFormation} onUpdateFormation={handleUpdateFormation} onDeleteFormation={handleDeleteFormation} formationLayouts={formationLayouts} onUpdateFormationLayout={(chartType, posId, x, y) => updateFormationLayout(chartType, posId, x, y)} onResetLayout={(chartType, formation) => resetFormationLayout(chartType, formation)} positionNames={positionNames} phase="SPECIAL TEAMS" />}
                            {view === 'opponent-scouting' && <OpponentScouting opponentData={currentWeek.opponentData || {}} onUpdateOpponentData={(data) => {
                                const updatedWeeks = weeks.map(w =>
                                    w.id === currentWeek.id ? { ...w, opponentData: data } : w
                                );
                                setWeeks(updatedWeeks);
                            }} />}

                            {/* Duplicate settings block removed */}

                            {view === 'help' && <UserGuide />}
                            {view === 'self-scout-offense' && <SelfScoutAnalytics phase="Offense" />}
                            {view === 'self-scout-defense' && <SelfScoutAnalytics phase="Defense" />}
                            {view === 'self-scout-special-teams' && <SelfScoutAnalytics phase="Special Teams" />}



                            {
                                showLogoutConfirm && (
                                    <div style={{
                                        position: 'fixed',
                                        top: 0,
                                        left: 0,
                                        right: 0,
                                        bottom: 0,
                                        background: 'rgba(0, 0, 0, 0.7)',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        zIndex: 10000
                                    }}>
                                        <div style={{
                                            background: 'white',
                                            padding: '2rem',
                                            borderRadius: '8px',
                                            maxWidth: '400px',
                                            width: '90%',
                                            boxShadow: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',
                                            border: '1px solid rgba(0,0,0,0.1)'
                                        }}>
                                            <h3 style={{ marginTop: 0, color: '#111827', marginBottom: '1rem', fontSize: '1.25rem' }}>Log Out?</h3>
                                            <p style={{ color: 'var(--text-secondary)', marginBottom: '1.5rem', lineHeight: '1.5' }}>
                                                Are you sure you want to sign out?
                                            </p>
                                            <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '1rem' }}>
                                                <button
                                                    onClick={() => setShowLogoutConfirm(false)}
                                                    style={{
                                                        padding: '0.75rem 1.5rem',
                                                        borderRadius: '6px',
                                                        border: '1px solid #e2e8f0',
                                                        background: 'white',
                                                        color: 'var(--text-secondary)',
                                                        fontWeight: '600',
                                                        cursor: 'pointer'
                                                    }}
                                                >
                                                    Cancel
                                                </button>
                                                <button
                                                    onClick={() => {
                                                        setShowLogoutConfirm(false);
                                                        logout();
                                                    }}
                                                    style={{
                                                        padding: '0.75rem 1.5rem',
                                                        borderRadius: '6px',
                                                        border: 'none',
                                                        ound: '#ef4444',
                                                        color: 'white',
                                                        fontWeight: '600',
                                                        cursor: 'pointer',
                                                        boxShadow: '0 4px 6px -1px rgba(239, 68, 68, 0.4)'
                                                    }}
                                                >
                                                    Log Out
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                )
                            }

                            {/* Invite Acceptance Modal */}
                            {
                                inviteData && (
                                    <div style={{
                                        position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
                                        background: 'rgba(0,0,0,0.85)', zIndex: 10001,
                                        display: 'flex', justifyContent: 'center', alignItems: 'center'
                                    }}>
                                        <div className="card" style={{ maxWidth: '400px', width: '90%', textAlign: 'center', padding: '2rem', border: '1px solid var(--border)', background: 'var(--bg-panel)', borderRadius: 'var(--radius)' }}>
                                            <div style={{ fontSize: '3rem', marginBottom: '1rem' }}>
                                                {inviteData.type === 'domain_match' ? '🏫' : '📩'}
                                            </div>
                                            <h2 style={{ marginBottom: '0.5rem' }}>
                                                {inviteData.type === 'domain_match' ? 'Join Your Team?' : "You're Invited!"}
                                            </h2>
                                            <p style={{ color: 'var(--text-secondary)', marginBottom: '1.5rem' }}>
                                                {inviteData.type === 'domain_match'
                                                    ? <span>Your email matches <strong>{inviteData.schoolName}</strong>. Join as a <strong>{inviteData.role}</strong>?</span>
                                                    : <span>To join <strong>{inviteData.schoolName}</strong> as a <strong>{inviteData.role}</strong>.</span>
                                                }                          </p>
                                            <button
                                                className="btn btn-primary"
                                                style={{ width: '100%', padding: '', e: '1.1rem', marginBottom: '0.5rem' }}
                                                onClick={handleAcceptInvite}
                                            >
                                                Accept & Join Team
                                            </button>
                                            <button
                                                className="btn btn-secondary"
                                                yle={{ width: '100%', padding: '0.75rem', fontSize: '0.9rem', background: 'transparent', border: 'none', textDecoration: 'underline' }}
                                                onClick={() => {
                                                    if (confirm("Are you sure you want to ignore the existing team and create a new school instead?")) {
                                                        setInviteData(null);
                                                        setSchoolSetupData({ showWizard: true, schoolId: `SCH_${Date.now()}` });
                                                    }
                                                }}
                                            >
                                                No, Create New School
                                            </button>
                                        </div>
                                    </div>
                                )
                            }
                        </main >
                        {/* Global Modals */}
                        <ManageWeekModal
                            isOpen={showManageWeekModal}
                            onClose={() => setShowManageWeekModal(false)}
                            currentWeek={currentWeek}
                            weeks={weeks}
                            onUpdateWeek={handleUpdateWeek}
                        />

                        {/* Play Details Modal (Root-Level for PlayChip right-click) */}
                        {playDetailsModalState.isOpen && (
                            <PlayDetailsModal
                                playId={playDetailsModalState.playId}
                                plays={plays}
                                gamePlanLayouts={gamePlanLayouts}
                                onUpdatePlay={handleUpdatePlay}
                                playBuckets={playBuckets}
                                playCategories={playCategories}
                                currentWeek={currentWeek}
                                onClose={closePlayDetails}
                            />
                        )}
                    </div>
                </PlayDetailsModalContext.Provider>
            );
        };
        class ErrorBoundary extends React.Component {
            constructor(props) {
                super(props);
                this.state = { hasError: false, error: null, errorInfo: null };
            }
            static getDerivedStateFromError(error) {
                return { hasError: true };
            }

            componentDidCatch(error, errorInfo) {
                this.setState({ error, errorInfo });
                console.error("Caught error:", error, errorInfo);
            }


            render() {
                if (this.state.hasError) {
                    return (
                        <div style={{ padding: '2rem', color: '#ef4444', background: '#1e293b', height: '100vh' }}>
                            <h2>Something went wrong.</h2>
                            <details style={{ whiteSpace: 'pre-wrap' }}>
                                {this.state.error && this.state.error.toString()}
                                <br />
                                {this.state.errorInfo && this.state.errorInfo.componentStack}
                            </details>
                        </div>
                    );
                }
                return this.props.children;
            }
        }

        ReactDOM.render(
            <ErrorBoundary>
                <AuthProvider>
                    <App />
                </AuthProvider>
            </ErrorBoundary>,
            document.getElementById('root')
        );
    </script>
</body>

</html>