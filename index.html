<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <script>
        window.onerror = function (msg, url, line, col, error) {
            alert("CRITICAL ERROR:\n" + msg + "\nLine: " + line + ":" + col + "\n" + (error ? error.stack : ""));
            return false;
        };
        window.addEventListener('unhandledrejection', function (event) {
            alert("UNHANDLED PROMISE:\n" + event.reason);
        });
    </script>
    <title>DoFO</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="stylesheet" href="style.css">
    <!-- React & ReactDOM (Development Version for better errors, switch to Production for speed) -->
    <script crossorigin="anonymous" src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script crossorigin="anonymous" src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>

    <!-- Babel Standalone -->
    <script crossorigin="anonymous" src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Tailwind CSS -->
    <script crossorigin="anonymous" src="https://cdn.tailwindcss.com"></script>

    <!-- Firebase SDK (v8.10.1 compat) -->
    <script crossorigin="anonymous" src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script crossorigin="anonymous" src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script crossorigin="anonymous" src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script crossorigin="anonymous" src="https://www.gstatic.com/firebasejs/8.10.1/firebase-storage.js"></script>

    <!-- Lucide Icons -->
    <script crossorigin="anonymous" src="https://unpkg.com/lucide@0.303.0"></script>

    <!-- PropTypes (Required for Recharts UMD) -->
    <script crossorigin="anonymous" src="https://unpkg.com/prop-types@15.8.1/prop-types.min.js"></script>

    <!-- Recharts -->
    <script crossorigin="anonymous" src="https://unpkg.com/recharts@2.12.3/umd/Recharts.js"></script>

    <!-- Framer Motion (via Unpkg) -->
    <script crossorigin="anonymous" src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>

    <!-- SortableJS -->
    <script crossorigin="anonymous"
        src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <!-- Classnames (Dependency for React-SortableJS) -->
    <script crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/classnames/2.3.2/index.min.js"></script>

    <!-- React SortableJS Shim (Fix for "require is not defined") -->
    <script>
        window.require = function (name) {
            if (name === 'react') return window.React;
            if (name === 'prop-types') return window.PropTypes;
            if (name === 'sortablejs') return window.Sortable;
            if (name === 'classnames') return window.classNames;
            if (name === 'tiny-invariant') return function (condition, message) { if (!condition) console.error("Invariant failed:", message); };
            return {};
        };
        window.module = { exports: {} };
        window.exports = window.module.exports;
    </script>
    <script crossorigin="anonymous"
        src="https://cdn.jsdelivr.net/npm/react-sortablejs@6.1.4/dist/index.min.js"></script>
    <script>
        if (window.module && window.module.exports && window.module.exports.ReactSortable) {
            window.ReactSortable = window.module.exports.ReactSortable;
            console.log("ReactSortable loaded successfully via Shim");
        } else {
            console.error("Failed to load ReactSortable via Shim");
        }
        // Cleanup global pollution
        delete window.require;
        delete window.module;
        delete window.exports;
    </script>

    <!-- Firebase Initialization -->
    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyChvjfVMQ_jrAt7C08pLTreckUIizKFKis",
            authDomain: "dofo-c3fbe.firebaseapp.com",
            projectId: "dofo-c3fbe",
            storageBucket: "dofo-c3fbe.firebasestorage.app",
            messagingSenderId: "953198874702",
            appId: "1:953198874702:web:025100b11c243f73f9731f",
            measurementId: "G-LCFEPZ57EJ"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);

        // Expose services globally
        window.auth = firebase.auth();
        window.db = firebase.firestore();
        window.storage = firebase.storage();

        console.log("Firebase Initialized:", firebase.app().name);

        // Check for file:// protocol (disabled for local dev - bypass handles this)
        // if (window.location.protocol === 'file:') {
        //     alert("⚠️ CRITICAL ERROR: Google Sign-In does NOT work when opening the file directly (file://). You MUST serve this file using a local web server (e.g., 'npx serve' or VS Code Live Server).");
        // }
    </script>

    <style>
        .wristband-print-container {
            display: none;
        }

        .print-only-text {
            display: none !important;
        }

        .print-only {
            display: none !important;
        }

        @media print {
            .print-only-text {
                display: block !important;
            }

            .print-only {
                display: flex !important;
            }

            @page {
                size: landscape !important;
                margin: 0.25in !important;
            }

            body {
                background: white !important;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
                margin: 0;
                padding: 0;
            }

            /* Print Styles */
            /* Hide UI Chrome */
            .sidebar,
            .play-bank-sidebar,
            .app-toolbar,
            .print-preview-header,
            .hide-on-print,
            button,
            .btn,
            input,
            select {
                display: none !important;
            }

            /* Practice Script Print Styles */
            .script-grid-container {
                display: block !important;
                overflow: visible !important;
                height: auto !important;
                padding: 0.5rem !important;
                background: white !important;
            }

            .script-grid-container > div {
                background: white !important;
                border: 1px solid black !important;
                margin-bottom: 0.5rem !important;
                break-inside: avoid !important;
            }

            .script-grid-container > div > div:first-child {
                background: #f3f4f6 !important;
                color: black !important;
                font-weight: bold !important;
                padding: 3px 8px !important;
                border-bottom: 1px solid black !important;
            }

            .script-grid-container table {
                width: 100% !important;
                border-collapse: collapse !important;
                background: white !important;
                color: black !important;
            }

            .script-grid-container th,
            .script-grid-container td {
                border: 1px solid black !important;
                padding: 4px 8px !important;
                background: white !important;
                color: black !important;
            }

            .script-grid-container th {
                background: #e5e7eb !important;
                font-weight: bold !important;
            }

            .script-grid-container select,
            .script-grid-container input[type="text"] {
                display: none !important;
            }

            .script-grid-container td::after {
                content: attr(data-print-value);
            }

            /* Compact FZDnD Rows for Print */
            .fzdnd-row-container {
                min-height: 22px !important;
                border: 1px solid black !important;
                border-top: none !important;
                /* Avoid double top borders */
                border-left: 1px solid black !important;
                /* Ensure left border */
                border-right: 1px solid black !important;
                /* Ensure right border */
            }

            .fzdnd-cell {
                min-height: 22px !important;
                padding: 1px 2px !important;
                border-bottom: 1px solid black !important;
                border-right: 1px solid black !important;
            }

            .fzdnd-cell:last-child {
                border-right: none !important;
                /* Container handles the right edge, or keep it if container lacks it? Container has right border now. */
            }

            .fzdnd-cell input {
                height: 18px !important;
                font-size: 0.65rem !important;
                padding: 0 !important;
                margin: 0 !important;
            }

            /* Toggle Cell in Print */
            .fzdnd-toggle-cell {
                border-right: 1px solid black !important;
                border-bottom: 1px solid black !important;
                background: transparent !important;
            }

            /* Header Row for Print */
            .fzdnd-header-row {
                border-left: 1px solid black !important;
                border-right: 1px solid black !important;
            }

            .print-only-scripts {
                display: block !important;
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                padding: 1rem;
                box-sizing: border-box;
                z-index: 99998;
            }

            /* Ensure Print Preview Modal behaves nicely */
            .print-preview-modal-wrapper {
                position: absolute !important;
                background: white !important;
                width: 100% !important;
                height: auto !important;
                overflow: visible !important;
                top: 0 !important;
                left: 0 !important;
                z-index: 99999 !important;
            }

            .print-preview-content {
                padding: 0 !important;
                overflow: visible !important;
            }

            /* Reset Game Plan Containers for Print */
            .app-container,
            .main-content,
            .game-plan-container,
            .game-plan-content,
            .depth-view-container,
            .depth-content-wrapper,
            .depth-chart-print-section,
            .depth-chart-print-view {
                height: auto !important;
                overflow: visible !important;
                display: block !important;
                flex: none !important;
                margin: 0 !important;
                padding: 0 !important;
            }

            /* Depth chart print view - ensure content visible */
            .depth-chart-print-view > div {
                position: relative !important;
                height: auto !important;
                width: 100% !important;
            }

            .depth-chart-print-view h1 {
                display: block !important;
                text-align: center !important;
                margin-bottom: 10px !important;
            }

            /* Hide controls and checkboxes during print */
            @media print {

                .btn,
                button,
                input[type="checkbox"],
                label {
                    display: none !important;
                }

                h2 {
                    display: block !important;
                    margin-bottom: 1rem !important;
                }
            }

            /* Ensure content utilizes full width and avoids breaks */
            .print-preview-content>div {
                width: 100%;
            }

            table,
            tr,
            td,
            .box,
            .call-sheet-grid {
                page-break-inside: avoid;
                break-inside: avoid;
            }

            /* Hide empty rows in print */
            .hidden-row {
                display: none !important;
            }

            /* FZ DND Print Layout - Full Width */
            .fzdnd-zone-container {
                page-break-inside: avoid;
                break-inside: avoid;
                margin-bottom: 0 !important;
            }

            .fzdnd-zone-grid {
                display: block !important;
                grid-template-columns: none !important;
            }

            .fzdnd-philosophy-column {
                display: none !important;
            }

            .fzdnd-content-wrapper {
                display: block !important;
                width: 100% !important;
            }

            /* Call sheet sections - allow natural flow, no forced page breaks */
            .call-sheet-section {
                page-break-before: auto !important;
                break-before: auto !important;
                page-break-after: auto !important;
                break-after: auto !important;
                /* Allow sections to break across pages */
                break-inside: auto !important;
                -webkit-column-break-inside: auto !important;
                margin-bottom: 0.25rem !important;
            }

            /* Hide empty rows in print */
            .print-hide-empty {
                display: none !important;
            }

            /* Single column layout for sheet view - sections span full width */
            .print-preview-content>div {
                width: 100% !important;
            }

            /* Sections span full page width, allow natural flow */
            .call-sheet-section {
                break-inside: auto !important;
                width: 100% !important;
                margin-bottom: 0.25rem !important;
            }

            /* Allow text to wrap in grid cells for print */
            .call-sheet-section div[style*="grid"]>div {
                white-space: normal !important;
                word-wrap: break-word !important;
                overflow-wrap: break-word !important;
            }

            /* Default portrait orientation */
            @page {
                size: portrait;
                margin: 0.4in;
            }

            /* Landscape orientation when class is applied */
            .print-landscape {
                width: 100% !important;
            }

            @page landscape {
                size: landscape;
                margin: 0.4in;
            }

            .print-preview-content.print-landscape {
                page: landscape;
            }

            /* Reduce font sizes and padding for density */
            .print-preview-content table,
            .print-preview-content div {
                font-size: 0.8rem !important;
            }

            .print-preview-content td,
            .print-preview-content th,
            .call-sheet-section>div>div>div {
                padding: 2px !important;
            }

            /* Smaller section headings */
            .call-sheet-section>div:first-child {
                font-size: 0.75rem !important;
                padding: 4px !important;
            }

            /* Tighter grid cells */
            .call-sheet-section div[style*="grid"]>div {
                padding: 1px !important;
                font-size: 0.65rem !important;
                min-height: 14px !important;
            }

            /* BUT show the print portal */
            .print-only-portal {
                display: block !important;
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: auto !important;
                background: white;
                z-index: 99999;
            }

            .print-only-portal * {
                visibility: visible !important;
            }

            /* Ensure body allows printing */
            body,
            html {
                visibility: visible !important;
                height: auto !important;
                overflow: visible !important;
                background: white !important;
            }
        }

        /* Screen Styles for Portal */
        .print-only-portal {
            display: none;
        }

        .print-only-scripts {
            display: none;
        }

        /* Travel Packet Printing Exception */
        .travel-print-container,
        .travel-print-container * {
            visibility: visible;
        }

        .travel-print-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background: white;
            color: black;
            padding: 2rem;
            z-index: 99998;
            display: block !important;
        }









        .wristband-print-container>* {
            display: flex !important;
        }

        .wristband-card {
            width: 4.75in;
            height: 2.75in;
            border: 2px solid black !important;
            display: flex;
            flex-direction: column;
            background: white;
            overflow: hidden;
            /* Ensure content stays within 5x3 */
        }

        .wristband-card-header {
            font-size: 9.5pt;
            font-weight: bold;
            background: black !important;
            color: white !important;
            text-align: center;
            padding: 2px 0;
            border-bottom: 2px solid black;
            text-transform: uppercase;
        }

        .wristband-content {
            flex: 1;
            display: flex;
            border-top: 1px solid black;
        }

        .wristband-col {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .wristband-col:first-child {
            border-right: 2px solid black;
            /* Split columns clearly */
        }

        .wristband-row {
            flex: 1;
            /* Distribute height evenly */
            display: flex;
            border-bottom: 1px solid black;
            align-items: center;
            overflow: hidden;
        }

        .wristband-row:last-child {
            border-bottom: none;
        }

        .wristband-num {
            width: 27px;
            /* Fixed width */
            font-size: 7.5pt;
            font-weight: bold;
            background: #f0f0f0 !important;
            /* Light grey for numbers */
            display: flex;
            align-items: center;
            justify-content: center;
            border-right: 1px solid black;
            height: 100%;
            color: black;
        }

        .wristband-play {
            flex: 1;
            font-size: 7.5pt;
            /* Smaller font to fit */
            font-weight: bold;
            padding: 0 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
            height: 100%;
        }

        /* Alternating row colors for readability if desired, but user image showed white/tan strips */
        /* Let's try to match user sample roughly or keep clean white */
        .wristband-row:nth-child(odd) .wristband-play {
            background: white;
        }

        .wristband-row:nth-child(even) .wristband-play {
            background: #ffedd5 !important;
            /* Orange-ish tint like screenshot */
        }

        /* Specific overrides for color classes if we pass them */
        .wristband-card.green .wristband-row:nth-child(even) .wristband-play {
            background: #dcfce7 !important;
        }

        /* --- NEW WRISTBAND STYLES --- */

        /* Grid Card (Diagrams) */
        .wristband-grid-card {
            width: 4.75in;
            height: 2.75in;
            border: 2px solid black !important;
            background: white;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(5, 1fr);
            width: 100%;
            height: 100%;
            box-sizing: border-box;
        }

        .wristband-grid-cell {
            border-right: 1px solid black;
            border-bottom: 1px solid black;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        /* Remove right border for last column */
        .wristband-grid-cell:nth-child(4n) {
            border-right: none;
        }

        /* Remove bottom border for last row */
        .wristband-grid-cell:nth-nth-child(n+17) {
            /* 17-20 are last row */
            border-bottom: none;
        }

        /* Actually simpler: just let container border handle edges? 
                Grid borders are tricky. Let's strictly border right/bottom and overlap or use gap.
                Gap is bad for print alignment. 
                Let's use outline/negative margin or standard table-like borders.
             */

        .wristband-grid-cell-header {
            font-size: 5.5pt;
            font-weight: bold;
            background: #eee;
            border-bottom: 1px solid #ccc;
            padding: 1px 2px;
            display: flex;
            justify-content: space-between;
            white-space: nowrap;
        }

        .wristband-grid-cell-body {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .wristband-grid-cell-body img,
        .wristband-grid-cell-body svg {
            object-fit: cover;
            width: 100%;
            height: 100%;
        }

        .wristband-grid-cell-footer {
            font-size: 6.5pt;
            font-weight: 800;
            text-align: center;
            background: black;
            color: white;
            padding: 1px 0;
            white-space: nowrap;
            overflow: hidden;
        }

        /* --- DEPTH CHART PRINT STYLES --- */
        .depth-chart-container {
            display: block !important;
            height: auto !important;
            overflow: visible !important;
        }

        .depth-chart-viewport {
            display: block !important;
            height: auto !important;
            min-height: 0 !important;
            overflow: visible !important;
            border: none !important;
        }

        /* Hide controls when printing */
        .depth-chart-controls {
            display: none !important;
        }

        /* Updated Text List Styles (High Contrast) */
        .wristband-card.text-list .wristband-card-header {
            background: black !important;
            color: white !important;
            font-size: 10.5pt;
            text-transform: uppercase;
            padding: 4px 0;
        }

        .wristband-card.text-list .wristband-row {
            border-bottom: 1px solid black;
            height: 12.5%;
            /* 8 rows per column for 16 items? Or stick to 20-25? User wants specific count. */
            /* User sample 1 had 301-316 per col? No, sample 2 has 25 rows (101-125). */
        }

        .wristband-card.text-list .wristband-num {
            background: black !important;
            color: white !important;
            font-weight: bold;
            font-size: 8.5pt;
            width: 30px;
        }

        .wristband-card.text-list .wristband-play {
            font-size: 8.5pt;
            font-weight: bold;
            color: black;
        }

        .wristband-card.text-list .wristband-row:nth-child(even) .wristband-play {
            background: #e5e5e5 !important;
            /* Light Grey striping instead of orange */
        }

        .wristband-card.text-list.green .wristband-row:nth-child(even) .wristband-play {
            background: #dcfce7 !important;
        }

        /* --- WRISTBAND BUILDER SCREEN STYLES --- */
        .wristband-spreadsheet-container {
            display: flex;
            gap: 2rem;
            height: 100%;
            overflow: auto;
        }

        .wristband-spreadsheet-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.7rem;
            background: white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            color: #000;
        }

        .wristband-spreadsheet-table thead {
            position: sticky;
            top: 0;
            z-index: 10;
            background: #f3f4f6;
            border-bottom: 2px solid #000;
        }

        .wristband-spreadsheet-table th {
            padding: 8px 12px;
            text-align: left;
            font-weight: 600;
            border: 1px solid #333;
            background: #f3f4f6;
            color: #000;
        }

        .wristband-spreadsheet-table td {
            padding: 1px 6px;
            border: 1px solid #333;
            height: 11px;
            vertical-align: middle;
            color: #000;
        }

        .wristband-spreadsheet-table td:first-child {
            font-weight: 600;
            text-align: center;
            width: 60px;
        }

        .wristband-spreadsheet-table td:nth-child(2) {
            font-weight: 500;
        }

        /* Alternating row colors for 100s (green) */
        .wristband-spreadsheet-table tbody tr.wb-100s:nth-child(odd) {
            background-color: #d1fae5;
        }

        .wristband-spreadsheet-table tbody tr.wb-100s:nth-child(even) {
            background-color: #a7f3d0;
        }

        /* Alternating row colors for 200s (orange) */
        .wristband-spreadsheet-table tbody tr.wb-200s:nth-child(odd) {
            background-color: #fed7aa;
        }

        .wristband-spreadsheet-table tbody tr.wb-200s:nth-child(even) {
            background-color: #fdba74;
        }

        /* Alternating row colors for 400s (purple) */
        .wristband-spreadsheet-table tbody tr.wb-400s:nth-child(odd) {
            background-color: #e9d5ff;
        }

        .wristband-spreadsheet-table tbody tr.wb-400s:nth-child(even) {
            background-color: #d8b4fe;
        }

        /* Alternating row colors for 500s (teal) */
        .wristband-spreadsheet-table tbody tr.wb-500s:nth-child(odd) {
            background-color: #99f6e4;
        }

        .wristband-spreadsheet-table tbody tr.wb-500s:nth-child(even) {
            background-color: #5eead4;
        }

        /* Alternating row colors for 600s (pink) */
        .wristband-spreadsheet-table tbody tr.wb-600s:nth-child(odd) {
            background-color: #fbcfe8;
        }

        .wristband-spreadsheet-table tbody tr.wb-600s:nth-child(even) {
            background-color: #f9a8d4;
        }

        .wristband-spreadsheet-table tbody tr:hover {
            outline: 2px solid var(--accent);
            outline-offset: -1px;
        }

        .wristband-spreadsheet-table tbody tr.selected {
            background-color: rgba(56, 189, 248, 0.3) !important;
        }

        .wristband-spreadsheet-table tbody tr.empty {
            opacity: 0.5;
        }

        .wristband-clear-btn {
            background: none;
            border: none;
            color: #ef4444;
            cursor: pointer;
            padding: 2px 6px;
            font-size: 0.75rem;
            opacity: 0.7;
        }

        .wristband-clear-btn:hover {
            opacity: 1;
        }

        /* Print styles for spreadsheet view */
        @media print {
            @page {
                size: letter landscape;
                margin: 0;
            }

            body {
                margin: 0;
                padding: 0;
            }

            /* Hide all non-print elements */
            .wristband-spreadsheet-container,
            .sidebar,
            .play-bank-sidebar,
            button,
            .nav-item,
            .top-nav,
            .main-content>*:not(.wristband-print-container):not(.depth-view-container):not(.depth-chart-print-section) {
                display: none !important;
            }

            /* Ensure depth chart sections show in print */
            .depth-chart-print-section {
                display: block !important;
                page-break-after: always !important;
            }

            /* Override for depth chart view - ensure all content visible */
            .depth-view-container,
            .depth-view-container *,
            .depth-chart-print-section *,
            .depth-chart-print-view,
            .depth-chart-print-view * {
                visibility: visible !important;
            }

            .depth-view-container {
                display: block !important;
                position: static !important;
                height: auto !important;
                overflow: visible !important;
            }

            /* Single depth chart print - hide editing view, show PrintView portal */
            .depth-chart-container {
                display: none !important;
            }

            .print-only-portal {
                display: block !important;
                position: absolute !important;
                top: 0 !important;
                left: 0 !important;
                width: 100% !important;
                background: white !important;
                z-index: 99999 !important;
            }

            .print-only-portal .depth-chart-print-view {
                display: block !important;
                background: white !important;
                padding: 20px !important;
            }

            /* Print Preview specific styles */
            .print-preview-header {
                display: none !important;
            }

            .print-preview-content {
                padding: 0 !important;
                overflow: visible !important;
            }
        }

        /* Show print container */


        /* 2x2 Grid Layout - Centered on page */
        .wristband-print-grid {
            display: grid;
            grid-template-columns: 2.75in 2.75in;
            grid-template-rows: 4.75in 4.75in;
            gap: 0.5in 0.5in;
            width: 6in;
            /* 2 cards × 2.75in + 1 gap × 0.5in */
            height: 10in;
            /* 2 cards × 4.75in + 1 gap × 0.5in */
            /* Center on page: (11 - 6) / 2 = 2.5in horizontal */
            margin: -0.75in auto 0;
            margin-left: 2.5in;
            margin-right: 2.5in;
            page-break-inside: avoid;
        }

        /* Individual Wristband Card - 4.75in × 2.75in landscape */
        .wristband-print-card {
            width: 4.75in;
            height: 2.75in;
            border: 2px solid black;
            background: white;
            overflow: hidden;
            page-break-inside: avoid;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        /* Card header styling */
        .wristband-print-card .print-card-header {
            background: black;
            color: white;
            padding: 4px 8px;
            font-weight: bold;
            font-size: 9pt;
            text-align: center;
            display: flex;
            justify-content: space-between;
            border-bottom: 2px solid black;
            flex-shrink: 0;
        }

        /* Colored wristband backgrounds */
        /* Green shades - alternating */
        .wristband-color-green-light {
            background: #d1fae5 !important;
        }

        .wristband-color-green-medium {
            background: #a7f3d0 !important;
        }

        /* Orange shades - alternating */
        .wristband-color-orange-light {
            background: #fed7aa !important;
        }

        .wristband-color-orange-medium {
            background: #fdba74 !important;
        }

        /* Red shades - alternating */
        .wristband-color-red-light {
            background: #fecaca !important;
        }

        .wristband-color-red-medium {
            background: #fca5a5 !important;
        }

        /* Blue shades - alternating */
        .wristband-color-blue-light {
            background: #bfdbfe !important;
        }

        .wristband-color-blue-medium {
            background: #93c5fd !important;
        }

        /* Yellow shades - alternating */
        .wristband-color-yellow-light {
            background: #fef08a !important;
        }

        .wristband-color-yellow-medium {
            background: #fde047 !important;
        }

        /* Purple shades - alternating */
        .wristband-color-purple-light {
            background: #e9d5ff !important;
        }

        .wristband-color-purple-medium {
            background: #d8b4fe !important;
        }

        /* Teal shades - alternating */
        .wristband-color-teal-light {
            background: #99f6e4 !important;
        }

        .wristband-color-teal-medium {
            background: #5eead4 !important;
        }

        /* Pink shades - alternating */
        .wristband-color-pink-light {
            background: #fbcfe8 !important;
        }

        .wristband-color-pink-medium {
            background: #f9a8d4 !important;
        }

        /* Card content area */
        .wristband-print-card .print-card-content {
            flex: 1;
            overflow: hidden;
        }

        /* Table styling for print */
        .wristband-print-card table {
            width: 100%;
            border-collapse: collapse;
            font-size: 6pt;
            height: 100%;
        }

        .wristband-print-card td {
            border: 1px solid #666;
            padding: 1px 2px;
            vertical-align: middle;
        }

        .wristband-print-card td:first-child {
            font-weight: bold;
            text-align: center;
            width: 25px;
        }

        .wristband-print-card-spreadsheet.orange tbody tr:nth-child(odd) {
            background-color: #fed7aa;
        }

        .wristband-print-card-spreadsheet.orange tbody tr:nth-child(even) {
            background-color: #fdba74;
        }
    </style>
</head>

<body>
    <!-- Error Handler (Standard JS) -->
    <script>
        window.onerror = function (message, source, lineno, colno, error) {
            console.error("Global Error Caught:", message, source, lineno, error);
            // If it's a generic "Script error." (cross-origin), we can't do much, but let's not nuke the app if it's running.
            // Only show the red screen if the root element is empty or if it's a critical error we want to surface.
            const root = document.getElementById('root');
            const hasContent = root && root.childElementCount > 0;

            // Don't nuke if it's just a resize observer loop limit exceeded or similar benign error
            if (message && message.includes('ResizeObserver')) return false;

            // For critical errors where the app probably crashed:
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); color:red; padding:20px; font-family:monospace; z-index:99999; overflow:auto;';
            errorDiv.innerHTML = '<h1>Application Error</h1><p><strong>Message:</strong> ' + message + '</p><p><strong>Source:</strong> ' + source + '</p><p><strong>Line:</strong> ' + lineno + '</p><pre>' + (error ? error.stack : 'No stack trace') + '</pre><button onclick="this.parentElement.remove()">Dismiss</button>';

            document.body.appendChild(errorDiv);
            return false;
        };
    </script>

    <div id="root"></div>
    <script type="text/babel">
        // CACHE BUST: 2026-01-24-v2
        const { useState, useEffect, useRef, useContext, createContext, useMemo, useCallback } = React;

        // Helper function to get display name for a play
        const getPlayDisplayName = (play) => {
            if (!play) return 'Unknown Play';
            return play.name || play.title || play.playName || 'Unnamed Play';
        };

        // --- FIRESTORE SYNC UTILITIES ---
        // HELPER: Clear all local app data
        // HELPER: Clear all local app data
        const clearAllLocalData = () => {
            // NUCLEAR OPTION: Wipe everything to guarantee a clean slate for new users/trials
            // FIX: Preserve the reload flag to prevent infinite loops in AuthProvider
            const reloadFlag = sessionStorage.getItem('just_reloaded_for_sync');

            localStorage.clear();
            sessionStorage.clear();

            if (reloadFlag) {
                sessionStorage.setItem('just_reloaded_for_sync', reloadFlag);
            }
            console.log("Local data COMPLETELY cleared (persisted sync flag).");
        };

        const loadUserDataFromFirestore = async (userId) => {
            try {
                console.log("Loading user data from Firestore for user (Force Server):", userId);
                const userDocRef = window.db.collection('users').doc(userId);
                const userDoc = await userDocRef.get({ source: 'server' });

                let appData = {};
                let isSchoolData = false;

                if (userDoc.exists) {
                    const userData = userDoc.data();
                    appData = userData; // Default to user data

                    // CHECK FOR MEMBERSHIPS (New Logic)
                    const membershipsSnapshot = await userDocRef.collection('memberships').get();
                    let activeSchoolId = null;

                    if (!membershipsSnapshot.empty) {
                        // Use first membership for now (TODO: Add "lastActiveSchool" to user profile)
                        activeSchoolId = membershipsSnapshot.docs[0].id;
                        console.log("Found membership for school:", activeSchoolId);
                    } else if (userData.schoolId) {
                        // MIGRATION: Auto-create membership
                        console.log("Migrating legacy schoolId to membership...");
                        activeSchoolId = userData.schoolId;
                        try {
                            await userDocRef.collection('memberships').doc(activeSchoolId).set({
                                role: 'admin', // Default to admin for legacy upgrades
                                joinedAt: new Date().toISOString(),
                                status: 'active'
                            });
                        } catch (err) {
                            console.error("Migration failed:", err);
                        }
                    }

                    // LOAD DATA
                    if (activeSchoolId) {
                        console.log("Loading SCHOOL data for:", activeSchoolId);
                        localStorage.setItem('hc_school_id', activeSchoolId);

                        const schoolDoc = await window.db.collection('schools').doc(activeSchoolId).get();
                        if (schoolDoc.exists) {
                            console.log("Loaded SCHOOL data");
                            appData = schoolDoc.data();
                            isSchoolData = true;

                            // SYNC MEMBER LIST (Ensure user is listed in school doc)
                            // Only add if not already listed by UID or email
                            try {
                                const currentMembers = appData.memberList || [];
                                const myEmail = window.auth.currentUser.email.toLowerCase();
                                const isListed = currentMembers.find(m =>
                                    m.uid === userId ||
                                    (m.email && m.email.toLowerCase() === myEmail)
                                );

                                if (!isListed) {
                                    console.log("Adding self to school memberList...");
                                    const newMember = {
                                        uid: userId,
                                        email: myEmail,
                                        role: 'admin', // Default for now, later derived from membership
                                        joinedAt: new Date().toISOString()
                                    };
                                    await window.db.collection('schools').doc(activeSchoolId).update({
                                        memberList: firebase.firestore.FieldValue.arrayUnion(newMember)
                                    });
                                }
                            } catch (err) {
                                console.warn("Failed to sync member list:", err);
                            }
                        } else {
                            console.warn("School ID found but document missing.");
                        }
                    } else {
                        // Check for Pending Invites (Auto-Join)
                        console.log("No membership found. Checking for invites...");
                        const myEmail = window.auth.currentUser.email.toLowerCase();
                        let inviteSchoolId = null;

                        try {
                            const inviteDoc = await window.db.collection('invites').doc(myEmail).get();
                            if (inviteDoc.exists) {
                                const inviteData = inviteDoc.data();
                                console.log("Found invite for school:", inviteData.schoolId);
                                inviteSchoolId = inviteData.schoolId;

                                // Auto-create membership
                                await userDocRef.collection('memberships').doc(inviteSchoolId).set({
                                    role: inviteData.role || 'assistant',
                                    joinedAt: new Date().toISOString(),
                                    status: 'active'
                                });
                                activeSchoolId = inviteSchoolId;
                            }
                        } catch (err) {
                            console.error("Error checking invites:", err);
                        }

                        if (activeSchoolId) {
                            // Recursively load data now that we have a school
                            // Or just fall through to the logic below?
                            // Logic below checks `if (activeSchoolId)` so we just need to set it!
                            console.log("Auto-joined school. Loading data...");
                        } else {
                            // Ensure we clear any stale school ID if they are not in a school
                            console.log("No school data found for user.");
                            localStorage.removeItem('hc_school_id');
                        }

                        localStorage.removeItem('hc_school_id');
                    }
                } else {
                    // NEW: User Doc does not exist (New User or Deleted Doc).
                    // WIPE LOCAL STORAGE to prevent "ghost" sessions from previous users on this device.
                    clearAllLocalData();
                    // Don't return, let execution continue so appData (empty) flows through to clear state
                }

                console.log("Applying data to localStorage...", appData);
                const data = appData;

                // Apply data to localStorage
                // CRITICAL FIX: Ensure keys match what the App component uses for initialization
                if (data.roster) {
                    localStorage.setItem('oc-dashboard-roster', JSON.stringify(data.roster)); // WAS: roster_data
                }
                if (data.plays) {
                    localStorage.setItem('oc-dashboard-plays', JSON.stringify(data.plays)); // WAS: play_library
                }
                if (data.staff) {
                    localStorage.setItem('oc-dashboard-staff', JSON.stringify(data.staff)); // NEW
                }
                if (data.depthChart) {
                    localStorage.setItem('oc-dashboard-depthchart', JSON.stringify(data.depthChart)); // NEW
                }

                if (data.settings) {
                    if (data.settings.teamLogo) localStorage.setItem('oc-dashboard-logo', data.settings.teamLogo);
                    // Fix: Check root name first (standard), then settings (legacy/alt)
                    if (data.name) localStorage.setItem('hc_school_name', data.name);
                    else if (data.settings.schoolName) localStorage.setItem('hc_school_name', data.settings.schoolName);
                    // Fix Accent Color Key
                    if (data.settings.accentColor) {
                        localStorage.setItem('oc-dashboard-accent', data.settings.accentColor); // Match App Init
                        localStorage.setItem('user_accent_color', data.settings.accentColor); // Legacy/Backup
                    }
                    // Fix Theme Key
                    if (data.settings.theme) {
                        localStorage.setItem('oc-dashboard-theme', data.settings.theme); // Match App Init
                        localStorage.setItem('user_theme', data.settings.theme); // Legacy/Backup
                    }
                    if (data.settings.activeYear) localStorage.setItem('hc-active-year', data.settings.activeYear);
                    if (data.settings.visibleFeatures) localStorage.setItem('hc-visible-features', JSON.stringify(data.settings.visibleFeatures));
                    // Fix: Load Position Names
                    if (data.settings.positionNames) localStorage.setItem('oc-dashboard-position-names', JSON.stringify(data.settings.positionNames));
                }

                // --- NEW SYNC ITEMS (Complete Coverage) ---
                if (data.weeks) {
                    localStorage.setItem('oc-dashboard-weeks', JSON.stringify(data.weeks));
                }
                if (data.billing) {
                    localStorage.setItem('hc_school_billing', JSON.stringify(data.billing));
                }
                if (data.attendance) {
                    localStorage.setItem('attendance_log', JSON.stringify(data.attendance));
                }

                if (data.formationLayouts) {
                    localStorage.setItem('formationLayouts', JSON.stringify(data.formationLayouts));
                }
                if (data.ratings) {
                    localStorage.setItem('oc-dashboard-ratings', JSON.stringify(data.ratings));
                }
                if (data.athleteAssessments) {
                    localStorage.setItem('athlete_assessments', JSON.stringify(data.athleteAssessments));
                }
                if (data.staff) {
                    localStorage.setItem('oc-dashboard-staff', JSON.stringify(data.staff));
                }

                // --- ADDITIONAL MISSING ITEMS ---
                if (data.formations) {
                    localStorage.setItem('oc-dashboard-formations', JSON.stringify(data.formations));
                }
                if (data.zonePhilosophies) {
                    localStorage.setItem('oc-dashboard-zone-philosophies', JSON.stringify(data.zonePhilosophies));
                }
                if (data.customFocus) {
                    localStorage.setItem('oc-dashboard-custom-focus', JSON.stringify(data.customFocus));
                }
                if (data.positionNames) {
                    localStorage.setItem('oc-dashboard-position-names', JSON.stringify(data.positionNames));
                }
                if (data.roleTasks) {
                    localStorage.setItem('staff_role_tasks', JSON.stringify(data.roleTasks));
                }
                if (data.wizLib) {
                    localStorage.setItem('wiz_ol_library', JSON.stringify(data.wizLib));
                } else if (data.wizLib) {
                    localStorage.setItem('wiz_ol_library', JSON.stringify(data.wizLib));
                }
                // Wristband Settings
                if (data.wbSettings) {
                    if (data.wbSettings.wb1Opp) localStorage.setItem('hc_wb1_opponent', data.wbSettings.wb1Opp);
                    if (data.wbSettings.wb1Iter) localStorage.setItem('hc_wb1_iteration', data.wbSettings.wb1Iter);
                    if (data.wbSettings.wb2Opp) localStorage.setItem('hc_wb2_opponent', data.wbSettings.wb2Opp);
                    if (data.wbSettings.wb2Iter) localStorage.setItem('hc_wb2_iteration', data.wbSettings.wb2Iter);
                    if (data.wbSettings.sheetUrl) localStorage.setItem('hc_wristband_sheet_url', data.wbSettings.sheetUrl);
                }

            } catch (error) {
                console.error("Error loading data from Firestore:", error);
                return { success: false, error };
            }
        };

        const syncToFirestore = async (userId, dataType, data) => {
            try {
                // DETERMINE DESTINATION (School or User)
                const schoolId = localStorage.getItem('hc_school_id');
                let docRef;
                let contextLog = "Personal";

                if (schoolId) {
                    docRef = window.db.collection('schools').doc(schoolId);
                    contextLog = `School (${schoolId})`;
                } else {
                    docRef = window.db.collection('users').doc(userId);
                }

                console.log(`Syncing ${dataType} to ${contextLog}...`);

                const updateData = {
                    [dataType]: data,
                    [`${dataType}LastModified`]: new Date().toISOString()
                };

                await docRef.set(updateData, { merge: true });
                console.log(`${dataType} synced successfully`);
                return { success: true };
            } catch (error) {
                console.error(`Error syncing ${dataType}:`, error);
                return { success: false, error };
            }
        };

        // --- AUTHENTICATION ---
        const AuthContext = createContext();

        // LOCAL DEV PASSWORD - change this to whatever you want
        const LOCAL_DEV_PASSWORD = 'dofo';

        const AuthProvider = ({ children }) => {
            const [currentUser, setCurrentUser] = useState(null);
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                // LOCAL FILE:// DEV BYPASS
                if (window.location.protocol === 'file:') {
                    const devSession = sessionStorage.getItem('local_dev_auth');
                    if (devSession === 'authenticated') {
                        // Already authenticated this session
                        const mockUser = {
                            uid: 'local_dev_user',
                            email: 'localdev@test.com',
                            displayName: 'Local Dev Admin',
                            photoURL: null
                        };
                        setCurrentUser(mockUser);
                        setLoading(false);
                        return;
                    }

                    // Prompt for password
                    const pwd = prompt('Local Dev Password:');
                    if (pwd === LOCAL_DEV_PASSWORD) {
                        sessionStorage.setItem('local_dev_auth', 'authenticated');
                        const mockUser = {
                            uid: 'local_dev_user',
                            email: 'localdev@test.com',
                            displayName: 'Local Dev Admin',
                            photoURL: null
                        };
                        setCurrentUser(mockUser);
                        setLoading(false);
                        return;
                    } else {
                        alert('Incorrect password');
                        setLoading(false);
                        return;
                    }
                }

                const unsubscribe = window.auth.onAuthStateChanged(async (user) => {
                    if (user) {
                        try {
                            // SUPER ADMIN BYPASS
                            // Always allow the owner to log in, ignoring access control rules
                            if (user.email.toLowerCase() === 'matthewfinn14@gmail.com') {
                                console.log("Super Admin Login detected. Bypassing access control.");
                                setCurrentUser(user);
                                setLoading(false);
                                return;
                            }

                            // CHECK ACCESS CONTROL
                            const accessDoc = await window.db.collection('config').doc('access').get();
                            if (accessDoc.exists) {
                                const accessData = accessDoc.data();
                                if (accessData.inviteRequired) {
                                    const allowed = accessData.allowedEmails || [];
                                    const userEmail = user.email.toLowerCase();

                                    // 1. Check explicit allowance
                                    let isAllowed = allowed.some(email => email.toLowerCase() === userEmail);

                                    // 2. If not allowed, check for pending invites
                                    if (!isAllowed) {
                                        const inviteCheck = await window.db.collection('invites')
                                            .where('email', '==', userEmail)
                                            .where('status', '==', 'pending')
                                            .limit(1)
                                            .get();
                                        if (!inviteCheck.empty) isAllowed = true;
                                    }

                                    // 3. If not allowed, check for existing memberships
                                    if (!isAllowed) {
                                        const memCheck = await window.db.collection('users').doc(user.uid)
                                            .collection('memberships')
                                            .where('status', '==', 'active')
                                            .limit(1)
                                            .get();
                                        if (!memCheck.empty) isAllowed = true;
                                    }

                                    if (!isAllowed) {
                                        console.warn("Access Denied: Email not in allowlist and no valid invites/memberships found.");
                                        alert("Access Denied: This application is currently invite-only. Please contact the administrator.");
                                        await window.auth.signOut();
                                        setCurrentUser(null);
                                        setLoading(false);
                                        return;
                                    }
                                }
                            }
                        } catch (err) {
                            console.error("Error checking access control:", err);
                            // Fallback: Allow login if check fails? Or Block?
                            // Default to ALLOW to avoid lockout during outages, but log heavily.
                        }
                    }
                    if (user) {
                        try {
                            // ... access control logic already handled above ...

                            // LOAD DATA BEFORE SETTING LOADING TO FALSE
                            // This ensures the App component sees fresh cloud data on its first render
                            // and removes the need for a flickering window.location.reload()
                            console.log("Fetching cloud data for user:", user.uid);
                            await loadUserDataFromFirestore(user.uid);
                        } catch (err) {
                            console.error("Error in startup sync:", err);
                        }
                    }
                    setCurrentUser(user);
                    setLoading(false);
                });
                return unsubscribe;
            }, []);


            const login = (email, password, loginMode = 'coach') => {
                // Store user type for routing
                localStorage.setItem('user_type', loginMode);
                return window.auth.signInWithEmailAndPassword(email, password);
            };

            const loginWithGoogle = async (loginMode = 'coach') => {
                localStorage.setItem('user_type', loginMode);
                const provider = new firebase.auth.GoogleAuthProvider();
                try {
                    const result = await window.auth.signInWithPopup(provider);
                    return result.user;
                } catch (error) {
                    console.error("Google Sign-In Error:", error);
                    throw error;
                }
            };

            const register = (email, password) => window.auth.createUserWithEmailAndPassword(email, password);
            const logout = async () => {
                const isDemo = localStorage.getItem('is_demo_session') === 'true';
                const currentSchoolId = localStorage.getItem('hc_school_id');
                const userId = window.auth.currentUser ? window.auth.currentUser.uid : null;

                if (isDemo && userId) {
                    if (confirm("End Demo Session? All demo data (School & User) will be PERMANENTLY DELETED.")) {
                        try {
                            console.log("Cleaning up demo session...");

                            // 1. Delete School (if exists)
                            if (currentSchoolId) {
                                await window.db.collection('schools').doc(currentSchoolId).delete();
                            }

                            // 2. Delete User Doc
                            // (We skip deep subcollection deletion for speed, but main doc is key)
                            await window.db.collection('users').doc(userId).delete();

                            // 3. Delete Auth Account
                            const user = window.auth.currentUser;
                            if (user) {
                                await user.delete().catch(err => console.warn("Could not delete auth user:", err));
                            }

                            console.log("Demo cleanup complete.");
                        } catch (e) {
                            console.error("Demo cleanup failed:", e);
                        }
                    } else {
                        return; // Cancel logout
                    }
                }

                clearAllLocalData();
                return window.auth.signOut();
            };

            if (loading) {
                return (
                    <div style={{ height: '100vh', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', background: '#0f172a', color: 'white', gap: '1rem' }}>
                        <div style={{ fontSize: '1.2rem' }}>
                            Loading Dashboard...
                        </div>
                        <div style={{ fontSize: '0.9rem', color: '#94a3b8' }}>
                            Syncing roster, plays, and settings from cloud...
                        </div>
                    </div>
                );
            }

            return (
                <AuthContext.Provider value={{ currentUser, login, loginWithGoogle, register, logout }}>
                    {children}
                </AuthContext.Provider>
            );
        };

        const useAuth = () => useContext(AuthContext);

        const useSchoolPlan = () => {
            const { currentUser } = useAuth();
            const [billingInfo, setBillingInfo] = useState(() => {
                try {
                    return JSON.parse(localStorage.getItem('hc_school_billing') || '{}');
                } catch (e) { return {}; }
            });

            const planStatus = useMemo(() => {
                const SITE_ADMINS = ['matthewfinn14@gmail.com', 'admin@digitaldofo.com'];
                if (currentUser && SITE_ADMINS.includes(currentUser.email.toLowerCase())) return 'ALL_ACCESS';

                const plan = billingInfo.plan || 'free';
                const now = new Date();

                if (plan === 'trial') {
                    if (billingInfo.trialEndsAt && new Date(billingInfo.trialEndsAt) > now) return 'PREMIUM_TRIAL';
                    return 'FREE';
                }
                if (plan === 'premium') {
                    if (billingInfo.subscriptionEndsAt && new Date(billingInfo.subscriptionEndsAt) <= now) return 'FREE';
                    return 'PREMIUM';
                }
                if (plan === 'all_access') return 'ALL_ACCESS';
                return 'FREE';
            }, [billingInfo, currentUser]);

            const updateBilling = (newData) => {
                setBillingInfo(newData);
                localStorage.setItem('hc_school_billing', JSON.stringify(newData));
            };

            return {
                planStatus,
                isPremium: ['PREMIUM', 'PREMIUM_TRIAL', 'ALL_ACCESS'].includes(planStatus),
                isFree: planStatus === 'FREE',
                billingInfo,
                updateBilling
            };
        };

        const FZDND_ZONES = [
            { id: 'red', title: 'Red Zone (20-Goalline)', color: '#fee2e2' },
            { id: 'orange', title: 'Orange Zone (40-20)', color: '#ffedd5' },
            { id: 'yellow', title: 'Yellow Zone (-40 to +40)', color: '#fef9c3' },
            { id: 'green', title: 'Green Zone (-20 to -40)', color: '#dcfce7' },
            { id: 'backedup', title: 'Backed Up (Goalline-10)', color: '#f1f5f9' }
        ];

        const PRIORITY_CATEGORIES = [
            { id: 'must_use', label: 'Must Use', color: 'bg-red-100 text-red-800' },
            { id: 'alert', label: 'Alert/Kill', color: 'bg-amber-100 text-amber-800' },
            { id: 'check_with_me', label: 'Check w/ Me', color: 'bg-blue-100 text-blue-800' },
            { id: 'waste', label: 'Waste', color: 'bg-gray-100 text-gray-800' }
        ];

        const signup = (email, password, loginMode = 'coach') => {
            localStorage.setItem('user_type', loginMode);
            return window.auth.createUserWithEmailAndPassword(email, password);
        };

        const LoginScreen = () => {
            const { login, loginWithGoogle } = useAuth();

            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [error, setError] = useState('');
            const [loading, setLoading] = useState(false);
            const [isRequestMode, setIsRequestMode] = useState(false);

            const handleSubmit = async (e) => {
                e.preventDefault();
                setError('');
                setLoading(true);
                try {
                    if (isRequestMode) {
                        // Create account - they'll be routed to AccessRequestForm after
                        await window.auth.createUserWithEmailAndPassword(email, password);
                    } else {
                        // Log in existing account
                        await login(email, password, 'coach');
                    }
                } catch (err) {
                    setError(err.message);
                    setLoading(false);
                }
            };

            const handleGoogleAuth = async () => {
                setError('');
                setLoading(true);
                try {
                    await loginWithGoogle('coach');
                } catch (err) {
                    console.error("Auth Error:", err);
                    setError(err.message);
                    setLoading(false);
                }
            };

            return (
                <div style={{
                    height: '100vh', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center',
                    background: 'linear-gradient(135deg, #0f172a 0%, #1e293b 100%)', color: 'white'
                }}>
                    {/* Logo above the card */}
                    <img
                        src="DoFO%20-%20White%20logo%20transparent%20bckgrnd.png"
                        alt="DoFO - Plan Faster. Prepare Smarter. Win the Week."
                        style={{ width: '320px', marginBottom: '2rem' }}
                    />

                    <div style={{ background: '#1e293b', padding: '2rem', borderRadius: '12px', width: '100%', maxWidth: '400px', boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.25)' }}>
                        <p style={{ textAlign: 'center', color: '#94a3b8', marginBottom: '1.5rem', fontSize: '0.95rem' }}>
                            {isRequestMode ? 'Create an account to get started' : 'Sign in to your account'}
                        </p>

                        {error && <div style={{ background: '#7f1d1d', color: '#fca5a5', padding: '0.75rem', borderRadius: '6px', marginBottom: '1rem', fontSize: '0.9rem' }}>{error}</div>}

                        {/* Google Sign In - Primary Option */}
                        <button
                            onClick={handleGoogleAuth}
                            disabled={loading}
                            style={{
                                width: '100%',
                                padding: '0.85rem',
                                borderRadius: '6px',
                                border: '1px solid #e2e8f0',
                                background: 'white',
                                color: '#0f172a',
                                fontWeight: '600',
                                cursor: loading ? 'not-allowed' : 'pointer',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                gap: '0.75rem',
                                fontSize: '0.95rem'
                            }}
                        >
                            <svg width="18" height="18" viewBox="0 0 24 24">
                                <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                                <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                                <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                                <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                            </svg>
                            {isRequestMode ? 'Continue with Google' : 'Sign in with Google'}
                        </button>

                        <div style={{ display: 'flex', alignItems: 'center', margin: '1.25rem 0' }}>
                            <div style={{ flex: 1, height: '1px', background: '#475569' }}></div>
                            <span style={{ padding: '0 0.75rem', color: '#64748b', fontSize: '0.8rem' }}>or use email</span>
                            <div style={{ flex: 1, height: '1px', background: '#475569' }}></div>
                        </div>

                        <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                            <div>
                                <input
                                    type="email"
                                    required
                                    value={email}
                                    onChange={(e) => setEmail(e.target.value)}
                                    style={{ width: '100%', padding: '0.75rem', borderRadius: '6px', border: '1px solid #475569', background: '#0f172a', color: 'white', boxSizing: 'border-box' }}
                                    placeholder="Email address"
                                />
                            </div>
                            <div>
                                <input
                                    type="password"
                                    required
                                    value={password}
                                    onChange={(e) => setPassword(e.target.value)}
                                    style={{ width: '100%', padding: '0.75rem', borderRadius: '6px', border: '1px solid #475569', background: '#0f172a', color: 'white', boxSizing: 'border-box' }}
                                    placeholder="Password"
                                />
                            </div>
                            <button
                                type="submit"
                                disabled={loading}
                                style={{
                                    marginTop: '0.25rem', padding: '0.75rem', borderRadius: '6px', border: 'none',
                                    background: loading ? '#475569' : '#0ea5e9',
                                    color: 'white', fontWeight: 'bold', cursor: loading ? 'not-allowed' : 'pointer'
                                }}
                            >
                                {loading ? 'Processing...' : (isRequestMode ? 'Create Account' : 'Sign In')}
                            </button>
                        </form>

                        <div style={{ textAlign: 'center', marginTop: '1.25rem' }}>
                            <button
                                onClick={() => setIsRequestMode(!isRequestMode)}
                                style={{ background: 'none', border: 'none', color: '#94a3b8', fontSize: '0.9rem', cursor: 'pointer' }}
                            >
                                {isRequestMode ? (
                                    <>Already have an account? <span style={{ color: '#38bdf8', textDecoration: 'underline' }}>Sign In</span></>
                                ) : (
                                    <>New here? <span style={{ color: '#10b981', textDecoration: 'underline' }}>Request Access</span></>
                                )}
                            </button>
                        </div>

                        {isRequestMode && (
                            <div style={{ marginTop: '1rem', padding: '0.75rem', background: 'rgba(16, 185, 129, 0.1)', borderRadius: '6px', fontSize: '0.8rem', color: '#6ee7b7', textAlign: 'center' }}>
                                After signing up, you'll complete a brief request form for approval.
                            </div>
                        )}

                        <div style={{ textAlign: 'center', marginTop: '1.5rem', paddingTop: '1rem', borderTop: '1px solid #334155' }}>
                            <button
                                type="button"
                                onClick={() => {
                                    localStorage.clear();
                                    sessionStorage.clear();
                                    alert("Local data cleared. Please refresh the page.");
                                    window.location.reload();
                                }}
                                style={{ background: 'transparent', border: 'none', color: '#475569', fontSize: '0.7rem', textDecoration: 'underline', cursor: 'pointer' }}
                            >
                                Reset Application Data
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const SchoolOnboardingWizard = ({ user, onComplete }) => {
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState('');

            // Data State
            const [schoolName, setSchoolName] = useState('');
            const [mascot, setMascot] = useState('');
            const [zipCode, setZipCode] = useState('');
            const [primaryColor, setPrimaryColor] = useState('#000000');
            const [secondaryColor, setSecondaryColor] = useState('#ffffff');

            // Default Positions (Hidden from wizard, used as defaults)
            const [offensePositions] = useState([
                { name: 'QB', type: 'QB' },
                { name: 'RB', type: 'RB' },
                { name: 'WR', type: 'WR' },
                { name: 'TE', type: 'TE' },
                { name: 'LT', type: 'OL' },
                { name: 'LG', type: 'OL' },
                { name: 'C', type: 'OL' },
                { name: 'RG', type: 'OL' },
                { name: 'RT', type: 'OL' }
            ]);

            const [defensePositions] = useState([
                { name: 'DL', type: 'DL' },
                { name: 'LB', type: 'LB' },
                { name: 'DB', type: 'DB' },
                { name: 'S', type: 'DB' }
            ]);

            const handleSave = async () => {
                if (!schoolName || !mascot || !zipCode) {
                    setError('Please fill in all fields (School Name, Mascot, Zip Code).');
                    return;
                }

                setLoading(true);
                setError('');
                try {
                    // 1. Create School Document
                    const schoolData = {
                        name: schoolName,
                        mascot: mascot,
                        zipCode: zipCode,
                        colors: { primary: primaryColor, secondary: secondaryColor },
                        settings: {
                            schoolName: schoolName,
                            mascot: mascot,
                            zipCode: zipCode,
                            accentColor: primaryColor, // Use primary as accent
                            offensePositions: offensePositions,
                            defensePositions: defensePositions,
                            activeYear: new Date().getFullYear().toString(),
                            theme: 'dark', // Default
                            initialized: true,
                            createdAt: new Date().toISOString(),
                            createdBy: user.uid
                        },
                        // Initialize empty collections/structures if needed
                        roster: [],
                        plays: {}, // Empty library
                        staff: [{
                            email: user.email,
                            role: 'Head Coach',
                            name: user.displayName || 'Coach',
                            uid: user.uid,
                            permissions: ['ADMIN']
                        }]
                    };

                    const schoolRef = await window.db.collection('schools').add(schoolData);
                    const schoolId = schoolRef.id;

                    // 2. Update User Profile with School ID
                    const userRef = window.db.collection('users').doc(user.uid);
                    await userRef.set({
                        schoolId: schoolId,
                        role: 'Head Coach',
                        email: user.email
                    }, { merge: true });

                    // 3. VERIFY WRITE (Retry logic to prevent race conditions on reload)
                    let confirmed = false;
                    let attempts = 0;
                    while (!confirmed && attempts < 5) {
                        try {
                            const checkDoc = await userRef.get({ source: 'server' }); // Force server check
                            if (checkDoc.exists && checkDoc.data().schoolId === schoolId) {
                                confirmed = true;
                            } else {
                                await new Promise(r => setTimeout(r, 1000));
                            }
                        } catch (e) {
                            console.warn("Verification check failed, retrying...");
                            await new Promise(r => setTimeout(r, 1000));
                        }
                        attempts++;
                    }

                    console.log("School Created & Verified:", schoolId);

                    // Force local storage update nicely
                    localStorage.setItem('hc_school_id', schoolId);

                    onComplete(schoolId);

                } catch (err) {
                    console.error("Error creating school:", err);
                    setError("Failed to create school: " + err.message);
                    setLoading(false);
                }
            };

            return (
                <div style={{
                    height: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center',
                    background: 'linear-gradient(135deg, #0f172a 0%, #1e293b 100%)', color: 'white'
                }}>
                    <div style={{ background: '#1e293b', padding: '2rem', borderRadius: '12px', width: '100%', maxWidth: '500px', boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.25)' }}>
                        <h1 style={{ fontSize: '1.5rem', fontWeight: 'bold', marginBottom: '1rem', textAlign: 'center', color: '#38bdf8' }}>
                            Welcome to DoFO!
                        </h1>
                        <p style={{ textAlign: 'center', color: '#94a3b8', marginBottom: '2rem' }}>
                            Let&apos;s get your team set up in seconds.
                        </p>

                        {error && <div style={{ background: '#7f1d1d', color: '#fca5a5', padding: '1rem', borderRadius: '8px', marginBottom: '1rem' }}>{error}</div>}

                        {/* Single Step Form */}
                        <div>
                            <div style={{ marginBottom: '1rem' }}>
                                <label style={{ display: 'block', marginBottom: '0.5rem', color: '#cbd5e1' }}>School Name</label>
                                <input
                                    value={schoolName} onChange={e => setSchoolName(e.target.value)}
                                    style={{ width: '100%', padding: '0.75rem', borderRadius: '6px', background: '#0f172a', border: '1px solid #475569', color: 'white' }}
                                    placeholder="e.g. East Dillon Lions"
                                />
                            </div>

                            <div style={{ display: 'flex', gap: '1rem', marginBottom: '1rem' }}>
                                <div style={{ flex: 1 }}>
                                    <label style={{ display: 'block', marginBottom: '0.5rem', color: '#cbd5e1' }}>Mascot</label>
                                    <input
                                        value={mascot} onChange={e => setMascot(e.target.value)}
                                        style={{ width: '100%', padding: '0.75rem', borderRadius: '6px', background: '#0f172a', border: '1px solid #475569', color: 'white' }}
                                        placeholder="e.g. Lions"
                                    />
                                </div>
                                <div style={{ flex: 1 }}>
                                    <label style={{ display: 'block', marginBottom: '0.5rem', color: '#cbd5e1' }}>Zip Code</label>
                                    <input
                                        value={zipCode} onChange={e => setZipCode(e.target.value)}
                                        style={{ width: '100%', padding: '0.75rem', borderRadius: '6px', background: '#0f172a', border: '1px solid #475569', color: 'white' }}
                                        placeholder="e.g. 90210"
                                    />
                                </div>
                            </div>

                            <div style={{ display: 'flex', gap: '1rem', marginBottom: '2rem' }}>
                                <div style={{ flex: 1 }}>
                                    <label style={{ display: 'block', marginBottom: '0.5rem', color: '#cbd5e1' }}>School Colors</label>
                                    <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center', background: '#0f172a', padding: '0.5rem', borderRadius: '6px', border: '1px solid #475569' }}>
                                        <input type="color" value={primaryColor} onChange={e => setPrimaryColor(e.target.value)} style={{ border: 'none', width: '32px', height: '32px', cursor: 'pointer', background: 'none' }} />
                                        <span style={{ fontSize: '0.85rem', color: '#94a3b8' }}>Primary</span>
                                    </div>
                                </div>
                                <div style={{ flex: 1 }}>
                                    <label style={{ display: 'block', marginBottom: '0.5rem', color: '#cbd5e1' }}>&nbsp;</label>
                                    <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center', background: '#0f172a', padding: '0.5rem', borderRadius: '6px', border: '1px solid #475569' }}>
                                        <input type="color" value={secondaryColor} onChange={e => setSecondaryColor(e.target.value)} style={{ border: 'none', width: '32px', height: '32px', cursor: 'pointer', background: 'none' }} />
                                        <span style={{ fontSize: '0.85rem', color: '#94a3b8' }}>Secondary</span>
                                    </div>
                                </div>
                            </div>

                            <button
                                onClick={handleSave}
                                disabled={loading}
                                style={{
                                    width: '100%',
                                    padding: '0.75rem 2rem', background: '#0ea5e9',
                                    border: 'none', color: 'white', borderRadius: '6px', fontWeight: 'bold', cursor: loading ? 'wait' : 'pointer',
                                    fontSize: '1rem'
                                }}
                            >
                                {loading ? 'Creating School...' : 'Complete Setup'}
                            </button>
                        </div>
                    </div>
                </div>
            )
        };

        // --- ACCESS REQUEST SYSTEM ---

        // Form for new users to request access
        const AccessRequestForm = ({ user, onSubmit }) => {
            const [loading, setLoading] = useState(false);
            const [checking, setChecking] = useState(true);
            const [existingRequest, setExistingRequest] = useState(null);
            const [formData, setFormData] = useState({
                name: user?.displayName || '',
                schoolName: '',
                role: 'Head Coach',
                phone: '',
                howHeard: ''
            });
            const [error, setError] = useState('');

            // Check for existing request on mount
            useEffect(() => {
                const checkExisting = async () => {
                    try {
                        const doc = await window.db.collection('access_requests').doc(user.email.toLowerCase()).get({ source: 'server' });
                        if (doc.exists) {
                            const data = doc.data();
                            console.log("AccessRequestForm: Found existing request with status:", data.status);
                            setExistingRequest(data);
                            // If there's an existing request with a non-null status, notify parent
                            if (data.status) {
                                onSubmit(data.status);
                            }
                        }
                    } catch (err) {
                        console.warn("Error checking existing request:", err);
                    }
                    setChecking(false);
                };
                checkExisting();
            }, [user.email]);

            const handleSubmit = async (e) => {
                e.preventDefault();
                if (!formData.name || !formData.schoolName) {
                    setError('Please fill in your name and school name.');
                    return;
                }

                setLoading(true);
                setError('');

                try {
                    // Double-check for existing request before submitting
                    const existingDoc = await window.db.collection('access_requests').doc(user.email.toLowerCase()).get();
                    if (existingDoc.exists && existingDoc.data().status) {
                        const existingStatus = existingDoc.data().status;
                        console.log("Request already exists with status:", existingStatus);
                        onSubmit(existingStatus);
                        return;
                    }

                    const requestData = {
                        ...formData,
                        email: user.email,
                        uid: user.uid,
                        status: 'pending',
                        submittedAt: new Date().toISOString(),
                        reviewedAt: null,
                        reviewedBy: null,
                        notes: ''
                    };

                    // Use email as document ID for easy lookup
                    await window.db.collection('access_requests').doc(user.email.toLowerCase()).set(requestData);

                    onSubmit('pending');
                } catch (err) {
                    console.error('Error submitting request:', err);
                    setError(`Failed to submit request: ${err.message || 'Unknown error'}. Please try again or contact support.`);
                }
                setLoading(false);
            };

            // Show loading while checking for existing request
            if (checking) {
                return (
                    <div style={{
                        height: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center',
                        background: 'linear-gradient(135deg, #0f172a 0%, #1e293b 100%)', color: 'white'
                    }}>
                        <div style={{ textAlign: 'center' }}>
                            <div style={{ fontSize: '1.5rem', marginBottom: '1rem' }}>Checking access status...</div>
                        </div>
                    </div>
                );
            }

            return (
                <div style={{
                    height: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center',
                    background: 'linear-gradient(135deg, #0f172a 0%, #1e293b 100%)', color: 'white'
                }}>
                    <div style={{ background: '#1e293b', padding: '2rem', borderRadius: '12px', width: '100%', maxWidth: '500px', boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.25)' }}>
                        <h1 style={{ fontSize: '1.5rem', fontWeight: 'bold', marginBottom: '0.5rem', textAlign: 'center', color: '#38bdf8' }}>
                            Request Access to DoFO
                        </h1>
                        <p style={{ textAlign: 'center', color: '#94a3b8', marginBottom: '2rem', fontSize: '0.9rem' }}>
                            Tell us about your program and we'll get you set up.
                        </p>

                        {error && <div style={{ background: '#7f1d1d', color: '#fca5a5', padding: '1rem', borderRadius: '8px', marginBottom: '1rem' }}>{error}</div>}

                        <form onSubmit={handleSubmit}>
                            <div style={{ marginBottom: '1rem' }}>
                                <label style={{ display: 'block', marginBottom: '0.5rem', color: '#cbd5e1' }}>Your Name *</label>
                                <input
                                    value={formData.name}
                                    onChange={e => setFormData({ ...formData, name: e.target.value })}
                                    style={{ width: '100%', padding: '0.75rem', borderRadius: '6px', background: '#0f172a', border: '1px solid #475569', color: 'white', boxSizing: 'border-box' }}
                                    placeholder="e.g. Coach Smith"
                                />
                            </div>

                            <div style={{ marginBottom: '1rem' }}>
                                <label style={{ display: 'block', marginBottom: '0.5rem', color: '#cbd5e1' }}>School / Program Name *</label>
                                <input
                                    value={formData.schoolName}
                                    onChange={e => setFormData({ ...formData, schoolName: e.target.value })}
                                    style={{ width: '100%', padding: '0.75rem', borderRadius: '6px', background: '#0f172a', border: '1px solid #475569', color: 'white', boxSizing: 'border-box' }}
                                    placeholder="e.g. East Dillon High School"
                                />
                            </div>

                            <div style={{ display: 'flex', gap: '1rem', marginBottom: '1rem' }}>
                                <div style={{ flex: 1 }}>
                                    <label style={{ display: 'block', marginBottom: '0.5rem', color: '#cbd5e1' }}>Your Role</label>
                                    <select
                                        value={formData.role}
                                        onChange={e => setFormData({ ...formData, role: e.target.value })}
                                        style={{ width: '100%', padding: '0.75rem', borderRadius: '6px', background: '#0f172a', border: '1px solid #475569', color: 'white' }}
                                    >
                                        <option value="Head Coach">Head Coach</option>
                                        <option value="Offensive Coordinator">Offensive Coordinator</option>
                                        <option value="Defensive Coordinator">Defensive Coordinator</option>
                                        <option value="Position Coach">Position Coach</option>
                                        <option value="Director of Operations">Director of Operations</option>
                                        <option value="Other">Other</option>
                                    </select>
                                </div>
                                <div style={{ flex: 1 }}>
                                    <label style={{ display: 'block', marginBottom: '0.5rem', color: '#cbd5e1' }}>Phone (optional)</label>
                                    <input
                                        value={formData.phone}
                                        onChange={e => setFormData({ ...formData, phone: e.target.value })}
                                        style={{ width: '100%', padding: '0.75rem', borderRadius: '6px', background: '#0f172a', border: '1px solid #475569', color: 'white', boxSizing: 'border-box' }}
                                        placeholder="555-123-4567"
                                    />
                                </div>
                            </div>

                            <div style={{ marginBottom: '1.5rem' }}>
                                <label style={{ display: 'block', marginBottom: '0.5rem', color: '#cbd5e1' }}>How did you hear about us?</label>
                                <select
                                    value={formData.howHeard}
                                    onChange={e => setFormData({ ...formData, howHeard: e.target.value })}
                                    style={{ width: '100%', padding: '0.75rem', borderRadius: '6px', background: '#0f172a', border: '1px solid #475569', color: 'white' }}
                                >
                                    <option value="">Select...</option>
                                    <option value="Coaching Clinic">Coaching Clinic</option>
                                    <option value="Another Coach">Another Coach</option>
                                    <option value="Social Media">Social Media</option>
                                    <option value="Google Search">Google Search</option>
                                    <option value="Other">Other</option>
                                </select>
                            </div>

                            <button
                                type="submit"
                                disabled={loading}
                                style={{
                                    width: '100%', padding: '1rem', background: '#38bdf8', color: '#0f172a',
                                    border: 'none', borderRadius: '8px', fontWeight: 'bold', fontSize: '1rem',
                                    cursor: loading ? 'not-allowed' : 'pointer', opacity: loading ? 0.7 : 1
                                }}
                            >
                                {loading ? 'Submitting...' : 'Request Access'}
                            </button>
                        </form>

                        <p style={{ textAlign: 'center', color: '#64748b', marginTop: '1.5rem', fontSize: '0.8rem' }}>
                            Signed in as {user?.email}
                            <br />
                            <button
                                onClick={() => window.auth.signOut()}
                                style={{ background: 'none', border: 'none', color: '#94a3b8', textDecoration: 'underline', cursor: 'pointer', marginTop: '0.5rem' }}
                            >
                                Sign out
                            </button>
                        </p>
                    </div>
                </div>
            );
        };

        // Screen shown while waiting for approval
        const PendingApprovalScreen = ({ user, requestData }) => {
            const submittedDate = requestData?.submittedAt ? new Date(requestData.submittedAt).toLocaleDateString() : 'recently';

            return (
                <div style={{
                    height: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center',
                    background: 'linear-gradient(135deg, #0f172a 0%, #1e293b 100%)', color: 'white'
                }}>
                    <div style={{ background: '#1e293b', padding: '2rem', borderRadius: '12px', width: '100%', maxWidth: '500px', textAlign: 'center', boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.25)' }}>
                        <div style={{ fontSize: '4rem', marginBottom: '1rem' }}>⏳</div>
                        <h1 style={{ fontSize: '1.5rem', fontWeight: 'bold', marginBottom: '0.5rem', color: '#38bdf8' }}>
                            Request Pending
                        </h1>
                        <p style={{ color: '#94a3b8', marginBottom: '1.5rem' }}>
                            Thanks for your interest in DoFO! We received your request on {submittedDate} and will review it shortly.
                        </p>

                        <div style={{ background: '#0f172a', padding: '1rem', borderRadius: '8px', marginBottom: '1.5rem', textAlign: 'left' }}>
                            <div style={{ color: '#64748b', fontSize: '0.8rem', marginBottom: '0.5rem' }}>YOUR REQUEST</div>
                            <div style={{ color: '#e2e8f0' }}><strong>{requestData?.name}</strong></div>
                            <div style={{ color: '#94a3b8' }}>{requestData?.schoolName}</div>
                            <div style={{ color: '#94a3b8', fontSize: '0.9rem' }}>{requestData?.role}</div>
                        </div>

                        <p style={{ color: '#64748b', fontSize: '0.85rem', marginBottom: '1rem' }}>
                            We typically respond within 24 hours. Check your email for updates!
                        </p>

                        <button
                            onClick={() => window.location.reload()}
                            style={{ background: '#334155', border: 'none', color: '#94a3b8', padding: '0.75rem 1.5rem', borderRadius: '6px', cursor: 'pointer', marginRight: '0.5rem' }}
                        >
                            Refresh Status
                        </button>
                        <button
                            onClick={() => window.auth.signOut()}
                            style={{ background: 'none', border: '1px solid #475569', color: '#94a3b8', padding: '0.75rem 1.5rem', borderRadius: '6px', cursor: 'pointer' }}
                        >
                            Sign Out
                        </button>
                    </div>
                </div>
            );
        };

        // Admin panel for reviewing access requests
        const AccessRequestsAdmin = ({ currentUser }) => {
            const [requests, setRequests] = useState([]);
            const [loading, setLoading] = useState(true);
            const [filter, setFilter] = useState('pending'); // 'pending' | 'approved' | 'rejected' | 'all'
            const [editingRequest, setEditingRequest] = useState(null);
            const [editForm, setEditForm] = useState({ trialDays: '', accessExpiresAt: '', notes: '' });

            useEffect(() => {
                const loadRequests = async () => {
                    try {
                        const snapshot = await window.db.collection('access_requests').orderBy('submittedAt', 'desc').get();
                        const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        setRequests(data);
                    } catch (err) {
                        console.error('Error loading requests:', err);
                    }
                    setLoading(false);
                };
                loadRequests();
            }, []);

            const handleApprove = async (request) => {
                const daysInput = prompt(`Approve ${request.name} (${request.schoolName})?\n\nEnter number of trial days to grant:`, '7');
                if (daysInput === null) return; // Cancelled

                const trialDays = parseInt(daysInput, 10);
                if (isNaN(trialDays) || trialDays < 1) {
                    alert('Please enter a valid number of days (minimum 1).');
                    return;
                }

                try {
                    const now = new Date();
                    const accessExpiresAt = new Date(now.getTime() + trialDays * 24 * 60 * 60 * 1000);
                    // Data gets removed 30 days after access expires (grace period)
                    const dataExpiresAt = new Date(accessExpiresAt.getTime() + 30 * 24 * 60 * 60 * 1000);

                    // Update request status
                    await window.db.collection('access_requests').doc(request.id).update({
                        status: 'approved',
                        reviewedAt: now.toISOString(),
                        reviewedBy: currentUser?.email || 'admin',
                        trialDays: trialDays,
                        accessExpiresAt: accessExpiresAt.toISOString(),
                        dataExpiresAt: dataExpiresAt.toISOString()
                    });

                    // Update local state
                    setRequests(prev => prev.map(r =>
                        r.id === request.id
                            ? { ...r, status: 'approved', reviewedAt: now.toISOString(), trialDays, accessExpiresAt: accessExpiresAt.toISOString() }
                            : r
                    ));

                    alert(`Approved! ${request.name} has ${trialDays} days of access (until ${accessExpiresAt.toLocaleDateString()}).`);
                } catch (err) {
                    console.error('Error approving:', err);
                    alert('Failed to approve. Check console.');
                }
            };

            const handleReject = async (request) => {
                const reason = prompt('Rejection reason (optional):');
                if (reason === null) return; // Cancelled

                try {
                    await window.db.collection('access_requests').doc(request.id).update({
                        status: 'rejected',
                        reviewedAt: new Date().toISOString(),
                        reviewedBy: currentUser?.email || 'admin',
                        notes: reason
                    });

                    setRequests(prev => prev.map(r =>
                        r.id === request.id
                            ? { ...r, status: 'rejected', reviewedAt: new Date().toISOString(), notes: reason }
                            : r
                    ));
                } catch (err) {
                    console.error('Error rejecting:', err);
                    alert('Failed to reject. Check console.');
                }
            };

            const handleEdit = (request) => {
                setEditForm({
                    trialDays: request.trialDays || '',
                    accessExpiresAt: request.accessExpiresAt ? request.accessExpiresAt.split('T')[0] : '',
                    notes: request.notes || ''
                });
                setEditingRequest(request);
            };

            const handleSaveEdit = async () => {
                if (!editingRequest) return;
                try {
                    const updates = {
                        notes: editForm.notes || ''
                    };

                    if (editForm.accessExpiresAt) {
                        updates.accessExpiresAt = new Date(editForm.accessExpiresAt).toISOString();
                        // Recalculate data deletion date (30 days after access expires)
                        updates.dataExpiresAt = new Date(new Date(editForm.accessExpiresAt).getTime() + 30 * 24 * 60 * 60 * 1000).toISOString();
                    }

                    if (editForm.trialDays) {
                        updates.trialDays = parseInt(editForm.trialDays, 10);
                    }

                    await window.db.collection('access_requests').doc(editingRequest.id).update(updates);

                    setRequests(prev => prev.map(r =>
                        r.id === editingRequest.id ? { ...r, ...updates } : r
                    ));

                    setEditingRequest(null);
                    alert('Access request updated successfully.');
                } catch (err) {
                    console.error('Error updating request:', err);
                    alert('Failed to update. Check console.');
                }
            };

            const filteredRequests = filter === 'all'
                ? requests
                : requests.filter(r => r.status === filter);

            const statusCounts = {
                pending: requests.filter(r => r.status === 'pending').length,
                approved: requests.filter(r => r.status === 'approved').length,
                rejected: requests.filter(r => r.status === 'rejected').length,
                archived: requests.filter(r => r.status === 'archived').length
            };

            if (loading) {
                return <div style={{ padding: '2rem', textAlign: 'center', color: 'var(--text-secondary)' }}>Loading requests...</div>;
            }

            return (
                <div style={{ padding: '1rem' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                        <h2 style={{ margin: 0 }}>Access Requests</h2>
                        <div style={{ display: 'flex', gap: '0.5rem' }}>
                            {['pending', 'approved', 'rejected', 'archived', 'all'].map(f => (
                                <button
                                    key={f}
                                    onClick={() => setFilter(f)}
                                    style={{
                                        padding: '0.5rem 1rem',
                                        background: filter === f ? 'var(--accent)' : 'var(--surface)',
                                        color: filter === f ? 'white' : 'var(--text-secondary)',
                                        border: '1px solid var(--border)',
                                        borderRadius: '6px',
                                        cursor: 'pointer',
                                        textTransform: 'capitalize'
                                    }}
                                >
                                    {f} {f !== 'all' && `(${statusCounts[f]})`}
                                </button>
                            ))}
                        </div>
                    </div>

                    {filteredRequests.length === 0 ? (
                        <div style={{ padding: '3rem', textAlign: 'center', color: 'var(--text-secondary)', background: 'var(--surface)', borderRadius: '8px' }}>
                            No {filter === 'all' ? '' : filter} requests found.
                        </div>
                    ) : (
                        <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                            {filteredRequests.map(request => (
                                <div
                                    key={request.id}
                                    style={{
                                        background: 'var(--surface)',
                                        padding: '1.25rem',
                                        borderRadius: '8px',
                                        border: request.status === 'pending' ? '2px solid var(--accent)' : '1px solid var(--border)'
                                    }}
                                >
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                                        <div>
                                            <div style={{ fontWeight: 'bold', fontSize: '1.1rem' }}>{request.name}</div>
                                            <div style={{ color: 'var(--text-secondary)' }}>{request.schoolName}</div>
                                            <div style={{ color: 'var(--text-secondary)', fontSize: '0.85rem', marginTop: '0.25rem' }}>
                                                {request.role} &bull; {request.email}
                                                {request.phone && ` &bull; ${request.phone}`}
                                            </div>
                                            {request.howHeard && (
                                                <div style={{ color: 'var(--text-secondary)', fontSize: '0.8rem', marginTop: '0.25rem' }}>
                                                    Source: {request.howHeard}
                                                </div>
                                            )}
                                            <div style={{ color: 'var(--text-secondary)', fontSize: '0.75rem', marginTop: '0.5rem' }}>
                                                Submitted: {new Date(request.submittedAt).toLocaleString()}
                                                {request.reviewedAt && ` | Reviewed: ${new Date(request.reviewedAt).toLocaleString()}`}
                                            </div>
                                            {request.notes && (
                                                <div style={{ color: '#f59e0b', fontSize: '0.8rem', marginTop: '0.25rem' }}>
                                                    Note: {request.notes}
                                                </div>
                                            )}
                                            {request.status === 'approved' && request.accessExpiresAt && (
                                                <div style={{
                                                    marginTop: '0.5rem',
                                                    padding: '0.5rem',
                                                    background: new Date(request.accessExpiresAt) < new Date() ? '#7f1d1d' : '#14532d',
                                                    borderRadius: '4px',
                                                    fontSize: '0.8rem'
                                                }}>
                                                    <span style={{ color: new Date(request.accessExpiresAt) < new Date() ? '#fca5a5' : '#86efac' }}>
                                                        {request.trialDays} day trial &bull;
                                                        {new Date(request.accessExpiresAt) < new Date()
                                                            ? ` Expired ${new Date(request.accessExpiresAt).toLocaleDateString()}`
                                                            : ` Expires ${new Date(request.accessExpiresAt).toLocaleDateString()}`
                                                        }
                                                        {request.dataExpiresAt && ` &bull; Data deletion: ${new Date(request.dataExpiresAt).toLocaleDateString()}`}
                                                    </span>
                                                </div>
                                            )}
                                        </div>
                                        <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center' }}>
                                            {request.status === 'pending' ? (
                                                <>
                                                    <button
                                                        onClick={() => handleApprove(request)}
                                                        style={{
                                                            padding: '0.5rem 1rem',
                                                            background: '#22c55e',
                                                            color: 'white',
                                                            border: 'none',
                                                            borderRadius: '6px',
                                                            cursor: 'pointer',
                                                            fontWeight: 'bold'
                                                        }}
                                                    >
                                                        Approve
                                                    </button>
                                                    <button
                                                        onClick={() => handleReject(request)}
                                                        style={{
                                                            padding: '0.5rem 1rem',
                                                            background: '#ef4444',
                                                            color: 'white',
                                                            border: 'none',
                                                            borderRadius: '6px',
                                                            cursor: 'pointer'
                                                        }}
                                                    >
                                                        Reject
                                                    </button>
                                                </>
                                            ) : request.status === 'archived' ? (
                                                <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-end', gap: '0.5rem' }}>
                                                    <span style={{
                                                        padding: '0.5rem 1rem',
                                                        background: '#374151',
                                                        color: '#9ca3af',
                                                        borderRadius: '6px',
                                                        fontSize: '0.85rem',
                                                        textTransform: 'uppercase'
                                                    }}>
                                                        ARCHIVED
                                                    </span>
                                                    <button
                                                        onClick={async () => {
                                                            if (!window.confirm(`Restore access for ${request.name}? They will need to create a new school.`)) return;
                                                            try {
                                                                await window.db.collection('access_requests').doc(request.id).update({
                                                                    status: 'approved',
                                                                    restoredAt: new Date().toISOString()
                                                                });
                                                                setRequests(prev => prev.map(r =>
                                                                    r.id === request.id ? { ...r, status: 'approved' } : r
                                                                ));
                                                                alert('Access restored. User can now create a new school.');
                                                            } catch (err) {
                                                                console.error('Error restoring:', err);
                                                                alert('Failed to restore. Check console.');
                                                            }
                                                        }}
                                                        style={{
                                                            padding: '0.25rem 0.75rem',
                                                            background: '#3b82f6',
                                                            color: 'white',
                                                            border: 'none',
                                                            borderRadius: '4px',
                                                            fontSize: '0.75rem',
                                                            cursor: 'pointer'
                                                        }}
                                                    >
                                                        Restore Access
                                                    </button>
                                                </div>
                                            ) : (
                                                <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-end', gap: '0.5rem' }}>
                                                    <span style={{
                                                        padding: '0.5rem 1rem',
                                                        background: request.status === 'approved' ? '#166534' : '#7f1d1d',
                                                        color: request.status === 'approved' ? '#86efac' : '#fca5a5',
                                                        borderRadius: '6px',
                                                        fontSize: '0.85rem',
                                                        textTransform: 'uppercase'
                                                    }}>
                                                        {request.status}
                                                    </span>
                                                    {request.status === 'approved' && (
                                                        <button
                                                            onClick={() => handleEdit(request)}
                                                            style={{
                                                                padding: '0.25rem 0.75rem',
                                                                background: 'transparent',
                                                                border: '1px solid var(--border)',
                                                                color: 'var(--text-secondary)',
                                                                borderRadius: '4px',
                                                                fontSize: '0.75rem',
                                                                cursor: 'pointer'
                                                            }}
                                                        >
                                                            Edit
                                                        </button>
                                                    )}
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}

                    {/* Edit Modal */}
                    {editingRequest && (
                        <div style={{
                            position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
                            background: 'rgba(0,0,0,0.7)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000
                        }}>
                            <div style={{ background: 'var(--surface)', padding: '1.5rem', borderRadius: '12px', width: '100%', maxWidth: '450px' }}>
                                <h3 style={{ margin: '0 0 1rem 0' }}>Edit Access Request</h3>
                                <p style={{ color: 'var(--text-secondary)', marginBottom: '1rem' }}>
                                    {editingRequest.name} ({editingRequest.email})
                                </p>

                                <div style={{ marginBottom: '1rem' }}>
                                    <label style={{ display: 'block', marginBottom: '0.25rem', fontSize: '0.85rem', color: 'var(--text-secondary)' }}>Trial Days</label>
                                    <input
                                        type="number"
                                        value={editForm.trialDays}
                                        onChange={(e) => setEditForm(prev => ({ ...prev, trialDays: e.target.value }))}
                                        style={{
                                            width: '100%', padding: '0.5rem', background: 'var(--bg)', border: '1px solid var(--border)',
                                            borderRadius: '6px', color: 'var(--text)'
                                        }}
                                    />
                                </div>

                                <div style={{ marginBottom: '1rem' }}>
                                    <label style={{ display: 'block', marginBottom: '0.25rem', fontSize: '0.85rem', color: 'var(--text-secondary)' }}>Access Expires</label>
                                    <input
                                        type="date"
                                        value={editForm.accessExpiresAt}
                                        onChange={(e) => setEditForm(prev => ({ ...prev, accessExpiresAt: e.target.value }))}
                                        style={{
                                            width: '100%', padding: '0.5rem', background: 'var(--bg)', border: '1px solid var(--border)',
                                            borderRadius: '6px', color: 'var(--text)'
                                        }}
                                    />
                                    <p style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', marginTop: '0.25rem' }}>
                                        Data will be deleted 30 days after this date.
                                    </p>
                                </div>

                                <div style={{ marginBottom: '1.5rem' }}>
                                    <label style={{ display: 'block', marginBottom: '0.25rem', fontSize: '0.85rem', color: 'var(--text-secondary)' }}>Notes</label>
                                    <textarea
                                        value={editForm.notes}
                                        onChange={(e) => setEditForm(prev => ({ ...prev, notes: e.target.value }))}
                                        rows={2}
                                        style={{
                                            width: '100%', padding: '0.5rem', background: 'var(--bg)', border: '1px solid var(--border)',
                                            borderRadius: '6px', color: 'var(--text)', resize: 'vertical'
                                        }}
                                    />
                                </div>

                                <div style={{ display: 'flex', gap: '0.5rem', justifyContent: 'flex-end' }}>
                                    <button
                                        onClick={() => setEditingRequest(null)}
                                        style={{ padding: '0.5rem 1rem', background: 'var(--bg)', border: '1px solid var(--border)', borderRadius: '6px', cursor: 'pointer', color: 'var(--text)' }}
                                    >
                                        Cancel
                                    </button>
                                    <button
                                        onClick={handleSaveEdit}
                                        style={{ padding: '0.5rem 1rem', background: 'var(--accent)', color: 'white', border: 'none', borderRadius: '6px', cursor: 'pointer' }}
                                    >
                                        Save Changes
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- Data & Constants ---

        const GAME_PLAN_LAYOUTS = {
            CALL_SHEET: [],
            MATRIX: {
                id: 'MATRIX',
                name: "Strike 'Em Out",
                cols: [
                    { id: 'FB_L', label: 'FB L', fullLabel: 'Base/Initial Left' },
                    { id: 'FB_R', label: 'FB R', fullLabel: 'Base/Initial Right' },
                    { id: 'CB_L', label: 'CB L', fullLabel: 'Base w/ Dressing Left' },
                    { id: 'CB_R', label: 'CB R', fullLabel: 'Base w/ Dressing Right' },
                    { id: 'CU_L', label: 'CU L', fullLabel: 'Convert Left' },
                    { id: 'CU_R', label: 'CU R', fullLabel: 'Convert Right' },
                    { id: 'SO_L', label: 'SO L', fullLabel: 'Explosive Left' },
                    { id: 'SO_R', label: 'SO R', fullLabel: 'Explosive Right' }
                ],
                formations: [
                    { id: '887', label: '887', color: '#ef4444' },
                    { id: '888', label: '888', color: '#ef4444' },
                    { id: '687', label: '687', color: '#fbbf24' },
                    { id: '688', label: '688', color: '#fbbf24' },
                    { id: '881', label: '881', color: '#facc15' },
                    { id: '984', label: '984', color: '#4ade80' },
                    { id: '983', label: '983', color: '#4ade80' },
                    { id: '488', label: '488', color: '#60a5fa' },
                    { id: '487', label: '487', color: '#60a5fa' },
                    { id: 'jets', label: 'Jets/Specials', color: '#a8a29e' }
                ],
                playTypes: [
                    { id: 'strong_run', label: 'STRONG RUN' },
                    { id: 'weak_run', label: 'WEAK RUN' },
                    { id: 'quick_game', label: 'QUICK GAME' },
                    { id: 'drop_back', label: 'DROPBACK' },
                    { id: 'gadget', label: 'GADGET' }
                ]
            }
        };

        // Built-in tag categories (minimal set - users can add custom categories)
        const TAG_CATEGORIES = {
            "Coverage Beaters": ["MOFO (Middle Open)", "MOFC (Middle Closed)", "Man Beater", "Zone Beater"],
            "Motion": [
                "Down motion",
                "THRU MO from 1x3 to 2x2",
                "THRU MO from 2x2 to 3x1",
                "Orbit MO from 1x3 to 2x2",
                "Orbit MO from 2x2 to 3x1",
                "RB push motion",
                "Zipper",
                "YAC",
                "YO-YO"
            ],
            "Primary Target": ["X", "A", "Z", "Y", "B", "Q", "F"],
            "Action Types": ["Strong Run", "Weak Run", "Quick Game", "Drop Back", "Screen", "Gadget"]
        };

        const HASH_PREFERENCES = ["Left", "Right", "Middle", "Any"];

        // New users start with empty plays array
        const INITIAL_PLAYS = [];

        // --- Components ---

        const Icon = ({ name, size = 20, color, style = {} }) => {
            const strokeColor = color || "currentColor";
            const iconStyle = { ...style, width: size, height: size, minWidth: size, minHeight: size };
            const commonProps = {
                xmlns: "http://www.w3.org/2000/svg",
                width: size,
                height: size,
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: strokeColor,
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                style: iconStyle
            };

            switch (name) {
                // -- Program Mgmt --
                case "Home": return <svg {...commonProps}><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" /><polyline points="9 22 9 12 15 12 15 22" /></svg>;
                case "Users": return <svg {...commonProps}><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" /><circle cx="9" cy="7" r="4" /><path d="M22 21v-2a4 4 0 0 0-3-3.87" /><path d="M16 3.13a4 4 0 0 1 0 7.75" /></svg>;
                case "Briefcase": return <svg {...commonProps}><rect width="20" height="14" x="2" y="6" rx="2" /><path d="M16 20V4a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16" /></svg>;
                case "ClipboardList": return <svg {...commonProps}><rect width="8" height="4" x="8" y="2" rx="1" ry="1" /><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" /><path d="M12 11h4" /><path d="M12 16h4" /><path d="M8 11h.01" /><path d="M8 16h.01" /></svg>;
                case "Calendar": return <svg {...commonProps}><rect width="18" height="18" x="3" y="4" rx="2" /><path d="M16 2v4" /><path d="M8 2v4" /><path d="M3 10h18" /></svg>;
                case "DollarSign": return <svg {...commonProps}><line x1="12" x2="12" y1="2" y2="22" /><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6" /></svg>;
                case "UserPlus": return <svg {...commonProps}><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" /><circle cx="9" cy="7" r="4" /><line x1="19" x2="19" y1="8" y2="14" /><line x1="22" x2="16" y1="11" y2="11" /></svg>;

                // -- Equipment --
                case "Package": return <svg {...commonProps}><path d="m7.5 4.27 9 5.15" /><path d="M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z" /><path d="m3.3 7 8.7 5 8.7-5" /><path d="M12 22v-9" /></svg>;
                case "ClipboardCheck": return <svg {...commonProps}><rect width="8" height="4" x="8" y="2" rx="1" ry="1" /><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" /><path d="m9 14 2 2 4-4" /></svg>;
                case "Trophy": return <svg {...commonProps}><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6" /><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18" /><path d="M4 22h16" /><path d="M10 14.66V17" /><path d="M14 14.66V17" /><path d="M12 2v8" /><path d="M12 22h0" /><path d="M12 10a4 4 0 0 0 4 4 4 4 0 0 0 4-4H4a4 4 0 0 0 4 4 4 4 0 0 0 4-4z" /></svg>;
                case "List": return <svg {...commonProps}><line x1="8" x2="21" y1="6" y2="6" /><line x1="8" x2="21" y1="12" y2="12" /><line x1="8" x2="21" y1="18" y2="18" /><line x1="3" x2="3.01" y1="6" y2="6" /><line x1="3" x2="3.01" y1="12" y2="12" /><line x1="3" x2="3.01" y1="18" y2="18" /></svg>;
                case "ShoppingCart": return <svg {...commonProps}><circle cx="8" cy="21" r="1" /><circle cx="19" cy="21" r="1" /><path d="M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12" /></svg>;

                // -- Apps --
                case "Smartphone": return <svg {...commonProps}><rect width="14" height="20" x="5" y="2" rx="2" ry="2" /><path d="M12 18h.01" /></svg>;
                case "UserCheck": return <svg {...commonProps}><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" /><circle cx="9" cy="7" r="4" /><polyline points="16 11 18 13 22 9" /></svg>;
                case "Clipboard": return <svg {...commonProps}><rect width="8" height="4" x="8" y="2" rx="1" ry="1" /><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" /></svg>;
                case "FileText": return <svg {...commonProps}><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7z" /><path d="M14 2v4a2 2 0 0 0 2 2h4" /><path d="M10 9H8" /><path d="M16 13H8" /><path d="M16 17H8" /></svg>;
                case "Gamepad2": return <svg {...commonProps}><line x1="6" x2="10" y1="12" y2="12" /><line x1="8" x2="8" y1="10" y2="14" /><line x1="15" x2="15.01" y1="13" y2="13" /><line x1="18" x2="18.01" y1="11" y2="11" /><rect width="20" height="12" x="2" y="6" rx="2" /></svg>;
                case "Monitor": return <svg {...commonProps}><rect width="20" height="14" x="2" y="3" rx="2" ry="2" /><line x1="8" x2="16" y1="21" y2="21" /><line x1="12" x2="12" y1="17" y2="21" /></svg>;
                case "Target": return <svg {...commonProps}><circle cx="12" cy="12" r="10" /><circle cx="12" cy="12" r="6" /><circle cx="12" cy="12" r="2" /></svg>;

                // -- Development --
                case "Activity": return <svg {...commonProps}><path d="M22 12h-4l-3 9L9 3l-3 9H2" /></svg>;
                case "Timer": return <svg {...commonProps}><line x1="10" x2="14" y1="2" y2="2" /><line x1="12" x2="15" y1="14" y2="11" /><circle cx="12" cy="14" r="8" /></svg>;
                case "Dumbbell": return <svg {...commonProps}><path d="m6.5 6.5 11 11" /><path d="m21 21-1-1" /><path d="m3 3 1 1" /><path d="m18 22 4-4" /><path d="m2 6 4-4" /><path d="m3 10 7-7" /><path d="m14 21 7-7" /></svg>;
                case "Swords": return <svg {...commonProps}><polyline points="14.5 17.5 3 6 3 3 6 3 17.5 14.5" /><line x1="13" x2="19" y1="19" y2="13" /><line x1="16" x2="20" y1="16" y2="20" /><line x1="19" x2="21" y1="21" y2="19" /><polyline points="14.5 6.5 18 3 21 3 21 6 17.5 9.5" /><line x1="5" x2="9" y1="14" y2="10" /><line x1="9" x2="11" y1="11" y2="13" /><line x1="12" x2="14" y1="14" y2="16" /></svg>;
                case "FileBarChart": return <svg {...commonProps}><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7z" /><path d="M14 2v4a2 2 0 0 0 2 2h4" /><path d="M8 12v-2" /><path d="M12 18v-6" /><path d="M16 14v-2" /></svg>;

                // -- Personnel --
                case "UserCog": return <svg {...commonProps}><circle cx="18" cy="15" r="3" /><circle cx="9" cy="7" r="4" /><path d="M10 15H6a4 4 0 0 0-4 4v2" /><path d="m21.7 16.4-.9-.3" /><path d="m15.2 13.9-.9-.3" /><path d="m16.6 18.7.3-.9" /><path d="m19.1 12.2.3-.9" /><path d="m19.6 18.7-.4-1" /><path d="m16.8 12.3-.4-1" /><path d="m14.3 16.6 1-.4" /><path d="m20.7 13.8 1-.4" /></svg>;
                case "User": return <svg {...commonProps}><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" /><circle cx="12" cy="7" r="4" /></svg>;

                // -- Game Week --
                case "CalendarClock": return <svg {...commonProps}><path d="M21 7.5V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h3.5" /><path d="M16 2v4" /><path d="M8 2v4" /><path d="M3 10h18" /><circle cx="18" cy="18" r="4" /><path d="M17 16l1 2 2 .5" /></svg>;
                case "Sun": return <svg {...commonProps}><circle cx="12" cy="12" r="4" /><path d="M12 2v2" /><path d="M12 20v2" /><path d="m4.93 4.93 1.41 1.41" /><path d="m17.66 17.66 1.41 1.41" /><path d="M2 12h2" /><path d="M20 12h2" /><path d="m6.34 17.66-1.41 1.41" /><path d="m19.07 4.93-1.41 1.41" /></svg>;
                case "Eye": return <svg {...commonProps}><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z" /><circle cx="12" cy="12" r="3" /></svg>;
                case "LayoutDashboard": return <svg {...commonProps}><rect width="7" height="9" x="3" y="3" rx="1" /><rect width="7" height="5" x="14" y="3" rx="1" /><rect width="7" height="9" x="14" y="12" rx="1" /><rect width="7" height="5" x="3" y="16" rx="1" /></svg>;
                case "Zap": return <svg {...commonProps}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2" /></svg>;
                case "PawPrint": return <svg {...commonProps}><circle cx="11" cy="4" r="2" /><circle cx="18" cy="8" r="2" /><circle cx="20" cy="15" r="2" /><path d="M5 20s2.05-2 5.04-2c2.99 0 5.16 2 5.16 2" /><circle cx="8" cy="13" r="3" /></svg>;
                case "Search": return <svg {...commonProps}><circle cx="11" cy="11" r="8" /><line x1="21" x2="16.65" y1="21" y2="16.65" /></svg>;
                case "PlusCircle": return <svg {...commonProps}><circle cx="12" cy="12" r="10" /><line x1="12" x2="12" y1="8" y2="16" /><line x1="8" x2="16" y1="12" y2="12" /></svg>;
                case "Watch": return <svg {...commonProps}><circle cx="12" cy="12" r="6" /><polyline points="12 10 12 12 13 13" /><path d="m16.13 7.66-.81-4.05a2 2 0 0 0-2-1.61h-2.68a2 2 0 0 0-2 1.61l-.78 4.05" /><path d="m7.88 16.36.8 4a2 2 0 0 0 2 1.61h2.72a2 2 0 0 0 2-1.61l.81-4.05" /></svg>;
                case "Megaphone": return <svg {...commonProps}><path d="m3 11 18-5v12L3 14v-3z" /><path d="M11.6 16.8a3 3 0 1 1-5.8-1.6" /></svg>;
                case "Whistle": return <svg {...commonProps}><path d="M11 3v8c-1.1 0-2 .9-2 2a3 3 0 0 0 3 3 3 3 0 0 0 3-3V3h-4z" /><path d="M15 9h3a3 3 0 0 1 3 3v2a1 1 0 0 1-1 1h-2" /><path d="M5.8 11.3L2 12l.7-3.8L5.8 11.3z" transform="rotate(-15 4 11)" /></svg>;

                // -- Scheme --
                case "Book": // Using BookOpen logic
                case "BookOpen": return <svg {...commonProps}><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z" /><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z" /></svg>;
                case "LayoutGrid": return <svg {...commonProps}><rect width="7" height="7" x="3" y="3" rx="1" /><rect width="7" height="7" x="14" y="3" rx="1" /><rect width="7" height="7" x="14" y="14" rx="1" /><rect width="7" height="7" x="3" y="14" rx="1" /></svg>; // Used for Formations
                case "Library": return <svg {...commonProps}><path d="m16 6 4 2 4-2" /><path d="M12 13V2.5A2.5 2.5 0 0 0 9.5 0S7 0 7 2.5V13" /><path d="M12 13V2.5A2.5 2.5 0 0 0 9.5 0S7 0 7 2.5V13" /><path d="M7 17v4a2.5 2.5 0 0 0 2.5 2.5C12 23.5 12 21 12 21" /><path d="M12 17v4a2.5 2.5 0 0 0 2.5 2.5C17 23.5 17 21 17 21" /></svg>;

                // -- Footer --
                case "Settings": return <svg {...commonProps}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.72l-.15.1a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.72l.15-.1a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z" /><circle cx="12" cy="12" r="3" /></svg>;
                case "Lock": return <svg {...commonProps}><rect width="18" height="11" x="3" y="11" rx="2" ry="2" /><path d="M7 11V7a5 5 0 0 1 10 0v4" /></svg>;
                case "Unlock": return <svg {...commonProps}><rect width="18" height="11" x="3" y="11" rx="2" ry="2" /><path d="M7 11V7a5 5 0 0 1 10 0v4" /></svg>; // Unlock is technically same icon in Lucide usually or open
                case "Pencil": return <svg {...commonProps}><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z" /><path d="m15 5 4 4" /></svg>;
                case "Trash2": return <svg {...commonProps}><path d="M3 6h18" /><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" /><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" /><line x1="10" x2="10" y1="11" y2="17" /><line x1="14" x2="14" y1="11" y2="17" /></svg>;
                case "HelpCircle": return <svg {...commonProps}><circle cx="12" cy="12" r="10" /><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3" /><line x1="12" x2="12.01" y1="17" y2="17" /></svg>;

                // -- Legacy / Others --
                case "X": return <svg {...commonProps}><path d="M18 6 6 18" /><path d="m6 6 12 12" /></svg>;
                case "ArrowLeft": return <svg {...commonProps}><path d="M19 12H5" /><path d="m12 19-7-7 7-7" /></svg>;
                case "ChevronDown": return <svg {...commonProps}><path d="m6 9 6 6 6-6" /></svg>;
                case "ChevronRight": return <svg {...commonProps}><path d="m9 18 6-6-6-6" /></svg>;
                case "ChevronUp": return <svg {...commonProps}><path d="m18 15-6-6-6 6" /></svg>;
                case "Chevron": // Fallback for shortened name?
                case "ChevronLeft": return <svg {...commonProps}><path d="m15 18-6-6 6-6" /></svg>;
                case "ChevronsRight": return <svg {...commonProps}><path d="m7 7 5 5-5 5" /><path d="m13 7 5 5-5 5" /></svg>;
                case "ChevronsLeft": return <svg {...commonProps}><path d="m11 17-5-5 5-5" /><path d="m18 17-5-5 5-5" /></svg>;

                case "Check": return <svg {...commonProps}><polyline points="20 6 9 17 4 12" /></svg>;
                case "Plus": return <svg {...commonProps}><path d="M5 12h14" /><path d="M12 5v14" /></svg>;
                case "Minus": return <svg {...commonProps}><path d="M5 12h14" /></svg>;

                // -- Missing Icons Added --
                case "Copy": return <svg {...commonProps}><rect x="9" y="9" width="13" height="13" rx="2" ry="2" /><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" /></svg>;
                case "MousePointer": return <svg {...commonProps}><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z" /><path d="M13 13l6 6" /></svg>;
                case "Edit3": return <svg {...commonProps}><path d="M12 20h9" /><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z" /></svg>;
                case "Trash": // Fallthrough to Trash2
                case "Trash2": return <svg {...commonProps}><path d="M3 6h18" /><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" /><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" /><line x1="10" x2="10" y1="11" y2="17" /><line x1="14" x2="14" y1="11" y2="17" /></svg>;
                case "Save": return <svg {...commonProps}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" /><polyline points="17 21 17 13 7 13 7 21" /><polyline points="7 3 7 8 15 8" /></svg>;
                case "RotateCcw": return <svg {...commonProps}><path d="M1 4v6h6" /><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10" /></svg>;
                case "RotateCw": return <svg {...commonProps}><path d="M23 4v6h-6" /><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10" /></svg>;
                case "RefreshCw": return <svg {...commonProps}><path d="M23 4v6h-6" /><path d="M1 20v-6h6" /><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15" /></svg>;
                case "Layout": return <svg {...commonProps}><rect x="3" y="3" width="18" height="18" rx="2" ry="2" /><line x1="3" y1="9" x2="21" y2="9" /><line x1="9" y1="21" x2="9" y2="9" /></svg>;
                case "CheckCircle": return <svg {...commonProps}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" /><polyline points="22 4 12 14.01 9 11.01" /></svg>;
                case "Database": return <svg {...commonProps}><ellipse cx="12" cy="5" rx="9" ry="3" /><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3" /><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5" /></svg>;
                case "Layers": return <svg {...commonProps}><polygon points="12 2 2 7 12 12 22 7 12 2" /><polyline points="2 17 12 22 22 17" /><polyline points="2 12 12 17 22 12" /></svg>;

                // -- Newly Added Icons --
                case "Activity": return <svg {...commonProps}><path d="M22 12h-4l-3 9L9 3l-3 9H2" /></svg>;
                case "Calendar": return <svg {...commonProps}><rect x="3" y="4" width="18" height="18" rx="2" ry="2" /><line x1="16" y1="2" x2="16" y2="6" /><line x1="8" y1="2" x2="8" y2="6" /><line x1="3" y1="10" x2="21" y2="10" /></svg>;
                case "CheckSquare": return <svg {...commonProps}><polyline points="9 11 12 14 22 4" /><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11" /></svg>;
                case "Clipboard": return <svg {...commonProps}><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" /><rect x="8" y="2" width="8" height="4" rx="1" ry="1" /></svg>;
                case "ClipboardCheck": return <svg {...commonProps}><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2" /><rect x="8" y="2" width="8" height="4" rx="1" ry="1" /><path d="m9 14 2 2 4-4" /></svg>;
                case "Compass": return <svg {...commonProps}><circle cx="12" cy="12" r="10" /><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76" /></svg>;
                case "Download": return <svg {...commonProps}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="7 10 12 15 17 10" /><line x1="12" x2="12" y1="15" y2="3" /></svg>;
                case "Dumbbell": return <svg {...commonProps}><path d="m6.5 6.5 11 11" /><path d="m21 21-1-1a4.5 4.5 0 0 0-6.364 0l-1.072 1.071a4.5 4.5 0 0 0-6.364 0l-1 .99" /><path d="m3 3 1 1a4.5 4.5 0 0 0 6.364 0l1.071 1.071a4.5 4.5 0 0 0 6.364 0l1.001-.993" /><path d="m11.5 6.5-6.002 5.996" /><path d="m25.5 12.5-6.002 5.996" transform="translate(-8)" /></svg>;
                case "Edit": return <svg {...commonProps}><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" /><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" /></svg>;
                case "Image": return <svg {...commonProps}><rect x="3" y="3" width="18" height="18" rx="2" ry="2" /><circle cx="8.5" cy="8.5" r="1.5" /><polyline points="21 15 16 10 5 21" /></svg>;
                case "Info": return <svg {...commonProps}><circle cx="12" cy="12" r="10" /><line x1="12" x2="12" y1="16" y2="12" /><line x1="12" x2="12.01" y1="8" y2="8" /></svg>;
                case "Link": return <svg {...commonProps}><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" /><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" /></svg>;
                case "List": return <svg {...commonProps}><line x1="8" x2="21" y1="6" y2="6" /><line x1="8" x2="21" y1="12" y2="12" /><line x1="8" x2="21" y1="18" y2="18" /><line x1="3" x2="3.01" y1="6" y2="6" /><line x1="3" x2="3.01" y1="12" y2="12" /><line x1="3" x2="3.01" y1="18" y2="18" /></svg>;
                case "LogOut": return <svg {...commonProps}><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" /><polyline points="16 17 21 12 16 7" /><line x1="21" x2="9" y1="12" y2="12" /></svg>;
                case "Printer": return <svg {...commonProps}><polyline points="6 9 6 2 18 2 18 9" /><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2" /><rect x="6" y="14" width="12" height="8" /></svg>;
                case "Scale": return <svg {...commonProps}><path d="m16 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z" /><path d="m2 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z" /><path d="M7 21h10" /><path d="M12 3v18" /><path d="M3 7h2c2 0 5-1 7-2 2 1 5 2 7 2h2" /></svg>;
                case "Shield": return <svg {...commonProps}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z" /></svg>;
                case "Star": return <svg {...commonProps}><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2" /></svg>;
                case "Swords": return <svg {...commonProps}><polyline points="14.5 17.5 3 6 3 3 6 3 17.5 14.5" /><line x1="13" x2="19" y1="19" y2="13" /><line x1="16" x2="20" y1="16" y2="20" /><line x1="19" x2="21" y1="21" y2="19" /><polyline points="14.5 6.5 18 3 21 3 21 6 17.5 9.5" /><line x1="5" x2="9" y1="14" y2="18" /><line x1="7" x2="4" y1="17" y2="20" /><line x1="3" x2="5" y1="19" y2="21" /></svg>;
                case "Target": return <svg {...commonProps}><circle cx="12" cy="12" r="10" /><circle cx="12" cy="12" r="6" /><circle cx="12" cy="12" r="2" /></svg>;
                case "Trophy": return <svg {...commonProps}><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6" /><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18" /><path d="M4 22h16" /><path d="M9 3v8c0 .248.016.492.046.732.186 1.488 1.134 2.766 2.454 3.518.35.2.7.4 1 1" /><path d="M15 3v8c0 .248-.016.492-.046.732-.186 1.488-1.134 2.766-2.454 3.518-.35.2-.7.4-1 1" /><path d="M12 16v6" /></svg>;
                case "Users": return <svg {...commonProps}><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" /><circle cx="9" cy="7" r="4" /><path d="M22 21v-2a4 4 0 0 0-3-3.87" /><path d="M16 3.13a4 4 0 0 1 0 7.75" /></svg>;

                // -- Additional Missing Icons --
                case "Award": return <svg {...commonProps}><circle cx="12" cy="8" r="7" /><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88" /></svg>;
                case "Clock": return <svg {...commonProps}><circle cx="12" cy="12" r="10" /><polyline points="12 6 12 12 16 14" /></svg>;
                case "HardHat": return <svg {...commonProps}><path d="M2 18a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1H3a1 1 0 0 0-1 1v2z" /><path d="M10 10V5a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v5" /><path d="M4 15v-3a6 6 0 0 1 6-6h0a6 6 0 0 1 6 6v3" /><path d="M14 10a2 2 0 0 0-2 2v2a2 2 0 0 0 4 0v-2a2 2 0 0 0-2-2z" /></svg>;
                case "Key": return <svg {...commonProps}><circle cx="7.5" cy="15.5" r="5.5" /><path d="m21 2-9.6 9.6" /><path d="m15.5 7.5 3 3L22 7l-3-3" /></svg>;

                // -- Settings & UI Fixes --
                case "Mail": return <svg {...commonProps}><rect width="20" height="16" x="2" y="4" rx="2" /><path d="m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7" /></svg>;
                case "Archive": return <svg {...commonProps}><rect width="20" height="5" x="2" y="3" rx="1" /><path d="M4 8v11a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8" /><path d="M10 12h4" /></svg>;
                case "Phone": return <svg {...commonProps}><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z" /></svg>;
                case "Edit2": return <svg {...commonProps}><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z" /><path d="m15 5 4 4" /></svg>;
                case "Pencil": return <svg {...commonProps}><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z" /><path d="m15 5 4 4" /></svg>;
                case "Trash2": return <svg {...commonProps}><path d="M3 6h18" /><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" /><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" /><line x1="10" x2="10" y1="11" y2="17" /><line x1="14" x2="14" y1="11" y2="17" /></svg>;
                case "Heart": return <svg {...commonProps}><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z" /></svg>;
                case "Code": return <svg {...commonProps}><polyline points="16 18 22 12 16 6" /><polyline points="8 6 2 12 8 18" /></svg>;
                case "Grid": return <svg {...commonProps}><rect x="3" y="3" width="7" height="7" /><rect x="14" y="3" width="7" height="7" /><rect x="14" y="14" width="7" height="7" /><rect x="3" y="14" width="7" height="7" /></svg>;
                case "Tag": return <svg {...commonProps}><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z" /><line x1="7" y1="7" x2="7.01" y2="7" /></svg>;
                case "Filter": return <svg {...commonProps}><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3" /></svg>;
                case "FilterX": return <svg {...commonProps}><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3" /><line x1="14" x2="20" y1="3" y2="9" /><line x1="20" x2="14" y1="3" y2="9" /></svg>;
                case "XCircle": return <svg {...commonProps}><circle cx="12" cy="12" r="10" /><line x1="15" x2="9" y1="9" y2="15" /><line x1="9" x2="15" y1="9" y2="15" /></svg>;

                case "BarChart2": return <svg {...commonProps}><line x1="18" y1="20" x2="18" y2="10" /><line x1="12" y1="20" x2="12" y2="4" /><line x1="6" y1="20" x2="6" y2="14" /></svg>;
                case "Landmark": return <svg {...commonProps}><line x1="3" x2="21" y1="22" y2="22" /><line x1="6" x2="6" y1="18" y2="11" /><line x1="10" x2="10" y1="18" y2="11" /><line x1="14" x2="14" y1="18" y2="11" /><line x1="18" x2="18" y1="18" y2="11" /><polygon points="12 2 20 7 4 7" /><line x1="3" x2="21" y1="7" y2="7" /></svg>;
                case "FileQuestion": return <svg {...commonProps}><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" /><path d="M10 10.3c.2-.4.5-.8.9-1a2.1 2.1 0 0 1 2.6.4c.3.4.5.8.5 1.3 0 1.3-2 2-2 2" /><path d="M12 17h.01" /></svg>;
                case "MessageSquare": return <svg {...commonProps}><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" /></svg>;

                default:
                    // Fallback to text (Emoji or just text)
                    return <span style={{ fontSize: '0.8rem', marginRight: '0.2rem', display: 'inline-block', width: 'auto', textAlign: 'center', opacity: 0.8, ...style, color: 'red' }}>MISSING: {name}</span>;
            }
        };

        // -------------------------------------------------------------------------
        // GLOBAL HELPER COMPONENTS (Moved out of components to prevent re-mounting)
        // -------------------------------------------------------------------------

        // Install Sortable Column
        const InstallSortableColumn = ({
            items,
            type,
            onListChange,
            onUpdatePlay,
            handleRemoveFromInstall,
            getGamePlanStatus,
            getScriptCount,
            handleTogglePriority,
            handleToggleNewPlay,
            newInstallIds = [],
            onOpenAssignmentModal,
            onDuplicatePlay,
            playBuckets = []
        }) => {

            // Group items by bucket
            const groupItems = (rawItems) => {
                const groups = { unassigned: [], buckets: {} };
                rawItems.forEach(item => {
                    if (item.bucketId && playBuckets.some(b => b.id === item.bucketId)) {
                        if (!groups.buckets[item.bucketId]) groups.buckets[item.bucketId] = [];
                        groups.buckets[item.bucketId].push(item);
                    } else {
                        groups.unassigned.push(item);
                    }
                });
                return groups;
            };

            const [groupedItems, setGroupedItems] = React.useState(groupItems(items));

            // Flatten groups back to array
            const flattenGroups = (groups) => {
                const sortedBucketIds = Object.keys(groups.buckets).sort((a, b) => {
                    const nameA = playBuckets.find(xb => xb.id === a)?.label || '';
                    const nameB = playBuckets.find(xb => xb.id === b)?.label || '';
                    return nameA.localeCompare(nameB);
                });
                let list = [...groups.unassigned];
                sortedBucketIds.forEach(bid => {
                    list = list.concat(groups.buckets[bid]);
                });
                return list;
            };

            // Sync with external changes
            const itemsSignature = items.map(p => `${p.id}-${p.priority}-${p.wristbandSlot}-${p.bucketId || ''}`).join(',');
            React.useEffect(() => {
                const flatLocal = flattenGroups(groupedItems);
                const localSignature = flatLocal.map(p => `${p.id}-${p.priority}-${p.wristbandSlot}-${p.bucketId || ''}`).join(',');
                if (itemsSignature !== localSignature) {
                    setGroupedItems(groupItems(items));
                }
            }, [itemsSignature]);

            const handleSetList = (newList, bucketId) => {
                setGroupedItems(prev => {
                    const oldList = bucketId ? (prev.buckets[bucketId] || []) : prev.unassigned;
                    const addedItem = newList.find(p => !oldList.some(old => old.id === p.id));

                    if (addedItem) {
                        const targetBucketId = bucketId || null;
                        if (addedItem.bucketId !== targetBucketId) {
                            onUpdatePlay(addedItem.id, { bucketId: targetBucketId });
                            addedItem.bucketId = targetBucketId;
                        }
                    }

                    const newGroups = { ...prev, buckets: { ...prev.buckets } };
                    if (bucketId) {
                        newGroups.buckets[bucketId] = newList;
                    } else {
                        newGroups.unassigned = newList;
                    }

                    const flat = flattenGroups(newGroups);
                    onListChange(flat);

                    return newGroups;
                });
            };

            const sortedBucketIds = Object.keys(groupedItems.buckets).sort((a, b) => {
                const nameA = playBuckets.find(xb => xb.id === a)?.label || '';
                const nameB = playBuckets.find(xb => xb.id === b)?.label || '';
                return nameA.localeCompare(nameB);
            });

            const ReactSortable = window.ReactSortable;

            // Use ref to track click timer for distinguishing single vs double click
            const clickTimerRef = React.useRef(null);

            const handleCardClick = (play, e) => {
                e.stopPropagation();

                // Clear any existing timer
                if (clickTimerRef.current) {
                    clearTimeout(clickTimerRef.current);
                    clickTimerRef.current = null;
                    return; // This is a double-click, do nothing (double-click handler will fire)
                }

                // Set a timer for single click
                clickTimerRef.current = setTimeout(() => {
                    clickTimerRef.current = null;
                    // Toggle priority
                    onUpdatePlay(play.id, { priority: !play.priority });
                }, 250);
            };

            const renderPlayCard = (play) => (
                <div
                    key={play.id}
                    className="card"
                    style={{
                        padding: '0.4rem',
                        marginBottom: '0.35rem',
                        borderLeft: `4px solid ${type === 'Run' ? '#10b981' : '#3b82f6'}`,
                        cursor: 'pointer',
                        background: 'white',
                        color: '#0f172a',
                        userSelect: 'none',
                        position: 'relative'
                    }}
                    onClick={(e) => handleCardClick(play, e)}
                    onDoubleClick={(e) => {
                        if (onOpenAssignmentModal) {
                            e.stopPropagation();
                            onOpenAssignmentModal(play.id, e.clientX, e.clientY);
                        }
                    }}
                >
                    <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'start' }}>
                        <div style={{ flex: 1, minWidth: 0 }}>
                            <div style={{ fontWeight: '600', fontSize: '0.85rem', display: 'flex', alignItems: 'center', gap: '4px', flexWrap: 'wrap' }}>
                                {play.priority && (
                                    <Icon name="Star" size={12} style={{ fill: '#eab308', color: '#eab308', flexShrink: 0 }} />
                                )}
                                <span style={{ overflow: 'hidden', textOverflow: 'ellipsis' }}>{getPlayDisplayName(play)}</span>
                                {play.wristbandSlot && (
                                    <span style={{
                                        background: '#eff6ff',
                                        color: '#1d4ed8',
                                        padding: '1px 5px',
                                        borderRadius: '3px',
                                        fontSize: '0.7rem',
                                        fontWeight: '600',
                                        flexShrink: 0
                                    }}>
                                        #{play.wristbandSlot}
                                    </span>
                                )}
                            </div>
                        </div>
                    </div>

                    <button
                        className="btn-ghost remove-btn"
                        onClick={(e) => { e.stopPropagation(); handleRemoveFromInstall(play.id); }}
                        style={{
                            position: 'absolute',
                            top: '2px',
                            right: '2px',
                            padding: '2px',
                            color: '#ef4444',
                            opacity: 0.3,
                            transition: 'opacity 0.2s',
                            background: 'white',
                            borderRadius: '3px'
                        }}
                        onMouseEnter={(e) => e.currentTarget.style.opacity = '1'}
                        onMouseLeave={(e) => e.currentTarget.style.opacity = '0.3'}
                        title="Remove from install"
                    >
                        <Icon name="X" size={12} />
                    </button>
                </div>
            );

            return (
                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                    {/* Unassigned Section */}
                    <ReactSortable
                        list={groupedItems.unassigned}
                        setList={(l) => handleSetList(l, null)}
                        group="installColumns"
                        animation={150}
                        style={{ minHeight: '50px' }}
                    >
                        {groupedItems.unassigned.map(play => renderPlayCard(play))}
                    </ReactSortable>

                    {/* Buckets */}
                    {sortedBucketIds.map(bucketId => {
                        const bucket = playBuckets.find(b => b.id === bucketId);
                        return (
                            <div key={bucketId} style={{ marginTop: '0.5rem' }}>
                                <div style={{
                                    fontSize: '0.75rem', fontWeight: 'bold', color: '#475569',
                                    marginBottom: '0.25rem', padding: '0.25rem 0.5rem',
                                    background: '#f1f5f9', borderRadius: '4px',
                                    display: 'flex', justifyContent: 'space-between'
                                }}>
                                    <span>{bucket ? bucket.label : 'Unknown Bucket'}</span>
                                    <span style={{ opacity: 0.5 }}>{groupedItems.buckets[bucketId].length}</span>
                                </div>
                                <ReactSortable
                                    list={groupedItems.buckets[bucketId]}
                                    setList={(l) => handleSetList(l, bucketId)}
                                    group="installColumns"
                                    animation={150}
                                    style={{ minHeight: '40px' }}
                                >
                                    {groupedItems.buckets[bucketId].map(play => renderPlayCard(play))}
                                </ReactSortable>
                            </div>
                        );
                    })}
                </div>
            );
        };

        // Priority Sortable Column
        const PrioritySortableColumn = ({ items, onListChange, className, style, emptyText, isLocked, onItemDoubleClick }) => {
            const [localItems, setLocalItems] = React.useState(items);

            // Stable Sync
            const itemsIds = items.map(p => p.id).join(',');
            React.useEffect(() => {
                const localIds = localItems.map(p => p.id).join(',');
                if (itemsIds !== localIds) {
                    setLocalItems(items);
                }
            }, [itemsIds]);

            return (
                <ReactSortable
                    list={localItems}
                    setList={(newList) => {
                        setLocalItems(newList);
                        onListChange(newList);
                    }}
                    group="priorityGroup"
                    animation={150}
                    style={style}
                    className={className}
                    disabled={isLocked}
                >
                    {localItems.map(play => (
                        <div
                            key={play.id}
                            style={{ padding: '0.4rem', background: 'white', color: '#1f2937', border: '1px solid var(--border)', borderRadius: '4px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', cursor: isLocked ? 'default' : 'grab', marginBottom: '4px', userSelect: 'none' }}
                            onDoubleClick={(e) => {
                                if (isLocked) return;
                                e.stopPropagation();
                                if (onItemDoubleClick) onItemDoubleClick(play, e);
                            }}
                        >
                            <div style={{ overflow: 'hidden' }}>
                                <div style={{ fontWeight: 'bold', fontSize: '0.9rem', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>{getPlayDisplayName(play)}</div>
                            </div>
                            {!isLocked && (
                                <button
                                    onClick={(e) => {
                                        e.stopPropagation();
                                    }}
                                    style={{ color: '#ef4444', padding: '2px', marginLeft: '4px', visibility: 'hidden' }}
                                    className="btn-ghost"
                                >
                                    <Icon name="X" size={14} />
                                </button>
                            )}
                        </div>
                    ))}
                </ReactSortable>
            );
        };

        const OPS_CALENDAR = [
            "Offseason",
            "Week 1 of Summer", "Week 2 of Summer", "Week 3 of Summer", "Week 4 of Summer",
            "Week 5 of Summer", "Week 6 of Summer", "Week 7 of Summer", "Week 8 of Summer",
            "Family Week", "Camp Week", "First Week of Practice",
            "Week 0", "Week 1", "Week 2", "Week 3", "Week 4", "Week 5",
            "Week 6", "Week 7", "Week 8", "Week 9", "Week 10", "Week 11",
            "Week 12", "Week 13", "First Week with No Game"
        ];

        const TagSelector = ({ selectedTags, onToggle, customTagCategories = [], onUpdateCustomCategories }) => {
            const [isAddingCategory, setIsAddingCategory] = useState(false);
            const [newCategoryName, setNewCategoryName] = useState('');
            const [editingCategory, setEditingCategory] = useState(null);
            const [newTagInput, setNewTagInput] = useState('');

            const handleAddCategory = () => {
                if (!newCategoryName.trim() || !onUpdateCustomCategories) return;
                const newCat = {
                    id: `custom_${Date.now()}`,
                    name: newCategoryName.trim(),
                    tags: []
                };
                onUpdateCustomCategories([...customTagCategories, newCat]);
                setNewCategoryName('');
                setIsAddingCategory(false);
                setEditingCategory(newCat.id);
            };

            const handleAddTag = (categoryId) => {
                if (!newTagInput.trim() || !onUpdateCustomCategories) return;
                onUpdateCustomCategories(customTagCategories.map(cat =>
                    cat.id === categoryId
                        ? { ...cat, tags: [...cat.tags, newTagInput.trim()] }
                        : cat
                ));
                setNewTagInput('');
            };

            const handleDeleteTag = (categoryId, tagToDelete) => {
                if (!onUpdateCustomCategories) return;
                onUpdateCustomCategories(customTagCategories.map(cat =>
                    cat.id === categoryId
                        ? { ...cat, tags: cat.tags.filter(t => t !== tagToDelete) }
                        : cat
                ));
            };

            const handleDeleteCategory = (categoryId) => {
                if (!onUpdateCustomCategories) return;
                if (window.confirm('Delete this category and all its tags?')) {
                    onUpdateCustomCategories(customTagCategories.filter(cat => cat.id !== categoryId));
                    if (editingCategory === categoryId) setEditingCategory(null);
                }
            };

            // Combine built-in and custom categories
            const allCategories = [
                ...Object.entries(TAG_CATEGORIES).map(([name, tags]) => ({ id: name, name, tags, isBuiltIn: true })),
                ...customTagCategories.map(cat => ({ ...cat, isBuiltIn: false }))
            ];

            return (
                <div className="space-y-4">
                    {allCategories.map(category => (
                        <div key={category.id} className="tags-section" style={{ position: 'relative' }}>
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.5rem' }}>
                                <div className="tags-category-title" style={{ margin: 0 }}>{category.name}</div>
                                {!category.isBuiltIn && onUpdateCustomCategories && (
                                    <div style={{ display: 'flex', gap: '0.5rem' }}>
                                        <button
                                            className="btn-ghost"
                                            style={{ padding: '2px 6px', fontSize: '0.7rem' }}
                                            onClick={() => setEditingCategory(editingCategory === category.id ? null : category.id)}
                                        >
                                            {editingCategory === category.id ? 'Done' : 'Edit'}
                                        </button>
                                        <button
                                            className="btn-ghost"
                                            style={{ padding: '2px 6px', fontSize: '0.7rem', color: '#ef4444' }}
                                            onClick={() => handleDeleteCategory(category.id)}
                                        >
                                            ×
                                        </button>
                                    </div>
                                )}
                            </div>
                            <div className="tags-grid">
                                {(category.tags || []).map(tag => (
                                    <div
                                        key={tag}
                                        className={`tag-chip ${selectedTags.includes(tag) ? 'selected' : ''}`}
                                        onClick={() => onToggle(tag)}
                                        style={{ position: 'relative' }}
                                    >
                                        {tag}
                                        {editingCategory === category.id && !category.isBuiltIn && (
                                            <span
                                                onClick={(e) => { e.stopPropagation(); handleDeleteTag(category.id, tag); }}
                                                style={{ marginLeft: '4px', color: '#ef4444', cursor: 'pointer', fontWeight: 'bold' }}
                                            >×</span>
                                        )}
                                    </div>
                                ))}
                                {editingCategory === category.id && !category.isBuiltIn && (
                                    <div style={{ display: 'flex', gap: '0.25rem' }}>
                                        <input
                                            type="text"
                                            className="form-input"
                                            placeholder="New tag..."
                                            value={newTagInput}
                                            onChange={e => setNewTagInput(e.target.value)}
                                            onKeyDown={e => e.key === 'Enter' && handleAddTag(category.id)}
                                            style={{ padding: '0.25rem 0.5rem', fontSize: '0.8rem', width: '120px' }}
                                        />
                                        <button className="btn btn-primary" style={{ padding: '0.25rem 0.5rem', fontSize: '0.75rem' }} onClick={() => handleAddTag(category.id)}>+</button>
                                    </div>
                                )}
                            </div>
                        </div>
                    ))}

                    {/* Add Custom Category */}
                    {onUpdateCustomCategories && (
                        <div style={{ marginTop: '1rem', paddingTop: '1rem', borderTop: '1px dashed var(--border)' }}>
                            {isAddingCategory ? (
                                <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center' }}>
                                    <input
                                        type="text"
                                        className="form-input"
                                        placeholder="Category name..."
                                        value={newCategoryName}
                                        onChange={e => setNewCategoryName(e.target.value)}
                                        onKeyDown={e => e.key === 'Enter' && handleAddCategory()}
                                        style={{ flex: 1, padding: '0.4rem 0.75rem' }}
                                        autoFocus
                                    />
                                    <button className="btn btn-primary" style={{ padding: '0.4rem 0.75rem' }} onClick={handleAddCategory}>Add</button>
                                    <button className="btn btn-secondary" style={{ padding: '0.4rem 0.75rem' }} onClick={() => { setIsAddingCategory(false); setNewCategoryName(''); }}>Cancel</button>
                                </div>
                            ) : (
                                <button
                                    className="btn btn-secondary"
                                    style={{ width: '100%', padding: '0.5rem', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '0.5rem' }}
                                    onClick={() => setIsAddingCategory(true)}
                                >
                                    <Icon name="Plus" size={14} /> Add Custom Category
                                </button>
                            )}
                        </div>
                    )}
                </div>
            );
        };

        // Helper to generate Zigzag Path
        const getZigZagPath = (points) => {
            if (points.length < 2) return '';
            let d = `M ${points[0].x},${points[0].y}`;
            for (let i = 0; i < points.length - 1; i++) {
                const A = points[i];
                const B = points[i + 1];
                const isLastSegment = i === points.length - 2;

                let targetB = B;
                let finalSegment = '';

                // If it's the last segment, leave a straight tail for the arrowhead
                if (isLastSegment) {
                    const totalDist = Math.hypot(B.x - A.x, B.y - A.y);
                    const arrowSpace = 5; // Reduced from 20 to 5 to hide transition inside arrow
                    if (totalDist > arrowSpace) {
                        const ratio = (totalDist - arrowSpace) / totalDist;
                        targetB = {
                            x: A.x + (B.x - A.x) * ratio,
                            y: A.y + (B.y - A.y) * ratio
                        };
                        finalSegment = ` L ${B.x},${B.y}`;
                    }
                }

                const dist = Math.hypot(targetB.x - A.x, targetB.y - A.y);
                const steps = Math.floor(dist / 10); // 10px zigzags

                if (steps <= 0) {
                    d += ` L ${targetB.x},${targetB.y}`;
                } else {
                    const dx = (targetB.x - A.x) / steps;
                    const dy = (targetB.y - A.y) / steps;
                    const nx = -dy * 0.5; // Width of zig
                    const ny = dx * 0.5;
                    for (let j = 1; j <= steps; j++) {
                        const mx = A.x + dx * j;
                        const my = A.y + dy * j;
                        if (j === steps) {
                            d += ` L ${mx},${my}`;
                        } else {
                            const side = j % 2 === 0 ? 1 : -1;
                            d += ` L ${mx + nx * side},${my + ny * side}`;
                        }
                    }
                }

                if (finalSegment) {
                    d += finalSegment;
                }
            }
            return d;
        };

        // --- PLAY DIAGRAM EDITOR ---
        const PlayDiagramEditor = ({ initialData, onSave, onCancel, mode = 'standard', formations = [], onAddFormation = () => { }, wizLibrary = [], setWizLibrary = () => { }, positionNames = {}, positionColors = {}, readOnly = false, formationOnly = false }) => {

            // Helper for default formation - uses position colors
            const getDefaultFormation = () => {
                const center = 400;
                const los = 340; // Shifted UP (was 400) to give ~8 yards depth (160px space below)

                // Use position colors with fallbacks
                const getColor = (pos, fallback) => positionColors[pos] || fallback;
                const cOL = getColor('C', '#64748b');
                const cQB = getColor('QB', '#1e3a5f');

                // Y-Offsets: 100px = 5 yards.
                // OL radius=15. Place at +18 to clear line.
                // QB Shotgun at 5 yds = +100px.

                if (mode === 'wiz-oline') {
                    // O-Line Wiz Default (T-G-C-G-T) - Large Text, Arched
                    // Los is 340. C at LOS. G at +15, T at +30.
                    const initialSize = 170;
                    return [
                        { id: Date.now() + 1, type: 'player', points: [{ x: center, y: los }], color: getColor('C', cOL), label: 'C', shape: 'text-only', variant: 'filled', fontSize: initialSize },
                        { id: Date.now() + 2, type: 'player', points: [{ x: center - 170, y: los + 15 }], color: getColor('LG', cOL), label: 'G', shape: 'text-only', variant: 'filled', fontSize: initialSize },
                        { id: Date.now() + 3, type: 'player', points: [{ x: center + 170, y: los + 15 }], color: getColor('RG', cOL), label: 'G', shape: 'text-only', variant: 'filled', fontSize: initialSize },
                        { id: Date.now() + 4, type: 'player', points: [{ x: center - 340, y: los + 30 }], color: getColor('LT', cOL), label: 'T', shape: 'text-only', variant: 'filled', fontSize: initialSize },
                        { id: Date.now() + 5, type: 'player', points: [{ x: center + 340, y: los + 30 }], color: getColor('RT', cOL), label: 'T', shape: 'text-only', variant: 'filled', fontSize: initialSize },
                    ];
                }

                if (mode === 'wiz-skill') {
                    // Skill Wiz Default (11 Players)
                    // OL is smaller text to match skill player icon size (~24px)
                    // "Behind the LOS" -> Push Y down.
                    // WIZ Card visible area: y=60 to y=520 (460px)
                    // Position LOS at y=400 to allow ~340px above for routes (~17 yards) and ~120px below for backfield (~6 yards)
                    const wizLos = 400;
                    const initialSize = 24; // Reduced from 40 to match skill player circles
                    const spacing = 40;
                    const olY = wizLos + 20; // Push down 20px (stays within y=520)

                    return [
                        // OL
                        { id: Date.now() + 1, type: 'player', points: [{ x: center, y: olY }], color: getColor('C', cOL), label: 'C', shape: 'text-only', variant: 'filled', fontSize: initialSize },
                        { id: Date.now() + 2, type: 'player', points: [{ x: center - spacing, y: olY }], color: getColor('LG', cOL), label: 'G', shape: 'text-only', variant: 'filled', fontSize: initialSize },
                        { id: Date.now() + 3, type: 'player', points: [{ x: center + spacing, y: olY }], color: getColor('RG', cOL), label: 'G', shape: 'text-only', variant: 'filled', fontSize: initialSize },
                        { id: Date.now() + 4, type: 'player', points: [{ x: center - (spacing * 2), y: olY }], color: getColor('LT', cOL), label: 'T', shape: 'text-only', variant: 'filled', fontSize: initialSize },
                        { id: Date.now() + 5, type: 'player', points: [{ x: center + (spacing * 2), y: olY }], color: getColor('RT', cOL), label: 'T', shape: 'text-only', variant: 'filled', fontSize: initialSize },
                        // Skill Players - Use position colors
                        // QB at shotgun depth (60px behind LOS, stays within visible area)
                        { id: Date.now() + 6, type: 'player', points: [{ x: center, y: wizLos + 60 }], color: getColor('QB', cQB), label: positionNames['QB'] || 'Q', shape: 'circle', variant: 'filled' },
                        // RB closer to QB (at y=460, within visible bounds)
                        { id: Date.now() + 7, type: 'player', points: [{ x: center - 60, y: wizLos + 60 }], color: getColor('RB', '#3b82f6'), label: positionNames['RB'] || 'B', shape: 'circle', variant: 'filled' },
                        { id: Date.now() + 8, type: 'player', points: [{ x: 100, y: wizLos + 10 }], color: getColor('X', '#a855f7'), label: positionNames['X'] || 'X', shape: 'circle', variant: 'filled' },
                        { id: Date.now() + 9, type: 'player', points: [{ x: 700, y: wizLos + 10 }], color: getColor('Z', '#22c55e'), label: positionNames['Z'] || 'Z', shape: 'circle', variant: 'filled' },
                        { id: Date.now() + 10, type: 'player', points: [{ x: 200, y: wizLos + 25 }], color: getColor('A', '#ef4444'), label: positionNames['A'] || 'A', shape: 'circle', variant: 'filled' },
                        { id: Date.now() + 11, type: 'player', points: [{ x: center + 120, y: wizLos + 10 }], color: getColor('Y', '#eab308'), label: positionNames['Y'] || 'Y', shape: 'circle', variant: 'filled' },
                    ];
                }

                return [
                    // OL - Now Circles, Filled, Shifted back (+18)
                    { id: Date.now() + 1, type: 'player', points: [{ x: center, y: los + 18 }], color: getColor('C', cOL), label: positionNames['C'] || 'C', shape: 'circle', variant: 'filled' },
                    { id: Date.now() + 2, type: 'player', points: [{ x: center - 40, y: los + 18 }], color: getColor('LG', cOL), label: positionNames['LG'] || 'G', shape: 'circle', variant: 'filled' },
                    { id: Date.now() + 3, type: 'player', points: [{ x: center + 40, y: los + 18 }], color: getColor('RG', cOL), label: positionNames['RG'] || 'G', shape: 'circle', variant: 'filled' },
                    { id: Date.now() + 4, type: 'player', points: [{ x: center - 80, y: los + 18 }], color: getColor('LT', cOL), label: positionNames['LT'] || 'T', shape: 'circle', variant: 'filled' },
                    { id: Date.now() + 5, type: 'player', points: [{ x: center + 80, y: los + 18 }], color: getColor('RT', cOL), label: positionNames['RT'] || 'T', shape: 'circle', variant: 'filled' },
                    // QB
                    { id: Date.now() + 6, type: 'player', points: [{ x: center, y: los + 120 }], color: getColor('QB', cQB), label: positionNames['QB'] || 'Q', shape: 'circle' },
                    // RB
                    { id: Date.now() + 7, type: 'player', points: [{ x: center, y: los + 220 }], color: getColor('RB', '#3b82f6'), label: positionNames['RB'] || 'R', shape: 'circle' },
                    // WR Left
                    { id: Date.now() + 8, type: 'player', points: [{ x: 100, y: los + 15 }], color: getColor('X', '#a855f7'), label: positionNames['X'] || 'X', shape: 'circle' },
                    // WR Right
                    { id: Date.now() + 9, type: 'player', points: [{ x: 700, y: los + 15 }], color: getColor('Z', '#22c55e'), label: positionNames['Z'] || 'Z', shape: 'circle' },
                    // Slot Left
                    { id: Date.now() + 10, type: 'player', points: [{ x: 200, y: los + 35 }], color: getColor('A', '#ef4444'), label: positionNames['A'] || 'H', shape: 'circle' },
                    // TE Right
                    { id: Date.now() + 11, type: 'player', points: [{ x: center + 120, y: los + 15 }], color: getColor('Y', '#eab308'), label: positionNames['Y'] || 'Y', shape: 'circle' },
                ];
            };

            // Scout Defense Defaults (4-3 Over)
            const getScoutDefenseFormation = () => {
                const center = 400;
                const los = 340;
                // Defense is ABOVE the LOS (smaller Y values)

                const cDL = '#1f2937'; // Dark Grey
                const cLB = '#374151';
                const cDB = '#4b5563';

                return [
                    // DL
                    { id: Date.now() + 1, type: 'player', points: [{ x: center - 90, y: los - 18 }], color: cDL, label: 'E', shape: 'square', variant: 'filled' }, // LE
                    { id: Date.now() + 2, type: 'player', points: [{ x: center - 30, y: los - 18 }], color: cDL, label: 'T', shape: 'square', variant: 'filled' }, // LT (3-tech)
                    { id: Date.now() + 3, type: 'player', points: [{ x: center + 30, y: los - 18 }], color: cDL, label: 'N', shape: 'square', variant: 'filled' }, // RT (1-tech)
                    { id: Date.now() + 4, type: 'player', points: [{ x: center + 90, y: los - 18 }], color: cDL, label: 'E', shape: 'square', variant: 'filled' }, // RE

                    // LB
                    { id: Date.now() + 5, type: 'player', points: [{ x: center - 110, y: los - 80 }], color: cLB, label: 'W', shape: 'square' }, // Will
                    { id: Date.now() + 6, type: 'player', points: [{ x: center, y: los - 80 }], color: cLB, label: 'M', shape: 'square' },       // Mike
                    { id: Date.now() + 7, type: 'player', points: [{ x: center + 110, y: los - 80 }], color: cLB, label: 'S', shape: 'star', variant: 'filled' }, // Sam (Star)

                    // DB
                    { id: Date.now() + 8, type: 'player', points: [{ x: center - 180, y: los - 35 }], color: cDB, label: 'C', shape: 'circle' }, // LCB
                    { id: Date.now() + 9, type: 'player', points: [{ x: center + 180, y: los - 35 }], color: cDB, label: 'C', shape: 'circle' }, // RCB
                    { id: Date.now() + 10, type: 'player', points: [{ x: center - 60, y: los - 200 }], color: cDB, label: 'F', shape: 'circle' }, // FS
                    { id: Date.now() + 11, type: 'player', points: [{ x: center + 60, y: los - 180 }], color: cDB, label: 'R', shape: 'circle' }, // Rover/SS
                ];
            };

            const handleScoutDefense = () => {
                if (elements.length > 0 && !window.confirm('Replace current diagram with Scout Defense?')) return;
                setElements(getScoutDefenseFormation());
            };

            const getScoutOffenseFormation = () => {
                const center = 400;
                const los = 340;
                const cScout = '#eab308'; // Yellow

                return [
                    // OL
                    { id: Date.now() + 1, type: 'player', points: [{ x: center, y: los + 18 }], color: cScout, label: positionNames['C'] || 'C', shape: 'circle', variant: 'filled' },
                    { id: Date.now() + 2, type: 'player', points: [{ x: center - 40, y: los + 18 }], color: cScout, label: positionNames['LG'] || 'G', shape: 'circle', variant: 'filled' },
                    { id: Date.now() + 3, type: 'player', points: [{ x: center + 40, y: los + 18 }], color: cScout, label: positionNames['RG'] || 'G', shape: 'circle', variant: 'filled' },
                    { id: Date.now() + 4, type: 'player', points: [{ x: center - 80, y: los + 18 }], color: cScout, label: positionNames['LT'] || 'T', shape: 'circle', variant: 'filled' },
                    { id: Date.now() + 5, type: 'player', points: [{ x: center + 80, y: los + 18 }], color: cScout, label: positionNames['RT'] || 'T', shape: 'circle', variant: 'filled' },
                    // QB
                    { id: Date.now() + 6, type: 'player', points: [{ x: center, y: los + 50 }], color: cScout, label: positionNames['QB'] || 'Q', shape: 'circle' },
                    // RB
                    { id: Date.now() + 7, type: 'player', points: [{ x: center, y: los + 120 }], color: cScout, label: positionNames['RB'] || 'R', shape: 'circle' },
                    // WRs
                    { id: Date.now() + 8, type: 'player', points: [{ x: 100, y: los + 15 }], color: cScout, label: positionNames['X'] || 'X', shape: 'circle' },
                    { id: Date.now() + 9, type: 'player', points: [{ x: 700, y: los + 15 }], color: cScout, label: positionNames['Z'] || 'Z', shape: 'circle' },
                    // TE/Slot
                    { id: Date.now() + 10, type: 'player', points: [{ x: center + 120, y: los + 15 }], color: cScout, label: positionNames['Y'] || 'Y', shape: 'circle' },
                    { id: Date.now() + 11, type: 'player', points: [{ x: 200, y: los + 35 }], color: cScout, label: positionNames['A'] || 'H', shape: 'circle' },
                ];
            };

            const handleScoutOffense = () => {
                if (elements.length > 0 && !window.confirm('Replace current diagram with Scout Offense?')) return;
                setElements(getScoutOffenseFormation());
            };

            // Initialize with data OR default formation
            const [elements, setElements] = useState(() => {
                if (initialData && initialData.elements && initialData.elements.length > 0) {
                    return initialData.elements;
                }
                return getDefaultFormation();
            });

            const [selectedTool, setSelectedTool] = useState('select'); // select, free, line, player, delete
            const [color, setColor] = useState('#000000');
            const [lineStyle, setLineStyle] = useState('solid'); // solid, dashed, zigzag
            const [lineWidth, setLineWidth] = useState(4); // 2, 4, 6, 8
            const [endType, setEndType] = useState('arrow'); // arrow, t, none
            const [showLineOptions, setShowLineOptions] = useState(false); // Dropdown for line options
            const [selectedPlayerIcon, setSelectedPlayerIcon] = useState({ label: 'Q', shape: 'circle' });

            // Text Size State for Wiz OL
            const [wizTextSize, setWizTextSize] = useState(170);
            const [customLetterInput, setCustomLetterInput] = useState('');

            // Field Position State (for dynamic yard lines)
            const [fieldPosition, setFieldPosition] = useState(50); // Starting yard line (0-100)

            // Field View Mode State (for WIZ Card view that matches print output)
            // 'standard' = full 900x600 viewBox, 'wiz-card' = cropped 800x460 viewBox matching WIZ grid cells
            const [fieldViewMode, setFieldViewMode] = useState(mode === 'wiz-skill' ? 'wiz-card' : 'standard');

            // Formation Selector State (for Wiz Skill)
            const [selectedFormationId, setSelectedFormationId] = useState('');



            // History State for Undo/Redo
            const [history, setHistory] = useState([elements]);
            const [historyIndex, setHistoryIndex] = useState(0);

            const updateHistory = (newElements) => {
                const newHistory = history.slice(0, historyIndex + 1);
                newHistory.push(newElements);
                setHistory(newHistory);
                setHistoryIndex(newHistory.length - 1);
            };

            // Load Formation from Library
            const loadFormation = (formationId) => {
                const formation = formations.find(f => f.id === formationId);
                if (!formation || !formation.positions) return;

                const center = 400;
                const los = 340;
                const newElements = [];

                // Default position config (shape/variant), color comes from positionColors prop
                const defaultColorMap = {
                    'C': '#64748b', 'G': '#64748b', 'T': '#64748b',
                    'LT': '#64748b', 'LG': '#64748b', 'RG': '#64748b', 'RT': '#64748b',
                    'QB': '#1e3a5f', 'Q': '#1e3a5f',
                    'RB': '#3b82f6', 'B': '#3b82f6',
                    'X': '#a855f7', 'Z': '#22c55e', 'Y': '#eab308',
                    'A': '#ef4444', 'F': '#f97316', 'H': '#06b6d4'
                };
                const positionConfig = {
                    'C': { shape: 'text-only', fontSize: 40 },
                    'G': { shape: 'text-only', fontSize: 40 },
                    'T': { shape: 'text-only', fontSize: 40 },
                    'LT': { shape: 'text-only', fontSize: 40 },
                    'LG': { shape: 'text-only', fontSize: 40 },
                    'RG': { shape: 'text-only', fontSize: 40 },
                    'RT': { shape: 'text-only', fontSize: 40 },
                    'QB': { shape: 'circle', variant: 'filled', label: 'Q' },
                    'Q': { shape: 'circle', variant: 'filled' },
                    'RB': { shape: 'circle', variant: 'filled', label: 'B' },
                    'B': { shape: 'circle', variant: 'filled' },
                    'X': { shape: 'circle', variant: 'filled' },
                    'Z': { shape: 'circle', variant: 'filled' },
                    'Y': { shape: 'circle', variant: 'filled' },
                    'A': { shape: 'circle', variant: 'filled' },
                    'F': { shape: 'circle', variant: 'filled' },
                    'H': { shape: 'circle', variant: 'filled' }
                };
                const getColor = (label) => positionColors[label] || defaultColorMap[label] || '#3b82f6';

                formation.positions.forEach((pos, idx) => {
                    // Convert percentage (0-100) to pixel coordinates (0-800 width, 0-500 height)
                    const x = (pos.x / 100) * 800;
                    const y = (pos.y / 100) * 500;

                    const config = positionConfig[pos.label] || { shape: 'circle', variant: 'filled' };

                    newElements.push({
                        id: Date.now() + idx,
                        type: 'player',
                        points: [{ x, y }],
                        color: getColor(pos.label),
                        label: positionNames[pos.label] || config.label || pos.label,
                        shape: config.shape || 'circle',
                        variant: config.variant || 'filled',
                        fontSize: config.fontSize
                    });
                });

                setElements(newElements);
                updateHistory(newElements);
            };

            // Selection State
            const [selectedIds, setSelectedIds] = useState(new Set());
            const [selectionBox, setSelectionBox] = useState(null);

            // Wiz Library State (Lifted to App)
            // wizLibrary passed as prop
            const [showSaveModal, setShowSaveModal] = useState(false);
            const [saveName, setSaveName] = useState('');

            // Library Helpers
            const initiateSave = () => {
                setSaveName('');
                setShowSaveModal(true);
            };

            const confirmSave = () => {
                if (!saveName) return;

                const newPreset = {
                    id: Date.now(),
                    name: saveName,
                    elements: elements
                };

                const updatedLibrary = [...wizLibrary, newPreset];
                setWizLibrary(updatedLibrary);
                localStorage.setItem('wiz_ol_library', JSON.stringify(updatedLibrary));
                setShowSaveModal(false);
            };

            const loadWizPreset = (presetId) => {
                const preset = wizLibrary.find(p => p.id === parseInt(presetId));
                if (preset) {
                    if (elements.length > 0 && !window.confirm(`Load "${preset.name}"? This will replace current drawing.`)) return;
                    // Ensure IDs are unique to avoid conflicts if re-saving?
                    // For now, just load as is.
                    const loadedElements = preset.elements.map(el => ({
                        ...el,
                        id: Date.now() + Math.random() // Regenerate IDs to avoid collision with history stacks
                    }));
                    updateElements(loadedElements);
                }
            };

            const deleteWizPreset = (presetId) => {
                if (!window.confirm("Delete this preset?")) return;
                const updatedLibrary = wizLibrary.filter(p => p.id !== parseInt(presetId));
                setWizLibrary(updatedLibrary);
                localStorage.setItem('wiz_ol_library', JSON.stringify(updatedLibrary));
            };

            // Formation Actions
            const flipFormation = () => {
                const flippedElements = elements.map(el => {
                    if (el.type === 'player' || el.type === 'poly' || el.type === 'free') {
                        return {
                            ...el,
                            points: el.points.map(p => ({
                                x: 800 - p.x,
                                y: p.y
                            }))
                        };
                    }
                    return el;
                });
                updateElements(flippedElements);
            };

            const saveAsFormationTemplate = () => {
                const name = window.prompt("Enter Formation Name:");
                if (!name) return;

                // Convert pixel coords back to percentages (0-100)
                // Editor width is 800, height is 500 (based on loadFormation logic)
                const positions = elements
                    .filter(el => el.type === 'player')
                    .map(el => ({
                        label: el.label,
                        x: (el.points[0].x / 800) * 100,
                        y: (el.points[0].y / 500) * 100
                    }));

                const newFormation = {
                    id: `form-${Date.now()}`,
                    name: name,
                    type: mode === 'scout-defense' ? 'Defense' : 'Offense',
                    positions: positions
                };

                onAddFormation(newFormation);
                alert(`Formation "${name}" saved to library!`);
            };

            // Drag State
            const [isDraggingElements, setIsDraggingElements] = useState(false);
            const [lastMousePos, setLastMousePos] = useState({ x: 0, y: 0 });

            // Helper to update elements with history
            const updateElements = (newElements, addToHistory = true) => {
                setElements(newElements);
                if (addToHistory) {
                    const newHistory = history.slice(0, historyIndex + 1);
                    newHistory.push(newElements);
                    setHistory(newHistory);
                    setHistoryIndex(newHistory.length - 1);
                }
            };

            const undo = () => {
                if (historyIndex > 0) {
                    const newIndex = historyIndex - 1;
                    setHistoryIndex(newIndex);
                    setElements(history[newIndex]);
                }
            };

            const redo = () => {
                if (historyIndex < history.length - 1) {
                    const newIndex = historyIndex + 1;
                    setHistoryIndex(newIndex);
                    setElements(history[newIndex]);
                }
            };

            const [isDrawing, setIsDrawing] = useState(false);
            const [currentPath, setCurrentPath] = useState(null);

            // Ref for SVG container to get coordinates
            const svgRef = useRef(null);

            // Tools configuration
            const ALL_TOOLS = [
                { id: 'select', icon: 'MousePointer', label: 'Select / Move' },
                { id: 'free', icon: 'Edit3', label: 'Freehand' },
                { id: 'line', icon: 'Minus', label: 'Polyline / Straight' },
                // Arrow tool removed, now an option on line
                { id: 'player', icon: 'User', label: 'Player Icon' },
                { id: 'delete', icon: 'Trash', label: 'Delete Mode' }
            ];
            // In formationOnly mode, only show select and player tools (no line drawing)
            const TOOLS = formationOnly
                ? ALL_TOOLS.filter(t => t.id === 'select' || t.id === 'player' || t.id === 'delete')
                : ALL_TOOLS;

            const COLORS = ['#000000', '#ef4444', '#3b82f6', '#22c55e', '#f97316', '#facc15', '#8b5cf6', '#ec4899', '#06b6d4'];

            const PLAYER_ICONS = [
                { label: 'Q', shape: 'circle' },
                { label: 'R', shape: 'circle' },
                { label: 'X', shape: 'circle' },
                { label: 'Y', shape: 'circle' },
                { label: 'Z', shape: 'circle' },
                { label: 'H', shape: 'circle' },
                { label: 'F', shape: 'circle' },
                { label: 'C', shape: 'square' },
                { label: 'G', shape: 'square' },
                { label: 'T', shape: 'square' },
                { label: 'S', shape: 'star' },  // Scout/Star
                { label: 'T', shape: 'target' } // Target
            ];

            // Coordinate calibration: Map mouse event to SVG coordinates
            const getPoint = (e) => {
                if (!svgRef.current) return { x: 0, y: 0 };
                const CTM = svgRef.current.getScreenCTM();
                if (!CTM) return { x: 0, y: 0 };
                return {
                    x: (e.clientX - CTM.e) / CTM.a,
                    y: (e.clientY - CTM.f) / CTM.d
                };
            };

            const handleMouseDown = (e) => {
                if (readOnly) return; // Disable interaction
                if (isDraggingElements) return; // Already dragging?
                if (selectedTool === 'delete') return;

                const point = getPoint(e);

                // Selection Box Logic (if Select tool)
                if (selectedTool === 'select') {
                    if (!e.shiftKey) setSelectedIds(new Set()); // Deselect unless shift
                    setSelectionBox({ start: point, current: point });
                    return;
                }

                // If clicking empty space...
                if (selectedTool === 'player') {
                    const newElement = {
                        id: Date.now(),
                        type: 'player',
                        points: [point],
                        color,
                        label: selectedPlayerIcon.label,
                        shape: selectedPlayerIcon.shape
                    };
                    updateElements([...elements, newElement]);
                    setSelectedIds(new Set([newElement.id])); // Select new element
                    return;
                }

                // Polyline Interaction
                if (selectedTool === 'line') {
                    if (!isDrawing) {
                        setIsDrawing(true);

                        // Smart Color Logic: Check if we clicked on a player
                        let drawColor = color;
                        const hitPlayer = elements.find(el => {
                            if (el.type !== 'player') return false;
                            const p = el.points[0];
                            // Rough hit test (circle radius ~30, text ~40)
                            const dist = Math.hypot(p.x - point.x, p.y - point.y);
                            return dist < 40; // generous hit radius
                        });

                        if (hitPlayer) {
                            drawColor = hitPlayer.color;
                            setColor(drawColor); // Update tool color for feedback
                        }

                        setCurrentPath({
                            id: Date.now(),
                            type: 'poly', // Generic polyline
                            color: drawColor,
                            style: lineStyle,
                            endType,
                            strokeWidth: lineWidth, // Save width
                            points: [point, { x: point.x + 1, y: point.y + 1 }] // Follower point
                        });
                    } else {
                        // Add segment anchor
                        setCurrentPath(prev => ({
                            ...prev,
                            points: [...prev.points.slice(0, -1), point, point] // Replace follower with actual point, then add new follower
                        }));
                    }
                } else if (selectedTool === 'free') {
                    setIsDrawing(true);

                    // Smart Color Logic
                    let drawColor = color;
                    const hitPlayer = elements.find(el => {
                        if (el.type !== 'player') return false;
                        const p = el.points[0];
                        const dist = Math.hypot(p.x - point.x, p.y - point.y);
                        return dist < 40;
                    });

                    if (hitPlayer) {
                        drawColor = hitPlayer.color;
                        setColor(drawColor);
                    }

                    setCurrentPath({
                        id: Date.now(),
                        type: 'free',
                        color: drawColor,
                        strokeWidth: lineWidth,
                        points: [point]
                    });
                }
            };

            const handleElementMouseDown = (e, elId) => {
                e.stopPropagation();
                if (selectedTool === 'delete') return; // Let click handle delete

                // Selection Logic
                const newSelected = new Set(selectedIds);
                if (e.shiftKey) {
                    if (newSelected.has(elId)) newSelected.delete(elId);
                    else newSelected.add(elId);
                } else {
                    if (!newSelected.has(elId)) {
                        newSelected.clear();
                        newSelected.add(elId);
                    }
                }
                setSelectedIds(newSelected);

                // Start Drag
                setIsDraggingElements(true);
                setLastMousePos(getPoint(e));
            };

            const handleMouseMove = (e) => {
                const point = getPoint(e);

                // Selection Box Update
                if (selectionBox) {
                    setSelectionBox(prev => ({ ...prev, current: point }));
                    return;
                }

                // Bulk Dragging Logic
                if (isDraggingElements) {
                    const dx = point.x - lastMousePos.x;
                    const dy = point.y - lastMousePos.y;

                    setElements(prev => prev.map(el => {
                        if (selectedIds.has(el.id)) {
                            // Move all points
                            return {
                                ...el,
                                points: el.points.map(p => ({ x: p.x + dx, y: p.y + dy }))
                            };
                        }
                        return el;
                    }));
                    setLastMousePos(point);
                    return;
                }

                // Drawing Logic
                if (!isDrawing || !currentPath) return;

                if (selectedTool === 'free') {
                    setCurrentPath(prev => ({
                        ...prev,
                        points: [...prev.points, point]
                    }));
                } else if (selectedTool === 'line') {
                    // Update the generic "follower" point (last point in array)
                    setCurrentPath(prev => {
                        const newPoints = [...prev.points];
                        newPoints[newPoints.length - 1] = point;
                        return { ...prev, points: newPoints };
                    });
                }
            };

            const handleDoubleClick = (e) => {
                if (!isDrawing || !currentPath) return;
                if (selectedTool === 'line') {
                    const finalPath = { ...currentPath };
                    // Remove the last point if it's just the cursor follower (already done in logic, but let's be safe)
                    // The 'follower' is usually the last point. 

                    // Filter out duplicate/too-close points
                    const uniquePoints = [];
                    if (finalPath.points.length > 0) {
                        uniquePoints.push(finalPath.points[0]);
                        for (let i = 1; i < finalPath.points.length; i++) {
                            const prev = uniquePoints[uniquePoints.length - 1];
                            const curr = finalPath.points[i];
                            const dist = Math.hypot(curr.x - prev.x, curr.y - prev.y);
                            if (dist > 2) { // Minimum 2px distance
                                uniquePoints.push(curr);
                            }
                        }
                    }

                    finalPath.points = uniquePoints;

                    setIsDrawing(false);
                    // Must have at least 2 points to be a line
                    if (finalPath.points.length > 1) {
                        updateElements([...elements, finalPath]);
                        setSelectedIds(new Set([finalPath.id]));
                    }
                    setCurrentPath(null);
                }
            };

            const handleMouseUp = () => {
                // Finish Selection Box
                if (selectionBox) {
                    // Calc bounds
                    const x1 = Math.min(selectionBox.start.x, selectionBox.current.x);
                    const y1 = Math.min(selectionBox.start.y, selectionBox.current.y);
                    const x2 = Math.max(selectionBox.start.x, selectionBox.current.x);
                    const y2 = Math.max(selectionBox.start.y, selectionBox.current.y);

                    const newSelected = new Set(selectedIds);
                    if (!selectionBox.start.shiftKey) { // Assuming we track shift? Actually handled in MouseDown clearing
                        // We already cleared in MouseDown if no shift.
                    }

                    elements.forEach(el => {
                        // Check if ANY point is in box
                        const isInside = el.points.some(p => p.x >= x1 && p.x <= x2 && p.y >= y1 && p.y <= y2);
                        if (isInside) newSelected.add(el.id);
                    });

                    setSelectedIds(newSelected);
                    setSelectionBox(null);
                    return;
                }

                // Finish Dragging
                if (isDraggingElements) {
                    setIsDraggingElements(false);
                    updateElements(elements); // Commit history
                    return;
                }

                // Stop Freehand Drawing
                if (selectedTool === 'free') {
                    setIsDrawing(false);
                    if (currentPath && currentPath.points.length > 1) {
                        updateElements([...elements, currentPath]);
                        setSelectedIds(new Set([currentPath.id]));
                    }
                    setCurrentPath(null);
                }
                // Line tool does NOT finish on mouse up, waits for double click
                // (Drag Logic moved up)
            };

            // Wiz Skill Formation (Custom Colors/Labels)
            const getWizFormation = (forcedSize) => {
                const center = 400;
                const los = 340; // Same geometry as default

                const cOL = '#000000';
                const cQB = '#ef4444'; // Red

                // Custom Skill Colors
                const cX = '#a855f7'; // Purple
                const cZ = '#22c55e'; // Green
                const cY = '#eab308'; // Yellow
                const cA = '#ef4444'; // Red (Slot)
                const cB = '#3b82f6'; // Blue (RB)

                return [
                    // OL - Text Only (Respects wizTextSize)
                    { id: Date.now() + 1, type: 'player', points: [{ x: center, y: los + 18 }], color: cOL, label: 'C', shape: 'text-only', fontSize: forcedSize || wizTextSize },
                    { id: Date.now() + 2, type: 'player', points: [{ x: center - 170, y: los + 18 + 15 }], color: cOL, label: 'G', shape: 'text-only', fontSize: forcedSize || wizTextSize },
                    { id: Date.now() + 3, type: 'player', points: [{ x: center + 170, y: los + 18 + 15 }], color: cOL, label: 'G', shape: 'text-only', fontSize: forcedSize || wizTextSize },
                    { id: Date.now() + 4, type: 'player', points: [{ x: center - 340, y: los + 18 + 30 }], color: cOL, label: 'T', shape: 'text-only', fontSize: forcedSize || wizTextSize },
                    { id: Date.now() + 5, type: 'player', points: [{ x: center + 340, y: los + 18 + 30 }], color: cOL, label: 'T', shape: 'text-only', fontSize: forcedSize || wizTextSize },
                    // QB - Red
                    { id: Date.now() + 6, type: 'player', points: [{ x: center, y: los + 100 }], color: cQB, label: 'Q', shape: 'circle' },
                    // B (was RB) - Blue
                    { id: Date.now() + 7, type: 'player', points: [{ x: center, y: los + 140 }], color: cB, label: 'B', shape: 'circle' },
                    // X - Purple
                    { id: Date.now() + 8, type: 'player', points: [{ x: 100, y: los + 15 }], color: cX, label: 'X', shape: 'circle' },
                    // Z - Green
                    { id: Date.now() + 9, type: 'player', points: [{ x: 700, y: los + 15 }], color: cZ, label: 'Z', shape: 'circle' },
                    // A (was H) - Red
                    { id: Date.now() + 10, type: 'player', points: [{ x: 200, y: los + 35 }], color: cA, label: 'A', shape: 'circle' },
                    // Y - Yellow
                    { id: Date.now() + 11, type: 'player', points: [{ x: center + 120, y: los + 15 }], color: cY, label: 'Y', shape: 'circle' },
                ];
            };

            const handleQuickOffense = () => {
                if (elements.length > 0 && !window.confirm('Clear current diagram?')) return;
                updateElements(getDefaultFormation());
            };

            const handleWizOffense = () => {
                if (elements.length > 0 && !window.confirm('Clear current diagram?')) return;
                setWizTextSize(170); // Ensure state is updated for controls
                updateElements(getWizFormation(170)); // Pass explicit size
            };

            const handleClickElement = (elId) => {
                if (selectedTool === 'delete') {
                    updateElements(elements.filter(el => el.id !== elId));
                } else {
                    // Logic handled in MouseDown now
                }
            };

            // Keyboard Shortcuts
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                    // Delete / Backspace
                    if (e.key === 'Delete' || e.key === 'Backspace') {
                        if (selectedIds.size > 0) {
                            updateElements(elements.filter(el => !selectedIds.has(el.id)));
                            setSelectedIds(new Set());
                        }
                    }

                    // Undo / Redo
                    if ((e.metaKey || e.ctrlKey) && e.key === 'z') {
                        e.preventDefault();
                        if (e.shiftKey) {
                            redo();
                        } else {
                            undo();
                        }
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [selectedIds, elements, history, historyIndex]);

            // Render SVG contents
            const renderElement = (el, isPreview = false) => {
                if (el.type === 'player') {
                    // ... (existing player render code) ...
                    // Update: Pass strokeWidth if needed, but usually players have fixed stroke?
                    // Let's keep players standard for now unless requested.
                    const { x, y } = el.points[0];
                    const size = 30; // Icon size
                    const isRect = el.shape === 'square';
                    const isFilled = el.variant === 'filled';
                    const fillColor = isFilled ? el.color : 'white';
                    const strokeColor = el.color; // Stroke matches color
                    const textColor = isFilled ? 'white' : el.color;


                    const isSelected = selectedIds.has(el.id);
                    // Critical Fix: If we are drawing (line/free) or placing players, ignore existing elements logic.
                    // Only allow interaction if tool is Select/Move or Delete.
                    const isInteractionTool = selectedTool === 'select' || selectedTool === 'delete';
                    const pointerEvents = isInteractionTool ? 'all' : 'none';

                    return (
                        <g
                            key={el.id}
                            onMouseDown={(e) => !isPreview && handleElementMouseDown(e, el.id)}
                            onClick={(e) => { e.stopPropagation(); !isPreview && handleClickElement(el.id); }}
                            style={{
                                cursor: selectedTool === 'delete' ? 'pointer' : (isPreview ? 'default' : 'move'),
                                opacity: isPreview ? 0.8 : 1,
                                pointerEvents: pointerEvents
                            }}
                        >
                            {/* Selection Highlight */}
                            {isSelected && !isPreview && (
                                isRect ? (
                                    <rect x={x - size / 2 - 4} y={y - size / 2 - 4} width={size + 8} height={size + 8} fill="none" stroke="#2563eb" strokeWidth="2" strokeDasharray="4,2" />
                                ) : (
                                    <circle cx={x} cy={y} r={size / 2 + 4} fill="none" stroke="#2563eb" strokeWidth="2" strokeDasharray="4,2" />
                                )
                            )}

                            {isRect ? (
                                <rect x={x - size / 2} y={y - size / 2} width={size} height={size} fill={fillColor} stroke={strokeColor} strokeWidth="2" />
                            ) : el.shape === 'star' ? (
                                <polygon
                                    points={`${x},${y - size / 1.5} ${x + size / 3},${y - size / 4} ${x + size / 1.2},${y - size / 4} ${x + size / 2},${y + size / 4} ${x + size / 1.5},${y + size / 1.2} ${x},${y + size / 2} ${x - size / 1.5},${y + size / 1.2} ${x - size / 2},${y + size / 4} ${x - size / 1.2},${y - size / 4} ${x - size / 3},${y - size / 4}`}
                                    fill={fillColor} stroke={strokeColor} strokeWidth="2"
                                />
                            ) : el.shape === 'target' ? (
                                <g>
                                    <circle cx={x} cy={y} r={size / 2} fill="none" stroke={strokeColor} strokeWidth="2" />
                                    <circle cx={x} cy={y} r={size / 4} fill={fillColor} stroke={strokeColor} strokeWidth="1" />
                                    <line x1={x - size / 2} y1={y} x2={x + size / 2} y2={y} stroke={strokeColor} strokeWidth="1" />
                                    <line x1={x} y1={y - size / 2} x2={x} y2={y + size / 2} stroke={strokeColor} strokeWidth="1" />
                                </g>
                            ) : el.shape === 'text-only' ? (
                                // No shape, just big text
                                // We need a transparent hit box so dragging works
                                (() => {
                                    // Calculate size once - prioritize element's saved size
                                    const tSize = el.fontSize || 170;
                                    return (
                                        <React.Fragment>
                                            <rect
                                                x={x - (tSize * 0.6) / 2}
                                                y={y - (tSize * 0.8) / 2}
                                                width={tSize * 0.6}
                                                height={tSize * 0.8}
                                                fill="transparent"
                                                stroke="none"
                                            />
                                            {isSelected && !isPreview && (
                                                <rect
                                                    x={x - (tSize * 0.6) / 2 - 4}
                                                    y={y - (tSize * 0.8) / 2 - 4}
                                                    width={(tSize * 0.6) + 8}
                                                    height={(tSize * 0.8) + 8}
                                                    fill="none"
                                                    stroke="#2563eb"
                                                    strokeWidth="2"
                                                    strokeDasharray="4,2"
                                                />
                                            )}
                                        </React.Fragment>
                                    );
                                })()
                            ) : (
                                <circle cx={x} cy={y} r={size / 2} fill={fillColor} stroke={strokeColor} strokeWidth="2" />
                            )}
                            <text
                                x={x}
                                y={y}
                                dy={el.shape === 'text-only' ? "0.35em" : "0.35em"}
                                textAnchor="middle"
                                fontSize={el.shape === 'text-only' ? (el.fontSize || 170) : "16"}
                                fontWeight="bold"
                                fill={el.shape === 'text-only' ? (el.color || 'black') : textColor}
                                style={{ pointerEvents: 'none', userSelect: 'none', fontFamily: 'Arial, sans-serif' }}
                            >
                                {el.type === 'player' ? (positionNames[el.label] || el.label) : el.label}
                            </text>
                        </g>
                    );
                }

                if (el.points.length < 2) return null;

                // Path Data Generation
                let d = '';
                if (el.style === 'zigzag') {
                    d = getZigZagPath(el.points);
                } else if (el.type === 'free' || el.type === 'poly') {
                    d = `M ${el.points.map(p => `${p.x},${p.y}`).join(' L ')}`;
                }

                // T-Block Marker (Custom logic since SVG markers are limited)
                let markerEnd = undefined;
                let tBlock = null;

                if (el.endType === 'arrow') {
                    markerEnd = `url(#arrowhead-${el.color})`;
                } else if (el.endType === 't') {
                    // Calculate perpendicular line at end
                    const end = el.points[el.points.length - 1];
                    const prev = el.points[el.points.length - 2] || el.points[0]; // Need vector
                    const dx = end.x - prev.x;
                    const dy = end.y - prev.y;
                    const len = Math.hypot(dx, dy) || 1;
                    const sWidth = parseInt(el.strokeWidth || 2);
                    // Scale T-width slightly with stroke, but mostly fixed length. 
                    // Length of T-bar: 30px total (15 scale).
                    // Thickness: match line width.
                    const perpX = (-dy / len) * 15;
                    const perpY = (dx / len) * 15;

                    tBlock = (
                        <line
                            x1={end.x - perpX} y1={end.y - perpY}
                            x2={end.x + perpX} y2={end.y + perpY}
                            stroke={el.color}
                            strokeWidth={sWidth}
                            strokeLinecap="round"
                        />
                    );
                } else if (el.endType === 'dot') {
                    const end = el.points[el.points.length - 1];
                    tBlock = (
                        <circle cx={end.x} cy={end.y} r="6" fill={el.color} />
                    );
                }

                const isSelected = selectedIds.has(el.id);
                const strokeWidth = el.strokeWidth || 4;
                const isInteractionTool = selectedTool === 'select' || selectedTool === 'delete';

                // Add click handler for ReadOnly mode
                const handleElementClick = (e) => {
                    if (!readOnly) return;
                    if (el.link || el.conceptLabel) {
                        e.stopPropagation();
                        if (el.link) {
                            const url = el.link.startsWith('http') ? el.link : null;
                            if (url) window.open(url, '_blank');
                            else alert(`Linked: ${el.conceptLabel}\n(No valid URL found)`);
                        } else {
                            alert(`Note: ${el.conceptLabel}`);
                        }
                    }
                };

                return (
                    <g key={el.id || 'current'} onClick={handleElementClick} style={{ cursor: (readOnly && (el.link || el.conceptLabel)) ? 'pointer' : (selectedTool === 'delete' ? 'pointer' : 'default'), opacity: isPreview ? 0.6 : 1, pointerEvents: (readOnly || isInteractionTool) ? 'all' : 'none' }}>
                        <path
                            d={d}
                            stroke={isSelected ? '#2563eb' : el.color}
                            strokeWidth={isSelected ? strokeWidth + 2 : strokeWidth}
                            fill="none"
                            strokeDasharray={el.style === 'dashed' ? "10,5" : "none"}
                            markerEnd={markerEnd}
                            filter={isSelected ? "drop-shadow(0 0 2px #2563eb)" : "none"}
                        />
                        {tBlock}
                        {/* Title for hover tooltip */}
                        {(el.link || el.conceptLabel) && <title>{`Linked: ${el.conceptLabel || 'Video'} ${el.link ? `(${el.link})` : ''}`}</title>}
                    </g>
                );
            };

            // Toggle Wiz Node (Y or F)
            // Toggle Wiz Node (Generic)
            const toggleWizNode = (label) => {
                setElements(prev => {
                    const exists = prev.find(e => e.label === label && e.type === 'player');
                    if (exists) {
                        return prev.filter(e => e.id !== exists.id);
                    } else {
                        const center = 400;
                        const los = 340 + 18;
                        let newPoint = { x: center + 60, y: los + 60 };
                        let shape = 'circle'; // Default to circle for skill players
                        let color = '#3b82f6'; // Skill blue default

                        if (mode === 'wiz-oline') {
                            shape = 'text-only';
                            color = '#000000';
                            // Place below the main line so user can drag into place
                            newPoint = { x: center, y: los + 150 };
                        } else {
                            if (label === 'Y') {
                                newPoint = { x: center + 180, y: los };
                                color = '#eab308'; // Yellow for Y
                            } else if (label === 'F') {
                                newPoint = { x: center + 60, y: los + 60 };
                                color = '#f97316'; // Orange for F
                            }
                        }

                        return [...prev, {
                            id: Date.now(),
                            type: 'player',
                            points: [newPoint],
                            color: color,
                            label: label,
                            shape: shape,
                            variant: 'filled',
                            fontSize: mode === 'wiz-oline' ? wizTextSize : undefined
                        }];
                    }
                });
            };

            // For WIZ modes, use fullscreen layout; for standard mode, use centered modal
            const isWizMode = mode === 'wiz-skill' || mode === 'wiz-oline';

            return (
                <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, width: '100vw', height: '100vh', background: isWizMode ? '#1e293b' : 'rgba(0,0,0,0.8)', zIndex: 99999, display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
                    <div className="animate-fade-in" style={{ width: isWizMode ? '100%' : '95%', height: isWizMode ? '100%' : '90%', background: 'white', borderRadius: isWizMode ? '0' : '12px', display: 'flex', flexDirection: 'column', overflow: 'hidden', boxShadow: isWizMode ? 'none' : '0 25px 50px -12px rgba(0, 0, 0, 0.25)' }}>
                        {/* Header / Toolbar */}
                        <div style={{ padding: '0.5rem 1rem', borderBottom: '1px solid #e5e7eb', display: readOnly ? 'none' : 'flex', alignItems: 'center', background: '#f8fafc', gap: '0.75rem' }}>

                            {/* --- LEFT: Save/Cancel Actions --- */}
                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.35rem' }}>
                                <button className="btn btn-secondary" onClick={onCancel} style={{ fontSize: '0.8rem', padding: '0.4rem 0.7rem', color: '#64748b', background: 'white', border: '1px solid #cbd5e1' }}>Cancel</button>
                                <button className="btn btn-primary" onClick={() => onSave({ elements })} style={{ fontSize: '0.8rem', padding: '0.4rem 0.7rem', color: 'white', backgroundColor: '#22c55e', fontWeight: 'bold', border: 'none' }}>
                                    <Icon name="Save" size={14} style={{ marginRight: '4px' }} /> Save
                                </button>
                            </div>

                            <div style={{ width: '1px', height: '24px', background: '#cbd5e1' }}></div>

                            {/* --- Edit Actions: Undo/Redo/Delete --- */}
                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.25rem' }}>
                                <button className="btn btn-secondary" onClick={undo} disabled={historyIndex === 0} title="Undo" style={{ padding: '0.35rem 0.5rem', display: 'flex', alignItems: 'center', gap: '0.2rem', color: '#64748b', backgroundColor: 'white', border: '1px solid #e2e8f0' }}>
                                    <Icon name="RotateCcw" size={14} />
                                </button>
                                <button className="btn btn-secondary" onClick={redo} disabled={historyIndex === history.length - 1} title="Redo" style={{ padding: '0.35rem 0.5rem', display: 'flex', alignItems: 'center', gap: '0.2rem', color: '#64748b', backgroundColor: 'white', border: '1px solid #e2e8f0' }}>
                                    <Icon name="RotateCw" size={14} />
                                </button>
                                <button className={`btn ${selectedTool === 'delete' ? 'btn-danger' : 'btn-secondary'}`} onClick={() => { if (selectedIds.size > 0) { updateElements(elements.filter(el => !selectedIds.has(el.id))); setSelectedIds(new Set()); } else { setSelectedTool('delete'); } }} title="Delete selected" style={{ padding: '0.35rem 0.5rem', display: 'flex', alignItems: 'center', color: selectedTool === 'delete' ? 'white' : '#ef4444', backgroundColor: selectedTool === 'delete' ? '#ef4444' : 'white', border: '1px solid #fca5a5' }}>
                                    <Icon name="Trash" size={14} />
                                </button>
                            </div>

                            <div style={{ width: '1px', height: '24px', background: '#cbd5e1' }}></div>

                            {/* --- Tools: Select/Move, Player, Line --- */}
                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.25rem' }}>
                                {TOOLS.filter(t => t.id !== 'delete' && !(mode === 'wiz-oline' && t.id === 'player')).map(tool => {
                                    if (tool.id === 'line' && formationOnly) return null;
                                    if (tool.id === 'line') {
                                        return (
                                            <div key={tool.id} style={{ position: 'relative' }}>
                                                <button
                                                    className={`btn ${selectedTool === tool.id ? 'btn-primary' : 'btn-secondary'}`}
                                                    onClick={() => selectedTool === 'line' ? setShowLineOptions(!showLineOptions) : (setSelectedTool('line'), setEndType('arrow'), setShowLineOptions(false))}
                                                    title="Line Tool"
                                                    style={{ padding: '0.35rem 0.6rem', display: 'flex', gap: '0.25rem', alignItems: 'center', color: '#1e293b' }}
                                                >
                                                    <Icon name={tool.icon} size={16} />
                                                    <span style={{ fontSize: '0.8rem' }}>Line</span>
                                                    {selectedTool === 'line' && <span style={{ fontSize: '0.7rem', opacity: 0.7 }}>▼</span>}
                                                </button>
                                                {showLineOptions && selectedTool === 'line' && (
                                                    <div style={{ position: 'absolute', top: '100%', left: 0, marginTop: '4px', background: 'white', border: '1px solid #ccc', borderRadius: '4px', boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)', zIndex: 50, display: 'flex', flexDirection: 'column', minWidth: '120px' }}>
                                                        {[{ id: 'arrow', label: 'Arrow →' }, { id: 't', label: 'Block —|' }, { id: 'dot', label: 'Dot •' }, { id: 'none', label: 'Plain —' }].map(opt => (
                                                            <button key={opt.id} onClick={(e) => { e.stopPropagation(); setEndType(opt.id); setShowLineOptions(false); }} style={{ padding: '0.5rem', textAlign: 'left', background: endType === opt.id ? '#f0f9ff' : 'white', border: 'none', borderBottom: '1px solid #eee', cursor: 'pointer', fontSize: '0.8rem', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                                {opt.label}
                                                                {endType === opt.id && <Icon name="CheckCircle" size={12} color="#0284c7" />}
                                                            </button>
                                                        ))}
                                                    </div>
                                                )}
                                            </div>
                                        );
                                    }
                                    return (
                                        <button key={tool.id} className={`btn ${selectedTool === tool.id ? 'btn-primary' : 'btn-secondary'}`} onClick={() => { setSelectedTool(tool.id); if (tool.id !== 'line') setShowLineOptions(false); }} title={tool.label} style={{ padding: '0.35rem 0.6rem', display: 'flex', gap: '0.25rem', alignItems: 'center', color: '#1e293b' }}>
                                            <Icon name={tool.icon} size={16} /><span style={{ fontSize: '0.8rem' }}>{tool.label}</span>
                                        </button>
                                    );
                                })}

                                {/* Line style options - shown inline when line tool active */}
                                {!formationOnly && (selectedTool === 'line' || selectedTool === 'free') && (
                                    <>
                                        <select value={lineStyle} onChange={(e) => setLineStyle(e.target.value)} className="form-input" style={{ padding: '0.3rem', fontSize: '0.75rem', width: 'auto', background: 'white', border: '1px solid #e2e8f0', borderRadius: '4px', color: '#1e293b' }}>
                                            <option value="solid">Solid</option>
                                            <option value="dashed">Dashed</option>
                                            <option value="zigzag">Zigzag</option>
                                        </select>
                                        <select value={lineWidth} onChange={(e) => { const w = parseInt(e.target.value); setLineWidth(w); if (selectedIds.size > 0) updateElements(elements.map(el => (selectedIds.has(el.id) && (el.type === 'line' || el.type === 'free' || el.type === 'poly')) ? { ...el, strokeWidth: w } : el)); }} className="form-input" style={{ padding: '0.3rem', fontSize: '0.75rem', width: 'auto', background: 'white', border: '1px solid #e2e8f0', borderRadius: '4px', color: '#1e293b' }}>
                                            <option value={2}>Thin</option>
                                            <option value={4}>Med</option>
                                            <option value={6}>Thick</option>
                                        </select>
                                    </>
                                )}
                            </div>

                            {/* --- Colors --- */}
                            <div style={{ display: 'flex', gap: '3px', alignItems: 'center', background: '#f1f5f9', padding: '4px 6px', borderRadius: '20px', border: '1px solid #e2e8f0' }}>
                                {COLORS.map(c => (
                                    <button key={c} onClick={() => { setColor(c); if (selectedIds.size > 0) updateElements(elements.map(el => selectedIds.has(el.id) ? { ...el, color: c } : el)); }} style={{ width: '18px', height: '18px', borderRadius: '50%', background: c, border: color === c ? '2px solid white' : '1px solid rgba(0,0,0,0.1)', boxShadow: color === c ? '0 0 0 2px #3b82f6' : 'none', cursor: 'pointer' }}></button>
                                ))}
                            </div>

                            <div style={{ flex: 1 }}></div>

                            {/* --- RIGHT: Formation & Flip --- */}
                            {mode.startsWith('wiz') && formations.length > 0 && !formationOnly && (
                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                    <select value={selectedFormationId} onChange={(e) => { setSelectedFormationId(e.target.value); if (e.target.value) loadFormation(e.target.value); }} style={{ padding: '0.35rem 0.5rem', fontSize: '0.8rem', borderRadius: '4px', border: '1px solid #cbd5e1', color: '#1e293b', backgroundColor: 'white' }}>
                                        <option value="">Formation...</option>
                                        {formations.map(f => (<option key={f.id} value={f.id}>{f.name}</option>))}
                                    </select>
                                </div>
                            )}

                            <button className="btn btn-secondary" onClick={flipFormation} title="Flip Left/Right" style={{ padding: '0.35rem 0.6rem', display: 'flex', gap: '0.25rem', alignItems: 'center', color: '#1e293b', backgroundColor: 'white', border: '1px solid #cbd5e1' }}>
                                <Icon name="RefreshCw" size={14} />
                                <span style={{ fontSize: '0.8rem' }}>Flip</span>
                            </button>

                            {!formationOnly && (
                                <button className="btn btn-secondary" onClick={saveAsFormationTemplate} title="Save as Formation" style={{ padding: '0.35rem 0.6rem', display: 'flex', gap: '0.25rem', alignItems: 'center', color: '#0891b2', backgroundColor: '#ecfeff', border: '1px solid #a5f3fc' }}>
                                    <Icon name="Layout" size={14} />
                                    <span style={{ fontSize: '0.8rem' }}>Save Formation</span>
                                </button>
                            )}

                            {/* --- Personnel (WIZ modes only) --- */}
                            {(mode === 'wiz-oline' || mode === 'wiz-skill') && !formationOnly && (
                                <div style={{ display: 'flex', gap: '0.3rem', alignItems: 'center', background: '#e0f2fe', padding: '0.3rem 0.5rem', borderRadius: '4px', border: '1px solid #7dd3fc' }}>
                                    {mode === 'wiz-skill' && (
                                        <>
                                            <button className={`btn ${elements.some(e => e.label === 'Y') ? 'btn-primary' : 'btn-secondary'}`} onClick={() => toggleWizNode('Y')} style={{ padding: '0.15rem 0.4rem', fontSize: '0.75rem', color: '#1e293b' }}>+Y</button>
                                            <button className={`btn ${elements.some(e => e.label === 'F') ? 'btn-primary' : 'btn-secondary'}`} onClick={() => toggleWizNode('F')} style={{ padding: '0.15rem 0.4rem', fontSize: '0.75rem', color: '#1e293b' }}>+F</button>
                                        </>
                                    )}
                                    <input type="text" value={customLetterInput} onChange={(e) => setCustomLetterInput(e.target.value.toUpperCase())} placeholder="?" maxLength={2} style={{ width: '22px', padding: '2px', textAlign: 'center', fontSize: '0.75rem', color: '#1e293b', border: '1px solid #94a3b8', borderRadius: '3px' }} />
                                    <button className="btn btn-secondary" onClick={() => { if (customLetterInput) { toggleWizNode(customLetterInput); setCustomLetterInput(''); } }} disabled={!customLetterInput} style={{ padding: '0.15rem 0.35rem', fontSize: '0.75rem', color: '#1e293b' }}>Add</button>

                                    {mode === 'wiz-oline' && (
                                        <>
                                            <div style={{ width: '1px', height: '16px', background: '#7dd3fc', margin: '0 0.15rem' }}></div>
                                            <button className="btn btn-secondary" onClick={() => { const s = Math.max(12, wizTextSize - 4); setWizTextSize(s); if (selectedIds.size > 0) updateElements(elements.map(el => (selectedIds.has(el.id) && el.shape === 'text-only') ? { ...el, fontSize: s } : el)); }} style={{ padding: '0 0.25rem', fontSize: '0.8rem', color: '#1e293b' }}>-</button>
                                            <span style={{ fontSize: '0.7rem', fontWeight: 'bold', minWidth: '1rem', textAlign: 'center' }}>{wizTextSize}</span>
                                            <button className="btn btn-secondary" onClick={() => { const s = Math.min(200, wizTextSize + 4); setWizTextSize(s); if (selectedIds.size > 0) updateElements(elements.map(el => (selectedIds.has(el.id) && el.shape === 'text-only') ? { ...el, fontSize: s } : el)); }} style={{ padding: '0 0.25rem', fontSize: '0.8rem', color: '#1e293b' }}>+</button>
                                            <div style={{ width: '1px', height: '16px', background: '#7dd3fc', margin: '0 0.15rem' }}></div>
                                            <button className="btn btn-secondary" onClick={initiateSave} title="Save to library" style={{ padding: '0.1rem 0.25rem', fontSize: '0.7rem', color: '#1e293b', border: 'none', background: 'transparent' }}><Icon name="Save" size={12} /></button>
                                            <select style={{ padding: '2px', fontSize: '0.7rem', width: '70px', color: '#1e293b', border: 'none', background: 'transparent' }} onChange={(e) => { if (e.target.value) { loadWizPreset(e.target.value); e.target.value = ""; } }} defaultValue="">
                                                <option value="" disabled>Lib</option>
                                                {wizLibrary.map(preset => (<option key={preset.id} value={preset.id}>{preset.name}</option>))}
                                            </select>
                                        </>
                                    )}
                                </div>
                            )}

                            {/* Field position selector - standard mode only */}
                            {mode !== 'wiz-oline' && mode !== 'wiz-skill' && (
                                <select value={fieldPosition} onChange={(e) => setFieldPosition(parseInt(e.target.value))} style={{ padding: '0.35rem 0.5rem', fontSize: '0.8rem', borderRadius: '4px', border: '1px solid #cbd5e1', color: '#1e293b', backgroundColor: 'white' }}>
                                    <option value={50}>Midfield</option><option value={20}>Red Zone</option><option value={5}>Goal Line</option><option value={35}>Open Field</option>
                                </select>
                            )}

                            {/* --- OVERLAYS (Floating within the toolbar wrap context) --- */}
                            {selectedTool === 'player' && (
                                <div style={{ display: 'flex', gap: '0.25rem', alignItems: 'center', background: '#e2e8f0', padding: '0.25rem', borderRadius: '4px', width: '100%', marginTop: '0.25rem' }}>
                                    {PLAYER_ICONS.map(p => (
                                        <button key={p.label + p.shape} onClick={() => setSelectedPlayerIcon(p)} style={{ width: '24px', height: '24px', borderRadius: '4px', border: selectedPlayerIcon.label === p.label && selectedPlayerIcon.shape === p.shape ? '2px solid var(--accent)' : '1px solid #ccc', background: 'white', fontWeight: 'bold', fontSize: '0.7rem', color: 'black', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>{p.shape === 'star' ? '★' : p.shape === 'target' ? '⌖' : p.label}</button>
                                    ))}
                                    <button className="btn btn-secondary" onClick={handleQuickOffense} title="11-Man Formation" style={{ fontSize: '0.7rem', padding: '0.25rem 0.4rem', color: '#1e293b', background: 'white', border: '1px solid #ccc' }}>⚡ Quick 11</button>
                                    <button className="btn btn-secondary" onClick={handleScoutDefense} title="Scout Defense Formation" style={{ fontSize: '0.7rem', padding: '0.25rem 0.4rem', backgroundColor: '#374151', color: 'white' }}>🛡 Scout Def</button>
                                    <button className="btn btn-secondary" onClick={handleScoutOffense} title="Scout Offense Formation" style={{ fontSize: '0.7rem', padding: '0.25rem 0.4rem', backgroundColor: '#eab308', color: 'black' }}>⚔️ Scout Off</button>
                                    <button className="btn btn-secondary" onClick={handleWizOffense} title="Wiz Skill Colors" style={{ fontSize: '0.7rem', padding: '0.25rem 0.4rem', background: '#e0f2fe', color: '#0369a1', borderColor: '#bae6fd' }}>🎨 Wiz</button>
                                </div>
                            )}

                            {showSaveModal && (
                                <div style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 100 }}>
                                    <div style={{ background: 'white', padding: '1.5rem', borderRadius: '8px', boxShadow: '0 4px 6px rgba(0,0,0,0.1)', width: '300px' }}>
                                        <h3 style={{ marginTop: 0, fontSize: '1.1rem' }}>Save to Library</h3>
                                        <input type="text" className="form-input" placeholder="Enter play name..." value={saveName} onChange={e => setSaveName(e.target.value)} style={{ width: '100%', marginBottom: '1rem', background: 'white', color: 'black' }} autoFocus />
                                        <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '0.5rem' }}>
                                            <button className="btn btn-secondary" onClick={() => setShowSaveModal(false)}>Cancel</button>
                                            <button className="btn btn-primary" onClick={confirmSave} disabled={!saveName}>Save</button>
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>

                        {/* Help Text - hide in WIZ modes for cleaner look */}
                        {!isWizMode && (
                            <div style={{ background: '#fff', borderBottom: '1px solid #eee', padding: '0.25rem 1rem', fontSize: '0.75rem', color: '#666', display: 'flex', justifyContent: 'center' }}>
                                {selectedTool === 'line' ? 'Tip: Click to start • Click to turn corner • Double-Click to finish' :
                                    selectedTool === 'player' ? 'Tip: Drag icons to move • Click on field to add new' : 'Drag to draw'}
                            </div>
                        )}

                        {/* Canvas */}
                        <div style={{
                            flex: 1,
                            position: 'relative',
                            background: isWizMode ? '#0f172a' : '#e5e7eb',
                            cursor: selectedTool === 'delete' ? 'no-drop' : (selectedTool === 'player' ? 'default' : 'crosshair'),
                            overflow: 'hidden',
                            display: 'flex',
                            justifyContent: 'center',
                            alignItems: 'center',
                            padding: isWizMode ? '1.5rem 3rem' : '1rem'
                        }}>
                            {/* Inner container with correct aspect ratio for WIZ Card mode */}
                            <div style={{
                                width: isWizMode ? 'auto' : (fieldViewMode === 'wiz-card' ? 'auto' : '100%'),
                                height: '100%',
                                aspectRatio: (isWizMode || fieldViewMode === 'wiz-card') ? '754 / 445' : 'auto',
                                maxWidth: '100%',
                                maxHeight: '100%',
                                background: '#ffffff',
                                boxShadow: isWizMode ? '0 4px 20px rgba(0,0,0,0.4)' : (fieldViewMode === 'wiz-card' ? '0 4px 6px -1px rgba(0, 0, 0, 0.1)' : 'none')
                            }}>
                                <svg
                                    ref={svgRef}
                                    width="100%"
                                    height="100%"
                                    viewBox={fieldViewMode === 'wiz-card' ? '0 0 754 445' : '0 0 900 600'}
                                    preserveAspectRatio={fieldViewMode === 'wiz-card' ? 'xMidYMid meet' : 'none'}
                                    style={fieldViewMode === 'wiz-card' ? { aspectRatio: '15.07 / 8.89' } : {}}
                                    onMouseDown={handleMouseDown}
                                    onMouseMove={handleMouseMove}
                                    onMouseUp={handleMouseUp}
                                    onDoubleClick={handleDoubleClick}
                                    onMouseLeave={handleMouseUp}
                                >
                                <defs>
                                    {COLORS.map(c => (
                                        <marker key={c} id={`arrowhead-${c}`} markerWidth="6" markerHeight="4" refX="5" refY="2" orient="auto">
                                            <polygon points="0 0, 6 2, 0 4" fill={c} />
                                        </marker>
                                    ))}
                                    {/* Grid Pattern */}
                                    <pattern id="grid" width="100" height="100" patternUnits="userSpaceOnUse">
                                        <path d="M 100 0 L 0 0 0 100" fill="none" stroke="#f0f0f0" strokeWidth="1" />
                                    </pattern>
                                </defs>

                                {/* Field Background Logic */}
                                {mode === 'detailed' ? (
                                    <g>
                                        <rect width="100%" height="100%" fill="white" />
                                        {/* Detailed grid/field lines (High School Specs) */}
                                        {/* Field Width 53.33 yards = 800px => 15px/yard */}
                                        {/* Hashes: Equal Thirds => 17.78 yds from sideline => 266.6px */}
                                        {/* Numbers: Top of numbers 9 yards from sideline => 135px */}

                                        {[0, 1, 2, 3, 4, 5, 6, 7].map(i => {
                                            // Lines every 5 yards (75px)
                                            // LOS at 350
                                            const y = 50 + (i * 75); // 50, 125, 200, 275, 350, 425, 500

                                            return (
                                                <g key={i}>
                                                    {/* Yard Line */}
                                                    <line x1="0" y1={y} x2="800" y2={y} stroke={y === 350 ? "#000" : "#e2e8f0"} strokeWidth={y === 350 ? 3 : 2} />

                                                    {/* High School Hashes (Thirds) */}
                                                    <line x1="266" y1={y - 8} x2="266" y2={y + 8} stroke="#000" strokeWidth="2" />
                                                    <line x1="534" y1={y - 8} x2="534" y2={y + 8} stroke="#000" strokeWidth="2" />

                                                    {/* Yard Numbers (Contrast Fixed) */}
                                                    {Math.abs(350 - y) % 150 === 0 && y !== 350 && (
                                                        <React.Fragment>
                                                            <text x="135" y={y + 8} fill="#64748b" fontSize="24" fontWeight="bold" textAnchor="middle" style={{ opacity: 0.6 }}>{(350 - y) / 15}</text>
                                                            <text x="665" y={y + 8} fill="#64748b" fontSize="24" fontWeight="bold" textAnchor="middle" style={{ opacity: 0.6 }}>{(350 - y) / 15}</text>
                                                        </React.Fragment>
                                                    )}
                                                </g>
                                            );
                                        })}
                                        {/* LOS Marker */}
                                        <text x="20" y="345" fontSize="12" fontWeight="bold" fill="#000">LOS</text>
                                        <text x="780" y="345" fontSize="12" fontWeight="bold" fill="#000" textAnchor="end">LOS</text>
                                    </g>
                                ) : mode === 'wiz-oline' ? (
                                    <g>
                                        <rect width="100%" height="100%" fill="white" />
                                        {/* No grid lines or yard markers for Wiz OL */}
                                    </g>
                                ) : (
                                    <g>
                                        {/* WIZ Field - Using background image */}
                                        <image
                                            href="WIZ%20Background.jpg"
                                            x="0"
                                            y="0"
                                            width="100%"
                                            height="100%"
                                            preserveAspectRatio="none"
                                        />
                                    </g>
                                )}

                                {/* WIZ Card Boundary Guides - shown when in wiz-skill mode with Full Field view to indicate what will be visible on printed WIZ cards */}
                                {mode === 'wiz-skill' && fieldViewMode === 'standard' && (
                                    <g>
                                        {/* Dimmed areas outside WIZ card visible bounds (y < 60 and y > 520) */}
                                        <rect x="0" y="0" width="900" height="60" fill="rgba(0,0,0,0.15)" />
                                        <rect x="0" y="520" width="900" height="80" fill="rgba(0,0,0,0.15)" />
                                        <rect x="800" y="60" width="100" height="460" fill="rgba(0,0,0,0.15)" />

                                        {/* Border showing exact WIZ card visible area (0-800 x, 60-520 y) */}
                                        <rect
                                            x="0"
                                            y="60"
                                            width="800"
                                            height="460"
                                            fill="none"
                                            stroke="#22c55e"
                                            strokeWidth="2"
                                            strokeDasharray="8,4"
                                        />

                                        {/* Label for visible area */}
                                        <text x="10" y="75" fontSize="10" fill="#22c55e" fontWeight="bold">WIZ Card Visible Area</text>
                                    </g>
                                )}

                                {elements.map(el => renderElement(el))}

                                {/* Selection Box */}
                                {selectionBox && (
                                    <rect
                                        x={Math.min(selectionBox.start.x, selectionBox.current.x)}
                                        y={Math.min(selectionBox.start.y, selectionBox.current.y)}
                                        width={Math.abs(selectionBox.current.x - selectionBox.start.x)}
                                        height={Math.abs(selectionBox.current.y - selectionBox.start.y)}
                                        fill="rgba(59, 130, 246, 0.1)"
                                        stroke="#3b82f6"
                                        strokeWidth="1"
                                        strokeDasharray="4,2"
                                        style={{ pointerEvents: 'none' }}
                                    />
                                )}

                                {/* Drawing Path Preview */}
                                {currentPath && renderElement(currentPath, true)}
                            </svg>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // Play Name Parser Utility
        const parsePlayName = (playName) => {
            if (!playName || typeof playName !== 'string') {
                return { numbers: [], formations: [], directions: [], tags: [], special: [], quoted: [], unassigned: [], orderedTokens: [] };
            }

            const result = {
                numbers: [],
                formations: [],
                directions: [],
                tags: [],
                special: [],
                quoted: [],
                unassigned: [],
                orderedTokens: []
            };

            const formationPatterns = [
                'DIAMOND', 'BUNCH', 'GRN', 'GREEN', 'RED', 'BLUE', 'BRT', 'BRIGHT',
                'ORNG', 'ORANGE', 'GOLD', 'BRN', 'BROWN', 'METAL', 'OVER', 'TANK'
            ];
            const directionPatterns = ['RT', 'LT', 'RIP', 'LIZ', 'RN'];
            const tagPatterns = [
                'GAMBLE', 'BOOMER', 'KNIFE', 'SMOKE', 'WILLY', 'CAPONE', 'SUPER', 'RPO',
                'STICK', 'JET', 'RICE', 'SHALLOW', 'LEAK', 'GOT7', 'ARC', 'MUSTANG',
                'SALT', 'VEER', 'STASH', 'MICKEY', 'CROSS', 'SHARK', 'DITCH', 'JUKE',
                'OPTION', 'WHEEL', 'SMASH', 'SWING', 'FIST', 'INVERTED', 'SPECIAL',
                'BULLS', 'TAG', 'DEPOT', 'NOLES'
            ];

            // Ordered tokenization
            const tokens = [];
            let current = "";
            let inQuotes = false;

            for (let i = 0; i < playName.length; i++) {
                const char = playName[i];
                if (char === '"') {
                    if (inQuotes) {
                        tokens.push(current);
                        current = "";
                        inQuotes = false;
                    } else {
                        if (current.trim()) tokens.push(current.trim());
                        current = "";
                        inQuotes = true;
                    }
                } else if (!inQuotes && (/\s/.test(char) || ['+', '*', '(', ')'].includes(char))) {
                    if (current.trim()) tokens.push(current.trim());
                    if (['+', '*', '(', ')'].includes(char)) tokens.push(char);
                    current = "";
                } else {
                    current += char;
                }
            }
            if (current.trim()) tokens.push(current.trim());

            tokens.forEach(token => {
                const upperToken = token.toUpperCase().trim();
                let type = 'unassigned';

                if (!upperToken) return;

                if (/^\d+[A-Z]?$/.test(upperToken)) {
                    type = 'number';
                    result.numbers.push(token);
                } else if (formationPatterns.includes(upperToken)) {
                    type = 'formation';
                    result.formations.push(token);
                } else if (directionPatterns.includes(upperToken)) {
                    type = 'direction';
                    result.directions.push(token);
                } else if (tagPatterns.includes(upperToken)) {
                    type = 'tag';
                    result.tags.push(token);
                } else if (['+', '*', '(', ')'].includes(token)) {
                    type = 'special';
                    result.special.push(token);
                } else if (playName.includes(`"${token}"`)) {
                    type = 'quoted';
                    result.quoted.push(token);
                } else {
                    type = 'unassigned';
                    result.unassigned.push(token);
                }

                result.orderedTokens.push({ text: token, type });
            });

            return result;
        };


        const PlayInput = ({ onSave, onCancel, onDelete, initialData, availableMiniScripts = [], initialAssignedScriptIds = [], wizLibrary, setWizLibrary, formations = [], positionNames = {}, positionColors = {}, playSyntax = [], termLibrary = {}, playBuckets = [], playCategories = [], onAddFormation = () => { }, passProtections = [], setPassProtections = () => { }, runBlocking = [], setRunBlocking = () => { }, customTagCategories = [], setCustomTagCategories }) => {
            const [isDiagramming, setIsDiagramming] = useState(false);
            const [activeScenarioId, setActiveScenarioId] = useState(null); // ID of scenario being edited
            const [activeDiagramMode, setActiveDiagramMode] = useState(null); // null, 'wiz-oline', 'wiz-skill', 'detailed'
            const [formData, setFormData] = useState({
                playCategory: '', // Existing field
                bucketId: '', // [NEW] Play Bucket ID
                formation: '',
                formationTag: '',
                name: '',
                color: '',
                motion: '',
                playAction: false,
                tag1: '',
                tag2: '',
                tags: [],
                image: null,
                diagramData: null, // New: Diagram elements
                wizOlineData: null, // O-Line Wiz
                wizOlineMode: 'diagram', // 'diagram' or 'image'
                olineSchemeId: '', // Selected scheme from library
                olineSchemeName: '', // Name of selected scheme
                wizSkillData: null, // Skill Wiz
                wizSkillMode: 'diagram', // 'diagram' or 'image'
                wizSkillImage: null,
                scenarios: [], // Array of Detailed Scenarios
                activeScenarioId: null, // ID of scenario being edited
                wristbandSlot: '',
                staplesSlot: '', // [NEW] Staples Wristband Slot (10-89)
                // New call sheet fields
                playType: '', // Fastball, Curveball, Change Up, Strikeout
                actionTypes: [], // Array: Strong Run, Weak Run, Quick Game, etc.
                hashPreference: 'Any', // Left, Right, Middle, Any
                baseType: '', // Run, Pass, RPO, Gadget
                fieldZones: [], // Array: Fringe, Red Zone, Gold Zone, Goal Line
                downDistance: [], // Array: from existing tags
                sequenceName: '', // Look-alike sequence
                sequenceOrder: '', // Order in sequence
                assignedScriptIds: initialAssignedScriptIds, // New: Tracks mini script assignments
                // Extended "Play Call Chain" fields
                scramble: '',
                show: '',
                concept: '',
                backsideTag: '',
                navTag: '',
                autoCompleteValues: {}, // For suggestions
                syntaxValues: {}, // Keep existing syntax values just in case
                ...(() => {
                    const merged = { ...initialData };
                    // Migration for backward compatibility
                    if (merged.wizOlineData || merged.rooskiOlineData) merged.wizOlineData = merged.wizOlineData || merged.rooskiOlineData;
                    if (merged.wizSkillData || merged.rooskiSkillData) merged.wizSkillData = merged.wizSkillData || merged.rooskiSkillData;
                    if (merged.wizOlineMode || merged.rooskiMode) merged.wizOlineMode = merged.wizOlineMode || merged.rooskiMode;
                    if (merged.wizSkillMode || merged.rooskiSkillMode) merged.wizSkillMode = merged.wizSkillMode || merged.rooskiSkillMode;
                    if (merged.wizOlineImage || merged.rooskiImage) merged.wizOlineImage = merged.wizOlineImage || merged.rooskiImage;
                    return merged;
                })()
            });

            // Play Name Parser State
            const [parsedComponents, setParsedComponents] = useState(null);
            const [draggedComponent, setDraggedComponent] = useState(null);
            const [usedComponents, setUsedComponents] = useState(new Set());

            // Parse play name when it changes
            useEffect(() => {
                if (formData.name && formData.name.trim()) {
                    const parsed = parsePlayName(formData.name);
                    setParsedComponents(parsed);
                } else {
                    setParsedComponents(null);
                }
            }, [formData.name]);




            // Auto-calculate Name and Formation when Syntax Values change
            useEffect(() => {
                if (playSyntax && playSyntax.length > 0) {
                    // 1. Calculate Name: Join all values
                    const nameParts = playSyntax.map(s => (formData.syntaxValues && formData.syntaxValues[s.id])).filter(v => v);
                    const newName = nameParts.join(' ').toUpperCase();

                    // 2. Extract Formation: Find component with label containing "Formation"
                    const formationComp = playSyntax.find(s => s.label.toLowerCase().includes('formation'));
                    const newFormation = formationComp ? ((formData.syntaxValues && formData.syntaxValues[formationComp.id]) || '') : formData.formation;

                    setFormData(prev => {
                        // FIX: If no syntax values are selected (nameParts empty), DO NOT wipe out the existing name.
                        if (nameParts.length === 0) return prev;

                        // Only update if changed to avoid loops
                        if (prev.name === newName && prev.formation === newFormation) return prev;

                        // GUARD: If we are in "parsing mode" (have used some components but not all), 
                        // do not overwrite the full name with just the currently assigned parts.
                        // This prevents the "disappearing tags" issue.
                        const totalParsable = parsedComponents?.orderedTokens?.filter(t => t.type !== 'special')?.length || 0;
                        if (usedComponents.size > 0 && usedComponents.size < totalParsable) {
                            return { ...prev, formation: newFormation };
                        }

                        return { ...prev, name: newName, formation: newFormation };
                    });
                }
            }, [formData.syntaxValues, playSyntax, usedComponents.size, parsedComponents]);

            // If initialData has diagramData but no image, we can render it? 
            // Currently the system uses 'image' for display. We might need to generate an SVG string as image or support rendering diagramData.
            // For now, let's allow saving and editing.

            const handleSaveDiagram = (data) => {
                try {
                    // CRITICAL DEBUG: Confirm function is called
                    window.alert("handleSaveDiagram CALLED! Data keys: " + (data ? Object.keys(data).join(',') : 'null'));

                    // Initialize sync objects
                    const newPlayerNotes = { ...(formData.playerNotes || {}) };
                    const newPlayerLinks = { ...(formData.playerLinks || {}) };

                    if (data && data.elements) {
                        const players = data.elements.filter(el => el.type === 'player');
                        // Find potential link lines (drills)
                        const links = data.elements.filter(el => (el.link || el.conceptLabel) &&
                            ['line', 'curve', 'zigzag', 'poly', 'free'].includes(el.type) &&
                            el.points && el.points.length > 0
                        );

                        // DEBUG: Confirm data discovery
                        window.alert(`Saving... Found ${players.length} players and ${links.length} potential links.`);

                        players.forEach(player => {
                            if (!player.points || !player.points[0]) return;
                            const pPos = player.points[0];

                            // Find lines starting OR ending near this player (within 80px)
                            const relevantLink = links.find(link => {
                                if (!link.points || link.points.length === 0) return false;
                                const startPoint = link.points[0];
                                const endPoint = link.points[link.points.length - 1];

                                const distStart = Math.sqrt(Math.pow(startPoint.x - pPos.x, 2) + Math.pow(startPoint.y - pPos.y, 2));
                                const distEnd = Math.sqrt(Math.pow(endPoint.x - pPos.x, 2) + Math.pow(endPoint.y - pPos.y, 2));

                                return distStart < 80 || distEnd < 80;
                            });

                            if (relevantLink) {
                                // Sync Note Text (Label)
                                const noteText = relevantLink.conceptLabel;
                                if (noteText) {
                                    newPlayerNotes[player.label] = noteText;
                                }

                                // Sync Link URL
                                if (relevantLink.link) {
                                    newPlayerLinks[player.label] = relevantLink.link;
                                }
                            }
                        });
                    }

                    // Update State
                    setFormData(prev => ({
                        ...prev,
                        diagramData: data,
                        playerNotes: newPlayerNotes,
                        playerLinks: newPlayerLinks
                    }));

                } catch (e) {
                    console.error("Save Error:", e);
                    window.alert("Save Error: " + e.message);
                } finally {
                    setIsDiagramming(false);
                }

                // Optional: Generate a thumbnail image from the diagram? 
                // Simple SVG data URI approach
                // Note: Converting elements to SVG string
                const svgContent = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="900" height="600" viewBox="0 0 900 600" style="background: white">
                        <g opacity="0.1">
                                    <line x1="0" y1="10%" x2="100%" y2="10%" stroke="#000" stroke-width="2" />
                                    <line x1="0" y1="30%" x2="100%" y2="30%" stroke="#000" stroke-width="2" />
                                    <line x1="0" y1="50%" x2="100%" y2="50%" stroke="#000" stroke-width="4" />
                                    <line x1="0" y1="70%" x2="100%" y2="70%" stroke="#000" stroke-width="2" />
                                    <line x1="0" y1="90%" x2="100%" y2="90%" stroke="#000" stroke-width="2" />
                        </g>
                        ${data.elements.map(el => {
                    let d = '';
                    if (el.type === 'free') {
                        d = `M ${el.points.map(p => `${p.x},${p.y}`).join(' L ')}`;
                    } else {
                        const start = el.points[0];
                        const end = el.points[el.points.length - 1];
                        d = `M ${start.x},${start.y} L ${end.x},${end.y}`;
                    }
                    // Markers are tricky in data URI without definitions.
                    // Simply defining markers in the SVG string
                    return `<path d="${d}" stroke="${el.color}" stroke-width="4" fill="none" stroke-dasharray="${el.style === 'dashed' ? '10,5' : 'none'}" />`;
                }).join('')}
                    </svg>
                `;
                const encoded = 'data:image/svg+xml;base64,' + btoa(svgContent);
                // setFormData(prev => ({ ...prev, diagramData: data, image: encoded })); // Use this if we want to preview it as image
                // Actually, let's keep diagramData separate and prefer it for rendering if available, falling back to image.
            };

            const toggleTag = (tag) => {
                setFormData(prev => ({
                    ...prev,
                    tags: prev.tags.includes(tag)
                        ? prev.tags.filter(t => t !== tag)
                        : [...prev.tags, tag]
                }));
            };

            const toggleActionType = (type) => {
                setFormData(prev => ({
                    ...prev,
                    actionTypes: prev.actionTypes.includes(type)
                        ? prev.actionTypes.filter(t => t !== type)
                        : [...prev.actionTypes, type]
                }));
            };

            const toggleFieldZone = (zone) => {
                setFormData(prev => ({
                    ...prev,
                    fieldZones: prev.fieldZones.includes(zone)
                        ? prev.fieldZones.filter(z => z !== zone)
                        : [...prev.fieldZones, zone]
                }));
            };

            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        setFormData(prev => ({ ...prev, image: reader.result, diagramData: null })); // Clear diagramData if image is uploaded
                    };
                    reader.readAsDataURL(file);
                }
            };

            const handleSkillImageUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        setFormData(prev => ({ ...prev, wizSkillImage: reader.result }));
                    };
                    reader.readAsDataURL(file);
                }
            };

            // SCENARIO HELPERS
            const handleAddScenario = () => {
                const newScenario = {
                    id: Date.now(),
                    front: 'Over',
                    coverage: 'Cover 3',
                    diagramData: null,
                    notes: { 'QB': '', 'RB': '', 'X': '', 'Z': '', 'Y': '', 'F': '', 'OL': '' }
                };
                setFormData(prev => ({
                    ...prev,
                    scenarios: [...(prev.scenarios || []), newScenario]
                }));
                setActiveScenarioId(newScenario.id); // Auto-select
            };

            const handleUpdateScenario = (id, field, value) => {
                setFormData(prev => ({
                    ...prev,
                    scenarios: prev.scenarios.map(s => s.id === id ? { ...s, [field]: value } : s)
                }));
            };

            const handleUpdateScenarioNote = (id, player, note) => {
                setFormData(prev => ({
                    ...prev,
                    scenarios: prev.scenarios.map(s => s.id === id ? {
                        ...s,
                        notes: { ...s.notes, [player]: note }
                    } : s)
                }));
            };

            const handleDeleteScenario = (id) => {
                if (window.confirm('Delete this scenario?')) {
                    setFormData(prev => ({
                        ...prev,
                        scenarios: prev.scenarios.filter(s => s.id !== id)
                    }));
                    if (activeScenarioId === id) setActiveScenarioId(null);
                }
            };


            // Drag-and-Drop Handlers
            const handleDragStart = (component, type) => {
                setDraggedComponent({ text: component, type: type });
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            };

            const handleDrop = (e, targetField) => {
                e.preventDefault();
                // Generic handler for all fields
                if (draggedComponent) {
                    const { text } = draggedComponent;
                    setFormData(prev => ({
                        ...prev,
                        [targetField]: text
                    }));
                    setUsedComponents(prev => new Set(prev).add(text));
                    setDraggedComponent(null);
                } else {
                    // Fallback for native text selection drag
                    const text = e.dataTransfer.getData("text/plain");
                    if (text) {
                        setFormData(prev => ({
                            ...prev,
                            [targetField]: text
                        }));
                    }
                }
            };

            const handleSubmit = (e) => {
                e.preventDefault();
                onSave({ ...formData, id: formData.id || Date.now().toString() });
            };

            const handleDelete = () => {
                if (window.confirm('Are you sure you want to delete this play? This cannot be undone.')) {
                    onDelete(formData.id);
                }
            };

            const renderDiagramPreview = (elements, useWizCardView = false) => {
                if (!elements || elements.length === 0) return (
                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', height: '100%', color: 'var(--text-secondary)', gap: '0.5rem' }}>
                        <Icon name="Image" size={24} style={{ opacity: 0.5 }} />
                        <span style={{ fontSize: '0.9rem' }}>No Diagram Data</span>
                    </div>
                );

                // Use WIZ card viewBox (0 60 800 460) for skill diagrams to match print output
                const viewBox = useWizCardView ? '0 60 800 460' : '0 0 900 600';
                const playerSize = useWizCardView ? 14 : 18;

                return (
                    <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox={viewBox} preserveAspectRatio="xMidYMid meet" style={{ background: '#f8fdf8', borderRadius: '4px', border: '1px solid #e5e7eb' }}>
                        {/* Arrow markers */}
                        <defs>
                            {['#000000', '#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#a855f7', '#22c55e', '#eab308'].map(c => {
                                const markerSize = useWizCardView ? 5 : 8;
                                const markerHeight = useWizCardView ? 4 : 6;
                                return (
                                    <marker key={c} id={`preview-arrow-${c.replace('#', '')}`} markerWidth={markerSize} markerHeight={markerHeight} refX={markerSize - 1} refY={markerHeight / 2} orient="auto">
                                        <polygon points={`0 0, ${markerSize} ${markerHeight/2}, 0 ${markerHeight}`} fill={c} />
                                    </marker>
                                );
                            })}
                        </defs>
                        {/* Field lines - adjusted for WIZ card viewBox (y: 60-520) */}
                        <g opacity="0.12">
                            {useWizCardView ? (
                                <>
                                    <line x1="0" y1="150" x2="800" y2="150" stroke="#666" strokeWidth="1" strokeDasharray="4,4" />
                                    <line x1="0" y1="250" x2="800" y2="250" stroke="#666" strokeWidth="1" strokeDasharray="4,4" />
                                    <line x1="0" y1="350" x2="800" y2="350" stroke="#666" strokeWidth="1" strokeDasharray="4,4" />
                                    <line x1="0" y1="400" x2="800" y2="400" stroke="#333" strokeWidth="2" />
                                    <line x1="0" y1="450" x2="800" y2="450" stroke="#666" strokeWidth="1" strokeDasharray="4,4" />
                                </>
                            ) : (
                                <>
                                    <line x1="0" y1="100" x2="900" y2="100" stroke="#666" strokeWidth="1" strokeDasharray="4,4" />
                                    <line x1="0" y1="200" x2="900" y2="200" stroke="#666" strokeWidth="1" strokeDasharray="4,4" />
                                    <line x1="0" y1="300" x2="900" y2="300" stroke="#333" strokeWidth="2" />
                                    <line x1="0" y1="400" x2="900" y2="400" stroke="#666" strokeWidth="1" strokeDasharray="4,4" />
                                    <line x1="0" y1="500" x2="900" y2="500" stroke="#666" strokeWidth="1" strokeDasharray="4,4" />
                                </>
                            )}
                        </g>
                        {elements.map((el, index) => {
                            // Render players with circles
                            if (el.type === 'player' && el.points && el.points[0]) {
                                const pt = el.points[0];
                                const isTextOnly = el.shape === 'text-only';
                                const baseFontSize = el.fontSize ? Math.min(el.fontSize, 20) : 18;
                                const fontSize = useWizCardView ? Math.round(baseFontSize * 0.65) : baseFontSize;

                                if (isTextOnly) {
                                    return (
                                        <text key={index} x={pt.x} y={pt.y} textAnchor="middle" dominantBaseline="middle" fontSize={fontSize} fontWeight="bold" fill={el.color || '#000'}>{el.label}</text>
                                    );
                                }

                                return (
                                    <g key={index}>
                                        <circle cx={pt.x} cy={pt.y} r={playerSize} fill="white" stroke={el.color || '#000'} strokeWidth={useWizCardView ? 2 : 3} />
                                        <text x={pt.x} y={pt.y + 1} textAnchor="middle" dominantBaseline="middle" fontSize={useWizCardView ? 10 : 14} fontWeight="bold" fill={el.color || '#000'}>{el.label}</text>
                                    </g>
                                );
                            }

                            // Render lines/routes
                            if ((el.type === 'line' || el.type === 'poly' || el.type === 'free') && el.points && el.points.length >= 2) {
                                const d = `M ${el.points.map(p => `${p.x},${p.y}`).join(' L ')}`;
                                const color = el.color || '#000';
                                const markerId = `preview-arrow-${color.replace('#', '')}`;
                                const hasArrow = el.endType === 'arrow' || el.endType === undefined;

                                return (
                                    <path
                                        key={index}
                                        d={d}
                                        stroke={color}
                                        strokeWidth={useWizCardView ? Math.max(2, (el.strokeWidth || 4) * 0.6) : (el.strokeWidth || 4)}
                                        fill="none"
                                        strokeDasharray={el.style === 'dashed' ? '8,4' : 'none'}
                                        markerEnd={hasArrow ? `url(#${markerId})` : 'none'}
                                    />
                                );
                            }

                            return null;
                        })}
                    </svg>
                );
            };

            return (
                <div className="animate-fade-in">
                    {/* Diagram Editor Modal */}
                    {isDiagramming && (
                        <PlayDiagramEditor
                            initialData={formData.diagramData}
                            onSave={handleSaveDiagram}
                            onCancel={() => setIsDiagramming(false)}
                            wizLibrary={wizLibrary}
                            setWizLibrary={setWizLibrary}
                            positionNames={positionNames}
                            positionColors={positionColors}
                            onAddFormation={onAddFormation}
                        />
                    )}

                    {/* Wiz O-Line Editor Modal */}
                    {activeDiagramMode === 'wiz-oline' && (
                        <PlayDiagramEditor
                            initialData={formData.wizOlineData ? { elements: formData.wizOlineData } : null}
                            mode="wiz-oline"
                            onSave={(data) => {
                                // Save to play
                                setFormData(prev => ({ ...prev, wizOlineData: data.elements }));

                                // Offer to save to library
                                if (formData.olineSchemeId) {
                                    // Update existing scheme
                                    const isProt = passProtections.some(p => p.id === formData.olineSchemeId);
                                    if (isProt) {
                                        setPassProtections(passProtections.map(p =>
                                            p.id === formData.olineSchemeId ? { ...p, diagramData: data.elements } : p
                                        ));
                                    } else {
                                        setRunBlocking(runBlocking.map(b =>
                                            b.id === formData.olineSchemeId ? { ...b, diagramData: data.elements } : b
                                        ));
                                    }
                                } else {
                                    // Offer to save as new scheme
                                    const saveName = prompt("Save this diagram to O-Line library? Enter name (or Cancel to skip):");
                                    if (saveName) {
                                        const isPass = confirm("Is this a Pass Protection? (OK = Pass, Cancel = Run Blocking)");
                                        const newScheme = {
                                            id: Date.now().toString(),
                                            name: saveName.toUpperCase(),
                                            diagramData: data.elements,
                                            slideDirection: 'right',
                                            manSide: 'left',
                                            type: 'zone',
                                            callText: '',
                                            notes: ''
                                        };
                                        if (isPass) {
                                            setPassProtections([...passProtections, newScheme]);
                                        } else {
                                            setRunBlocking([...runBlocking, newScheme]);
                                        }
                                        setFormData(prev => ({ ...prev, olineSchemeId: newScheme.id, olineSchemeName: newScheme.name }));
                                    }
                                }
                                setActiveDiagramMode(null);
                            }}
                            onCancel={() => setActiveDiagramMode(null)}
                            wizLibrary={wizLibrary}
                            setWizLibrary={setWizLibrary}
                            positionNames={positionNames}
                            positionColors={positionColors}
                            onAddFormation={onAddFormation}
                        />
                    )}

                    {/* Wiz Skill Editor Modal */}
                    {activeDiagramMode === 'wiz-skill' && (
                        <PlayDiagramEditor
                            initialData={formData.wizSkillData ? { elements: formData.wizSkillData } : null}
                            mode="wiz-skill"
                            formations={formations}
                            onSave={(data) => {
                                setFormData({ ...formData, wizSkillData: data.elements });
                                setActiveDiagramMode(null);
                            }}
                            onCancel={() => setActiveDiagramMode(null)}
                            wizLibrary={wizLibrary}
                            setWizLibrary={setWizLibrary}
                            positionNames={positionNames}
                            positionColors={positionColors}
                            onAddFormation={onAddFormation}
                        />
                    )}

                    {/* Detailed Scenario Editor Modal */}
                    {activeDiagramMode === 'detailed' && activeScenarioId && (
                        <PlayDiagramEditor
                            initialData={formData.scenarios.find(s => s.id === activeScenarioId)?.diagramData ? { elements: formData.scenarios.find(s => s.id === activeScenarioId).diagramData } : null}
                            mode="detailed"
                            onSave={(data) => {
                                handleUpdateScenario(activeScenarioId, 'diagramData', data.elements);
                                setActiveDiagramMode(null);
                            }}
                            onCancel={() => setActiveDiagramMode(null)}
                            wizLibrary={wizLibrary}
                            setWizLibrary={setWizLibrary}
                            positionNames={positionNames}
                            positionColors={positionColors}
                            onAddFormation={onAddFormation}
                        />
                    )}

                    <div style={{
                        display: 'flex',
                        justifyContent: 'space-between',
                        alignItems: 'center',
                        marginBottom: '1.5rem',
                        position: 'sticky',
                        top: 0,
                        zIndex: 100,
                        backgroundColor: 'var(--bg-app)',
                        padding: '1rem 0',
                        borderBottom: '1px solid var(--border)',
                        marginTop: '-1rem' // Pull up slightly to counteract padding if needed, or just normal flow
                    }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                            <h2 style={{ margin: 0 }}>{initialData ? 'Edit Play' : 'New Play Design'}</h2>
                        </div>
                        <div style={{ display: 'flex', gap: '0.5rem' }}>
                            <button
                                type="button"
                                onClick={onCancel}
                                className="btn btn-secondary"
                            >
                                Cancel
                            </button>
                            <button
                                type="button"
                                onClick={handleSubmit}
                                className="btn btn-primary"
                                style={{
                                    boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)'
                                }}
                            >
                                💾 Save Play
                            </button>
                            {initialData && (
                                <button
                                    type="button"
                                    onClick={handleDelete}
                                    className="btn"
                                    style={{ backgroundColor: 'rgba(239, 68, 68, 0.1)', color: '#ef4444', border: '1px solid #ef4444' }}
                                >
                                    🗑️
                                </button>
                            )}
                        </div>
                    </div>
                    <form onSubmit={handleSubmit}>


                        {/* NEW TOP SECTION: PLAY CALL */}
                        <div style={{ marginBottom: '1.5rem' }}>
                            {playSyntax && playSyntax.length > 0 && (
                                <div style={{ background: 'var(--bg-main)', padding: '1.5rem', borderRadius: '12px', border: '1px solid var(--border)', boxShadow: 'var(--shadow-sm)' }}>
                                    <div style={{ borderBottom: '1px solid var(--border)', paddingBottom: '0.75rem', marginBottom: '1.25rem', fontSize: '1.1rem', fontWeight: '800', color: 'var(--text-primary)', textTransform: 'uppercase', letterSpacing: '0.05em', display: 'flex', alignItems: 'center', gap: '0.75rem' }}>
                                        <Icon name="ClipboardList" size={20} style={{ color: 'var(--accent)' }} />
                                        PLAY CALL
                                    </div>
                                    <div className="form-group" style={{ marginBottom: '1.25rem' }}>
                                        <label className="form-label">Play Call</label>
                                        <input
                                            className="form-input"
                                            value={formData.name}
                                            onChange={e => setFormData({ ...formData, name: e.target.value.toUpperCase() })}
                                            placeholder="e.g. TRIBE / Spider 2 Y Banana"
                                            required
                                        />
                                    </div>
                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginBottom: '1.25rem' }}>
                                        <div className="form-group" style={{ marginBottom: 0 }}>
                                            <label className="form-label">Category</label>
                                            <select
                                                className="form-input"
                                                value={formData.playCategory || ''}
                                                onChange={e => setFormData({ ...formData, playCategory: e.target.value, bucketId: '' })}
                                            >
                                                <option value="">Select Category...</option>
                                                {playCategories.map(cat => (
                                                    <option key={cat.id} value={cat.id}>{cat.label}</option>
                                                ))}
                                            </select>
                                        </div>
                                        <div className="form-group" style={{ marginBottom: 0 }}>
                                            <label className="form-label">Play Family</label>
                                            <select
                                                className="form-input"
                                                value={formData.bucketId || ''}
                                                onChange={e => setFormData({ ...formData, bucketId: e.target.value })}
                                                disabled={!formData.playCategory}
                                            >
                                                <option value="">Select Play Family...</option>
                                                {playBuckets
                                                    .filter(b => b.categoryId === formData.playCategory)
                                                    .map(bucket => (
                                                        <option key={bucket.id} value={bucket.id}>{bucket.label}</option>
                                                    ))
                                                }
                                            </select>
                                        </div>
                                    </div>
                                    <div className="form-group" style={{ marginBottom: '1.25rem' }}>
                                        <label className="form-label">Wiz / Short Name <span style={{ fontSize: '0.8em', color: '#64748b', fontWeight: 'normal' }}>(Optional)</span></label>
                                        <input
                                            className="form-input"
                                            value={formData.wizName || ''}
                                            onChange={e => setFormData({ ...formData, wizName: e.target.value })}
                                            placeholder="Short name for 4x4 grids..."
                                        />
                                    </div>
                                    {/* Draggable Parsed Components */}
                                    {parsedComponents && (
                                        <div style={{ marginBottom: '1rem', padding: '0.75rem', background: '#f8fafc', border: '1px solid #e2e8f0', borderRadius: '8px' }}>
                                            <div style={{ fontSize: '0.85rem', fontWeight: 'bold', marginBottom: '0.5rem', color: '#64748b' }}>
                                                Parsed Components (drag to fields below)
                                            </div>
                                            <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.5rem' }}>
                                                {parsedComponents.orderedTokens && parsedComponents.orderedTokens.map((token, idx) => {
                                                    const isUsed = usedComponents.has(token.text);
                                                    if (isUsed || token.type === 'special') return null;

                                                    // Use the same color scheme as before
                                                    let bgColor = '#94a3b8'; // unassigned
                                                    if (token.type === 'number') bgColor = '#3b82f6';
                                                    else if (token.type === 'formation') bgColor = '#10b981';
                                                    else if (token.type === 'direction') bgColor = '#f97316';
                                                    else if (token.type === 'tag') bgColor = '#8b5cf6';
                                                    else if (token.type === 'quoted') bgColor = '#6b7280';

                                                    return (
                                                        <div
                                                            key={`${token.text}-${idx}`}
                                                            draggable
                                                            onDragStart={() => handleDragStart(token.text, token.type)}
                                                            style={{
                                                                padding: '0.25rem 0.65rem',
                                                                background: bgColor,
                                                                color: 'white',
                                                                borderRadius: '4px',
                                                                fontSize: '0.85rem',
                                                                fontWeight: '600',
                                                                cursor: 'grab',
                                                                userSelect: 'none',
                                                                boxShadow: '0 1px 2px rgba(0,0,0,0.1)'
                                                            }}
                                                        >
                                                            {token.type === 'quoted' ? `"${token.text}"` : token.text}
                                                        </div>
                                                    );
                                                })}
                                                {(!parsedComponents.orderedTokens || parsedComponents.orderedTokens.filter(t => t.type !== 'special' && !usedComponents.has(t.text)).length === 0) && (
                                                    <div style={{ fontSize: '0.8rem', color: '#94a3b8', fontStyle: 'italic' }}>
                                                        All components assigned or no components found
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    )}
                                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))', gap: '1.25rem' }}>
                                        {playSyntax.map(comp => (
                                            <div key={comp.id} className="form-group" style={{ margin: 0 }}>
                                                <label className="form-label">{comp.label}</label>
                                                <input
                                                    className="form-input"
                                                    list={`terms-${comp.id}`}
                                                    value={formData.syntaxValues?.[comp.id] || ''}
                                                    onDragOver={handleDragOver}
                                                    onDrop={(e) => {
                                                        e.preventDefault();
                                                        if (draggedComponent) {
                                                            const { text } = draggedComponent;
                                                            setFormData(prev => ({
                                                                ...prev,
                                                                syntaxValues: {
                                                                    ...(prev.syntaxValues || {}),
                                                                    [comp.id]: text
                                                                }
                                                            }));
                                                            setUsedComponents(prev => new Set(prev).add(text));
                                                            setDraggedComponent(null);
                                                        } else {
                                                            const text = e.dataTransfer.getData("text/plain");
                                                            if (text) {
                                                                setFormData(prev => ({
                                                                    ...prev,
                                                                    syntaxValues: {
                                                                        ...(prev.syntaxValues || {}),
                                                                        [comp.id]: text
                                                                    }
                                                                }));
                                                            }
                                                        }
                                                    }}
                                                    onChange={e => {
                                                        const newVal = e.target.value;
                                                        setFormData(prev => ({
                                                            ...prev,
                                                            syntaxValues: {
                                                                ...(prev.syntaxValues || {}),
                                                                [comp.id]: newVal
                                                            }
                                                        }));
                                                    }}
                                                    placeholder={`Select or typing ${comp.label}...`}
                                                />
                                                <datalist id={`terms-${comp.id}`}>
                                                    {termLibrary[comp.id]?.map(t => (
                                                        <option key={t.id} value={t.label} />
                                                    ))}
                                                </datalist>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}

                            {(!playSyntax || playSyntax.length === 0) && (
                                <div style={{ background: 'var(--bg-main)', padding: '1.5rem', borderRadius: '12px', border: '1px solid var(--border)', boxShadow: 'var(--shadow-sm)' }}>
                                    <div style={{ borderBottom: '1px solid var(--border)', paddingBottom: '0.75rem', marginBottom: '1.25rem', fontSize: '1.1rem', fontWeight: '800', color: 'var(--text-primary)', textTransform: 'uppercase', letterSpacing: '0.05em', display: 'flex', alignItems: 'center', gap: '0.75rem' }}>
                                        <Icon name="ClipboardList" size={20} style={{ color: 'var(--accent)' }} />
                                        PLAY CALL
                                    </div>
                                    <div className="form-group" style={{ marginBottom: '1.25rem' }}>
                                        <label className="form-label">Play Call</label>
                                        <input
                                            className="form-input"
                                            value={formData.name}
                                            onChange={e => setFormData({ ...formData, name: e.target.value.toUpperCase() })}
                                            placeholder="e.g. TRIBE / Spider 2 Y Banana"
                                            required
                                        />
                                    </div>
                                    <div className="form-group" style={{ marginBottom: '1.25rem' }}>
                                        <label className="form-label">Wiz / Short Name <span style={{ fontSize: '0.8em', color: '#64748b', fontWeight: 'normal' }}>(Optional)</span></label>
                                        <input
                                            className="form-input"
                                            value={formData.wizName || ''}
                                            onChange={e => setFormData({ ...formData, wizName: e.target.value })}
                                            placeholder="Short name for 4x4 grids..."
                                        />
                                    </div>

                                    {parsedComponents && (
                                        <div style={{ marginBottom: '1rem', padding: '0.75rem', background: '#f8fafc', border: '1px solid #e2e8f0', borderRadius: '8px' }}>
                                            <div style={{ fontSize: '0.85rem', fontWeight: 'bold', marginBottom: '0.5rem', color: '#64748b' }}>
                                                Parsed Components (drag to fields below)
                                            </div>
                                            <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.5rem' }}>
                                                {parsedComponents.orderedTokens && parsedComponents.orderedTokens.map((token, idx) => {
                                                    const isUsed = usedComponents.has(token.text);
                                                    if (isUsed || token.type === 'special') return null;

                                                    let bgColor = '#94a3b8';
                                                    if (token.type === 'number') bgColor = '#3b82f6';
                                                    else if (token.type === 'formation') bgColor = '#10b981';
                                                    else if (token.type === 'direction') bgColor = '#f97316';
                                                    else if (token.type === 'tag') bgColor = '#8b5cf6';
                                                    else if (token.type === 'quoted') bgColor = '#6b7280';

                                                    return (
                                                        <div
                                                            key={`${token.text}-${idx}`}
                                                            draggable
                                                            onDragStart={() => handleDragStart(token.text, token.type)}
                                                            style={{
                                                                padding: '0.25rem 0.5rem',
                                                                background: bgColor,
                                                                color: 'white',
                                                                borderRadius: '4px',
                                                                fontSize: '0.8rem',
                                                                cursor: 'grab'
                                                            }}
                                                        >
                                                            {token.type === 'quoted' ? `"${token.text}"` : token.text}
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                    )}

                                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))', gap: '1.25rem' }}>
                                        <div className="form-group">
                                            <label className="form-label">Formation</label>
                                            <input className="form-input" value={formData.formation} onChange={e => setFormData({ ...formData, formation: e.target.value })} />
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                        {/* DIAGRAMS SECTION: SIDE-BY-SIDE DIAGRAMS */}
                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1.5rem', marginTop: '1.5rem' }}>
                            {/* Wiz O-Line Diagram */}
                            <div className="form-group" style={{ background: 'var(--bg-main)', padding: '1rem', borderRadius: '12px', border: '1px solid var(--border)' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.75rem', borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem' }}>
                                    <label className="form-label" style={{ margin: 0, fontSize: '0.85rem', textTransform: 'uppercase', letterSpacing: '0.05em', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                        <Icon name="Users" size={16} style={{ color: 'var(--accent)' }} />
                                        Wiz O-Line Diagram
                                    </label>
                                    <div style={{ display: 'flex', gap: '0.5rem', fontSize: '0.8rem' }}>
                                        <button type="button" onClick={() => setFormData(prev => ({ ...prev, wizOlineMode: 'diagram' }))} style={{ background: 'none', border: 'none', color: (formData.wizOlineMode || 'diagram') === 'diagram' ? 'var(--accent)' : 'var(--text-secondary)', fontWeight: (formData.wizOlineMode || 'diagram') === 'diagram' ? 'bold' : 'normal', cursor: 'pointer' }}>Diagram</button>
                                        <button type="button" onClick={() => setFormData(prev => ({ ...prev, wizOlineMode: 'upload' }))} style={{ background: 'none', border: 'none', color: formData.wizOlineMode === 'upload' ? 'var(--accent)' : 'var(--text-secondary)', fontWeight: formData.wizOlineMode === 'upload' ? 'bold' : 'normal', cursor: 'pointer' }}>Upload</button>
                                    </div>
                                </div>

                                {/* Scheme Selector */}
                                {(formData.wizOlineMode || 'diagram') === 'diagram' && (
                                    <div style={{ marginBottom: '0.75rem' }}>
                                        <select
                                            className="form-input"
                                            value={formData.olineSchemeId || ''}
                                            onChange={(e) => {
                                                const schemeId = e.target.value;
                                                if (!schemeId) {
                                                    setFormData(prev => ({ ...prev, olineSchemeId: '', olineSchemeName: '' }));
                                                    return;
                                                }
                                                // Find scheme in either protections or blocking
                                                const prot = passProtections.find(p => p.id === schemeId);
                                                const block = runBlocking.find(b => b.id === schemeId);
                                                const scheme = prot || block;
                                                if (scheme) {
                                                    setFormData(prev => ({
                                                        ...prev,
                                                        olineSchemeId: scheme.id,
                                                        olineSchemeName: scheme.name,
                                                        wizOlineData: scheme.diagramData || prev.wizOlineData
                                                    }));
                                                }
                                            }}
                                            style={{ fontSize: '0.85rem' }}
                                        >
                                            <option value="">-- Select Scheme or Create New --</option>
                                            {passProtections.length > 0 && (
                                                <optgroup label="Pass Protections">
                                                    {passProtections.map(p => (
                                                        <option key={p.id} value={p.id}>{p.name}</option>
                                                    ))}
                                                </optgroup>
                                            )}
                                            {runBlocking.length > 0 && (
                                                <optgroup label="Run Blocking">
                                                    {runBlocking.map(b => (
                                                        <option key={b.id} value={b.id}>{b.name}</option>
                                                    ))}
                                                </optgroup>
                                            )}
                                        </select>
                                        {formData.olineSchemeName && (
                                            <div style={{ marginTop: '0.25rem', fontSize: '0.75rem', color: 'var(--text-secondary)' }}>
                                                Selected: <strong>{formData.olineSchemeName}</strong>
                                            </div>
                                        )}
                                    </div>
                                )}

                                <div style={{ minHeight: '150px', background: 'var(--bg-input)', borderRadius: '8px', overflow: 'hidden', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'var(--text-secondary)', fontSize: '0.9rem', position: 'relative' }}>
                                    {formData.wizOlineMode === 'upload' ? (
                                        formData.image ? (
                                            <div style={{ position: 'relative', width: '100%', height: '100%' }}>
                                                <img src={formData.image} alt="O-Line" style={{ width: '100%', height: '100%', objectFit: 'contain' }} />
                                                <button
                                                    type="button"
                                                    onClick={(e) => { e.stopPropagation(); setFormData(prev => ({ ...prev, image: null })); }}
                                                    style={{ position: 'absolute', top: 5, right: 5, background: 'rgba(0,0,0,0.5)', color: 'white', border: 'none', borderRadius: '50%', width: 24, height: 24, cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center' }}
                                                >
                                                    ×
                                                </button>
                                            </div>
                                        ) : (
                                            <div style={{ textAlign: 'center' }}>
                                                <input type="file" accept="image/*" onChange={handleImageUpload} style={{ display: 'none' }} id="oline-upload" />
                                                <label htmlFor="oline-upload" className="btn btn-secondary" style={{ cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                    <Icon name="Upload" size={16} /> Upload Image
                                                </label>
                                            </div>
                                        )
                                    ) : (
                                        formData.wizOlineData && formData.wizOlineData.length > 0 ? (
                                            <div onClick={() => setActiveDiagramMode('wiz-oline')} style={{ width: '100%', height: '100%', cursor: 'pointer' }}>
                                                {renderDiagramPreview(formData.wizOlineData)}
                                            </div>
                                        ) : (
                                            <button type="button" className="btn btn-secondary" onClick={() => setActiveDiagramMode('wiz-oline')}>
                                                <Icon name="Plus" size={16} /> Create Diagram
                                            </button>
                                        )
                                    )}
                                </div>
                            </div>

                            {/* Wiz Skill Diagram */}
                            <div className="form-group" style={{ background: 'var(--bg-main)', padding: '1rem', borderRadius: '12px', border: '1px solid var(--border)' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem', borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem' }}>
                                    <label className="form-label" style={{ margin: 0, fontSize: '0.85rem', textTransform: 'uppercase', letterSpacing: '0.05em', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                        <Icon name="Target" size={16} style={{ color: 'var(--accent)' }} />
                                        Wiz Skill Diagram
                                    </label>
                                    <div style={{ display: 'flex', gap: '0.5rem', fontSize: '0.8rem' }}>
                                        <button type="button" onClick={() => setFormData(prev => ({ ...prev, wizSkillMode: 'diagram' }))} style={{ background: 'none', border: 'none', color: (formData.wizSkillMode || 'diagram') === 'diagram' ? 'var(--accent)' : 'var(--text-secondary)', fontWeight: (formData.wizSkillMode || 'diagram') === 'diagram' ? 'bold' : 'normal', cursor: 'pointer' }}>Diagram</button>
                                        <button type="button" onClick={() => setFormData(prev => ({ ...prev, wizSkillMode: 'upload' }))} style={{ background: 'none', border: 'none', color: formData.wizSkillMode === 'upload' ? 'var(--accent)' : 'var(--text-secondary)', fontWeight: formData.wizSkillMode === 'upload' ? 'bold' : 'normal', cursor: 'pointer' }}>Upload</button>
                                    </div>
                                </div>
                                <div style={{ minHeight: '150px', background: 'var(--bg-input)', borderRadius: '8px', overflow: 'hidden', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'var(--text-secondary)', fontSize: '0.9rem', position: 'relative' }}>
                                    {formData.wizSkillMode === 'upload' ? (
                                        formData.wizSkillImage ? (
                                            <div style={{ position: 'relative', width: '100%', height: '100%' }}>
                                                <img src={formData.wizSkillImage} alt="Skill" style={{ width: '100%', height: '100%', objectFit: 'contain' }} />
                                                <button
                                                    type="button"
                                                    onClick={(e) => { e.stopPropagation(); setFormData(prev => ({ ...prev, wizSkillImage: null })); }}
                                                    style={{ position: 'absolute', top: 5, right: 5, background: 'rgba(0,0,0,0.5)', color: 'white', border: 'none', borderRadius: '50%', width: 24, height: 24, cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center' }}
                                                >
                                                    ×
                                                </button>
                                            </div>
                                        ) : (
                                            <div style={{ textAlign: 'center' }}>
                                                <input type="file" accept="image/*" onChange={handleSkillImageUpload} style={{ display: 'none' }} id="skill-upload" />
                                                <label htmlFor="skill-upload" className="btn btn-secondary" style={{ cursor: 'pointer', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                    <Icon name="Upload" size={16} /> Upload Image
                                                </label>
                                            </div>
                                        )
                                    ) : (
                                        formData.wizSkillData && formData.wizSkillData.length > 0 ? (
                                            <div onClick={() => setActiveDiagramMode('wiz-skill')} style={{ width: '100%', height: '100%', cursor: 'pointer' }}>
                                                {renderDiagramPreview(formData.wizSkillData, true)}
                                            </div>
                                        ) : (
                                            <button type="button" className="btn btn-secondary" onClick={() => setActiveDiagramMode('wiz-skill')}>
                                                <Icon name="Plus" size={16} /> Create Diagram
                                            </button>
                                        )
                                    )}
                                </div>
                            </div>
                        </div>

                        {/* SECTION: PLAYER ASSIGNMENT NOTES */}
                        <div style={{ marginTop: '1.5rem' }}>
                            <div style={{
                                padding: '1.5rem', background: 'var(--bg-main)', borderRadius: '12px', border: '1px solid var(--border)',
                                display: 'flex', flexDirection: 'column'
                            }}>
                                <label className="form-label" style={{ marginBottom: '1rem', fontWeight: 'bold' }}>Player Assignment Notes</label>
                                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '0.75rem', flex: 1, overflowY: 'auto', maxHeight: '500px' }}>
                                    {(() => {
                                        // 1. Get default/configured positions + any extra from diagram
                                        const standardKeys = ['QB', 'RB', 'X', 'Z', 'Y', 'A', 'F', 'H', 'LT', 'LG', 'C', 'RG', 'RT'];
                                        const defaultPos = standardKeys.map(key => positionNames[key] || key);

                                        // 2. Extract unique player labels from diagramData
                                        const diagramPlayers = (formData.diagramData?.elements || [])
                                            .filter(el => el.type === 'player' && el.label)
                                            .map(el => el.label);

                                        // Merge and dedupe
                                        const allPositions = Array.from(new Set([...defaultPos, ...diagramPlayers]));

                                        return allPositions.map(pos => (
                                            <div key={pos} style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '0.5rem' }}>
                                                <span style={{ width: '40px', fontWeight: 'bold', fontSize: '0.9rem', color: 'var(--text-primary)', flexShrink: 0 }}>{pos}</span>
                                                <input
                                                    className="form-input"
                                                    style={{ padding: '0.4rem 0.6rem', flex: 1, fontSize: '0.9rem' }}
                                                    placeholder={`Notes for ${pos}...`}
                                                    value={formData.playerNotes?.[pos] || ''}
                                                    onChange={(e) => setFormData(prev => ({
                                                        ...prev,
                                                        playerNotes: { ...prev.playerNotes, [pos]: e.target.value }
                                                    }))}
                                                />
                                            </div>
                                        ));
                                    })()}
                                </div>
                            </div>
                        </div>


                        <div className="form-group" style={{ marginTop: '1.5rem', background: 'var(--bg-main)', padding: '1.5rem', borderRadius: '12px', border: '1px solid var(--border)' }}>
                            <label className="form-label" style={{ marginBottom: '1rem' }}>Situational Tags (or drag tags here)</label>

                            {/* Show Bucket/Family from PlayDetailsModal */}
                            {formData.bucketId && (() => {
                                const bucket = playBuckets.find(b => b.id === formData.bucketId);
                                if (!bucket) return null;
                                const category = playCategories.find(c => c.id === bucket.categoryId);
                                return (
                                    <div style={{
                                        marginBottom: '1rem',
                                        padding: '0.75rem 1rem',
                                        background: 'var(--bg-alt)',
                                        borderRadius: '8px',
                                        border: '1px solid var(--border)',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '0.5rem',
                                        fontSize: '0.85rem'
                                    }}>
                                        <span style={{ color: 'var(--text-muted)' }}>Game Plan Assignment:</span>
                                        {category && <span style={{ fontWeight: '500' }}>{category.name}</span>}
                                        {category && <span style={{ color: 'var(--text-muted)' }}>/</span>}
                                        <span style={{
                                            background: bucket.color || 'var(--accent)',
                                            color: '#fff',
                                            padding: '2px 8px',
                                            borderRadius: '4px',
                                            fontWeight: '500'
                                        }}>
                                            {bucket.name}
                                        </span>
                                    </div>
                                );
                            })()}

                            <div
                                onDrop={(e) => {
                                    e.preventDefault();
                                    if (draggedComponent) {
                                        toggleTag(draggedComponent.text);
                                        setDraggedComponent(null);
                                    }
                                }}
                                onDragOver={(e) => {
                                    e.preventDefault();
                                    e.dataTransfer.dropEffect = 'copy';
                                }}
                                style={{
                                    border: draggedComponent ? '2px dashed #3b82f6' : '1px solid transparent',
                                    borderRadius: '8px', padding: draggedComponent ? '0.5rem' : '0', transition: 'all 0.2s'
                                }}
                            >
                                <TagSelector
                                    selectedTags={formData.tags}
                                    onToggle={toggleTag}
                                    customTagCategories={customTagCategories}
                                    onUpdateCustomCategories={setCustomTagCategories}
                                />
                            </div>
                        </div>

                        <div style={{ display: 'flex', gap: '1rem', marginTop: '2rem', paddingBottom: '2rem' }}>
                            <button type="submit" className="btn btn-primary">Save Play</button>
                            <button type="button" onClick={onCancel} className="btn btn-secondary">Cancel</button>
                        </div>
                    </form >
                </div >

            );
        };

        const PlayCard = ({ play, onEdit, isSelected, onToggleSelect = () => { }, onQuickEdit }) => {
            return (
                <div
                    className={`play-card ${isSelected ? 'selected' : ''}`}
                    data-play-id={play.id}
                    onClick={(e) => {
                        // If quick edit exists, use it. Otherwise fallback to edit.
                        if (onQuickEdit) {
                            onQuickEdit(play, e.clientX, e.clientY);
                        } else {
                            onEdit(play);
                        }
                    }}
                    onDoubleClick={(e) => {
                        e.stopPropagation();
                        onEdit(play);
                    }}
                    style={{ cursor: 'pointer', position: 'relative', border: isSelected ? '2px solid var(--accent)' : '1px solid var(--border)' }}
                >
                    <div
                        onClick={(e) => {
                            e.stopPropagation();
                            onToggleSelect(play.id, e);
                        }}
                        style={{
                            position: 'absolute', right: '5px', top: '5px', zIndex: 10,
                            width: '24px', height: '24px', display: 'flex', alignItems: 'center', justifyContent: 'center',
                            background: 'rgba(255,255,255,0.8)', borderRadius: '4px'
                        }}
                    >
                        <input
                            type="checkbox"
                            checked={isSelected}
                            onChange={() => { }} // Handled by div click
                            style={{ width: '18px', height: '18px', cursor: 'pointer' }}
                        />
                    </div>
                    {/* Explicit Edit Pencil */}
                    <div
                        onClick={(e) => {
                            e.stopPropagation();
                            onEdit(play);
                        }}
                        style={{
                            position: 'absolute', right: '35px', top: '5px', zIndex: 10,
                            width: '24px', height: '24px', display: 'flex', alignItems: 'center', justifyContent: 'center',
                            background: 'rgba(255,255,255,0.8)', borderRadius: '4px', cursor: 'pointer', color: 'var(--text-secondary)'
                        }}
                        title="Edit Play Details"
                    >
                        <Icon name="Edit2" size={14} />
                    </div>

                    {(() => {
                        // Get diagram elements from any available source
                        let elements = null;
                        if (play.wizSkillData && Array.isArray(play.wizSkillData) && play.wizSkillData.length > 0) {
                            elements = play.wizSkillData;
                        } else if (play.rooskiSkillData && Array.isArray(play.rooskiSkillData) && play.rooskiSkillData.length > 0) {
                            elements = play.rooskiSkillData;
                        } else if (play.wizOlineData && Array.isArray(play.wizOlineData) && play.wizOlineData.length > 0) {
                            elements = play.wizOlineData;
                        } else if (play.diagramData) {
                            if (Array.isArray(play.diagramData) && play.diagramData.length > 0) {
                                elements = play.diagramData;
                            } else if (play.diagramData.elements && Array.isArray(play.diagramData.elements) && play.diagramData.elements.length > 0) {
                                elements = play.diagramData.elements;
                            }
                        }

                        if (play.image) {
                            return <img src={play.image} className="play-image" alt={play.name} />;
                        }

                        return (
                            <div className="play-diagram" style={{ height: '180px', background: elements ? '#f0fdf4' : '#f3f4f6', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                                {elements ? (
                                <svg viewBox="0 60 800 460" width="100%" height="100%" style={{ display: 'block' }} preserveAspectRatio="xMidYMid meet">
                                    <defs>
                                        {['#000000', '#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#a855f7', '#22c55e', '#eab308'].map(c => (
                                            <marker key={c} id={`pc-arrow-${c.replace('#', '')}`} markerWidth="6" markerHeight="4" refX="5" refY="2" orient="auto">
                                                <polygon points="0 0, 6 2, 0 4" fill={c} />
                                            </marker>
                                        ))}
                                    </defs>
                                    <g opacity="0.15">
                                        <line x1="0" y1="150" x2="800" y2="150" stroke="#000" strokeWidth="2" />
                                        <line x1="0" y1="250" x2="800" y2="250" stroke="#000" strokeWidth="2" />
                                        <line x1="0" y1="350" x2="800" y2="350" stroke="#000" strokeWidth="2" />
                                        <line x1="0" y1="400" x2="800" y2="400" stroke="#000" strokeWidth="3" />
                                        <line x1="0" y1="450" x2="800" y2="450" stroke="#000" strokeWidth="2" />
                                    </g>
                                    {elements.map((el, idx) => {
                                        if (el.type === 'player' && el.points && el.points[0]) {
                                            const { x, y } = el.points[0];
                                            const isTextOnly = el.shape === 'text-only';
                                            const fontSize = el.fontSize || 14;

                                            if (isTextOnly) {
                                                return <text key={el.id || idx} x={x} y={y} textAnchor="middle" dominantBaseline="middle" fontSize={fontSize} fontWeight="bold" fill={el.color || '#000'}>{el.label}</text>;
                                            }

                                            const size = 14;
                                            const isRect = el.shape === 'square';
                                            return (
                                                <g key={el.id || idx}>
                                                    {isRect ? (
                                                        <rect x={x - size} y={y - size} width={size * 2} height={size * 2} fill="white" stroke={el.color || '#000'} strokeWidth="2" />
                                                    ) : (
                                                        <circle cx={x} cy={y} r={size} fill="white" stroke={el.color || '#000'} strokeWidth="2" />
                                                    )}
                                                    <text x={x} y={y + 1} textAnchor="middle" dominantBaseline="middle" fontSize="10" fontWeight="bold" fill={el.color || '#000'}>{el.label}</text>
                                                </g>
                                            );
                                        }

                                        if (!el.points || el.points.length < 2) return null;

                                        let d = '';
                                        if (el.style === 'zigzag' && typeof getZigZagPath === 'function') {
                                            d = getZigZagPath(el.points);
                                        } else {
                                            d = `M ${el.points.map(p => `${p.x},${p.y}`).join(' L ')}`;
                                        }

                                        const color = el.color || '#000';
                                        const markerId = `pc-arrow-${color.replace('#', '')}`;
                                        let markerEnd = undefined;
                                        let tBlock = null;

                                        if (el.endType === 'arrow' || (!el.endType && el.type !== 'free')) {
                                            markerEnd = `url(#${markerId})`;
                                        } else if (el.endType === 't') {
                                            const end = el.points[el.points.length - 1];
                                            const prev = el.points[el.points.length - 2] || el.points[0];
                                            const dx = end.x - prev.x;
                                            const dy = end.y - prev.y;
                                            const len = Math.hypot(dx, dy) || 1;
                                            const perpX = (-dy / len) * 12;
                                            const perpY = (dx / len) * 12;
                                            tBlock = <line x1={end.x - perpX} y1={end.y - perpY} x2={end.x + perpX} y2={end.y + perpY} stroke={color} strokeWidth="3" />;
                                        } else if (el.endType === 'dot') {
                                            const end = el.points[el.points.length - 1];
                                            tBlock = <circle cx={end.x} cy={end.y} r="5" fill={color} />;
                                        }

                                        return (
                                            <g key={el.id || idx}>
                                                <path d={d} stroke={color} strokeWidth="3" fill="none" strokeDasharray={el.style === 'dashed' ? '8,4' : 'none'} markerEnd={markerEnd} />
                                                {tBlock}
                                            </g>
                                        );
                                    })}
                                </svg>
                                ) : (
                                    <div style={{ color: '#9ca3af', textAlign: 'center' }}>
                                        <span style={{ fontSize: '1.5rem' }}>📷</span>
                                        <div style={{ fontSize: '0.8rem', fontWeight: '500', marginTop: '0.25rem' }}>No Diagram</div>
                                    </div>
                                )}
                            </div>
                        );
                    })()}
                    <div className="play-content">
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start' }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', flex: 1 }}>
                                <h3 className="play-title">{getPlayDisplayName(play)}</h3>
                                {play.incomplete && (
                                    <span style={{
                                        background: '#eab308',
                                        color: 'white',
                                        padding: '0.25rem 0.5rem',
                                        borderRadius: '4px',
                                        fontSize: '0.7rem',
                                        fontWeight: 'bold',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '0.25rem'
                                    }}>
                                        ⚠️ INCOMPLETE
                                    </span>
                                )}
                            </div>
                            {play.wristbandSlot && <span className="mini-tag" style={{ background: 'var(--accent)', color: '#000' }}>#{play.wristbandSlot}</span>} {play.staplesSlot && <span className="mini-tag" style={{ background: '#f59e0b', color: '#000', marginLeft: '2px' }}>S:{play.staplesSlot}</span>}
                        </div>
                        <div className="play-meta">
                            {(() => {
                                const nameLower = play.name.toLowerCase();
                                const parts = [];
                                // Logic for Formation & Formation Tag
                                const normalize = (s) => (s || '').toLowerCase()
                                    .replace(/green/g, 'grn').replace(/bright/g, 'brt')
                                    .replace(/black/g, 'blk').replace(/white/g, 'wht')
                                    .replace(/blue/g, 'blu').replace(/brown/g, 'brn')
                                    .replace(/right/g, 'rt').replace(/left/g, 'lt');

                                const nName = normalize(play.name);
                                const showForm = play.formation && !nName.includes(normalize(play.formation));
                                const showFormTag = play.formationTag && !nName.includes(normalize(play.formationTag));

                                if (showForm) {
                                    let txt = play.formation;
                                    if (showFormTag) txt += ` (${play.formationTag})`;
                                    parts.push(txt);
                                } else if (showFormTag) {
                                    parts.push(`(${play.formationTag})`);
                                }

                                // Logic for Color - REMOVED


                                return parts.map((part, i) => (
                                    <React.Fragment key={i}>
                                        {i > 0 && " • "}
                                        {part}
                                    </React.Fragment>
                                ));
                            })()}
                        </div>
                        <div className="play-tags">
                            {/* Tag 1 */}
                            {/* Tag 1 */}
                            {play.tag1 && !play.name.toLowerCase().includes(play.tag1.toLowerCase()) && (
                                <span className="mini-tag">
                                    {(TAG_CATEGORIES["Motion"] || []).includes(play.tag1) ? `"${play.tag1}"` : play.tag1}
                                </span>
                            )}

                            {/* Tag 2 */}
                            {play.tag2 && !play.name.toLowerCase().includes(play.tag2.toLowerCase()) && (
                                <span className="mini-tag">
                                    ({play.tag2})
                                </span>
                            )}

                            {/* Other Tags array (deduplicated) */}
                            {play.tags && play.tags.map(tag => {
                                // Deduplicate if tag matches fields OR Play Name
                                if (tag === play.tag1 || tag === play.tag2) return null;
                                if (play.name.toLowerCase().includes(tag.toLowerCase())) return null;

                                const isMotion = (TAG_CATEGORIES["Motion"] || []).includes(tag);
                                return <span key={tag} className="mini-tag">{isMotion ? `"${tag}"` : tag}</span>
                            })}
                        </div>
                    </div>
                </div >
            );
        };

        const WristbandPrintCard = ({ title, start, end, slotMap, colorClass }) => {
            // Split range into two columns
            const totalSlots = end - start + 1;
            const mid = Math.ceil(totalSlots / 2);

            // Column 1: start to start + mid - 1
            // Column 2: start + mid to end
            // Wait, for table layout, we likely want just one long list if it's a single column card? 
            // Or if it's 2 columns per card (User image shows 4 columns total on page, so 2 per card).
            // Let's stick to the 2-column per card layout but use TABLES.

            // Actually, HTML tables are great for single columns. To do 2 columns, we can use 2 tables side-by-side.

            const col1Slots = [];
            const col2Slots = [];
            const rowsPerCol = Math.ceil((end - start + 1) / 2);
            // Or fixed 24?

            for (let i = 0; i < rowsPerCol; i++) {
                if (start + i <= end) col1Slots.push(start + i);
                if (start + rowsPerCol + i <= end) col2Slots.push(start + rowsPerCol + i);
            }

            const renderTable = (slots) => (
                <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '8pt', tableLayout: 'fixed' }}>
                    <thead>
                        <tr style={{ background: '#eee', borderBottom: '1px solid black' }}>
                            <th style={{ width: '25px', padding: '2px', borderRight: '1px solid #ccc', textAlign: 'center' }}>#</th>
                            <th style={{ textAlign: 'left', padding: '2px 4px' }}>Play Call</th>
                        </tr>
                    </thead>
                    <tbody>
                        {slots.map((slot, idx) => {
                            const play = slot ? slotMap[slot] : null;
                            return (
                                <tr key={slot} style={{ borderBottom: '1px solid #ccc', height: '18px', backgroundColor: idx % 2 === 1 ? '#f9fafb' : 'white' }}>
                                    <td style={{ textAlign: 'center', borderRight: '1px solid #ccc', fontWeight: 'bold' }}>{slot}</td>
                                    <td style={{ padding: '0 4px', overflow: 'hidden', whiteSpace: 'nowrap', textOverflow: 'ellipsis', fontWeight: '600' }}>
                                        {play?.name || ''}
                                    </td>
                                </tr>
                            );
                        })}
                    </tbody>
                </table>
            );

            return (
                <div className={`wristband-card ${colorClass} text-list`} style={{ display: 'flex', flexDirection: 'column' }}>
                    <div className="wristband-card-header">{title}</div>
                    <div className="wristband-content" style={{ display: 'flex' }}>
                        <div className="wristband-col" style={{ width: '50%', borderRight: '1px solid black' }}>
                            {renderTable(col1Slots)}
                        </div>
                        <div className="wristband-col" style={{ width: '50%' }}>
                            {renderTable(col2Slots)}
                        </div>
                    </div>
                </div>
            );
        };

        // Helper for SVG rendering to avoid duplication
        const WristbandDiagramSVG = ({ data, minimal }) => {
            return (
                <svg
                    viewBox="0 0 900 600"
                    width="100%"
                    height="100%"
                    style={{ display: 'block' }}
                    preserveAspectRatio="xMidYMid meet"
                >
                    <g opacity="0.15">
                        <line x1="0" y1="10%" x2="100%" y2="10%" stroke="#000" strokeWidth={minimal ? 4 : 2} />
                        <line x1="0" y1="30%" x2="100%" y2="30%" stroke="#000" strokeWidth={minimal ? 4 : 2} />
                        <line x1="0" y1="50%" x2="100%" y2="50%" stroke="#000" strokeWidth={minimal ? 6 : 4} />
                        <line x1="0" y1="70%" x2="100%" y2="70%" stroke="#000" strokeWidth={minimal ? 4 : 2} />
                        <line x1="0" y1="90%" x2="100%" y2="90%" stroke="#000" strokeWidth={minimal ? 4 : 2} />
                    </g>
                    {data.elements && data.elements.map(el => {
                        if (el.type === 'player') {
                            const { x, y } = el.points[0];
                            const size = minimal ? 50 : 30; // Larger relative dots for small print
                            const isRect = el.shape === 'square';
                            return (
                                <g key={el.id}>
                                    {isRect ? (
                                        <rect x={x - size / 2} y={y - size / 2} width={size} height={size} fill="white" stroke={el.color} strokeWidth={minimal ? 4 : 2} />
                                    ) : (
                                        <circle cx={x} cy={y} r={size / 2} fill="white" stroke={el.color} strokeWidth={minimal ? 4 : 2} />
                                    )}
                                    {!minimal && <text x={x} y={y} dy="0.35em" textAnchor="middle" fontSize="16" fontWeight="bold" fill={el.color}>{el.label}</text>}
                                </g>
                            );
                        }

                        let d = '';
                        if (el.style === 'zigzag') {
                            d = getZigZagPath(el.points);
                        } else if (el.style === 'curved' && el.points.length >= 2) {
                            const p = el.points;
                            d = `M ${p[0].x} ${p[0].y} Q ${p[1].x} ${p[1].y} ${p[p.length - 1].x} ${p[p.length - 1].y}`;
                        } else {
                            d = `M ${el.points.map(p => `${p.x},${p.y}`).join(' L ')}`;
                        }

                        return (
                            <g key={el.id}>
                                <path d={d} stroke={el.color} strokeWidth={minimal ? 6 : 3} fill="none" strokeDasharray={el.style === 'dashed' ? '10,5' : 'none'} />
                                {el.endMarker === 'arrow' && (
                                    <polygon points="-6,-6 6,0 -6,6" fill={el.color} transform={`translate(${el.points[el.points.length - 1].x}, ${el.points[el.points.length - 1].y})`} />
                                )}
                            </g>
                        );
                    })}
                </svg>
            );
        };

        const WristbandDiagramCard = ({ slot, play }) => {
            return (
                <div className="wristband-card" style={{ display: 'flex', flexDirection: 'column' }}>
                    <div className="wristband-card-header">#{slot} - {play?.name || 'Empty'}</div>
                    <div style={{ flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '0.25rem', overflow: 'hidden', background: '#fff' }}>
                        {play?.diagramData ? (
                            <WristbandDiagramSVG data={play.diagramData} minimal={false} />
                        ) : (
                            <span style={{ color: '#ccc' }}>No Diagram</span>
                        )}
                    </div>
                </div>
            );
        };

        const WristbandGridCard = ({ startSlot, endSlot, slotMap, onUpdatePlay }) => {
            const slots = [];
            for (let i = startSlot; i <= endSlot; i++) {
                slots.push(i);
            }
            while (slots.length < 20) {
                slots.push(null);
            }

            return (
                <div className="wristband-grid-card">
                    {slots.map((slot, index) => {
                        const play = slot ? slotMap[slot] : null;
                        return (
                            <div key={index} className="wristband-grid-cell" style={{ display: 'flex', flexDirection: 'column', height: '100%', border: '1px solid black', overflow: 'hidden', position: 'relative' }}>
                                {/* Clear button in top-right corner */}
                                {play && onUpdatePlay && (
                                    <button
                                        className="wristband-clear-btn"
                                        onClick={(e) => { e.stopPropagation(); onUpdatePlay({ ...play, wristbandSlot: '' }); }}
                                        style={{
                                            position: 'absolute',
                                            top: '2px',
                                            right: '2px',
                                            zIndex: 10,
                                            fontSize: '10px',
                                            padding: '0 4px',
                                            lineHeight: '14px',
                                            background: 'rgba(255, 255, 255, 0.9)',
                                            borderRadius: '2px'
                                        }}
                                    >
                                        ×
                                    </button>
                                )}
                                {/* Top: Diagram (80%) */}
                                <div className="wristband-grid-cell-body" style={{ flex: '0 0 75%', borderBottom: '1px solid black', display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '2px' }}>
                                    {play?.diagramData ? (
                                        <div style={{ width: '100%', height: '100%' }}>
                                            <WristbandDiagramSVG data={play.diagramData} minimal={true} />
                                        </div>
                                    ) : (
                                        <span style={{ fontSize: '8pt', color: '#ddd' }}>-</span>
                                    )}
                                </div>
                                {/* Bottom: Info (20%) */}
                                <div className="wristband-grid-cell-header" style={{ flex: '1', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '6pt', fontWeight: 'bold', background: '#f5f5f5', textAlign: 'center', lineHeight: '1.1' }}>
                                    {slot ? (
                                        <span>#{slot} {play?.name ? `- ${getPlayDisplayName(play).substring(0, 15)}` : ''}</span>
                                    ) : null}
                                </div>
                            </div>
                        );
                    })}
                </div>
            );
        };

        const PlayModalHeader = ({ play, playBuckets = [], onUpdatePlay, onClose, title, subtitle }) => {
            if (!play) return null;

            // Helper to get play display name
            const displayName = title || play.name || 'Unknown Play';

            return (
                <div style={{ padding: '8px 12px', borderBottom: '1px solid #f1f5f9', background: '#f8fafc' }}>
                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '8px' }}>
                        <div style={{ fontWeight: 'bold', color: '#1e293b', fontSize: '0.9rem' }}>
                            {displayName}
                            {subtitle && <div style={{ fontSize: '0.7rem', color: '#64748b', fontWeight: 'normal' }}>{subtitle}</div>}
                        </div>
                        {onClose && (
                            <button
                                onClick={onClose}
                                style={{ background: 'none', border: 'none', cursor: 'pointer', fontSize: '1.2rem', color: '#94a3b8', lineHeight: 1 }}
                            >
                                ×
                            </button>
                        )}
                    </div>

                    {/* Play Type Toggles */}
                    <div style={{ marginBottom: '12px', borderBottom: '1px solid #e2e8f0', paddingBottom: '12px' }}>
                        <div style={{ fontSize: '0.75rem', fontWeight: 'bold', color: '#64748b', marginBottom: '4px', textTransform: 'uppercase' }}>Play Type</div>
                        <div style={{ display: 'flex', flexWrap: 'wrap', gap: '4px' }}>
                            {playBuckets.filter(b => !b.categoryId).map(bucket => {
                                const isSelected = play.bucketId === bucket.id || (
                                    !play.bucketId && play.type && (
                                        play.type.toLowerCase() === bucket.id ||
                                        play.type.toLowerCase() === bucket.label.toLowerCase() ||
                                        (play.type.toLowerCase().includes('run') && (bucket.id === 'run' || bucket.id === 'run-root'))
                                    )
                                );
                                return (
                                    <button
                                        key={bucket.id}
                                        onClick={() => {
                                            if (onUpdatePlay) onUpdatePlay(play.id, {
                                                type: bucket.label,
                                                bucketId: bucket.id
                                            });
                                        }}
                                        className="btn-xs"
                                        style={{
                                            background: isSelected ? bucket.color || '#3b82f6' : 'white',
                                            color: isSelected ? (bucket.textColor || 'white') : '#64748b',
                                            border: isSelected ? '1px solid rgba(0,0,0,0.1)' : '1px solid #cbd5e1',
                                            fontSize: '0.7rem',
                                            padding: '2px 8px',
                                            cursor: 'pointer',
                                            borderRadius: '4px',
                                            fontWeight: isSelected ? 'bold' : 'normal'
                                        }}
                                    >
                                        {bucket.label}
                                    </button>
                                );
                            })}
                        </div>
                    </div>

                    {/* Concept Family */}
                    <div style={{ marginBottom: '12px', borderBottom: '1px solid #e2e8f0', paddingBottom: '12px' }}>
                        <div style={{ fontSize: '0.75rem', fontWeight: 'bold', color: '#64748b', marginBottom: '4px', textTransform: 'uppercase' }}>Concept Family</div>
                        <select
                            value={play.conceptFamily || ''}
                            onChange={(e) => {
                                if (onUpdatePlay) onUpdatePlay(play.id, { conceptFamily: e.target.value });
                            }}
                            style={{ width: '100%', padding: '4px', fontSize: '0.8rem', borderRadius: '4px', border: '1px solid #cbd5e1' }}
                        >
                            <option value="">-- No Concept Assigned --</option>
                            {/* Filter buckets that have a categoryId matching the play's bucketId OR generic if needed */}
                            {playBuckets
                                .filter(b => b.categoryId && (
                                    b.categoryId === play.bucketId
                                    // Relaxed check: or if no bucketId, show all? No, strict to bucket usually best.
                                    // Or if play has no bucketId but type matches?
                                    // Let's assume bucketId is set or synched.
                                ))
                                .sort((a, b) => (a.label || '').localeCompare(b.label || ''))
                                .map(b => (
                                    <option key={b.id} value={b.label}>{b.label}</option>
                                ))}
                        </select>
                    </div>
                </div>
            );
        };

        /* -------------------------------------------------------------------------- */
        /*                           PLAY CHIP COMPONENTS                             */
        /* -------------------------------------------------------------------------- */

        // Context for opening PlayDetailsModal from any PlayChip
        const PlayDetailsModalContext = React.createContext({
            openPlayDetails: () => { },
        });

        const usePlayDetailsModal = () => React.useContext(PlayDetailsModalContext);

        // PlayChip - Visual chip/pill component for a play
        const PlayChip = ({
            play,              // Play object (required if no playId+plays)
            playId,            // Alternative: just pass ID
            plays,             // Required if using playId
            playBuckets = [],  // For category color
            onRemove,          // Optional - shows X button if provided
            showFlags = true,  // Show Priority/Wiz/MiniScript indicators
            size = 'md',       // 'sm' | 'md' | 'lg'
            draggable = false, // Enable drag
            onClick,           // Optional click handler
            className = '',
        }) => {
            const { openPlayDetails } = usePlayDetailsModal();

            // Resolve play object
            const resolvedPlay = play || (plays && plays.find(p => p.id === playId));
            if (!resolvedPlay) return null;

            // Get bucket color
            const bucket = playBuckets.find(b => b.id === resolvedPlay.bucketId);
            const bgColor = bucket?.color || '#e2e8f0';
            const textColor = bucket?.textColor || '#1e293b';

            // Size variants
            const sizes = {
                sm: { padding: '2px 8px', fontSize: '0.7rem', gap: '3px', iconSize: 10 },
                md: { padding: '4px 10px', fontSize: '0.8rem', gap: '4px', iconSize: 12 },
                lg: { padding: '6px 12px', fontSize: '0.9rem', gap: '5px', iconSize: 14 },
            };
            const s = sizes[size] || sizes.md;

            // Flags
            const isPriority = resolvedPlay.priority;
            const isWiz = resolvedPlay.isWiz;
            const isMiniScript = resolvedPlay.isMiniScript;

            // Drag handlers
            const handleDragStart = (e) => {
                if (!draggable) return;
                e.dataTransfer.setData('text/plain', resolvedPlay.id);
                e.dataTransfer.setData('application/x-play-id', resolvedPlay.id);
                e.dataTransfer.effectAllowed = 'copy';
            };

            // Right-click to open modal
            const handleContextMenu = (e) => {
                e.preventDefault();
                openPlayDetails(resolvedPlay.id);
            };

            return (
                <span
                    className={`play-chip ${className}`}
                    draggable={draggable}
                    onDragStart={handleDragStart}
                    onContextMenu={handleContextMenu}
                    onClick={onClick}
                    style={{
                        display: 'inline-flex',
                        alignItems: 'center',
                        gap: s.gap,
                        padding: s.padding,
                        fontSize: s.fontSize,
                        fontWeight: 600,
                        borderRadius: '6px',
                        background: bgColor,
                        color: textColor,
                        cursor: draggable ? 'grab' : (onClick ? 'pointer' : 'default'),
                        userSelect: 'none',
                        whiteSpace: 'nowrap',
                        transition: 'all 0.15s ease',
                    }}
                    title="Right-click to edit details"
                >
                    {/* Flag indicators */}
                    {showFlags && isPriority && <span style={{ opacity: 0.9 }}>★</span>}
                    {showFlags && isWiz && <span style={{ opacity: 0.9 }}>⚡</span>}
                    {showFlags && isMiniScript && <span style={{ opacity: 0.9 }}>📋</span>}

                    {/* Play name */}
                    <span>{resolvedPlay.name}</span>

                    {/* Remove button */}
                    {onRemove && (
                        <button
                            onClick={(e) => {
                                e.stopPropagation();
                                onRemove(resolvedPlay.id);
                            }}
                            style={{
                                background: 'transparent',
                                border: 'none',
                                cursor: 'pointer',
                                padding: '0 2px',
                                marginLeft: '2px',
                                color: textColor,
                                opacity: 0.6,
                                display: 'flex',
                                alignItems: 'center',
                            }}
                            onMouseEnter={(e) => e.target.style.opacity = 1}
                            onMouseLeave={(e) => e.target.style.opacity = 0.6}
                        >
                            <Icon name="X" size={s.iconSize} />
                        </button>
                    )}
                </span>
            );
        };

        // PracticeScriptTable - Unified script table for practice segments
        // Supports both modal view and Practice Scripts page with all features
        const PracticeScriptTable = ({
            script = [],              // Array of script rows
            onUpdateScript,           // Callback to update script
            plays = [],               // All plays for lookup
            playCategories = [],      // For PlayChip colors (buckets)
            isLocked = false,         // Disable editing
            onDrop,                   // Optional custom drop handler
            onQuickAddPlay,           // Callback to create new play on blur
            // Segment info (optional - for header and segment-specific behavior)
            segment = null,           // { id, type, situation, startTime, duration }
            showHeader = false,       // Show segment header with time/type/duration
            // Column visibility
            visibleColumns = {        // Which columns to show
                hash: true,
                down: true,
                dist: true,
                situation: true,
                playCall: true,
                defense: true,
                notes: true,
                actions: true
            },
            // Behavior options
            downAsDropdown = false,   // Use dropdown for down (1-4) vs text input
            situationDropdown = false, // Use dropdown for situation (S/M/L/XL for 3rd down)
            showYardLine = false,     // Show YardLine column instead of Situation
            compact = false,          // Compact padding for denser view
            tableId = null,           // For datalist IDs
            // Advanced features for Practice Scripts page
            notesAsButton = false,    // Render notes as button instead of input
            onEditNotes,              // Callback when notes button clicked: (segmentId, rowId) => void
            onInsertRow,              // Custom insert row handler: (idx, script) => newScript
            onDeleteRow,              // Custom delete handler: (idx, slot, script) => void (if returns false, skips default)
            confirmDelete = false,    // Show confirm dialog before delete
            onFieldKeyDown,           // Keyboard handler: (e, segmentId, slotId, field, script, updateFn) => void
            getNotesDisplay,          // Custom function to get notes display: (slot) => { hasNotes, label }
        }) => {
            const { openPlayDetails } = usePlayDetailsModal();
            const padding = compact ? '4px' : '0.5rem';

            // Support both 'dist' and 'distance' field names
            const getDistance = (slot) => slot.dist || slot.distance || '';
            const setDistance = (slot, value) => {
                // Use whichever field already exists, default to 'dist'
                if ('distance' in slot) return { distance: value };
                return { dist: value };
            };

            const updateRow = (idx, updates) => {
                const newScript = [...script];
                newScript[idx] = { ...newScript[idx], ...updates };
                onUpdateScript(newScript);
            };

            const updateRowById = (slotId, updates) => {
                const newScript = script.map(s => s.id === slotId ? { ...s, ...updates } : s);
                onUpdateScript(newScript);
            };

            const insertRowAfter = (idx) => {
                const newScript = [...script];
                const newRow = {
                    id: `row_${Date.now()}`,
                    hash: 'M',
                    down: '',
                    dist: '',
                    situation: '',
                    playName: '',
                    playId: '',
                    defense: '',
                    notes: '',
                    yardLine: ''
                };
                newScript.splice(idx + 1, 0, newRow);
                onUpdateScript(newScript);
            };

            const deleteRow = (idx) => {
                const newScript = script.filter((_, i) => i !== idx);
                onUpdateScript(newScript);
            };

            const addRow = () => {
                const newRow = {
                    id: `row_${Date.now()}`,
                    hash: 'M',
                    down: '',
                    dist: '',
                    situation: '',
                    playName: '',
                    playId: '',
                    defense: '',
                    notes: '',
                    yardLine: ''
                };
                onUpdateScript([...script, newRow]);
            };

            const handleRowDrop = (e, idx) => {
                e.preventDefault();
                if (onDrop) {
                    onDrop(e, idx);
                    return;
                }
                try {
                    const data = JSON.parse(e.dataTransfer.getData('application/react-dnd'));
                    if (data && (data.playId || data.name)) {
                        updateRow(idx, {
                            playName: data.name || script[idx].playName,
                            playId: data.playId || ''
                        });
                    }
                } catch (err) {
                    // Try plain text format
                    const playId = e.dataTransfer.getData('application/x-play-id') || e.dataTransfer.getData('text/plain');
                    if (playId) {
                        const play = plays.find(p => p.id === playId);
                        if (play) {
                            updateRow(idx, { playName: play.name, playId: play.id });
                        }
                    }
                }
            };

            const handlePlayInputChange = (idx, slot, value) => {
                const val = value.toUpperCase();
                const foundPlay = plays.find(p => p.name === val);
                updateRow(idx, {
                    playName: val,
                    playId: foundPlay ? foundPlay.id : ''
                });
            };

            const handlePlayInputBlur = (idx, slot) => {
                if (slot.playName && !slot.playId && onQuickAddPlay) {
                    const newPlay = onQuickAddPlay(slot.playName);
                    if (newPlay) {
                        updateRow(idx, { playName: newPlay.name, playId: newPlay.id });
                    }
                }
            };

            // Count visible columns for colspan
            const colCount = 1 + // # column always shown
                (visibleColumns.hash ? 1 : 0) +
                (visibleColumns.down ? 1 : 0) +
                (visibleColumns.dist ? 1 : 0) +
                (visibleColumns.situation || showYardLine ? 1 : 0) +
                (visibleColumns.playCall ? 1 : 0) +
                (visibleColumns.defense ? 1 : 0) +
                (visibleColumns.notes ? 1 : 0) +
                (visibleColumns.actions && !isLocked ? 1 : 0);

            return (
                <div style={{
                    border: showHeader ? '1px solid var(--border)' : 'none',
                    borderRadius: showHeader ? '8px' : '0',
                    backgroundColor: showHeader ? 'var(--bg-panel)' : 'transparent',
                    overflow: 'hidden'
                }}>
                    {/* Optional Segment Header */}
                    {showHeader && segment && (
                        <div style={{
                            backgroundColor: 'var(--bg-surface)',
                            padding: '0.5rem 0.75rem',
                            borderBottom: '1px solid var(--border)',
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center',
                            minHeight: '40px'
                        }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.75rem' }}>
                                <span style={{ color: 'var(--accent)', fontWeight: 'bold' }}>{segment.startTime || ''}</span>
                                <span style={{ textTransform: 'uppercase', fontWeight: '600', fontSize: '0.95rem' }}>{segment.type}</span>
                                {segment.duration && (
                                    <span style={{ color: 'var(--text-secondary)', fontSize: '0.85rem' }}>({segment.duration} min)</span>
                                )}
                                {segment.situation && (
                                    <span style={{ backgroundColor: 'var(--bg-body)', border: '1px solid var(--border)', padding: '1px 6px', borderRadius: '4px', fontSize: '0.8rem', color: 'var(--text-secondary)' }}>
                                        {segment.situation}
                                    </span>
                                )}
                            </div>
                        </div>
                    )}

                    {/* Datalist for play autocomplete */}
                    {tableId && (
                        <datalist id={`play-options-${tableId}`}>
                            {plays.map(p => (
                                <option key={p.id} value={p.name}>{p.formation}</option>
                            ))}
                        </datalist>
                    )}

                    <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '0.9rem' }}>
                        <thead style={{ background: 'var(--bg-panel)' }}>
                            <tr style={{ borderBottom: '2px solid var(--border)', backgroundColor: 'var(--bg-body)' }}>
                                <th style={{ padding, textAlign: 'center', width: '40px', color: 'var(--text-secondary)' }}>#</th>
                                {visibleColumns.hash && (
                                    <th style={{ padding, textAlign: 'center', width: '70px' }}>Hash</th>
                                )}
                                {visibleColumns.down && (
                                    <th style={{ padding, textAlign: 'center', width: '50px' }}>Dn</th>
                                )}
                                {visibleColumns.dist && (
                                    <th style={{ padding, textAlign: 'center', width: '50px' }}>Dist</th>
                                )}
                                {showYardLine ? (
                                    <th style={{ padding, textAlign: 'left', width: '60px' }}>Yd</th>
                                ) : visibleColumns.situation && (
                                    <th style={{ padding, textAlign: 'left', width: '120px' }}>Situation</th>
                                )}
                                {visibleColumns.playCall && (
                                    <th style={{ padding, textAlign: 'left' }}>Play Call</th>
                                )}
                                {visibleColumns.defense && (
                                    <th style={{ padding, textAlign: 'left', width: '140px' }}>Defense</th>
                                )}
                                {visibleColumns.notes && (
                                    <th style={{ padding, textAlign: 'left', width: '140px' }}>Notes</th>
                                )}
                                {visibleColumns.actions && !isLocked && (
                                    <th style={{ padding, width: '70px', textAlign: 'center' }}>Act</th>
                                )}
                            </tr>
                        </thead>
                        <tbody>
                            {script.map((slot, idx) => (
                                <tr
                                    key={slot.id || idx}
                                    style={{ borderBottom: '1px solid var(--border)' }}
                                    onDragOver={(e) => e.preventDefault()}
                                    onDrop={(e) => handleRowDrop(e, idx)}
                                >
                                    <td style={{ padding, textAlign: 'center', fontWeight: 'bold', color: 'var(--text-secondary)' }}>{idx + 1}</td>

                                    {/* Hash */}
                                    {visibleColumns.hash && (
                                        <td style={{ padding }}>
                                            {isLocked ? (
                                                <span style={{ fontWeight: 'bold', textAlign: 'center', display: 'block' }}>{slot.hash}</span>
                                            ) : (
                                                <select
                                                    className="form-input"
                                                    style={{ padding: compact ? '2px' : '0.25rem', textAlign: 'center', fontWeight: 'bold', width: '100%' }}
                                                    value={slot.hash || 'M'}
                                                    onChange={e => updateRow(idx, { hash: e.target.value })}
                                                >
                                                    <option value="R">R</option>
                                                    <option value="RM">RM</option>
                                                    <option value="M">M</option>
                                                    <option value="LM">LM</option>
                                                    <option value="L">L</option>
                                                </select>
                                            )}
                                        </td>
                                    )}

                                    {/* Down */}
                                    {visibleColumns.down && (
                                        <td style={{ padding }}>
                                            {isLocked ? (
                                                <span style={{ textAlign: 'center', display: 'block' }}>{slot.down}</span>
                                            ) : downAsDropdown ? (
                                                <select
                                                    className="form-input"
                                                    style={{ padding: compact ? '4px' : '0.25rem', width: '100%', textAlign: 'center' }}
                                                    value={slot.down || ''}
                                                    onChange={e => updateRow(idx, { down: e.target.value })}
                                                >
                                                    <option value=""></option>
                                                    <option value="1">1</option>
                                                    <option value="2">2</option>
                                                    <option value="3">3</option>
                                                    <option value="4">4</option>
                                                </select>
                                            ) : (
                                                <input
                                                    className="form-input"
                                                    style={{ padding: compact ? '4px' : '0.25rem', width: '100%', textAlign: 'center' }}
                                                    value={slot.down || ''}
                                                    onChange={e => updateRow(idx, { down: e.target.value })}
                                                />
                                            )}
                                        </td>
                                    )}

                                    {/* Distance */}
                                    {visibleColumns.dist && (
                                        <td style={{ padding }}>
                                            {isLocked ? (
                                                <span style={{ textAlign: 'center', display: 'block' }}>{getDistance(slot)}</span>
                                            ) : (
                                                <input
                                                    className="form-input"
                                                    style={{ padding: compact ? '4px' : '0.25rem', width: '100%', textAlign: 'center' }}
                                                    value={getDistance(slot)}
                                                    onChange={e => updateRow(idx, setDistance(slot, e.target.value))}
                                                />
                                            )}
                                        </td>
                                    )}

                                    {/* YardLine or Situation */}
                                    {showYardLine ? (
                                        <td style={{ padding }}>
                                            {isLocked ? (
                                                <span>{slot.yardLine}</span>
                                            ) : (
                                                <input
                                                    className="form-input"
                                                    style={{ padding: compact ? '4px' : '0.25rem', width: '100%', backgroundColor: 'var(--bg-body)' }}
                                                    value={slot.yardLine || ''}
                                                    onChange={e => updateRow(idx, { yardLine: e.target.value })}
                                                    placeholder="-30"
                                                />
                                            )}
                                        </td>
                                    ) : visibleColumns.situation && (
                                        <td style={{ padding }}>
                                            {isLocked ? (
                                                <span>{slot.situation}</span>
                                            ) : situationDropdown ? (
                                                <select
                                                    className="form-input"
                                                    style={{ padding: compact ? '4px' : '0.25rem', width: '100%' }}
                                                    value={slot.situation || ''}
                                                    onChange={e => updateRow(idx, { situation: e.target.value })}
                                                >
                                                    <option value="">--</option>
                                                    <option value="S">S (Short)</option>
                                                    <option value="M">M (Medium)</option>
                                                    <option value="L">L (Long)</option>
                                                    <option value="XL">XL (Extra Long)</option>
                                                </select>
                                            ) : (
                                                <input
                                                    className="form-input"
                                                    style={{ padding: compact ? '4px' : '0.25rem', width: '100%' }}
                                                    value={slot.situation || ''}
                                                    onChange={e => updateRow(idx, { situation: e.target.value })}
                                                    placeholder="Situation"
                                                />
                                            )}
                                        </td>
                                    )}

                                    {/* Play Call */}
                                    {visibleColumns.playCall && (
                                        <td style={{ padding }}>
                                            {isLocked ? (
                                                slot.playId ? (
                                                    <PlayChip
                                                        play={plays.find(p => p.id === slot.playId) || { id: slot.playId, name: slot.playName }}
                                                        playBuckets={playCategories}
                                                    />
                                                ) : (
                                                    <span style={{ fontWeight: 'bold' }}>{slot.playName}</span>
                                                )
                                            ) : slot.playId ? (
                                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                    <PlayChip
                                                        play={plays.find(p => p.id === slot.playId) || { id: slot.playId, name: slot.playName }}
                                                        playBuckets={playCategories}
                                                    />
                                                    <button
                                                        className="btn"
                                                        style={{ color: '#94a3b8', padding: '0.1rem', fontSize: '0.7rem' }}
                                                        onClick={() => updateRow(idx, { playName: '', playId: '' })}
                                                        title="Clear play"
                                                    >
                                                        ✕
                                                    </button>
                                                </div>
                                            ) : (
                                                <input
                                                    className="form-input"
                                                    list={tableId ? `play-options-${tableId}` : undefined}
                                                    style={{ padding: compact ? '4px' : '0.25rem', width: '100%', fontWeight: 'bold' }}
                                                    value={slot.playName || ''}
                                                    onChange={e => handlePlayInputChange(idx, slot, e.target.value)}
                                                    onBlur={() => handlePlayInputBlur(idx, slot)}
                                                    onDragOver={(e) => e.preventDefault()}
                                                    onDrop={(e) => handleRowDrop(e, idx)}
                                                    placeholder="Play Call..."
                                                />
                                            )}
                                        </td>
                                    )}

                                    {/* Defense */}
                                    {visibleColumns.defense && (
                                        <td style={{ padding }}>
                                            {isLocked ? (
                                                <span>{slot.defense}</span>
                                            ) : (
                                                <input
                                                    className="form-input"
                                                    style={{ padding: compact ? '4px' : '0.25rem', width: '100%' }}
                                                    value={slot.defense || ''}
                                                    onChange={e => updateRow(idx, { defense: e.target.value })}
                                                    placeholder="Defense"
                                                />
                                            )}
                                        </td>
                                    )}

                                    {/* Notes */}
                                    {visibleColumns.notes && (
                                        <td style={{ padding }}>
                                            {isLocked ? (
                                                <span>{slot.notes}</span>
                                            ) : notesAsButton ? (
                                                (() => {
                                                    const notesInfo = getNotesDisplay ? getNotesDisplay(slot) : { hasNotes: !!slot.notes, label: slot.notes ? '📝 Notes' : 'Add Note...' };
                                                    return (
                                                        <button
                                                            className="btn btn-secondary"
                                                            style={{
                                                                width: '100%',
                                                                padding: compact ? '4px' : '0.25rem',
                                                                textAlign: 'left',
                                                                fontSize: '0.8rem',
                                                                color: notesInfo.hasNotes ? 'var(--primary)' : 'var(--text-secondary)',
                                                                borderColor: notesInfo.hasNotes ? 'var(--primary)' : 'var(--border)'
                                                            }}
                                                            onClick={() => onEditNotes && onEditNotes(segment?.id, slot.id)}
                                                        >
                                                            {notesInfo.label}
                                                        </button>
                                                    );
                                                })()
                                            ) : (
                                                <input
                                                    className="form-input"
                                                    style={{ padding: compact ? '4px' : '0.25rem', width: '100%' }}
                                                    value={slot.notes || ''}
                                                    onChange={e => updateRow(idx, { notes: e.target.value })}
                                                    placeholder="Add Note..."
                                                />
                                            )}
                                        </td>
                                    )}

                                    {/* Actions */}
                                    {visibleColumns.actions && !isLocked && (
                                        <td style={{ padding, textAlign: 'center', whiteSpace: 'nowrap' }}>
                                            <div style={{ display: 'flex', gap: '0.25rem', justifyContent: 'center' }}>
                                                <button
                                                    className={compact ? "btn btn-secondary" : "btn"}
                                                    style={{
                                                        color: 'var(--accent)',
                                                        padding: compact ? '2px 6px' : '0.25rem',
                                                        fontWeight: 'bold',
                                                        fontSize: compact ? '0.8rem' : undefined
                                                    }}
                                                    onClick={() => {
                                                        if (onInsertRow) {
                                                            const newScript = onInsertRow(idx, script);
                                                            if (newScript) onUpdateScript(newScript);
                                                        } else {
                                                            insertRowAfter(idx);
                                                        }
                                                    }}
                                                    tabIndex={-1}
                                                    title="Insert row below"
                                                >
                                                    +
                                                </button>
                                                <button
                                                    className={compact ? "btn btn-secondary" : "btn"}
                                                    style={{
                                                        color: '#ef4444',
                                                        padding: compact ? '2px 6px' : '0.25rem',
                                                        fontSize: compact ? '0.8rem' : undefined
                                                    }}
                                                    onClick={() => {
                                                        if (onDeleteRow) {
                                                            onDeleteRow(idx, slot, script);
                                                        } else if (confirmDelete) {
                                                            if (confirm('Delete this row?')) {
                                                                deleteRow(idx);
                                                            }
                                                        } else {
                                                            deleteRow(idx);
                                                        }
                                                    }}
                                                    tabIndex={-1}
                                                    title="Delete row"
                                                >
                                                    ×
                                                </button>
                                            </div>
                                        </td>
                                    )}
                                </tr>
                            ))}
                            {!isLocked && (
                                <tr>
                                    <td colSpan={colCount} style={{ padding: '1rem', textAlign: 'center' }}>
                                        <button className="btn btn-secondary" onClick={addRow}>
                                            + Add Play Row
                                        </button>
                                    </td>
                                </tr>
                            )}
                        </tbody>
                    </table>
                </div>
            );
        };

        // PlayChipInput - Input field with autocomplete that creates PlayChips
        const PlayChipInput = ({
            plays = [],             // All plays for autocomplete
            selectedPlayIds = [],   // Currently selected plays (array of IDs)
            onChange,               // Called with updated array of play IDs
            onQuickAddPlay,         // Creates new play if not found
            playBuckets = [],       // For chip colors
            placeholder = 'Type play name...',
            allowCreate = true,     // Allow creating new plays
            disabled = false,
        }) => {
            const [inputValue, setInputValue] = useState('');
            const [showDropdown, setShowDropdown] = useState(false);
            const [highlightedIndex, setHighlightedIndex] = useState(0);
            const inputRef = useRef(null);
            const dropdownRef = useRef(null);

            // Filter plays for autocomplete
            const filteredPlays = useMemo(() => {
                if (!inputValue.trim()) return [];
                const search = inputValue.toLowerCase();
                return plays
                    .filter(p =>
                        p.name.toLowerCase().includes(search) &&
                        !selectedPlayIds.includes(p.id)
                    )
                    .slice(0, 8); // Limit results
            }, [inputValue, plays, selectedPlayIds]);

            // Check if input matches existing play exactly
            const exactMatch = plays.find(p =>
                p.name.toLowerCase() === inputValue.trim().toLowerCase()
            );

            // Show create option?
            const showCreateOption = allowCreate &&
                inputValue.trim() &&
                !exactMatch &&
                onQuickAddPlay;

            // Handle selecting a play from dropdown
            const handleSelectPlay = (playId) => {
                if (!selectedPlayIds.includes(playId)) {
                    onChange([...selectedPlayIds, playId]);
                }
                setInputValue('');
                setShowDropdown(false);
                setHighlightedIndex(0);
                inputRef.current?.focus();
            };

            // Handle creating a new play
            const handleCreatePlay = async () => {
                if (!inputValue.trim() || !onQuickAddPlay) return;
                const newPlay = await onQuickAddPlay(inputValue.trim());
                if (newPlay?.id) {
                    onChange([...selectedPlayIds, newPlay.id]);
                }
                setInputValue('');
                setShowDropdown(false);
                setHighlightedIndex(0);
            };

            // Handle removing a chip
            const handleRemoveChip = (playId) => {
                onChange(selectedPlayIds.filter(id => id !== playId));
            };

            // Handle keyboard navigation
            const handleKeyDown = (e) => {
                const totalItems = filteredPlays.length + (showCreateOption ? 1 : 0);

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    setHighlightedIndex(i => Math.min(i + 1, totalItems - 1));
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    setHighlightedIndex(i => Math.max(i - 1, 0));
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (highlightedIndex < filteredPlays.length) {
                        handleSelectPlay(filteredPlays[highlightedIndex].id);
                    } else if (showCreateOption) {
                        handleCreatePlay();
                    }
                } else if (e.key === 'Escape') {
                    setShowDropdown(false);
                } else if (e.key === 'Backspace' && !inputValue && selectedPlayIds.length > 0) {
                    // Remove last chip on backspace with empty input
                    handleRemoveChip(selectedPlayIds[selectedPlayIds.length - 1]);
                }
            };

            // Handle drop
            const handleDrop = (e) => {
                e.preventDefault();
                const playId = e.dataTransfer.getData('application/x-play-id') ||
                    e.dataTransfer.getData('text/plain');
                if (playId && !selectedPlayIds.includes(playId)) {
                    const playExists = plays.some(p => p.id === playId);
                    if (playExists) {
                        onChange([...selectedPlayIds, playId]);
                    }
                }
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            };

            // Close dropdown on outside click
            useEffect(() => {
                const handleClickOutside = (e) => {
                    if (dropdownRef.current && !dropdownRef.current.contains(e.target) &&
                        inputRef.current && !inputRef.current.contains(e.target)) {
                        setShowDropdown(false);
                    }
                };
                document.addEventListener('mousedown', handleClickOutside);
                return () => document.removeEventListener('mousedown', handleClickOutside);
            }, []);

            return (
                <div
                    style={{
                        display: 'flex',
                        flexWrap: 'wrap',
                        alignItems: 'center',
                        gap: '6px',
                        padding: '6px 10px',
                        background: disabled ? '#f1f5f9' : 'white',
                        border: '1px solid #e2e8f0',
                        borderRadius: '8px',
                        minHeight: '42px',
                        position: 'relative',
                    }}
                    onDrop={handleDrop}
                    onDragOver={handleDragOver}
                >
                    {/* Existing chips */}
                    {selectedPlayIds.map(playId => {
                        const play = plays.find(p => p.id === playId);
                        if (!play) return null;
                        return (
                            <PlayChip
                                key={playId}
                                play={play}
                                playBuckets={playBuckets}
                                onRemove={handleRemoveChip}
                                size="sm"
                                showFlags={true}
                            />
                        );
                    })}

                    {/* Input field */}
                    <input
                        ref={inputRef}
                        type="text"
                        value={inputValue}
                        onChange={(e) => {
                            setInputValue(e.target.value);
                            setShowDropdown(true);
                            setHighlightedIndex(0);
                        }}
                        onFocus={() => inputValue && setShowDropdown(true)}
                        onKeyDown={handleKeyDown}
                        placeholder={selectedPlayIds.length === 0 ? placeholder : ''}
                        disabled={disabled}
                        style={{
                            flex: 1,
                            minWidth: '120px',
                            border: 'none',
                            outline: 'none',
                            fontSize: '0.9rem',
                            background: 'transparent',
                            padding: '4px 0',
                        }}
                    />

                    {/* Dropdown */}
                    {showDropdown && (filteredPlays.length > 0 || showCreateOption) && (
                        <div
                            ref={dropdownRef}
                            style={{
                                position: 'absolute',
                                top: '100%',
                                left: 0,
                                right: 0,
                                marginTop: '4px',
                                background: 'white',
                                border: '1px solid #e2e8f0',
                                borderRadius: '8px',
                                boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)',
                                zIndex: 50,
                                maxHeight: '240px',
                                overflowY: 'auto',
                            }}
                        >
                            {filteredPlays.map((play, idx) => (
                                <div
                                    key={play.id}
                                    onClick={() => handleSelectPlay(play.id)}
                                    style={{
                                        padding: '8px 12px',
                                        cursor: 'pointer',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'space-between',
                                        background: idx === highlightedIndex ? '#f1f5f9' : 'white',
                                        borderBottom: idx < filteredPlays.length - 1 || showCreateOption ? '1px solid #f1f5f9' : 'none',
                                    }}
                                    onMouseEnter={() => setHighlightedIndex(idx)}
                                >
                                    <span style={{ fontWeight: 500, color: '#1e293b' }}>{play.name}</span>
                                    {play.wristbandSlot && (
                                        <span style={{ fontSize: '0.75rem', color: '#94a3b8' }}>
                                            {play.wristbandSlot}
                                        </span>
                                    )}
                                </div>
                            ))}

                            {showCreateOption && (
                                <div
                                    onClick={handleCreatePlay}
                                    style={{
                                        padding: '8px 12px',
                                        cursor: 'pointer',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '6px',
                                        background: highlightedIndex === filteredPlays.length ? '#f1f5f9' : 'white',
                                        color: '#3b82f6',
                                        fontWeight: 500,
                                        borderTop: filteredPlays.length > 0 ? '1px solid #e2e8f0' : 'none',
                                    }}
                                    onMouseEnter={() => setHighlightedIndex(filteredPlays.length)}
                                >
                                    <Icon name="Plus" size={14} />
                                    <span>Create "{inputValue.trim().toUpperCase()}"</span>
                                </div>
                            )}
                        </div>
                    )}
                </div>
            );
        };

        /* -------------------------------------------------------------------------- */
        /*                           PLAY DETAILS MODAL                               */
        /* -------------------------------------------------------------------------- */

        const PlayDetailsModal = ({
            playId,
            plays,
            weekDate, // Can be null if not applicable
            newInstallIds = [],
            gamePlanLayouts = GAME_PLAN_LAYOUTS,
            assignedIds = new Set(), // Set of situation IDs this play is assigned to
            onClose,
            onUpdateWeek, // Optional: function(date, field, val)
            onUpdatePlay, // Required: function(id, updates)
            onAssignSituation, // Optional: function(playId, box) -> adds to script/situation
            onSuggest, // Optional: function(playId, setId) -> adds play suggestion for situation
            suggestions = {}, // Current suggestions { setId: [playId, ...] }
            position = { x: 0, y: 0 },
            playBuckets = [], // Concept families (nested under categories)
            playCategories = [], // Top-level buckets (Run, Pass, Screen)
            currentWeek, // Added for validation
        }) => {
            const play = plays.find(p => p.id === playId);
            if (!play) return null;

            // Local state for immediate visual feedback on situation assignments
            const [localAssignedIds, setLocalAssignedIds] = useState(() => new Set(assignedIds));

            // Sync with prop when it changes (e.g., modal reopens with different play)
            useEffect(() => {
                setLocalAssignedIds(new Set(assignedIds));
            }, [playId]);

            // Handle situation assignment with immediate visual feedback
            const handleSituationClick = (box) => {
                if (!onAssignSituation) return;

                // Toggle local state immediately for visual feedback
                setLocalAssignedIds(prev => {
                    const newSet = new Set(prev);
                    if (newSet.has(box.setId)) {
                        newSet.delete(box.setId);
                    } else {
                        newSet.add(box.setId);
                    }
                    return newSet;
                });

                // Call the actual handler to persist the change
                onAssignSituation(playId, box);
            };

            const isNew = (newInstallIds || []).includes(playId);
            const isPriority = play.priority || false;
            const isWiz = !!(play.isWiz);
            const isMiniScript = !!play.isMiniScript;

            // Toggle handlers
            const handleToggleNew = () => {
                if (!onUpdateWeek || !weekDate) return;
                const currentNewIds = newInstallIds || [];
                let newIds;
                if (currentNewIds.includes(playId)) {
                    newIds = currentNewIds.filter(id => id !== playId);
                } else {
                    newIds = [...currentNewIds, playId];
                }
                onUpdateWeek(weekDate, 'newInstallIds', newIds);
            };

            const handleTogglePriority = () => {
                if (!onUpdatePlay) return;
                onUpdatePlay(playId, { priority: !isPriority });
            };

            const handleToggleWiz = () => {
                if (!onUpdatePlay) return;
                onUpdatePlay(playId, { isWiz: !isWiz });
            };

            const handleToggleMiniScript = () => {
                if (!onUpdatePlay) return;
                onUpdatePlay(playId, { isMiniScript: !isMiniScript });
            };

            const popoverHeight = 450;
            const popoverWidth = 300; // Increase width slightly for better fit

            // Simple collision detection
            let top = position.y;
            let left = position.x;
            if (top + popoverHeight > window.innerHeight) top = window.innerHeight - popoverHeight - 10;
            if (left + popoverWidth > window.innerWidth) left = window.innerWidth - popoverWidth - 10;

            return (
                <div style={{
                    position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
                    background: 'rgba(0,0,0,0.4)', zIndex: 9999, // Darker backdrop
                    display: 'flex', alignItems: 'center', justifyContent: 'center' // Center it
                }} onClick={onClose}>
                    <div style={{
                        background: 'white', width: '420px', maxHeight: '600px', // Wider and taller
                        borderRadius: '12px', boxShadow: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',
                        display: 'flex', flexDirection: 'column', overflow: 'hidden'
                    }} onClick={e => e.stopPropagation()}>

                        {/* UNIFIED HEADER */}
                        <div style={{ padding: '16px', borderBottom: '1px solid #e2e8f0', display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                            <div>
                                <h3 style={{ margin: 0, fontSize: '1.25rem', fontWeight: 700, color: '#0f172a' }}>
                                    {play.name}
                                </h3>
                                {/* Show play's assigned bucket and concept family */}
                                {(play.bucketId || play.conceptFamily) && (
                                    <div style={{ display: 'flex', gap: '4px', marginTop: '6px', flexWrap: 'wrap' }}>
                                        {play.bucketId && (() => {
                                            const bucket = playCategories.find(c => c.id === play.bucketId);
                                            return bucket ? (
                                                <span style={{
                                                    fontSize: '0.7rem', padding: '2px 6px', borderRadius: '4px',
                                                    background: bucket.color || '#64748b', color: bucket.textColor || '#fff', fontWeight: 600
                                                }}>
                                                    {bucket.label}
                                                </span>
                                            ) : null;
                                        })()}
                                        {play.conceptFamily && (() => {
                                            const family = playBuckets.find(b => b.label === play.conceptFamily);
                                            return (
                                                <span style={{
                                                    fontSize: '0.7rem', padding: '2px 6px', borderRadius: '4px',
                                                    background: family?.color || '#94a3b8', color: family?.textColor || '#fff', fontWeight: 600
                                                }}>
                                                    {play.conceptFamily}
                                                </span>
                                            );
                                        })()}
                                    </div>
                                )}
                            </div>
                            <button onClick={onClose} style={{
                                background: 'transparent', border: 'none', cursor: 'pointer',
                                color: '#94a3b8', padding: '4px'
                            }}>
                                <Icon name="X" size={20} />
                            </button>
                        </div>

                        {/* TOGGLES ROW */}
                        <div style={{ padding: '12px 16px', borderBottom: '1px solid #e2e8f0', display: 'flex', flexWrap: 'wrap', gap: '8px', alignItems: 'center' }}>
                            <button
                                onClick={handleTogglePriority}
                                style={{
                                    padding: '6px 12px', borderRadius: '6px', fontSize: '0.85rem', fontWeight: 600, cursor: 'pointer',
                                    border: isPriority ? '1px solid #f59e0b' : '1px solid #cbd5e1',
                                    background: isPriority ? '#fffbeb' : 'white',
                                    color: isPriority ? '#b45309' : '#64748b',
                                }}
                            >
                                Priority
                            </button>
                            <button
                                onClick={handleToggleWiz}
                                style={{
                                    padding: '6px 12px', borderRadius: '6px', fontSize: '0.85rem', fontWeight: 600, cursor: 'pointer',
                                    border: isWiz ? '1px solid #8b5cf6' : '1px solid #cbd5e1',
                                    background: isWiz ? '#f3e8ff' : 'white',
                                    color: isWiz ? '#7c3aed' : '#64748b',
                                }}
                            >
                                Wiz
                            </button>
                            <button
                                onClick={handleToggleMiniScript}
                                style={{
                                    padding: '6px 12px', borderRadius: '6px', fontSize: '0.85rem', fontWeight: 600, cursor: 'pointer',
                                    border: isMiniScript ? '1px solid #06b6d4' : '1px solid #cbd5e1',
                                    background: isMiniScript ? '#ecfeff' : 'white',
                                    color: isMiniScript ? '#0891b2' : '#64748b',
                                }}
                            >
                                Mini Script
                            </button>
                            <div style={{ marginLeft: 'auto', display: 'flex', alignItems: 'center', gap: '4px' }}>
                                <label style={{ fontSize: '0.85rem', fontWeight: 600, color: '#64748b' }}>WB:</label>
                                <div style={{ position: 'relative', width: '60px' }}>
                                    <input
                                        type="text"
                                        value={play.wristbandSlot || ''}
                                        onChange={(e) => {
                                            const val = e.target.value;

                                            // Validation Logic
                                            let isBlocked = false;
                                            const currentWbSettings = currentWeek?.wristbands || {};
                                            const enabledSections = currentWbSettings.enabledSections || {};

                                            const cardKeys = ['card1', 'card2', 'card3', 'card4', 'card5', 'card6'];
                                            for (const key of cardKeys) {
                                                if (enabledSections[key] !== false) continue;
                                                const card = currentWbSettings[key];
                                                if (!card) continue;
                                                const cardNum = parseInt(key.replace('card', ''));

                                                if (card.type && (card.type === 'wiz')) {
                                                    for (let i = 1; i <= 16; i++) {
                                                        if (val === `${cardNum}${String(i).padStart(2, '0')}`) isBlocked = true;
                                                    }
                                                } else {
                                                    const start = cardNum * 100 + 1;
                                                    const end = start + 47;
                                                    const num = parseInt(val);
                                                    if (!isNaN(num) && num >= start && num <= end && String(num) === val) isBlocked = true;
                                                }
                                            }

                                            // Check Staples
                                            if (enabledSections.staples === false) {
                                                const num = parseInt(val);
                                                if (!isNaN(num) && num >= 10 && num <= 89 && String(num) === val) isBlocked = true;
                                            }

                                            if (isBlocked) {
                                                alert("This wristband section is disabled.");
                                                return;
                                            }

                                            onUpdatePlay(playId, { wristbandSlot: val });
                                        }}
                                        style={{
                                            width: '100%', padding: '4px 6px', fontSize: '0.9rem', fontWeight: 600,
                                            borderRadius: '4px', border: '1px solid #cbd5e1',
                                            color: '#0f172a', textAlign: 'center'
                                        }}
                                    />
                                </div>
                            </div>
                        </div>

                        {/* BUCKET SELECTION */}
                        {playCategories && playCategories.length > 0 && (
                            <div style={{ padding: '12px 16px', borderBottom: '1px solid #e2e8f0' }}>
                                <div style={{
                                    fontSize: '0.7rem', fontWeight: '700', color: '#94a3b8',
                                    marginBottom: '8px', textTransform: 'uppercase', letterSpacing: '0.05em'
                                }}>
                                    Bucket
                                </div>
                                <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px' }}>
                                    {playCategories.map(cat => {
                                        const isSelected = play.bucketId === cat.id;
                                        return (
                                            <button
                                                key={cat.id}
                                                onClick={() => onUpdatePlay && onUpdatePlay(playId, {
                                                    bucketId: isSelected ? null : cat.id,
                                                    conceptFamily: isSelected ? null : play.conceptFamily // Clear family if deselecting bucket
                                                })}
                                                style={{
                                                    padding: '5px 10px',
                                                    borderRadius: '6px',
                                                    fontSize: '0.8rem',
                                                    fontWeight: 600,
                                                    cursor: 'pointer',
                                                    border: isSelected ? `2px solid ${cat.color || '#3b82f6'}` : '1px solid #e2e8f0',
                                                    background: isSelected ? (cat.color || '#3b82f6') : 'white',
                                                    color: isSelected ? (cat.textColor || '#fff') : '#64748b',
                                                    transition: 'all 0.15s ease',
                                                }}
                                            >
                                                {cat.label}
                                            </button>
                                        );
                                    })}
                                </div>
                            </div>
                        )}

                        {/* CONCEPT FAMILY SELECTION (nested under selected bucket) */}
                        {play.bucketId && playBuckets && playBuckets.filter(b => b.categoryId === play.bucketId).length > 0 && (
                            <div style={{ padding: '12px 16px', borderBottom: '1px solid #e2e8f0' }}>
                                <div style={{
                                    fontSize: '0.7rem', fontWeight: '700', color: '#94a3b8',
                                    marginBottom: '8px', textTransform: 'uppercase', letterSpacing: '0.05em'
                                }}>
                                    Concept Family
                                </div>
                                <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px' }}>
                                    {playBuckets
                                        .filter(b => b.categoryId === play.bucketId)
                                        .map(family => {
                                            const isSelected = play.conceptFamily === family.label;
                                            return (
                                                <button
                                                    key={family.id}
                                                    onClick={() => onUpdatePlay && onUpdatePlay(playId, {
                                                        conceptFamily: isSelected ? null : family.label
                                                    })}
                                                    style={{
                                                        padding: '5px 10px',
                                                        borderRadius: '6px',
                                                        fontSize: '0.8rem',
                                                        fontWeight: 600,
                                                        cursor: 'pointer',
                                                        border: isSelected ? `2px solid ${family.color || '#64748b'}` : '1px solid #e2e8f0',
                                                        background: isSelected ? (family.color || '#64748b') : 'white',
                                                        color: isSelected ? (family.textColor || '#fff') : '#64748b',
                                                        transition: 'all 0.15s ease',
                                                    }}
                                                >
                                                    {family.label}
                                                </button>
                                            );
                                        })}
                                </div>
                            </div>
                        )}

                        {/* BODY - SCROLLABLE CHIPS */}
                        <div style={{ padding: '16px', overflowY: 'auto', flex: 1 }}>
                            {/* Suggest Mode Toggle - only show if onSuggest is available */}
                            {onSuggest && (
                                <div style={{
                                    marginBottom: '12px',
                                    padding: '8px 12px',
                                    background: '#fef2f2',
                                    borderRadius: '6px',
                                    border: '1px solid #fecaca',
                                    fontSize: '0.8rem',
                                    color: '#991b1b'
                                }}>
                                    <strong>Suggest Mode:</strong> Click situations below to suggest this play
                                </div>
                            )}
                            {(gamePlanLayouts?.CALL_SHEET?.sections || []).map((section, sIdx) => {
                                const relevantBoxes = (section.boxes || []).filter(b => b.header && !b.hidden);
                                if (relevantBoxes.length === 0) return null;

                                return (
                                    <div key={sIdx} style={{ marginBottom: '20px' }}>
                                        <div style={{
                                            fontSize: '0.75rem', fontWeight: '800', color: '#94a3b8',
                                            marginBottom: '8px', textTransform: 'uppercase', letterSpacing: '0.05em'
                                        }}>
                                            {section.title || `Section ${sIdx + 1}`}
                                        </div>
                                        <div style={{ display: 'flex', flexWrap: 'wrap', gap: '8px' }}>
                                            {relevantBoxes.map((box, bIdx) => {
                                                const isCheck = localAssignedIds.has(box.setId);
                                                const isSuggested = suggestions[box.setId]?.includes(playId);
                                                // Determine active color based on box config or fallbacks
                                                const activeBorderColor = box.color || '#3b82f6';

                                                return (
                                                    <button
                                                        key={bIdx}
                                                        onClick={() => {
                                                            if (onSuggest) {
                                                                // Suggest mode: toggle suggestion
                                                                onSuggest(playId, box.setId);
                                                            } else {
                                                                handleSituationClick(box);
                                                            }
                                                        }}
                                                        style={{
                                                            padding: '6px 10px',
                                                            borderRadius: '6px',
                                                            cursor: 'pointer',
                                                            fontSize: '0.8rem',
                                                            fontWeight: isCheck || isSuggested ? '600' : '500',
                                                            border: isSuggested ? '2px solid #ef4444' : isCheck ? `2px solid ${activeBorderColor}` : '1px solid #e2e8f0',
                                                            background: isSuggested ? '#fef2f2' : isCheck ? `${activeBorderColor}15` : 'white',
                                                            color: isSuggested ? '#ef4444' : isCheck ? activeBorderColor : '#64748b',
                                                            boxShadow: isCheck ? `0 0 0 1px ${activeBorderColor}40` : 'none',
                                                            transition: 'all 0.15s ease',
                                                            position: 'relative',
                                                            overflow: 'hidden'
                                                        }}
                                                    >
                                                        {isSuggested && (
                                                            <div style={{
                                                                position: 'absolute', left: 0, top: 0, bottom: 0, width: '4px',
                                                                background: '#ef4444'
                                                            }} />
                                                        )}
                                                        {isCheck && !isSuggested && (
                                                            <div style={{
                                                                position: 'absolute', left: 0, top: 0, bottom: 0, width: '4px',
                                                                background: activeBorderColor
                                                            }} />
                                                        )}
                                                        {box.header}
                                                        {isSuggested && <span style={{ marginLeft: '4px', fontSize: '0.7rem' }}>★</span>}
                                                    </button>
                                                );
                                            })}
                                        </div>
                                    </div>
                                );
                            })}
                        </div >
                    </div >
                </div >
            );
        };

        const checkRedundantFormation = (playName, formationName) => {
            if (!playName || !formationName) return false;
            const pName = playName.toLowerCase();
            const fName = formationName.toLowerCase();

            // 1. Direct Check
            if (pName.includes(fName)) return true;

            // 2. Abbreviation Check
            const abbreviations = {
                'green': 'grn',
                'orange': 'orng',
                'yellow': 'ylw',
                'blue': 'blu',
                'gold': 'gld',
                'black': 'blk',
                'white': 'wht',
                'brown': 'brn',
                'right': 'rt',
                'left': 'lt'
            };

            let normalizedFormation = fName;
            Object.keys(abbreviations).forEach(full => {
                normalizedFormation = normalizedFormation.replace(new RegExp(full, 'g'), abbreviations[full]);
            });

            if (pName.includes(normalizedFormation)) return true;

            return false;
        };

        // Helper to format wristband slot labels
        const getWristbandLabel = (play) => {
            if (!play.wristbandSlot) return '';
            return play.wristbandSlot + (play.isMiniScript || play.isWiz ? '' : 'T');
        };

        const WristbandBuilder = ({ plays, weeks, currentWeek, gamePlan, onUpdatePlay, onUpdateWeek, wbSettings, setWbSettings, onNavigate, installList = [], seasonOpponent, playCategories = [], onQuickAddPlay, formations = [], onAddFormation, wizLibrary = [], setWizLibrary, positionNames = {}, positionColors = {}, passProtections = [], setPassProtections, runBlocking = [], setRunBlocking, addToNextSlotRef }) => {
            const { currentUser } = useAuth();
            const [selectedCardId, setSelectedCardId] = useState('card1'); // Default to Card 1
            const [sidebarMode, setSidebarMode] = useState('plays'); // 'plays' or 'scripts'
            const [selectedPlayId, setSelectedPlayId] = useState(null);
            const [searchTerm, setSearchTerm] = useState('');
            const [confirmModal, setConfirmModal] = useState(null); // { action: 'wb1'|'wb2'|'both', message: string }
            const [quickAddSlot, setQuickAddSlot] = useState(null);
            const [quickAddValue, setQuickAddValue] = useState('');
            const [quickAddSuggestions, setQuickAddSuggestions] = useState([]);
            const [selectedDay, setSelectedDay] = useState('Monday');
            const [staplesInputs, setStaplesInputs] = useState({}); // Track input values for Staples slots

            // WIZ diagram editing state
            const [editingWizPlay, setEditingWizPlay] = useState(null); // Play being edited
            const [editingWizType, setEditingWizType] = useState(null); // 'skill' or 'oline'

            // Layout constants
            const rowHeight = 11;
            const fontSize = 0.55;

            // Header customization helpers
            const updateCard = (cardId, updates) => {
                setWbSettings(prev => ({
                    ...prev,
                    [cardId]: { ...prev[cardId], ...updates }
                }));
            };

            // Migration effect: Convert old flat settings to new nested structure
            useEffect(() => {
                if (!wbSettings.card1) {
                    // It's the old structure or empty
                    const newWb = {
                        card1: { type: 'standard', opp: wbSettings.wb1Opp || '', iter: wbSettings.wb1Iter || '1', rows: [] },
                        card2: { type: 'standard', opp: wbSettings.wb2Opp || '', iter: wbSettings.wb2Iter || '1', rows: [] },
                        card3: { type: 'standard', opp: '', iter: '1', rows: [] },
                        card4: { type: 'standard', opp: '', iter: '1', rows: [] },
                        card5: { type: 'standard', opp: '', iter: '1', rows: [] },
                        card6: { type: 'standard', opp: '', iter: '1', rows: [] },
                        version: 'v3'
                    };
                    setWbSettings(newWb);
                } else if (!wbSettings.card4) {
                    // Migrate from v2 to v3 (add new cards)
                    setWbSettings(prev => ({
                        ...prev,
                        card4: { type: 'standard', opp: '', iter: '1', rows: [] },
                        card5: { type: 'standard', opp: '', iter: '1', rows: [] },
                        card6: { type: 'standard', opp: '', iter: '1', rows: [] },
                        version: 'v3'
                    }));
                } else {
                    // Check for old 'modular' type and auto-migrate to 'mini-scripts'
                    let hasMigration = false;
                    const updates = {};
                    ['card1', 'card2', 'card3', 'card4', 'card5', 'card6'].forEach(cardKey => {
                        const card = wbSettings[cardKey];
                        if (card && card.type === 'modular' && card.rows && !card.version) {
                            // If it has 'rows' and NO version (legacy), migrate to mini-scripts
                            updates[cardKey] = { ...card, type: 'mini-scripts', version: 'v1' };
                            hasMigration = true;
                        }
                    });

                    if (hasMigration) {
                        setWbSettings(prev => ({ ...prev, ...updates }));
                    }
                }
            }, []);

            // Auto-sync to Firestore (debounced or just when changed)
            // REMOVED: Now handled by 'weeks' sync in App component
            // useEffect(() => {
            //     if (currentUser && (wbSettings.version === 'v2' || wbSettings.version === 'v3')) {
            //         syncToFirestore(currentUser.uid, 'wbSettings', wbSettings);
            //     }
            // }, [wbSettings, currentUser]);

            // Quick add state

            // Filter plays for the sidebar list
            const filteredPlays = useMemo(() => {
                // 1. Filter
                const filtered = plays.filter(p =>
                    p.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    p.formation.toLowerCase().includes(searchTerm.toLowerCase())
                );

                // 2. Sort: Priority > Install > Rest
                return filtered.sort((a, b) => {
                    // Tier 1: Priority (Stars)
                    if (a.priority && !b.priority) return -1;
                    if (!a.priority && b.priority) return 1;

                    // Tier 2: Install List (if priorities are equal)
                    // Only check this if both are NOT priority (or both ARE priority, but usually priority > install)
                    if (!a.priority && !b.priority) {
                        const aInstalled = installList.includes(a.id);
                        const bInstalled = installList.includes(b.id);
                        if (aInstalled && !bInstalled) return -1;
                        if (!aInstalled && bInstalled) return 1;
                    }

                    // Tier 3: Alphabetical Name
                    return a.name.localeCompare(b.name);
                });
            }, [plays, searchTerm, installList]);

            // Group plays by slot for easy lookup
            const slotMap = useMemo(() => {
                const map = {};
                plays.forEach(p => {
                    if (p.wristbandSlot) map[p.wristbandSlot] = p;
                    if (p.staplesSlot) map[p.staplesSlot] = p;
                });
                return map;
            }, [plays]);

            // Initialize Staples inputs based on current play assignments
            useEffect(() => {
                const inputs = {};
                for (let slot = 10; slot <= 89; slot++) {
                    const play = slotMap[slot];
                    if (play) {
                        inputs[slot] = getPlaySignature(play);
                    }
                }
                setStaplesInputs(inputs);
            }, [slotMap]);

            // Auto-cleanup Ghost Assignments (Wiz/Mini-Scripts overflow)
            useEffect(() => {
                if (!wbSettings || !selectedCardId) return;

                const card = wbSettings[selectedCardId];
                if (!card) return;

                let startSlot = 0;
                if (selectedCardId === 'card1') startSlot = 101;
                else if (selectedCardId === 'card2') startSlot = 201;
                else if (selectedCardId === 'card3') startSlot = 301;
                else if (selectedCardId === 'card4') startSlot = 401;
                else if (selectedCardId === 'card5') startSlot = 501;
                else if (selectedCardId === 'card6') startSlot = 601;

                if (startSlot === 0) return;

                const updates = [];

                if (card.type === 'wiz') {
                    const maxWiz = startSlot + 15;
                    const maxStandard = startSlot + 47; // Standard 48 slots

                    // Identify ghosts: plays assigned to > maxWiz but within standard range
                    plays.forEach(p => {
                        if (!p.wristbandSlot) return;
                        const slotStr = p.wristbandSlot.toString();
                        const slot = parseInt(slotStr, 10);

                        if (slot > maxWiz && slot <= maxStandard) {
                            updates.push({ ...p, wristbandSlot: '' });
                        }
                    });

                } else if (card.type === 'mini-scripts') {
                    const minStandard = startSlot;
                    const maxStandard = startSlot + 99; // Wide net

                    // Identify ghosts: plays assigned to numeric slots (Traditional) when in Mini-Scripts
                    plays.forEach(p => {
                        if (!p.wristbandSlot) return;
                        const slotStr = p.wristbandSlot.toString();

                        // If it's pure number, it's a Traditional ghost in Mini-Scripts land
                        // Mini-Scripts use "101A", "101B"
                        if (/^\d+$/.test(slotStr)) {
                            const slot = parseInt(slotStr, 10);
                            if (slot >= minStandard && slot <= maxStandard) {
                                updates.push({ ...p, wristbandSlot: '' });
                            }
                        }
                    });
                }

                if (updates.length > 0) {
                    // Use setTimeout to avoid render-cycle conflicts if immediate
                    setTimeout(() => onUpdatePlay(updates), 0);
                }
            }, [wbSettings, selectedCardId, plays]); // Dependency on plays ensures we re-check if data loads later


            // Sync Mini-Script assignments (101A/101B)
            useEffect(() => {
                // Prevent running if no plays or settings
                if (!plays || plays.length === 0 || !wbSettings) return;

                const newAssignments = new Map(); // playId -> slot string

                ['card1', 'card2', 'card3', 'card4', 'card5', 'card6'].forEach(cardId => {
                    const card = wbSettings[cardId];
                    if (card && card.type === 'mini-scripts' && card.rows) {
                        const startCoord = cardId === 'card1' ? 101 : (cardId === 'card2' ? 201 : (cardId === 'card3' ? 301 : (cardId === 'card4' ? 401 : (cardId === 'card5' ? 501 : 601))));
                        let currentCoord = startCoord;

                        card.rows.forEach(row => {
                            if (row.type !== 'header') {
                                const coord = currentCoord++;

                                // Slot A (Play 1)
                                if (row.col1Id) {
                                    newAssignments.set(row.col1Id, `${coord}A`);
                                } else if (row.col1) {
                                    // Try find by name
                                    const p = plays.find(pl => pl.name === row.col1);
                                    if (p) newAssignments.set(p.id, `${coord}A`);
                                }

                                // Slot B (Play 2)
                                if (row.col3Id) {
                                    newAssignments.set(row.col3Id, `${coord}B`);
                                } else if (row.col3) {
                                    // Try find by name
                                    const p = plays.find(pl => pl.name === row.col3);
                                    if (p) newAssignments.set(p.id, `${coord}B`);
                                }
                            }
                        });
                    }
                });

                // Calculate updates to plays
                const updates = [];
                plays.forEach(p => {
                    const target = newAssignments.get(p.id);
                    const current = p.wristbandSlot;

                    if (target) {
                        if (current !== target) {
                            updates.push({ ...p, wristbandSlot: target });
                        }
                    } else {
                        // If Play has a Mini-Script slot (digits + A/B) but is no longer mapped, clear it.
                        // Explicitly check for A/B suffix to avoid clearing standard wristband slots (integers)
                        if (current && /^\d+[AB]$/.test(current)) {
                            updates.push({ ...p, wristbandSlot: '' });
                        }
                    }
                });

                if (updates.length > 0) {
                    onUpdatePlay(updates);
                }

            }, [wbSettings, plays]);


            // Helper to match Staples concept + color
            const getPlaySignature = (p) => {
                if (!p.name) return '';

                let s = p.name.trim();
                const form = (p.formation || '').trim();

                // 1. Strip structural formations from start
                // We define "Structural" as anything not in the usual color list
                const colors = ['RED', 'BLUE', 'GRN', 'GREEN', 'BRIGHT', 'BRT', 'ORNG', 'ORANGE', 'GOLD', 'BRN', 'BROWN', 'TEAL', 'PINK', 'PURPLE', 'YELLOW'];
                const isColorFormation = colors.includes(form.toUpperCase());

                if (form && !isColorFormation) {
                    // Case-insensitive strip from start
                    const regex = new RegExp('^' + form.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\s+', 'i');
                    s = s.replace(regex, '');
                }

                // 2. Strip explicit tags if they are in the tags array
                if (p.tags && p.tags.length > 0) {
                    p.tags.forEach(tag => {
                        if (tag) {
                            // Strip tag as a word everywhere
                            const regex = new RegExp('\\b' + tag.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'gi');
                            s = s.replace(regex, '');
                        }
                    });
                }

                // 3. Final cleanup: strip common non-concept chars but keep + for variations
                // We keep + because the user specifically said "+ TRIBE" should stay distinct.
                return s.replace(/\s+/g, ' ').replace(/\*$/, '').trim();
            };

            const assignPlayToSlot = (play, slot, cardId) => {
                const card = wbSettings[cardId];
                if (!card) return;

                const isWiz = card.layout === 'wiz';
                const isMiniScript = card.layout === 'mini-scripts';

                if (card.type === 'staples') {
                    const signature = getPlaySignature(play);
                    const matchingPlays = plays.filter(p => getPlaySignature(p) === signature);
                    const updates = matchingPlays.map(p => ({
                        ...p,
                        staplesSlot: slot.toString(),
                    }));
                    onUpdatePlay(updates);
                } else {
                    onUpdatePlay({
                        ...play,
                        wristbandSlot: slot.toString(),
                        isWiz: isWiz,
                        isMiniScript: isMiniScript,
                        isWiz: false
                    });
                }
            };

            const handleAutoAssign = (play) => {
                const card = wbSettings[selectedCardId];
                if (!card) return;

                let availableSlot = null;
                if (card.type === 'staples') {
                    for (let i = 10; i <= 89; i++) {
                        if (!slotMap[i]) {
                            availableSlot = i;
                            break;
                        }
                    }
                } else {
                    const startSlot = selectedCardId === 'card1' ? 101 : (selectedCardId === 'card2' ? 201 : (selectedCardId === 'card3' ? 301 : (selectedCardId === 'card4' ? 401 : (selectedCardId === 'card5' ? 501 : 601))));
                    const maxSlots = (card.layout === 'wiz') ? 16 : 48;
                    for (let i = 0; i < maxSlots; i++) {
                        const slot = startSlot + i;
                        if (!slotMap[slot]) {
                            availableSlot = slot;
                            break;
                        }
                    }
                }

                if (availableSlot) {
                    assignPlayToSlot(play, availableSlot, selectedCardId);
                }
            };

            // Register "add to next slot" handler for sidebar
            useEffect(() => {
                if (addToNextSlotRef) {
                    addToNextSlotRef.current = (playId, play) => {
                        if (play) {
                            handleAutoAssign(play);
                        } else {
                            const foundPlay = plays.find(p => p.id === playId);
                            if (foundPlay) {
                                handleAutoAssign(foundPlay);
                            }
                        }
                    };
                }
                return () => {
                    if (addToNextSlotRef) addToNextSlotRef.current = null;
                };
            }, [addToNextSlotRef, plays, wbSettings, selectedCardId, slotMap]);

            const handleAssignSlot = (slot) => {
                if (!selectedPlayId) return;
                const play = plays.find(p => p.id === selectedPlayId);
                if (play) {
                    assignPlayToSlot(play, slot, selectedCardId);
                    setSelectedPlayId(null);
                }
            };

            const handleUpdateRow = (cardId, rowId, updates) => {
                const card = wbSettings[cardId];
                const newRows = card.rows.map(r => r.id === rowId ? { ...r, ...updates } : r);
                updateCard(cardId, { rows: newRows });
            };

            const handleRemoveRow = (cardId, rowId) => {
                const card = wbSettings[cardId];
                const newRows = card.rows.filter(r => r.id !== rowId);
                updateCard(cardId, { rows: newRows });
            };

            const handleMoveRow = (cardId, rowId, direction) => {
                const card = wbSettings[cardId];
                const index = card.rows.findIndex(r => r.id === rowId);
                if (index === -1) return;
                const newIndex = index + direction;
                if (newIndex < 0 || newIndex >= card.rows.length) return;

                const newRows = [...card.rows];
                const [moved] = newRows.splice(index, 1);
                newRows.splice(newIndex, 0, moved);
                updateCard(cardId, { rows: newRows });
            };

            const handleAddPlayRow = (cardId, play) => {
                const card = wbSettings[cardId];
                const newRow = {
                    id: Date.now().toString(),
                    type: 'play-row',
                    col1: play.name,
                    col2: '',
                    col3: ''
                };
                updateCard(cardId, { rows: [...card.rows, newRow] });
            };

            const handleAddScriptRows = (cardId, miniScript) => {
                const card = wbSettings[cardId];
                const newRows = (miniScript.playIds || []).map(playId => ({
                    id: `row_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    type: 'play',
                    playId: playId,
                    playName: plays.find(p => p.id === playId)?.name || 'Unknown'
                }));
                updateCard(cardId, { rows: [...card.rows, ...newRows] });
            };

            const handleAddTempoRow = (cardId, tempoType) => {
                const card = wbSettings[cardId];
                const protocol = CALENDAR_CONSTANTS.PRACTICE_TEMPO_PROTOCOLS.find(p => p.id === tempoType);
                const newRow = {
                    id: `row_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    type: 'tempo',
                    tempoType: tempoType,
                    label: protocol ? protocol.code : tempoType
                };
                updateCard(cardId, { rows: [...card.rows, newRow] });
            };

            const handleAddHeaderRow = (cardId) => {
                const card = wbSettings[cardId];
                if (!card) return;

                const timestamp = Date.now();
                const newHeader = {
                    id: timestamp.toString(),
                    type: 'header',
                    label: '',
                    color: 'gray'
                };

                const newPlayRow = {
                    id: `row_${timestamp + 1}_${Math.random().toString(36).substr(2, 9)}`,
                    type: 'play-row',
                    col0: '',
                    col1: '',
                    col2: '',
                    col3: ''
                };

                updateCard(cardId, { rows: [...card.rows, newHeader, newPlayRow] });
            };

            const handleLayoutChange = (newType) => {
                let startSlot = 0;
                if (selectedCardId === 'card1') startSlot = 101;
                else if (selectedCardId === 'card2') startSlot = 201;
                else if (selectedCardId === 'card3') startSlot = 301;
                else if (selectedCardId === 'card4') startSlot = 401;
                else if (selectedCardId === 'card5') startSlot = 501;
                else if (selectedCardId === 'card6') startSlot = 601;

                const updates = [];

                // Unified Layout Change Logic
                updateCard(selectedCardId, { layout: newType, type: newType });

                if (startSlot > 0) {
                    const isWiz = newType === 'wiz';
                    const isMini = newType === 'mini-scripts';
                    const isWizType = newType === 'wiz';
                    const cardMin = startSlot;
                    const cardMax = startSlot + 99;
                    const wizMax = startSlot + 15;

                    const updatesToApply = [];

                    plays.forEach(p => {
                        const slot = parseInt(p.wristbandSlot || 0);
                        if (slot >= cardMin && slot <= cardMax) {
                            let update = { ...p };
                            let changed = false;

                            // 1. Update Layout Flags
                            if (p.isWiz !== isWiz || p.isMiniScript !== isMini || (isWizType && !p.isWiz)) {
                                update.isWiz = isWiz || isWizType;
                                update.isMiniScript = isMini;
                                changed = true;
                            }

                            // 2. Clear Out-of-Bounds (for 16-slot grids)
                            if (isWizType && slot > wizMax) {
                                update.wristbandSlot = '';
                                changed = true;
                            }

                            if (changed) updatesToApply.push(update);
                        }
                    });

                    if (updatesToApply.length > 0) {
                        onUpdatePlay(updatesToApply);
                    }
                }
            };


            const handleClearCard = (cardId) => {
                const cardName = cardId === 'card1' ? 'WB1 (100s)' : (cardId === 'card2' ? 'WB2 (200s)' : (cardId === 'card3' ? 'WB3 (300s)' : (cardId === 'card4' ? 'WB4 (400s)' : (cardId === 'card5' ? 'WB5 (500s)' : (cardId === 'card6' ? 'WB6 (600s)' : 'STAPLES')))));
                setConfirmModal({
                    action: cardId,
                    message: `Clear all plays from ${cardName}? This cannot be undone.`
                });
            };

            const handleClearBoth = () => {
                setConfirmModal({
                    action: 'all',
                    message: 'Clear ALL wristband assignments? This cannot be undone.'
                });
            };

            const confirmClear = () => {
                if (!confirmModal) return;

                const updates = [];

                if (confirmModal.action === 'all') {
                    // Clear all play linkings
                    plays.forEach(play => {
                        let needsUpdate = false;
                        const update = { ...play };
                        if (play.wristbandSlot) {
                            update.wristbandSlot = '';
                            needsUpdate = true;
                        }
                        if (play.staplesSlot) {
                            update.staplesSlot = '';
                            needsUpdate = true;
                        }
                        if (needsUpdate) updates.push(update);
                    });

                    // Clear all modular rows
                    setWbSettings(prev => ({
                        card1: { ...prev.card1, rows: [] },
                        card2: { ...prev.card2, rows: [] },
                        card3: { ...prev.card3, rows: [] },
                        card4: { ...prev.card4, rows: [] },
                        card5: { ...prev.card5, rows: [] },
                        card6: { ...prev.card6, rows: [] }
                    }));
                } else {
                    const cardId = confirmModal.action;
                    const card = wbSettings[cardId];

                    if (card && card.type === 'staples') {
                        // Clear Staples (10-89)
                        plays.forEach(play => {
                            if (play.staplesSlot) {
                                const slot = parseInt(play.staplesSlot, 10);
                                if (!isNaN(slot) && slot >= 10 && slot <= 89) {
                                    updates.push({ ...play, staplesSlot: '' });
                                }
                            }
                        });
                    } else {
                        // Standard Clear (works for Standard, Wiz, Mini-Scripts if they use slots)
                        const start = cardId === 'card1' ? 101 : (cardId === 'card2' ? 201 : (cardId === 'card3' ? 301 : (cardId === 'card4' ? 401 : (cardId === 'card5' ? 501 : 601))));
                        const end = start + 99; // Allow for wider range (e.g. up to 199) to catch A/B slots if parsed as int

                        plays.forEach(play => {
                            if (play.wristbandSlot) {
                                const slot = parseInt(play.wristbandSlot, 10);
                                // Check if slot matches the card range (e.g. 101-199)
                                if (!isNaN(slot) && slot >= start && slot < start + 100) {
                                    updates.push({ ...play, wristbandSlot: '' });
                                }
                            }
                        });
                    }

                    updateCard(cardId, { rows: [] });
                }

                if (updates.length > 0) {
                    onUpdatePlay(updates);
                }

                setConfirmModal(null);
            };

            const cancelClear = () => {
                setConfirmModal(null);
            };

            // Quick Add Functions
            const handleQuickAddStart = (slot) => {
                setQuickAddSlot(slot);
                setQuickAddValue('');
                setQuickAddSuggestions([]);
                setSelectedPlayId(null); // Clear any selected play
            };

            const handleQuickAddChange = (value) => {
                setQuickAddValue(value.toUpperCase());
                // Filter plays for autocomplete
                if (value.trim()) {
                    const suggestions = plays.filter(p =>
                        p.name.toLowerCase().includes(value.toLowerCase())
                    ).slice(0, 5);
                    setQuickAddSuggestions(suggestions);
                } else {
                    setQuickAddSuggestions([]);
                }
            };

            const handleQuickAddSubmit = (slot) => {
                if (!quickAddValue.trim()) return;

                // Check if play exists (case-insensitive exact match)
                const existingPlay = plays.find(p =>
                    p.name.toLowerCase() === quickAddValue.trim().toLowerCase()
                );

                if (existingPlay) {
                    // Link to existing play
                    onUpdatePlay({ ...existingPlay, wristbandSlot: slot.toString() });
                } else {
                    // Create minimal new play
                    const newPlay = {
                        id: `play_${Date.now()}`,
                        name: quickAddValue.trim(),
                        formation: '',
                        tags: [],
                        wristbandSlot: slot.toString(),
                        diagramData: null,
                        personnel: '',
                        concept: '',
                        notes: '',
                        incomplete: true // Mark as incomplete so user can upgrade later
                    };
                    onUpdatePlay(newPlay); // This will add to plays array
                }

                setQuickAddSlot(null);
                setQuickAddValue('');
                setQuickAddSuggestions([]);
            };

            const handleQuickAddSelectSuggestion = (play, slot) => {
                // User clicked autocomplete suggestion
                onUpdatePlay({ ...play, wristbandSlot: slot.toString() });
                setQuickAddSlot(null);
                setQuickAddValue('');
                setQuickAddSuggestions([]);
            };

            const handleQuickAddCancel = () => {
                setQuickAddSlot(null);
                setQuickAddValue('');
                setQuickAddSuggestions([]);
            };

            // Staples Input Handlers
            const handleStaplesInputChange = (slot, value) => {
                setStaplesInputs(prev => ({ ...prev, [slot]: value }));
            };

            const handleStaplesInputBlur = (slot) => {
                const inputValue = (staplesInputs[slot] || '').trim().toUpperCase();

                if (!inputValue) {
                    // Clear the slot if input is empty
                    const playsToUpdate = plays.filter(p => p.staplesSlot === slot.toString());
                    if (playsToUpdate.length > 0) {
                        const updates = playsToUpdate.map(p => ({ ...p, staplesSlot: '' }));
                        onUpdatePlay(updates);
                    }
                    return;
                }

                // Find all plays that match this signature (excluding formation)
                const matchingPlays = plays.filter(p => {
                    const playSignature = getPlaySignature(p).toUpperCase();
                    return playSignature === inputValue;
                });

                if (matchingPlays.length > 0) {
                    // Update all matching plays
                    const updates = matchingPlays.map(p => ({
                        ...p,
                        staplesSlot: slot.toString()
                    }));
                    onUpdatePlay(updates);
                } else {
                    // No matches found - optionally show warning
                    console.warn(`No plays found matching signature: ${inputValue}`);
                }
            };

            const handleStaplesInputKeyDown = (e, slot) => {
                if (e.key === 'Enter') {
                    e.target.blur(); // Trigger blur handler
                }
            };


            // Generate slots for tables
            const slots100 = [];
            const slots200 = [];
            for (let i = 101; i <= 148; i++) slots100.push(i);
            for (let i = 201; i <= 248; i++) slots200.push(i);


            const renderSpreadsheetTable = (slots, rangeClass, cardId, title = '') => {
                const card = wbSettings[cardId];
                if (!card) return null;
                const isMiniScripts = card.type === 'mini-scripts';


                // Determine row source
                let displayRows = [];
                if (isMiniScripts) {
                    // Mini-Scripts uses the sequence of rows defined in the card
                    displayRows = card.rows.map((row, idx) => {
                        if (row.type === 'play') {
                            const play = plays.find(p => p.id === row.playId);
                            const playName = row.playName || play?.name || 'Unknown';
                            const wristbandSlot = play?.wristbandSlot || '';
                            const displayText = wristbandSlot ? `[${wristbandSlot}] ${playName}` : playName;
                            return {
                                slot: slots[0] + idx, // This linear slot might not match the 3-column grouping perfectly if we just use idx, but it's consistent with existing logic. 
                                // Actually for 3-col grouping (A/B/C), if rows are linear, we chunk them.
                                type: row.type,
                                text: displayText,
                                playId: row.playId,
                                rowId: row.id
                            };
                        } else {
                            return {
                                slot: slots[0] + idx,
                                type: row.type,
                                text: row.label,
                                playId: row.playId,
                                rowId: row.id
                            };
                        }
                    });
                } else {
                    // Standard uses the absolute slots
                    displayRows = slots.map(slot => {
                        const play = slotMap[slot];
                        return {
                            slot: slot,
                            type: 'play',
                            text: play ? `${play.name}${play.formation && !checkRedundantFormation(play.name, play.formation) ? ' - ' + play.formation : ''}` : '',
                            play: play
                        };
                    });
                }

                if (isMiniScripts) {
                    // ---------------------------------------------------------
                    // MINI-SCRIPTS LAYOUT: 1 Coord Column + 3 Play Columns
                    // ---------------------------------------------------------

                    // Calculate start index for coord if not provided
                    // Calculate start index for coord if not provided
                    const startCoord = cardId === 'card1' ? 101 : (cardId === 'card2' ? 201 : (cardId === 'card3' ? 301 : (cardId === 'card4' ? 401 : (cardId === 'card5' ? 501 : 601))));
                    let currentCoord = startCoord;

                    return (
                        <div style={{ width: '100%', height: '100%', display: 'flex', flexDirection: 'column', border: '2px solid black' }}>
                            {/* Header */}
                            <div style={{
                                background: 'black',
                                color: 'white',
                                fontWeight: 'bold',
                                fontSize: '10pt',
                                padding: '2px 4px',
                                display: 'flex',
                                justifyContent: 'space-between',
                                alignItems: 'center'
                            }}>
                                <span style={{ textTransform: 'uppercase' }}>SCRIPT</span>
                                <span>{title}</span>
                            </div>

                            {/* Table */}
                            <div style={{ flex: 1, overflow: 'hidden' }}>
                                <table className="wristband-spreadsheet-table" style={{ width: '100%', tableLayout: 'fixed', borderCollapse: 'collapse' }}>
                                    <colgroup>
                                        <col style={{ width: '38px' }} />
                                        <col style={{ width: '45px' }} />
                                        <col style={{ width: 'auto' }} />
                                        <col style={{ width: '45px' }} />
                                        <col style={{ width: 'auto' }} />
                                    </colgroup>
                                    <thead>
                                        <tr style={{ background: '#e5e5e5', fontSize: '8pt', fontWeight: 'bold', textAlign: 'center', height: 'auto' }}>
                                            <th style={{ borderBottom: '1px solid #000', borderRight: '1px solid #000', padding: 0, textAlign: 'center' }}>#</th>
                                            <th style={{ borderBottom: '1px solid #000', borderRight: '1px solid #000', padding: 0, textAlign: 'center' }}>TEMPO</th>
                                            <th style={{ borderBottom: '1px solid #000', borderRight: '1px solid #000', padding: 0, textAlign: 'center' }}>PLAY A</th>
                                            <th style={{ borderBottom: '1px solid #000', borderRight: '1px solid #000', padding: 0, textAlign: 'center' }}>TEMPO</th>
                                            <th style={{ borderBottom: '1px solid #000', padding: 0, textAlign: 'center' }}>PLAY B</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {card.rows && card.rows.map((row, rowIndex) => {
                                            if (row.type === 'header') {
                                                // Header Row
                                                const bg = row.color === 'black' ? '#000' :
                                                    row.color === 'red' ? '#ef4444' :
                                                        row.color === 'blue' ? '#3b82f6' :
                                                            row.color === 'green' ? '#22c55e' :
                                                                row.color === 'orange' ? '#f97316' : '#d1d5db';
                                                const fg = row.color === 'black' || row.color === 'blue' || row.color === 'red' ? '#fff' : '#000';

                                                return (
                                                    <tr key={row.id}>
                                                        <td colSpan="5" style={{
                                                            background: bg,
                                                            color: fg,
                                                            fontWeight: 'bold',
                                                            textAlign: 'center',
                                                            padding: '2px 8px',
                                                            border: '1px solid #333',
                                                            fontSize: `${fontSize}rem`
                                                        }}>
                                                            {row.label}
                                                        </td>
                                                    </tr>
                                                );
                                            } else {
                                                // Play Row
                                                const thisCoord = currentCoord++;

                                                // Determine background shade
                                                let rowBackground = 'inherit';
                                                const effectiveColor = row.color || (card && card.color) || 'none';

                                                if (effectiveColor && effectiveColor !== 'none') {
                                                    const shades = ['light', 'medium'];
                                                    const shade = shades[rowIndex % 2]; // Use rowIndex for alternating colors
                                                    const colorMap = {
                                                        'green-light': '#d1fae5', 'green-medium': '#a7f3d0',
                                                        'orange-light': '#fed7aa', 'orange-medium': '#fdba74',
                                                        'red-light': '#fecaca', 'red-medium': '#fca5a5',
                                                        'blue-light': '#bfdbfe', 'blue-medium': '#93c5fd',
                                                        'yellow-light': '#fef08a', 'yellow-medium': '#fde047',
                                                        'purple-light': '#e9d5ff', 'purple-medium': '#d8b4fe',
                                                        'teal-light': '#99f6e4', 'teal-medium': '#5eead4',
                                                        'pink-light': '#fbcfe8', 'pink-medium': '#f9a8d4'
                                                    };
                                                    rowBackground = colorMap[`${effectiveColor}-${shade}`] || 'inherit';
                                                }

                                                return (
                                                    <tr key={row.id} style={{ height: `${rowHeight}px` }}>
                                                        {/* Coord */}
                                                        <td style={{
                                                            border: '1px solid #333',
                                                            textAlign: 'center',
                                                            fontWeight: 'bold',
                                                            fontSize: `${fontSize}rem`,
                                                            background: rowBackground
                                                        }}>
                                                            {thisCoord}
                                                        </td>
                                                        {/* Tempo Left */}
                                                        <td style={{
                                                            border: '1px solid #333',
                                                            padding: '0 2px',
                                                            fontSize: `${fontSize}rem`,
                                                            verticalAlign: 'middle',
                                                            overflow: 'hidden',
                                                            whiteSpace: 'nowrap',
                                                            textOverflow: 'ellipsis',
                                                            fontWeight: 'bold',
                                                            textAlign: 'center',
                                                            background: '#ffedd5'
                                                        }}>
                                                            {row.col0}
                                                        </td>
                                                        {/* Play 1 */}
                                                        <td style={{
                                                            border: '1px solid #333',
                                                            padding: '0 2px',
                                                            fontSize: `${fontSize}rem`,
                                                            verticalAlign: 'middle',
                                                            overflow: 'hidden',
                                                            whiteSpace: 'nowrap',
                                                            textOverflow: 'ellipsis',
                                                            background: rowBackground
                                                        }}>
                                                            {row.col1}
                                                        </td>
                                                        {/* Tempo */}
                                                        <td style={{
                                                            border: '1px solid #333',
                                                            padding: '0 2px',
                                                            fontSize: `${fontSize}rem`,
                                                            verticalAlign: 'middle',
                                                            overflow: 'hidden',
                                                            whiteSpace: 'nowrap',
                                                            textOverflow: 'ellipsis',
                                                            fontWeight: 'bold',
                                                            textAlign: 'center',
                                                            background: '#ffedd5' // Always light orange for tempo? Or maybe just inherit? Keeping tempo distinct is usually good.
                                                        }}>
                                                            {row.col2}
                                                        </td>
                                                        {/* Play 2 */}
                                                        <td style={{
                                                            border: '1px solid #333',
                                                            padding: '0 2px',
                                                            fontSize: `${fontSize}rem`,
                                                            verticalAlign: 'middle',
                                                            overflow: 'hidden',
                                                            whiteSpace: 'nowrap',
                                                            textOverflow: 'ellipsis',
                                                            background: rowBackground
                                                        }}>
                                                            {row.col3}
                                                        </td>
                                                    </tr>
                                                );
                                            }
                                        })}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    );
                }

                // ---------------------------------------------------------

                if (card && card.type === 'staples') {
                    // STAPLES LAYOUT: 4 Columns x 20 Rows (Slots 10-89)
                    // Col 1: 10-29
                    // Col 2: 30-49
                    // Col 3: 50-69
                    // Col 4: 70-89

                    const col1 = displayRows.slice(0, 20);
                    const col2 = displayRows.slice(20, 40);
                    const col3 = displayRows.slice(40, 60);
                    const col4 = displayRows.slice(60, 80);

                    // Create 20 rows
                    const tableRows = [];
                    for (let i = 0; i < 20; i++) {
                        tableRows.push([
                            col1[i] || null,
                            col2[i] || null,
                            col3[i] || null,
                            col4[i] || null
                        ]);
                    }

                    return (
                        <div style={{ width: '100%', height: '100%', display: 'flex', flexDirection: 'column', border: '2px solid black' }}>
                            {/* Header */}
                            <div style={{
                                background: 'black',
                                color: 'white',
                                fontWeight: 'bold',
                                fontSize: '10pt',
                                padding: '2px 4px',
                                display: 'flex',
                                justifyContent: 'space-between',
                                alignItems: 'center'
                            }}>
                                <span style={{ textTransform: 'uppercase' }}>STAPLES</span>
                                <span>{title}</span>
                            </div>

                            {/* Table */}
                            <div style={{ flex: 1, overflow: 'hidden' }}>
                                <table className="wristband-spreadsheet-table" style={{ width: '100%', tableLayout: 'fixed', borderCollapse: 'collapse' }}>
                                    {/* 4 sets of (Coord + Play) columns */}
                                    <colgroup>
                                        <col style={{ width: '30px' }} />
                                        <col style={{ width: '22%' }} />
                                        <col style={{ width: '30px' }} />
                                        <col style={{ width: '22%' }} />
                                        <col style={{ width: '30px' }} />
                                        <col style={{ width: '22%' }} />
                                        <col style={{ width: '30px' }} />
                                        <col style={{ width: '22%' }} />
                                    </colgroup>
                                    <tbody>
                                        {tableRows.map((rowGroup, rowIndex) => {
                                            // Calculate color background
                                            let cellBackground = 'inherit';
                                            if (card && card.color && card.color !== 'none') {
                                                const shades = ['light', 'medium'];
                                                const shade = shades[rowIndex % 2];
                                                const colorMap = {
                                                    'green-light': '#d1fae5', 'green-medium': '#a7f3d0',
                                                    'orange-light': '#fed7aa', 'orange-medium': '#fdba74',
                                                    'red-light': '#fecaca', 'red-medium': '#fca5a5',
                                                    'blue-light': '#bfdbfe', 'blue-medium': '#93c5fd',
                                                    'yellow-light': '#fef08a', 'yellow-medium': '#fde047',
                                                    'purple-light': '#e9d5ff', 'purple-medium': '#d8b4fe',
                                                    'teal-light': '#99f6e4', 'teal-medium': '#5eead4',
                                                    'pink-light': '#fbcfe8', 'pink-medium': '#f9a8d4'
                                                };
                                                cellBackground = colorMap[`${card.color}-${shade}`] || 'inherit';
                                            }

                                            return (
                                                <tr key={rowIndex} className={rangeClass} style={{ height: `${rowHeight}px` }}>
                                                    {rowGroup.map((cellData, colIdx) => {
                                                        // Render Pair: Slot + Play
                                                        // If no cell data, render empty cells
                                                        if (!cellData) {
                                                            return (
                                                                <React.Fragment key={colIdx}>
                                                                    <td style={{ border: '1px solid #333', background: cellBackground }}></td>
                                                                    <td style={{ border: '1px solid #333', background: cellBackground }}></td>
                                                                </React.Fragment>
                                                            );
                                                        }

                                                        const play = cellData.play;
                                                        // Since we are not in Editor mode here potentially, handleAssignSlot might not be needed if this is print view
                                                        // But previous code included onClick. I'll include it for consistency with Standard.
                                                        const isClickable = !isMiniScripts && selectedPlayId && !play;

                                                        return (
                                                            <React.Fragment key={colIdx}>
                                                                {/* Coord */}
                                                                <td style={{
                                                                    border: '1px solid #333',
                                                                    textAlign: 'center', fontWeight: 'bold',
                                                                    fontSize: `${fontSize}rem`,
                                                                    background: cellBackground
                                                                }}>
                                                                    {cellData.slot}
                                                                </td>
                                                                {/* Play */}
                                                                <td
                                                                    onClick={() => handleAssignSlot(cellData.slot)}
                                                                    style={{
                                                                        border: '1px solid #333',
                                                                        padding: '0 2px',
                                                                        fontSize: `${fontSize}rem`,
                                                                        verticalAlign: 'middle',
                                                                        overflow: 'hidden', whiteSpace: 'nowrap', textOverflow: 'ellipsis',
                                                                        background: cellBackground,
                                                                        cursor: isClickable ? 'pointer' : 'default',
                                                                        backgroundColor: isClickable ? '#dbeafe' : cellBackground
                                                                    }}>
                                                                    <input
                                                                        type="text"
                                                                        value={staplesInputs[cellData.slot] || ''}
                                                                        onChange={(e) => handleStaplesInputChange(cellData.slot, e.target.value)}
                                                                        onBlur={() => handleStaplesInputBlur(cellData.slot)}
                                                                        onKeyDown={(e) => handleStaplesInputKeyDown(e, cellData.slot)}
                                                                        placeholder="Type play..."
                                                                        style={{
                                                                            width: '100%',
                                                                            border: 'none',
                                                                            background: 'transparent',
                                                                            fontSize: 'inherit',
                                                                            padding: '0',
                                                                            outline: 'none',
                                                                            fontFamily: 'inherit'
                                                                        }}
                                                                    />
                                                                </td>
                                                            </React.Fragment>
                                                        );
                                                    })}
                                                </tr>
                                            );
                                        })}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    );
                }

                // STANDARD / TRADITIONAL LAYOUT (Original Logic)
                // ---------------------------------------------------------

                // Split into two columns: odd coordinates on left, even on right
                const col1 = []; // Odd coordinates (101, 103, 105, ...)
                const col2 = []; // Even coordinates (102, 104, 106, ...)

                displayRows.forEach(row => {
                    const slotNum = parseInt(row.slot);
                    // Standard (starts at 101/1), Odd is Left, Even is Right
                    if (slotNum % 2 === 1) {
                        col1.push(row);
                    } else {
                        col2.push(row);
                    }
                });

                // Ensure columns have equal length for rendering
                const rowCount = Math.max(col1.length, col2.length, 24);
                const tableRows = [];
                for (let i = 0; i < rowCount; i++) {
                    tableRows.push([col1[i] || null, col2[i] || null]);
                }

                return (
                    <div style={{ width: '100%', height: '100%', display: 'flex', flexDirection: 'column', border: '2px solid black' }}>
                        {/* Header - Split layout */}
                        <div style={{
                            background: 'black',
                            color: 'white',
                            fontWeight: 'bold',
                            fontSize: '10pt',
                            padding: '0 2px',
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center'
                        }}>
                            <span style={{ textTransform: 'uppercase' }}>TRADITIONAL</span>
                            <span>{title}</span>
                        </div>
                        {/* Table */}
                        <table className="wristband-spreadsheet-table">
                            <tbody>
                                {tableRows.map((rowGroup, rowIndex) => (
                                    <tr key={rowIndex} className={rangeClass}>
                                        {rowGroup.map((cellData, colIndex) => {
                                            if (cellData && cellData.type === 'spacer') return null;

                                            if (cellData && cellData.isHeader) {
                                                const isTempo = cellData.type === 'tempo';
                                                return (
                                                    <React.Fragment key={colIndex}>
                                                        <td colSpan={4} style={{
                                                            background: isTempo ? '#ffedd5' : '#333',
                                                            color: isTempo ? 'black' : 'white',
                                                            fontWeight: 'bold',
                                                            textAlign: 'center',
                                                            border: '1px solid #333',
                                                            fontSize: '8pt',
                                                            padding: '2px'
                                                        }}>
                                                            {cellData.text}
                                                        </td>
                                                    </React.Fragment>
                                                );
                                            }

                                            if (!cellData) return <React.Fragment key={colIndex}><td style={{ border: '1px solid #333', height: `${rowHeight}px` }} /><td style={{ border: '1px solid #333', height: `${rowHeight}px` }} /></React.Fragment>;

                                            const play = cellData.play;
                                            const isClickable = !isMiniScripts && selectedPlayId && !play;

                                            // Calculate color background for this row
                                            let cellBackground = 'inherit';
                                            if (card && card.color && card.color !== 'none') {
                                                const colorBase = card.color;
                                                const shadeIndex = rowIndex % 2;
                                                const shades = ['light', 'medium'];
                                                const shade = shades[shadeIndex];
                                                const colorMap = {
                                                    'green-light': '#d1fae5', 'green-medium': '#a7f3d0',
                                                    'orange-light': '#fed7aa', 'orange-medium': '#fdba74',
                                                    'red-light': '#fecaca', 'red-medium': '#fca5a5',
                                                    'blue-light': '#bfdbfe', 'blue-medium': '#93c5fd',
                                                    'yellow-light': '#fef08a', 'yellow-medium': '#fde047',
                                                    'purple-light': '#e9d5ff', 'purple-medium': '#d8b4fe',
                                                    'teal-light': '#99f6e4', 'teal-medium': '#5eead4',
                                                    'pink-light': '#fbcfe8', 'pink-medium': '#f9a8d4'
                                                };
                                                cellBackground = colorMap[`${colorBase}-${shade}`] || 'inherit';
                                            }

                                            // Header/Tempo Row Render
                                            if (cellData.isHeader) {
                                                const isTempo = cellData.type === 'tempo';
                                                return (
                                                    <React.Fragment key={`${colIndex}-${cellData.slot}`}>
                                                        <td
                                                            colSpan={2}
                                                            style={{
                                                                fontWeight: 'bold',
                                                                background: isTempo ? '#ffedd5' : '#333',
                                                                color: isTempo ? 'black' : 'white',
                                                                textAlign: 'center',
                                                                border: '1px solid #333',
                                                                height: `${rowHeight}px`,
                                                                maxHeight: `${rowHeight}px`,
                                                                fontSize: `${fontSize}rem`,
                                                                verticalAlign: 'middle',
                                                                overflow: 'hidden',
                                                                whiteSpace: 'nowrap'
                                                            }}
                                                        >
                                                            {cellData.text}
                                                        </td>
                                                    </React.Fragment>
                                                );
                                            }

                                            return (
                                                <React.Fragment key={`${colIndex}-${cellData.slot}`}>
                                                    <td
                                                        style={{
                                                            fontWeight: 'bold',
                                                            width: '45px',
                                                            cursor: isClickable ? 'pointer' : 'default',
                                                            background: isClickable ? 'rgba(56, 189, 248, 0.2)' : cellBackground,
                                                            padding: '0 2px',
                                                            border: '1px solid #333',
                                                            height: `${rowHeight}px`,
                                                            maxHeight: `${rowHeight}px`,
                                                            fontSize: `${fontSize}rem`,
                                                            verticalAlign: 'middle',
                                                            color: '#000',
                                                            overflow: 'hidden',
                                                            whiteSpace: 'nowrap',
                                                            lineHeight: `${rowHeight}px`,
                                                            boxSizing: 'border-box',
                                                            textAlign: 'center'
                                                        }}
                                                        onClick={() => !isMiniScripts && handleAssignSlot(cellData.slot)}
                                                    >
                                                        {cellData.slot}
                                                    </td>
                                                    <td
                                                        style={{
                                                            cursor: isClickable ? 'pointer' : 'default',
                                                            background: isClickable ? 'rgba(56, 189, 248, 0.2)' : (cellData.type === 'tempo' ? '#ffedd5' : cellBackground),
                                                            padding: '0 2px',
                                                            border: '1px solid #333',
                                                            height: `${rowHeight}px`,
                                                            maxHeight: `${rowHeight}px`,
                                                            fontSize: `${fontSize}rem`,
                                                            verticalAlign: 'middle',
                                                            fontWeight: cellData.type === 'tempo' ? 'bold' : 'normal',
                                                            color: '#000',
                                                            overflow: 'hidden',
                                                            textOverflow: 'ellipsis',
                                                            whiteSpace: 'nowrap',
                                                            lineHeight: `${rowHeight}px`,
                                                            boxSizing: 'border-box'
                                                        }}
                                                        onClick={() => !isMiniScripts && handleAssignSlot(cellData.slot)}
                                                    >
                                                        {quickAddSlot === cellData.slot ? (
                                                            <div style={{ position: 'relative', width: '100%', height: '100%' }} onClick={(e) => e.stopPropagation()}>
                                                                <input
                                                                    type="text"
                                                                    value={quickAddValue}
                                                                    onChange={(e) => handleQuickAddChange(e.target.value)}
                                                                    onKeyDown={(e) => {
                                                                        if (e.key === 'Enter') handleQuickAddSubmit(cellData.slot);
                                                                        if (e.key === 'Escape') handleQuickAddCancel();
                                                                    }}
                                                                    onBlur={() => setTimeout(() => handleQuickAddCancel(), 200)}
                                                                    autoFocus
                                                                    style={{ width: '100%', height: '100%', fontSize: `${fontSize}rem`, border: 'none', background: 'white' }}
                                                                />
                                                            </div>
                                                        ) : (
                                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                                <span>{cellData.text}</span>
                                                                {!isMiniScripts && !play && (
                                                                    <button
                                                                        onClick={(e) => { e.stopPropagation(); handleQuickAddStart(cellData.slot); }}
                                                                        style={{ fontSize: '0.5rem', color: '#999', background: 'none', border: 'none' }}
                                                                    >
                                                                        +
                                                                    </button>
                                                                )}
                                                                {!isMiniScripts && play && (
                                                                    <button
                                                                        className="wristband-clear-btn"
                                                                        onClick={(e) => { e.stopPropagation(); onUpdatePlay({ ...play, wristbandSlot: '' }); }}
                                                                        style={{ fontSize: '0.6rem', padding: '0 2px', height: '10px' }}
                                                                    >
                                                                        ×
                                                                    </button>
                                                                )}
                                                            </div>
                                                        )}
                                                    </td>
                                                </React.Fragment>
                                            );
                                        })}
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                );
            };

            // Audible wristband: Coordinate in left column, two play columns on right
            const renderAudibleTable = (slots, rangeClass, cardId, title = '') => {
                const card = wbSettings[cardId];
                if (!card) return null;

                // Get all plays for the slots
                const displayRows = slots.map(slot => {
                    const play = slotMap[slot];
                    return {
                        slot: slot,
                        text: play ? `${play.name}${play.formation && !checkRedundantFormation(play.name, play.formation) ? ' - ' + play.formation : ''}` : '',
                        play: play
                    };
                });

                // Group rows: each row shows coordinate + 2 plays
                const tableRows = [];
                for (let i = 0; i < displayRows.length; i += 2) {
                    const row1 = displayRows[i];
                    const row2 = displayRows[i + 1] || { slot: '', text: '', play: null };
                    tableRows.push({ coordinate: row1.slot, play1: row1, play2: row2 });
                }

                // Ensure minimum rows for consistent layout
                while (tableRows.length < 24) {
                    tableRows.push({ coordinate: '', play1: { slot: '', text: '', play: null }, play2: { slot: '', text: '', play: null } });
                }

                return (
                    <div style={{ width: '100%', height: '100%', display: 'flex', flexDirection: 'column', border: '2px solid black' }}>
                        {/* Header */}
                        <div style={{
                            background: 'black',
                            color: 'white',
                            fontWeight: 'bold',
                            fontSize: '10pt',
                            padding: '0 2px',
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center'
                        }}>
                            <span style={{ textTransform: 'uppercase' }}>AUDIBLE</span>
                            <span>{title}</span>
                        </div>
                        {/* Table */}
                        <table className="wristband-spreadsheet-table">
                            <tbody>
                                {tableRows.map((row, rowIndex) => {
                                    // Calculate color background for this row
                                    let cellBackground = 'inherit';
                                    if (card && card.color && card.color !== 'none') {
                                        const colorBase = card.color;
                                        const shadeIndex = rowIndex % 2;
                                        const shades = ['light', 'medium'];
                                        const shade = shades[shadeIndex];
                                        const colorMap = {
                                            'green-light': '#d1fae5', 'green-medium': '#a7f3d0',
                                            'orange-light': '#fed7aa', 'orange-medium': '#fdba74',
                                            'red-light': '#fecaca', 'red-medium': '#fca5a5',
                                            'blue-light': '#bfdbfe', 'blue-medium': '#93c5fd',
                                            'yellow-light': '#fef08a', 'yellow-medium': '#fde047',
                                            'purple-light': '#e9d5ff', 'purple-medium': '#d8b4fe',
                                            'teal-light': '#99f6e4', 'teal-medium': '#5eead4',
                                            'pink-light': '#fbcfe8', 'pink-medium': '#f9a8d4'
                                        };
                                        cellBackground = colorMap[`${colorBase}-${shade}`] || 'inherit';
                                    }

                                    return (
                                        <tr key={rowIndex} className={rangeClass}>
                                            {/* Coordinate Column */}
                                            <td style={{
                                                fontWeight: 'bold',
                                                width: '45px',
                                                background: cellBackground,
                                                padding: '0 2px',
                                                border: '1px solid #333',
                                                height: `${rowHeight}px`,
                                                fontSize: `${fontSize}rem`,
                                                verticalAlign: 'middle',
                                                color: '#000',
                                                textAlign: 'center',
                                                lineHeight: `${rowHeight}px`
                                            }}>
                                                {row.coordinate}
                                            </td>
                                            {/* Play 1 Column */}
                                            <td style={{
                                                background: cellBackground,
                                                padding: '0 2px',
                                                border: '1px solid #333',
                                                height: `${rowHeight}px`,
                                                fontSize: `${fontSize}rem`,
                                                verticalAlign: 'middle',
                                                color: '#000',
                                                overflow: 'hidden',
                                                textOverflow: 'ellipsis',
                                                whiteSpace: 'nowrap',
                                                lineHeight: `${rowHeight}px`,
                                                cursor: selectedPlayId && !row.play1.play ? 'pointer' : 'default'
                                            }}
                                                onClick={() => row.play1.slot && handleAssignSlot(row.play1.slot)}>
                                                {row.play1.text}
                                            </td>
                                            {/* Play 2 Column */}
                                            <td style={{
                                                background: cellBackground,
                                                padding: '0 2px',
                                                border: '1px solid #333',
                                                height: `${rowHeight}px`,
                                                fontSize: `${fontSize}rem`,
                                                verticalAlign: 'middle',
                                                color: '#000',
                                                overflow: 'hidden',
                                                textOverflow: 'ellipsis',
                                                whiteSpace: 'nowrap',
                                                lineHeight: `${rowHeight}px`,
                                                cursor: selectedPlayId && !row.play2.play ? 'pointer' : 'default'
                                            }}
                                                onClick={() => row.play2.slot && handleAssignSlot(row.play2.slot)}>
                                                {row.play2.text}
                                            </td>
                                        </tr>
                                    );
                                })}
                            </tbody>
                        </table>
                    </div>
                );
            };

            // Helper function to calculate bounding box of diagram elements
            const calculateDiagramBounds = (elements) => {
                if (!elements || elements.length === 0) {
                    return { minX: 0, minY: 0, maxX: 800, maxY: 500, width: 800, height: 500 };
                }

                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;
                const padding = 20; // Padding around the bounding box

                elements.forEach(el => {
                    if (el.type === 'player') {
                        const { x, y } = el.points[0];
                        const size = 30; // Player icon size
                        minX = Math.min(minX, x - size / 2);
                        minY = Math.min(minY, y - size / 2);
                        maxX = Math.max(maxX, x + size / 2);
                        maxY = Math.max(maxY, y + size / 2);
                    } else {
                        // Routes/arrows - check all points
                        el.points.forEach(p => {
                            minX = Math.min(minX, p.x);
                            minY = Math.min(minY, p.y);
                            maxX = Math.max(maxX, p.x);
                            maxY = Math.max(maxY, p.y);
                        });
                    }
                });

                // Add padding
                minX = Math.max(0, minX - padding);
                minY = Math.max(0, minY - padding);
                maxX = Math.min(800, maxX + padding);
                maxY = Math.min(500, maxY + padding);

                return {
                    minX,
                    minY,
                    maxX,
                    maxY,
                    width: maxX - minX,
                    height: maxY - minY
                };
            };

            const renderPlayThumbnail = (play, type = 'standard') => {
                if (!play) return null;

                // Determine which data to use based on type
                let data = null;
                if (type === 'skill' && (play.wizSkillData || play.rooskiSkillData)) {
                    data = { elements: play.wizSkillData || play.rooskiSkillData };
                } else if (type === 'oline' && (play.wizOlineData || play.rooskiOlineData)) {
                    data = { elements: play.wizOlineData || play.rooskiOlineData };
                } else if (play.diagramData) {
                    data = play.diagramData;
                }

                if (!data || !data.elements || data.elements.length === 0) return null;

                // Fixed viewBox for consistent field representation
                // Cell aspect ratio on 5x3 card with 4x4 grid is ~1.75:1
                // Using 800x460 to match this ratio and fill cells better
                const fieldWidth = 800;
                const fieldHeight = 460;
                const viewBoxX = 0;
                const viewBoxY = 60; // Offset to show ~13 yards upfield and ~6 yards backfield from LOS at y=400

                // Define colors for route lines
                const routeColors = ['#ef4444', '#3b82f6', '#22c55e', '#eab308', '#a855f7', '#f97316', '#06b6d4', '#ec4899'];

                return (
                    <svg
                        viewBox={`${viewBoxX} ${viewBoxY} ${fieldWidth} ${fieldHeight}`}
                        width="100%"
                        height="100%"
                        style={{ display: 'block', background: 'white', flex: 1, minHeight: 0, minWidth: 0 }}
                        preserveAspectRatio="xMidYMid meet"
                    >
                        {/* Arrow markers for each color */}
                        <defs>
                            {routeColors.map(color => (
                                <marker
                                    key={color}
                                    id={`wiz-arrow-${color.replace('#', '')}`}
                                    markerWidth="10"
                                    markerHeight="10"
                                    refX="9"
                                    refY="3"
                                    orient="auto"
                                    markerUnits="strokeWidth"
                                >
                                    <path d="M0,0 L0,6 L9,3 z" fill={color} />
                                </marker>
                            ))}
                            <marker id="wiz-arrow-000000" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                                <path d="M0,0 L0,6 L9,3 z" fill="#000000" />
                            </marker>
                        </defs>

                        {/* Field background - white */}
                        <rect x={viewBoxX} y={viewBoxY} width={fieldWidth} height={fieldHeight} fill="white" />

                        {/* Yard lines on LEFT side - 5, 10, 15 going UP from bottom */}
                        {/* LOS is at bottom (y=450), each 5 yards = ~100px up */}
                        <g stroke="#c4a052" strokeWidth="2" fill="none">
                            {/* Hash marks at TOP (orange/gold) */}
                            <line x1="250" y1="20" x2="250" y2="50" />
                            <line x1="550" y1="20" x2="550" y2="50" />
                        </g>
                        <g fill="#888" fontSize="14" fontWeight="bold">
                            {/* Yard numbers on left - positioned from bottom going up */}
                            <text x="15" y="365">5</text>
                            <text x="10" y="265">10</text>
                            <text x="10" y="165">15</text>
                        </g>
                        {/* Faint yard lines across field */}
                        <g stroke="#ddd" strokeWidth="1">
                            <line x1="35" y1="350" x2={fieldWidth - 20} y2="350" />
                            <line x1="35" y1="250" x2={fieldWidth - 20} y2="250" />
                            <line x1="35" y1="150" x2={fieldWidth - 20} y2="150" />
                        </g>

                        {/* Render diagram elements */}
                        {data.elements && data.elements.map(el => {
                            if (el.type === 'player') {
                                const { x, y } = el.points[0];
                                const size = el.shape === 'text-only' ? 0 : 28;
                                const isRect = el.shape === 'square';
                                const isTextOnly = el.shape === 'text-only';
                                const fontSize = isTextOnly ? (el.fontSize ? Math.min(el.fontSize * 0.25, 40) : 24) : 14;

                                return (
                                    <g key={el.id}>
                                        {!isTextOnly && (isRect ? (
                                            <rect x={x - size / 2} y={y - size / 2} width={size} height={size} fill="white" stroke={el.color} strokeWidth="3" />
                                        ) : (
                                            <circle cx={x} cy={y} r={size / 2} fill="white" stroke={el.color} strokeWidth="3" />
                                        ))}
                                        <text
                                            x={x}
                                            y={y}
                                            dy={isTextOnly ? "0.35em" : "0.35em"}
                                            textAnchor="middle"
                                            fontSize={fontSize}
                                            fontWeight="bold"
                                            fill={el.color}
                                        >
                                            {el.label}
                                        </text>
                                    </g>
                                );
                            }

                            // Route/line rendering
                            let d = '';
                            if (el.style === 'zigzag') {
                                d = getZigZagPath(el.points);
                            } else if (el.type === 'free' || el.points.length > 1) {
                                d = `M ${el.points.map(p => `${p.x},${p.y}`).join(' L ')}`;
                            }

                            let markerEnd = undefined;
                            let tBlock = null;
                            const colorHex = (el.color || '#000000').replace('#', '');

                            if (el.endType === 'arrow' || (!el.endType && el.type !== 'free')) {
                                markerEnd = `url(#wiz-arrow-${colorHex})`;
                            } else if (el.endType === 't') {
                                const end = el.points[el.points.length - 1];
                                const prev = el.points[el.points.length - 2] || el.points[0];
                                const dx = end.x - prev.x;
                                const dy = end.y - prev.y;
                                const len = Math.hypot(dx, dy) || 1;
                                const perpX = (-dy / len) * 12;
                                const perpY = (dx / len) * 12;
                                tBlock = (
                                    <line
                                        x1={end.x - perpX} y1={end.y - perpY}
                                        x2={end.x + perpX} y2={end.y + perpY}
                                        stroke={el.color}
                                        strokeWidth="5"
                                    />
                                );
                            } else if (el.endType === 'dot') {
                                const end = el.points[el.points.length - 1];
                                tBlock = (
                                    <circle cx={end.x} cy={end.y} r="5" fill={el.color} />
                                );
                            } else if (el.endType === 'none') {
                                markerEnd = undefined;
                            } else if (el.type === 'arrow') {
                                markerEnd = `url(#wiz-arrow-${colorHex})`;
                            }

                            return (
                                <g key={el.id}>
                                    <path
                                        d={d}
                                        stroke={el.color}
                                        strokeWidth="5"
                                        fill="none"
                                        strokeDasharray={el.style === 'dashed' ? "8,4" : "none"}
                                        markerEnd={markerEnd}
                                    />
                                    {tBlock}
                                </g>
                            );
                        })}
                    </svg>
                );
            };

            const renderWizGrid = (slots, title, viewType) => {
                // 4x4 Grid for 3x5 card - each cell has diagram on top, coordinate/name below
                const rows = [];
                for (let i = 0; i < slots.length; i += 4) {
                    rows.push(slots.slice(i, i + 4));
                }

                return (
                    <div className="wiz-grid-container" style={{ width: '100%', height: '100%', display: 'flex', flexDirection: 'column', border: '2px solid black' }}>
                        {/* Header - Split layout */}
                        <div style={{
                            background: 'black',
                            color: 'white',
                            fontWeight: 'bold',
                            fontSize: '10pt',
                            padding: '2px 4px',
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center'
                        }}>
                            <span style={{ textTransform: 'uppercase' }}>WIZ</span>
                            <span>{title}</span>
                        </div>
                        {/* Grid */}
                        <div style={{ flex: 1, display: 'flex', flexDirection: 'column' }}>
                            {rows.map((rowSlots, rIndex) => (
                                <div key={rIndex} style={{ height: '25%', minHeight: '25%', maxHeight: '25%', display: 'flex', borderBottom: rIndex < rows.length - 1 ? '1px solid black' : 'none' }}>
                                    {rowSlots.map((slot, cIndex) => {
                                        const play = slotMap[slot];

                                        // Filter plays based on view type
                                        // Always show the play if it is assigned to the slot
                                        // The renderPlayThumbnail function will handle showing/hiding the diagram based on available data
                                        const displayPlay = play;
                                        const isClickable = selectedPlayId && !play;

                                        // Check if this cell has diagram data for current view type
                                        const hasDiagram = displayPlay && (
                                            viewType === 'skill' ? (displayPlay.wizSkillData && displayPlay.wizSkillData.length > 0) :
                                            viewType === 'oline' ? (displayPlay.wizOlineData && displayPlay.wizOlineData.length > 0) : false
                                        );

                                        return (
                                            <div
                                                key={slot}
                                                style={{
                                                    flex: 1,
                                                    borderRight: cIndex < 3 ? '1px solid black' : 'none',
                                                    display: 'flex',
                                                    flexDirection: 'column',
                                                    cursor: displayPlay ? 'pointer' : (isClickable ? 'pointer' : 'default'),
                                                    background: isClickable ? 'rgba(56, 189, 248, 0.2)' : 'white',
                                                    overflow: 'hidden',
                                                    position: 'relative'
                                                }}
                                                onClick={() => handleAssignSlot(slot)}
                                                onDoubleClick={(e) => {
                                                    e.stopPropagation();
                                                    if (displayPlay) {
                                                        // Open diagram editor for this play
                                                        setEditingWizPlay(displayPlay);
                                                        setEditingWizType(viewType === 'skill' ? 'wiz-skill' : 'wiz-oline');
                                                    }
                                                }}
                                                title={displayPlay ? `Double-click to edit ${viewType === 'skill' ? 'skill' : 'O-line'} diagram` : ''}
                                            >
                                                {/* Clear button in top-right corner */}
                                                {displayPlay && (
                                                    <button
                                                        className="wristband-clear-btn"
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            onUpdatePlay({ ...displayPlay, wristbandSlot: '' });
                                                        }}
                                                        style={{
                                                            position: 'absolute',
                                                            top: '2px',
                                                            right: '2px',
                                                            zIndex: 10,
                                                            fontSize: '10px',
                                                            padding: '0 4px',
                                                            lineHeight: '14px',
                                                            background: 'rgba(255, 255, 255, 0.9)',
                                                            borderRadius: '2px'
                                                        }}
                                                    >
                                                        ×
                                                    </button>
                                                )}
                                                {/* Diagram area - takes up most of the cell */}
                                                <div style={{
                                                    flex: 1,
                                                    display: 'flex',
                                                    alignItems: 'stretch',
                                                    justifyContent: 'stretch',
                                                    overflow: 'hidden',
                                                    minHeight: 0,
                                                    background: 'white'
                                                }}>
                                                    {displayPlay && hasDiagram && renderPlayThumbnail(displayPlay, viewType)}
                                                    {displayPlay && !hasDiagram && (
                                                        <div style={{
                                                            width: '100%',
                                                            height: '100%',
                                                            display: 'flex',
                                                            alignItems: 'center',
                                                            justifyContent: 'center',
                                                            flexDirection: 'column',
                                                            color: '#999',
                                                            fontSize: '7pt',
                                                            textAlign: 'center',
                                                            padding: '4px',
                                                            background: '#f5f5f5'
                                                        }}>
                                                            <span style={{ fontSize: '16px', marginBottom: '2px' }}>✏️</span>
                                                            <span>Double-click<br/>to draw</span>
                                                        </div>
                                                    )}
                                                </div>

                                                {/* Bottom row: Coordinate (left) | Play Name (right) - compact like the reference */}
                                                <div style={{
                                                    display: 'flex',
                                                    borderTop: '1px solid black',
                                                    height: '14px',
                                                    minHeight: '14px',
                                                    maxHeight: '14px',
                                                    background: 'white'
                                                }}>
                                                    {/* Coordinate cell */}
                                                    <div style={{
                                                        width: '28px',
                                                        minWidth: '28px',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        fontSize: '8pt',
                                                        fontWeight: 'bold',
                                                        color: '#000',
                                                        borderRight: '1px solid black',
                                                        background: 'white'
                                                    }}>
                                                        {slot}
                                                    </div>

                                                    {/* Play name cell */}
                                                    <div style={{
                                                        flex: 1,
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        justifyContent: 'flex-start',
                                                        fontSize: '6pt',
                                                        fontWeight: 'bold',
                                                        padding: '0 3px',
                                                        textAlign: 'left',
                                                        overflow: 'hidden',
                                                        textOverflow: 'ellipsis',
                                                        whiteSpace: 'nowrap',
                                                        background: 'white',
                                                        color: '#000'
                                                    }}>
                                                        {displayPlay ? displayPlay.name : ''}
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            ))}
                        </div>
                    </div>
                );
            };

            // Card-specific slots
            const getSlotsForCard = (cardId) => {
                const card = wbSettings[cardId];

                if (card && card.type === 'staples') {
                    const slots = [];
                    for (let i = 10; i <= 89; i++) slots.push(i);
                    return slots;
                }

                if (card && (card.type === 'wiz')) {
                    // Wiz uses 16 slots: X01-X16 where X is the series number
                    const series = cardId === 'card1' ? 1 : (cardId === 'card2' ? 2 : (cardId === 'card3' ? 3 : (cardId === 'card4' ? 4 : (cardId === 'card5' ? 5 : 6))));
                    const slots = [];
                    for (let i = 1; i <= 16; i++) {
                        slots.push(`${series}${String(i).padStart(2, '0')}`);
                    }
                    return slots;
                }

                // Standard/Modular use 48 slots
                const start = cardId === 'card1' ? 101 : (cardId === 'card2' ? 201 : (cardId === 'card3' ? 301 : (cardId === 'card4' ? 401 : (cardId === 'card5' ? 501 : 601))));
                const slots = [];
                for (let i = start; i <= start + 47; i++) slots.push(i);
                return slots;
            };

            const renderMiniScriptEditorRows = (card, cardId) => {
                const rows = [];
                const startCoord = cardId === 'card1' ? 101 : (cardId === 'card2' ? 201 : (cardId === 'card3' ? 301 : (cardId === 'card4' ? 401 : (cardId === 'card5' ? 501 : 601))));

                let currentCoord = startCoord;

                // Iterate through all rows directly
                if (card.rows && card.rows.length > 0) {
                    card.rows.forEach((item, i) => {
                        if (item.type === 'header') {
                            // Render Header
                            rows.push(
                                <div key={item.id} style={{ padding: '0.5rem', border: '1px solid var(--border)', borderRadius: '4px', background: 'var(--bg-input)', marginBottom: '0.5rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                    <div style={{ display: 'flex', flexDirection: 'column', flex: 1 }}>
                                        <label style={{ fontSize: '0.7rem', color: 'var(--text-secondary)', marginBottom: '2px' }}>Header Label</label>
                                        <input
                                            value={item.label}
                                            onChange={(e) => handleUpdateRow(selectedCardId, item.id, { label: e.target.value })}
                                            style={{ width: '100%', fontWeight: 'bold', fontSize: '0.9rem', padding: '4px', border: '1px solid var(--border)', borderRadius: '4px', background: 'var(--bg-panel)', color: 'var(--text-primary)' }}
                                            placeholder="SECTION HEADER"
                                        />
                                    </div>
                                    <div style={{ display: 'flex', flexDirection: 'column' }}>
                                        <label style={{ fontSize: '0.7rem', color: 'var(--text-secondary)', marginBottom: '2px' }}>Color</label>
                                        <select
                                            value={item.color || 'gray'}
                                            onChange={(e) => handleUpdateRow(selectedCardId, item.id, { color: e.target.value })}
                                            style={{ fontSize: '0.8rem', padding: '4px', border: '1px solid var(--border)', borderRadius: '4px', background: 'var(--bg-panel)', color: 'var(--text-primary)' }}
                                        >
                                            <option value="gray">Gray</option>
                                            <option value="black">Black</option>
                                            <option value="red">Red</option>
                                            <option value="blue">Blue</option>
                                            <option value="green">Green</option>
                                            <option value="orange">Orange</option>
                                        </select>
                                    </div>
                                    <div style={{ display: 'flex', gap: '2px', alignSelf: 'flex-end', paddingBottom: '2px' }}>
                                        <button className="btn btn-secondary" style={{ padding: '4px' }} onClick={() => handleMoveRow(selectedCardId, item.id, -1)} title="Move Up">↑</button>
                                        <button className="btn btn-secondary" style={{ padding: '4px' }} onClick={() => handleMoveRow(selectedCardId, item.id, 1)} title="Move Down">↓</button>
                                        <button className="btn btn-danger" style={{ padding: '4px 8px' }} onClick={() => handleRemoveRow(selectedCardId, item.id)} title="Delete Header">×</button>
                                    </div>
                                </div>
                            );
                        } else {
                            // Render Play Row (3 Inputs: Play1, Tempo, Play2)
                            rows.push(
                                <div key={item.id} style={{ display: 'grid', gridTemplateColumns: '40px 80px 1fr 80px 1fr 80px', gap: '0.5rem', alignItems: 'center', marginBottom: '0.5rem' }}>
                                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '2px' }}>
                                        <div style={{ fontSize: '0.8rem', fontWeight: 'bold', color: 'var(--text-secondary)' }}>
                                            {currentCoord}
                                        </div>
                                        <select
                                            value={item.color || ''}
                                            onChange={(e) => handleUpdateRow(selectedCardId, item.id, { color: e.target.value })}
                                            style={{ width: '100%', fontSize: '0.6rem', padding: '1px', border: '1px solid var(--border)', borderRadius: '2px', background: 'var(--bg-panel)', color: 'var(--text-primary)' }}
                                            title="Row Color"
                                        >
                                            <option value="">Default</option>
                                            <option value="blue">Blue</option>
                                            <option value="orange">Tan</option>
                                            <option value="green">Green</option>
                                            <option value="red">Red</option>
                                            <option value="yellow">Yel</option>
                                            <option value="purple">Purp</option>
                                        </select>
                                    </div>

                                    {/* Tempo (Left) */}
                                    <input
                                        value={item.col0 || ''}
                                        onChange={(e) => handleUpdateRow(selectedCardId, item.id, { col0: e.target.value })}
                                        placeholder="Tempo"
                                        style={{ width: '100%', padding: '6px', border: '1px solid var(--border)', borderRadius: '4px', background: 'var(--bg-panel)', color: 'var(--text-primary)', fontSize: '0.8rem', textAlign: 'center', fontWeight: 'bold' }}
                                    />

                                    {/* Play 1 */}
                                    <input
                                        value={item.col1 || ''}
                                        onChange={(e) => handleUpdateRow(selectedCardId, item.id, { col1: e.target.value.toUpperCase() })}
                                        onDragOver={(e) => e.preventDefault()}
                                        onDrop={(e) => {
                                            e.preventDefault();
                                            const playName = e.dataTransfer.getData('text/plain');
                                            if (playName) {
                                                const p = plays.find(p => p.name === playName);
                                                handleUpdateRow(selectedCardId, item.id, { col1: playName, col1Id: p ? p.id : null });
                                            }
                                        }}
                                        onBlur={() => {
                                            if (item.col1 && !item.col1Id && onQuickAddPlay) {
                                                const newPlay = onQuickAddPlay(item.col1);
                                                if (newPlay) {
                                                    handleUpdateRow(selectedCardId, item.id, { col1: newPlay.name, col1Id: newPlay.id });
                                                }
                                            }
                                        }}
                                        placeholder="Play A"
                                        style={{ width: '100%', padding: '6px', border: '1px solid var(--border)', borderRadius: '4px', background: 'var(--bg-panel)', color: 'var(--text-primary)', fontSize: '0.8rem' }}
                                    />

                                    {/* Tempo (Middle) */}
                                    <input
                                        value={item.col2 || ''}
                                        onChange={(e) => handleUpdateRow(selectedCardId, item.id, { col2: e.target.value })}
                                        placeholder="Tempo"
                                        style={{ width: '100%', padding: '6px', border: '1px solid var(--border)', borderRadius: '4px', background: 'var(--bg-panel)', color: 'var(--text-primary)', fontSize: '0.8rem', textAlign: 'center', fontWeight: 'bold' }}
                                    />

                                    {/* Play 2 */}
                                    <input
                                        value={item.col3 || ''}
                                        onChange={(e) => handleUpdateRow(selectedCardId, item.id, { col3: e.target.value.toUpperCase() })}
                                        onDragOver={(e) => e.preventDefault()}
                                        onDrop={(e) => {
                                            e.preventDefault();
                                            const playName = e.dataTransfer.getData('text/plain');
                                            if (playName) {
                                                const p = plays.find(p => p.name === playName);
                                                handleUpdateRow(selectedCardId, item.id, { col3: playName, col3Id: p ? p.id : null });
                                            }
                                        }}
                                        onBlur={() => {
                                            if (item.col3 && !item.col3Id && onQuickAddPlay) {
                                                const newPlay = onQuickAddPlay(item.col3);
                                                if (newPlay) {
                                                    handleUpdateRow(selectedCardId, item.id, { col3: newPlay.name, col3Id: newPlay.id });
                                                }
                                            }
                                        }}
                                        placeholder="Play B"
                                        style={{ width: '100%', padding: '6px', border: '1px solid var(--border)', borderRadius: '4px', background: 'var(--bg-panel)', color: 'var(--text-primary)', fontSize: '0.8rem' }}
                                    />

                                    {/* Actions */}
                                    <div style={{ display: 'flex', gap: '2px', justifyContent: 'flex-end' }}>
                                        <button className="btn btn-secondary" style={{ padding: '4px' }} onClick={() => handleMoveRow(selectedCardId, item.id, -1)} title="Move Up">↑</button>
                                        <button className="btn btn-secondary" style={{ padding: '4px' }} onClick={() => handleMoveRow(selectedCardId, item.id, 1)} title="Move Down">↓</button>
                                        <button className="btn btn-danger" style={{ padding: '4px 8px' }} onClick={() => handleRemoveRow(selectedCardId, item.id)} title="Delete">×</button>
                                    </div>
                                </div>
                            );
                            currentCoord++;
                        }
                    });
                }

                return rows;
            };

            const miniScripts = useMemo(() => {
                return (gamePlan?.miniScripts || []);
            }, [gamePlan]);

            const activeCard = wbSettings[selectedCardId];

            return (
                <div style={{ display: 'flex', height: 'calc(100vh - 100px)', gap: '2rem' }}>
                    {/* WIZ Diagram Editor Modal */}
                    {editingWizPlay && editingWizType && (
                        <PlayDiagramEditor
                            initialData={editingWizType === 'wiz-skill'
                                ? (editingWizPlay.wizSkillData ? { elements: editingWizPlay.wizSkillData } : null)
                                : (editingWizPlay.wizOlineData ? { elements: editingWizPlay.wizOlineData } : null)
                            }
                            mode={editingWizType}
                            formations={formations}
                            onSave={(data) => {
                                // Update the play with new diagram data
                                const updates = editingWizType === 'wiz-skill'
                                    ? { wizSkillData: data.elements }
                                    : { wizOlineData: data.elements };
                                onUpdatePlay({ ...editingWizPlay, ...updates });

                                // If O-Line and scheme ID is set, offer to save to library
                                if (editingWizType === 'wiz-oline' && editingWizPlay.olineSchemeId) {
                                    const isProt = passProtections.some(p => p.id === editingWizPlay.olineSchemeId);
                                    if (isProt && setPassProtections) {
                                        setPassProtections(passProtections.map(p =>
                                            p.id === editingWizPlay.olineSchemeId ? { ...p, diagramData: data.elements } : p
                                        ));
                                    } else if (setRunBlocking) {
                                        setRunBlocking(runBlocking.map(b =>
                                            b.id === editingWizPlay.olineSchemeId ? { ...b, diagramData: data.elements } : b
                                        ));
                                    }
                                }

                                setEditingWizPlay(null);
                                setEditingWizType(null);
                            }}
                            onCancel={() => {
                                setEditingWizPlay(null);
                                setEditingWizType(null);
                            }}
                            wizLibrary={wizLibrary}
                            setWizLibrary={setWizLibrary}
                            positionNames={positionNames}
                            positionColors={positionColors}
                            onAddFormation={onAddFormation}
                        />
                    )}

                    {/* Left: Sidebar (Plays or Scripts) */}
                    <div style={{ width: '250px', display: 'flex', flexDirection: 'column', borderRight: '1px solid var(--border)', paddingRight: '1rem' }}>


                        {sidebarMode === 'plays' ? (
                            <>
                                <input
                                    className="form-input"
                                    placeholder="Search plays..."
                                    value={searchTerm}
                                    onChange={e => setSearchTerm(e.target.value)}
                                    style={{ marginBottom: '1rem' }}
                                />
                                <div style={{ flex: 1, overflowY: 'auto', display: 'flex', flexDirection: 'column', gap: '0.25rem' }}>
                                    {filteredPlays.map(play => (
                                        <div
                                            key={play.id}
                                            draggable={true}
                                            onDragStart={(e) => {
                                                e.dataTransfer.setData('text/plain', play.name);
                                            }}
                                            onClick={() => {
                                                if (activeCard && (activeCard.type === 'mini-scripts' || activeCard.type === 'modular')) {
                                                    handleAddPlayRow(selectedCardId, play);
                                                } else {
                                                    setSelectedPlayId(play.id);
                                                }
                                            }}
                                            onDoubleClick={() => handleAutoAssign(play)}
                                            style={{
                                                padding: '0.35rem 0.5rem',
                                                borderRadius: '4px',
                                                border: '1px solid',
                                                borderColor: selectedPlayId === play.id ? 'var(--accent)' : 'var(--border)',
                                                backgroundColor: selectedPlayId === play.id ? 'rgba(56, 189, 248, 0.1)' : 'var(--bg-panel)',
                                                cursor: 'pointer',
                                                opacity: play.wristbandSlot ? 0.5 : 1
                                            }}
                                        >
                                            <div style={{ fontWeight: 'bold', fontSize: '0.75rem', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                                                    {play.priority && <Icon name="Star" size={12} style={{ fill: '#eab308', color: '#eab308' }} />}

                                                    {/* Wiz Badge */}
                                                    {play.isWiz && (
                                                        <span style={{
                                                            fontSize: '0.6rem',
                                                            background: '#fee2e2',
                                                            color: '#991b1b',
                                                            padding: '1px 3px',
                                                            borderRadius: '4px',
                                                            fontWeight: 'bold',
                                                            border: '1px solid #fecaca'
                                                        }}>R</span>
                                                    )}

                                                    {/* Mini Script Badge */}
                                                    {play.isMiniScript && (
                                                        <span style={{
                                                            fontSize: '0.6rem',
                                                            background: '#e0e7ff',
                                                            color: '#3730a3',
                                                            padding: '1px 3px',
                                                            borderRadius: '4px',
                                                            fontWeight: 'bold',
                                                            border: '1px solid #c7d2fe'
                                                        }}>MS</span>
                                                    )}

                                                    <span>{play.name}</span>
                                                </div>
                                                <div style={{ display: 'flex', alignItems: 'center' }}>
                                                    {play.wristbandSlot && <span style={{ fontSize: '0.65rem', color: 'var(--accent)' }}>{getWristbandLabel(play)}</span>}
                                                    {play.staplesSlot && <span style={{ fontSize: '0.65rem', color: '#f59e0b', marginLeft: '4px' }}>[{play.staplesSlot}]</span>}
                                                </div>
                                            </div>

                                        </div>
                                    ))}
                                </div>
                            </>
                        ) : (
                            <>
                                <div style={{ flex: 1, overflowY: 'auto', display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                    <div style={{ padding: '0.5rem', background: 'rgba(56, 189, 248, 0.05)', borderRadius: '4px', marginBottom: '0.5rem' }}>
                                        <h4 style={{ fontSize: '0.8rem', marginBottom: '0.5rem' }}>Tempo Protocols</h4>
                                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '0.25rem' }}>
                                            {CALENDAR_CONSTANTS.PRACTICE_TEMPO_PROTOCOLS.map(p => (
                                                <button
                                                    key={p.id}
                                                    onClick={() => handleAddTempoRow(selectedCardId, p.id)}
                                                    className="btn btn-secondary"
                                                    style={{ fontSize: '0.7rem', padding: '4px' }}
                                                >
                                                    + {p.code}
                                                </button>
                                            ))}
                                        </div>
                                    </div>

                                    <h4 style={{ fontSize: '0.8rem', margin: '0.5rem 0' }}>Mini Scripts</h4>
                                    {miniScripts.map((script, idx) => (
                                        <div
                                            key={script.id || idx}
                                            onClick={() => handleAddScriptRows(selectedCardId, script)}
                                            style={{
                                                padding: '0.5rem',
                                                borderRadius: '4px',
                                                border: '1px solid var(--border)',
                                                background: 'var(--bg-panel)',
                                                cursor: 'pointer'
                                            }}
                                            onMouseEnter={e => e.currentTarget.style.borderColor = 'var(--accent)'}
                                            onMouseLeave={e => e.currentTarget.style.borderColor = 'var(--border)'}
                                        >
                                            <div style={{ fontWeight: 'bold', fontSize: '0.75rem' }}>{script.name}</div>
                                            <div style={{ fontSize: '0.7rem', color: 'var(--text-secondary)' }}>
                                                {script.playIds?.length || 0} plays
                                            </div>
                                        </div>
                                    ))}
                                    {miniScripts.length === 0 && (
                                        <div style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', textAlign: 'center', padding: '1rem' }}>
                                            No mini scripts found in game plan
                                        </div>
                                    )}
                                </div>
                            </>
                        )}
                    </div>

                    {/* Right: Main Content */}
                    <div style={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
                        {/* Header Tabs */}
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                            <div style={{ display: 'flex', gap: '0.5rem' }}>
                                {['staples', 'card1', 'card2', 'card3', 'card4', 'card5', 'card6'].map(id => (
                                    <button
                                        key={id}
                                        onClick={() => setSelectedCardId(id)}
                                        style={{
                                            padding: '0.5rem 1rem',
                                            borderRadius: '6px 6px 0 0',
                                            border: '1px solid var(--border)',
                                            borderBottom: selectedCardId === id ? '2px solid var(--accent)' : '1px solid var(--border)',
                                            background: selectedCardId === id ? 'var(--bg-panel)' : 'transparent',
                                            color: selectedCardId === id ? 'var(--text-primary)' : 'var(--text-secondary)',
                                            fontWeight: 'bold',
                                            cursor: 'pointer'
                                        }}
                                    >
                                        {id === 'card1' ? '100s' : (id === 'card2' ? '200s' : (id === 'card3' ? '300s' : (id === 'card4' ? '400s' : (id === 'card5' ? '500s' : (id === 'card6' ? '600s' : 'STAPLES')))))}
                                    </button>
                                ))}
                            </div>
                            <div style={{ display: 'flex', gap: '0.5rem' }}>
                                <button className="btn btn-secondary" onClick={() => onNavigate && onNavigate('print-hub')}>Print</button>
                                <button className="btn btn-danger" onClick={() => handleClearCard(selectedCardId)}>Clear Card</button>
                                <button className="btn btn-danger" onClick={handleClearBoth} style={{ fontWeight: 'bold' }}>Clear All</button>
                            </div>
                            {confirmModal && (
                                <div style={{
                                    position: 'fixed',
                                    top: 0,
                                    left: 0,
                                    right: 0,
                                    bottom: 0,
                                    backgroundColor: 'rgba(0,0,0,0.8)',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    zIndex: 9999
                                }}>
                                    <div style={{
                                        backgroundColor: 'var(--bg-panel)',
                                        padding: '2rem',
                                        borderRadius: '8px',
                                        maxWidth: '500px',
                                        textAlign: 'center',
                                        border: '1px solid var(--border)'
                                    }}>
                                        <h3 style={{ marginTop: 0 }}>Confirm Action</h3>
                                        <p>{confirmModal.message}</p>
                                        <div style={{ display: 'flex', gap: '1rem', justifyContent: 'center', marginTop: '1.5rem' }}>
                                            <button className="btn btn-secondary" onClick={() => setConfirmModal(null)}>Cancel</button>
                                            <button className="btn btn-danger" onClick={confirmClear}>Confirm</button>
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>


                        {/* Card Settings Bar */}
                        {activeCard && (
                            <div style={{
                                display: 'flex',
                                alignItems: 'center',
                                gap: '1rem',
                                padding: '0.75rem',
                                background: 'var(--bg-panel)',
                                border: '1px solid var(--border)',
                                borderRadius: '4px',
                                marginBottom: '1rem'
                            }}>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                    <label style={{ fontSize: '0.8rem', fontWeight: 'bold' }}>Layout:</label>
                                    <select
                                        className="form-input"
                                        style={{ width: 'auto', padding: '4px 8px' }}
                                        value={activeCard.type}
                                        onChange={e => handleLayoutChange(e.target.value)}
                                        disabled={selectedCardId === 'staples'}
                                    >
                                        <option value="standard">Standard (Traditional)</option>

                                        <option value="mini-scripts">Mini-Scripts</option>

                                        <option value="wiz">WIZ (16-slot grid)</option>

                                    </select>
                                </div>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                    <label style={{ fontSize: '0.8rem', fontWeight: 'bold' }}>Opponent:</label>
                                    <input
                                        className="form-input"
                                        style={{ width: '120px', padding: '4px 8px' }}
                                        onChange={e => updateCard(selectedCardId, { opp: e.target.value })}
                                        placeholder="Opponent"
                                    />
                                </div>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                    <label style={{ fontSize: '0.8rem', fontWeight: 'bold' }}>Iter:</label>
                                    <input
                                        style={{ width: '50px', padding: '4px 8px' }}
                                        value={activeCard.iter}
                                        onChange={e => updateCard(selectedCardId, { iter: e.target.value })}
                                        placeholder="1"
                                    />
                                </div>
                                {(activeCard.type === 'standard' || activeCard.type === 'audible') && (
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                        <label style={{ fontSize: '0.8rem', fontWeight: 'bold' }}>Color:</label>
                                        <select
                                            className="form-input"
                                            style={{ width: 'auto', padding: '4px 8px' }}
                                            value={activeCard.color || 'none'}
                                            onChange={e => updateCard(selectedCardId, { color: e.target.value })}
                                        >
                                            <option value="none">None (White)</option>
                                            <option value="green">Green</option>
                                            <option value="orange">Orange</option>
                                            <option value="red">Red</option>
                                            <option value="blue">Blue</option>
                                            <option value="yellow">Yellow</option>
                                            <option value="purple">Purple</option>
                                            <option value="teal">Teal</option>
                                            <option value="pink">Pink</option>
                                        </select>
                                    </div>
                                )}
                                {(activeCard.type === 'wiz') && (
                                    <>
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                            <label style={{ fontSize: '0.8rem', fontWeight: 'bold' }}>View:</label>
                                            <select
                                                className="form-input"
                                                style={{ width: 'auto', padding: '4px 8px' }}
                                                value={activeCard.wizView || 'skill'}
                                                onChange={e => updateCard(selectedCardId, { wizView: e.target.value })}
                                            >
                                                <option value="skill">Skill Positions</option>
                                                <option value="oline">O-Line</option>
                                            </select>
                                        </div>
                                    </>
                                )}
                            </div>
                        )}

                        {/* Rendering Logic */}
                        <div style={{ flex: 1, overflowY: 'auto', padding: '0.5rem' }}>
                            {selectedCardId === 'staples' ? (
                                <div style={{ maxWidth: '800px', width: '600px', margin: '0 auto', background: 'white', color: 'black', padding: '1.5rem', border: '2px solid #333', borderRadius: '8px', boxShadow: '0 4px 12px rgba(0,0,0,0.1)', aspectRatio: '5/3' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem', paddingBottom: '0.5rem', borderBottom: '2px solid var(--accent)' }}>
                                        <span style={{ fontWeight: 'bold', textTransform: 'uppercase' }}>STAPLES</span>
                                        <span style={{ fontWeight: 'bold' }}>10-89</span>
                                    </div>
                                    {renderSpreadsheetTable(getSlotsForCard(selectedCardId), 'standard-view', selectedCardId, 'STAPLES')}
                                </div>
                            ) : (activeCard.type === 'mini-scripts') ? (
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                                    <div style={{ display: 'flex', justifyContent: 'flex-end' }}>
                                        <button className="btn btn-secondary" onClick={() => handleAddHeaderRow(selectedCardId)} style={{ fontSize: '0.8rem' }}>+ Add Section Header</button>
                                    </div>
                                    {/* Modular Editor List */}
                                    <div style={{ flex: 1 }}>
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                            {/* Header */}
                                            <div style={{ display: 'grid', gridTemplateColumns: '40px 80px 1fr 80px 1fr 80px', gap: '0.5rem', padding: '0 0.5rem', fontSize: '0.75rem', fontWeight: 'bold', color: 'var(--text-secondary)' }}>
                                                <div style={{ textAlign: 'center' }}>#</div>
                                                <div style={{ textAlign: 'center' }}>Tempo</div>
                                                <div>Play A</div>
                                                <div style={{ textAlign: 'center' }}>Tempo</div>
                                                <div>Play B</div>
                                                <div></div>
                                            </div>
                                            {/* Rows */}
                                            {renderMiniScriptEditorRows(activeCard, selectedCardId)}
                                        </div>
                                    </div>

                                    {/* Split Preview */}
                                    <div style={{ width: '100%' }}>
                                        <h3 style={{ fontSize: '1rem', marginBottom: '1rem' }}>Preview</h3>
                                        {activeCard.type === 'mini-scripts' ? (
                                            <div style={{
                                                background: 'white',
                                                padding: '1rem',
                                                border: '2px solid #333',
                                                borderRadius: '4px',
                                                boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
                                                width: '100%',
                                                maxWidth: '600px',
                                                margin: '0 auto',
                                                aspectRatio: '5/3',
                                                color: 'black'
                                            }}>
                                                {/* Header REMOVED per user request
                                                <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem', paddingBottom: '0.5rem', borderBottom: '2px solid #333' }}>
                                                    <span style={{ fontWeight: 'bold', textTransform: 'uppercase', fontSize: '0.9rem' }}>{activeCard.opp || 'OPPONENT'}</span>
                                                    <span style={{ fontWeight: 'bold', fontSize: '0.9rem' }}>Card {selectedCardId === 'card1' ? '1' : (selectedCardId === 'card2' ? '2' : (selectedCardId === 'card3' ? '3' : (selectedCardId === 'card4' ? '4' : (selectedCardId === 'card5' ? '5' : '6'))))}{activeCard.iter ? ` - Iter ${activeCard.iter}` : ''}</span>
                                                </div>
                                                */}
                                                {renderSpreadsheetTable(getSlotsForCard(selectedCardId), 'modular-preview', selectedCardId, activeCard.opp || activeCard.opponent || '')}
                                            </div>
                                        ) : (
                                            <div style={{ maxWidth: '800px', width: '600px', margin: '0 auto', background: 'white', color: 'black', padding: '1.5rem', border: '2px solid #333', borderRadius: '8px', boxShadow: '0 4px 12px rgba(0,0,0,0.1)', aspectRatio: '5/3' }}>
                                                {/*
                                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem', paddingBottom: '0.5rem', borderBottom: '2px solid var(--accent)' }}>
                                                    <span style={{ fontWeight: 'bold', textTransform: 'uppercase' }}>{activeCard.opp || 'OPPONENT'}</span>
                                                    <span style={{ fontWeight: 'bold' }}>{selectedCardId === 'card1' ? '100s' : (selectedCardId === 'card2' ? '200s' : (selectedCardId === 'card3' ? '300s' : (selectedCardId === 'card4' ? '400s' : (selectedCardId === 'card5' ? '500s' : '600s'))))} (v{activeCard.iter || '1'})</span>
                                                </div>
                                                */}
                                                {renderSpreadsheetTable(getSlotsForCard(selectedCardId), 'standard-view', selectedCardId, activeCard.opp || activeCard.opponent || '')}
                                            </div>
                                        )}
                                    </div>
                                </div>
                            ) : activeCard ? (
                                <div style={{ maxWidth: '800px', width: '600px', margin: '0 auto', background: 'white', color: 'black', padding: '1.5rem', border: '2px solid #333', borderRadius: '8px', boxShadow: '0 4px 12px rgba(0,0,0,0.1)', aspectRatio: '5/3' }}>
                                    {/*
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem', paddingBottom: '0.5rem', borderBottom: '2px solid var(--accent)' }}>
                                        <span style={{ fontWeight: 'bold', textTransform: 'uppercase' }}>{activeCard.opp || 'OPPONENT'}</span>
                                        <span style={{ fontWeight: 'bold' }}>{selectedCardId === 'card1' ? '100s' : (selectedCardId === 'card2' ? '200s' : (selectedCardId === 'card3' ? '300s' : (selectedCardId === 'card4' ? '400s' : (selectedCardId === 'card5' ? '500s' : '600s'))))} (v{activeCard.iter || '1'})</span>
                                    </div>
                                    */}
                                    {activeCard.type === 'wiz' ? (
                                        <div style={{
                                            width: '100%',
                                            aspectRatio: '5 / 3',
                                            margin: '0 auto'
                                        }}>
                                            {renderWizGrid(
                                                getSlotsForCard(selectedCardId),
                                                `${activeCard.opponent || 'OPPONENT'} ${activeCard.iteration || '1'}`,
                                                activeCard.wizView || 'skill'
                                            )}
                                        </div>
                                    ) : activeCard.type === 'audible' ? (
                                        renderAudibleTable(getSlotsForCard(selectedCardId), 'standard-view', selectedCardId, activeCard.opp || activeCard.opponent || '')
                                    ) : (
                                        renderSpreadsheetTable(getSlotsForCard(selectedCardId), 'standard-view', selectedCardId, activeCard.opp || activeCard.opponent || '')
                                    )}
                                </div>
                            ) : null}\n                        </div>
                    </div>

                    {/* Print Layout (hidden on screen, shown when printing) */}
                    {selectedCardId === 'staples' ? (
                        <div className="wristband-print-container" style={{ display: 'none' }}>
                            <div className="wristband-print-grid">
                                {/* Render 4 identical copies of the Staples card */}
                                {[1, 2, 3, 4].map(copyNum => (
                                    <div key={copyNum} className="wristband-print-card">
                                        <>
                                            {/* Header */}
                                            <div className="print-card-header">
                                                <span>STAPLES</span>
                                                <span>10-89</span>
                                            </div>
                                            {/* Content */}
                                            <div className="print-card-content">
                                                {renderSpreadsheetTable(getSlotsForCard(selectedCardId), 'print-view', selectedCardId, 'STAPLES')}
                                            </div>
                                        </>
                                    </div>
                                ))}
                            </div>
                        </div>
                    ) : activeCard && (activeCard.type === 'wiz') ? (
                        <>
                            {/* Skill Version - Page 1 */}
                            <div className="wristband-print-container" style={{ display: 'none', pageBreakAfter: 'always' }}>
                                <div className="wristband-print-grid">
                                    {[1, 2, 3, 4].map(copyNum => (
                                        <div key={copyNum} className="wristband-print-card">
                                            {renderWizGrid(
                                                getSlotsForCard(selectedCardId),
                                                `${activeCard.opponent || 'OPPONENT'} ${activeCard.iteration || '1'}`,
                                                'skill'
                                            )}
                                        </div>
                                    ))}
                                </div>
                            </div>

                            {/* O-Line Version - Page 2 */}
                            <div className="wristband-print-container" style={{ display: 'none' }}>
                                <div className="wristband-print-grid">
                                    {[1, 2, 3, 4].map(copyNum => (
                                        <div key={copyNum} className="wristband-print-card">
                                            {renderWizGrid(
                                                getSlotsForCard(selectedCardId),
                                                `${activeCard.opponent || 'OPPONENT'} ${activeCard.iteration || '1'}`,
                                                'oline'
                                            )}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </>
                    ) : activeCard ? (
                        <div className="wristband-print-container" style={{ display: 'none' }}>
                            <div className="wristband-print-grid">
                                {/* Render 4 identical copies of the active card */}
                                {[1, 2, 3, 4].map(copyNum => {
                                    return (
                                        <div key={copyNum} className="wristband-print-card">
                                            <>
                                                {/* Header */}
                                                <div className="print-card-header">
                                                    <span>{activeCard.opp || 'OPPONENT'}</span>
                                                    <span>{selectedCardId === 'card1' ? '100s' : (selectedCardId === 'card2' ? '200s' : (selectedCardId === 'card3' ? '300s' : (selectedCardId === 'card4' ? '400s' : (selectedCardId === 'card5' ? '500s' : '600s'))))} (v{activeCard.iter || '1'})</span>
                                                </div>
                                                {/* Content */}
                                                <div className="print-card-content">
                                                    {activeCard.type === 'audible'
                                                        ? renderAudibleTable(getSlotsForCard(selectedCardId), 'print-view', selectedCardId, activeCard.opp || activeCard.opponent || '')
                                                        : renderSpreadsheetTable(getSlotsForCard(selectedCardId), 'print-view', selectedCardId, activeCard.opp || activeCard.opponent || '')
                                                    }
                                                </div>
                                            </>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    ) : null}
                </div>
            );

        };

        // New print card component for spreadsheet style

        // New print card component for spreadsheet style
        const WristbandPrintCardSpreadsheet = ({ title, slots, slotMap, colorClass }) => {
            // Split into two columns
            const mid = Math.ceil(slots.length / 2);
            const col1 = slots.slice(0, mid);
            const col2 = slots.slice(mid);

            const renderColumn = (columnSlots) => (
                <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                    <thead>
                        <tr>
                            <th style={{ width: '30px' }}>#</th>
                            <th>Play</th>
                        </tr>
                    </thead>
                    <tbody>
                        {columnSlots.map(slot => {
                            const play = slotMap[slot];
                            return (
                                <tr key={slot}>
                                    <td>{slot}</td>
                                    <td>{play?.name || ''}</td>
                                </tr>
                            );
                        })}
                    </tbody>
                </table>
            );

            return (
                <div className={`wristband-print-card-spreadsheet ${colorClass}`}>
                    <div className="card-header">{title}</div>
                    <div style={{ display: 'flex', height: 'calc(100% - 24px)' }}>
                        <div style={{ width: '50%', borderRight: '1px solid black' }}>
                            {renderColumn(col1)}
                        </div>
                        <div style={{ width: '50%' }}>
                            {renderColumn(col2)}
                        </div>
                    </div>
                </div>
            );
        };

        // --- HELPER FUNCTIONS & COMPONENTS ---
        const isOffenseSegment = (type) => {
            const offenseTypes = ['Team O', '7-on-7', 'Inside Run', 'Competition', 'O FUNDI', 'Take-Off', 'Goal Line', 'Short Yardage'];
            return offenseTypes.includes(type);
        };

        const migrateSegmentNotes = (segment) => {
            if (!segment.notes) {
                return { ...segment, notes: {} };
            }
            if (typeof segment.notes === 'string') {
                return {
                    ...segment,
                    notes: segment.notes ? { 'ALL_COACHES': segment.notes } : {}
                };
            }
            return segment;
        };

        const migrateScriptRowNotes = (row) => {
            if (!row.notes) return { ...row, notes: {} };
            if (typeof row.notes === 'string') {
                return { ...row, notes: { 'ALL_COACHES': row.notes } };
            }
            return row;
        };

        // --- NOTES MODAL COMPONENT (Re-implemented as top-level) ---
        const NotesModal = ({ plan, updateCurrentPlan, staff, segmentId, onClose, segment: providedSegment, onUpdateNotes }) => {
            if (!segmentId && !providedSegment) return null;

            // Use provided segment OR find it in the plan (safely)
            const segment = providedSegment || (
                segmentId === 'WARMUP'
                    ? { id: 'WARMUP', notes: plan?.warmupNotes || {} }
                    : plan?.segments?.find(s => s.id == segmentId)
            );

            if (!segment) return null;

            const migrated = segmentId === 'WARMUP'
                ? { notes: plan?.warmupNotes || {} }
                : migrateSegmentNotes(segment);

            // Helper to update notes
            const handleUpdateNotes = (staffId, value) => {
                // If a custom callback is provided, use it (e.g. for Pre-game Timeline)
                if (onUpdateNotes) {
                    onUpdateNotes(segment.id, staffId, value);
                    return;
                }

                const newNotes = { ...migrated.notes, [staffId]: value };

                if (segmentId === 'WARMUP') {
                    updateCurrentPlan({ ...plan, warmupNotes: newNotes });
                } else {
                    // Update segment in plan
                    const updatedSegments = plan.segments.map(s =>
                        s.id === segmentId ? { ...s, notes: newNotes } : s
                    );
                    updateCurrentPlan({ ...plan, segments: updatedSegments });
                }
            };

            // Get staff (all staff are coaches)
            const allStaff = staff || [];
            const coaches = allStaff.filter(s => !s.archived);

            return (
                <div
                    style={{
                        position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
                        backgroundColor: 'rgba(0, 0, 0, 0.5)', backdropFilter: 'blur(2px)',
                        display: 'flex', alignItems: 'center', justifyContent: 'center',
                        zIndex: 10000, padding: '2rem'
                    }}
                    onClick={onClose}
                >
                    <div
                        style={{
                            backgroundColor: 'var(--bg-panel)',
                            borderRadius: 'var(--radius)',
                            border: '1px solid var(--border)',
                            boxShadow: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',
                            width: '100%', maxWidth: '900px', maxHeight: '85vh',
                            display: 'flex', flexDirection: 'column', overflow: 'hidden'
                        }}
                        onClick={e => e.stopPropagation()}
                    >
                        {/* Header */}
                        <div style={{
                            padding: '1.25rem 1.5rem',
                            borderBottom: '1px solid var(--border)',
                            display: 'flex', justifyContent: 'space-between', alignItems: 'center',
                            background: 'var(--bg-main)'
                        }}>
                            <h3 style={{ margin: 0, fontSize: '1.1rem', fontWeight: 600, display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                <Icon name="FileText" size={18} />
                                {segmentId === 'WARMUP' ? 'Warmup Notes' : `Segment Notes: ${segment.type} (${segment.duration}m)`}
                            </h3>
                            <button
                                onClick={onClose}
                                style={{
                                    background: 'transparent', border: 'none', color: 'var(--text-secondary)',
                                    cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center',
                                    padding: '4px', borderRadius: '4px'
                                }}
                            >
                                <Icon name="X" size={20} />
                            </button>
                        </div>

                        {/* Content */}
                        <div style={{ padding: '1.5rem', overflowY: 'auto', flex: 1, backgroundColor: 'var(--bg-app)' }}>
                            <table style={{ width: '100%', borderCollapse: 'collapse', border: '1px solid var(--border)' }}>
                                <thead>
                                    <tr style={{ background: 'var(--bg-main)', borderBottom: '2px solid var(--border)' }}>
                                        <th style={{ padding: '0.75rem', textAlign: 'left', width: '30%', borderRight: '1px solid var(--border)' }}>Staff Member</th>
                                        <th style={{ padding: '0.75rem', textAlign: 'left' }}>Notes</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {/* Global Note */}
                                    <tr style={{ borderBottom: '1px solid var(--border)', background: '#fff' }}>
                                        <td style={{ padding: '0.75rem', borderRight: '1px solid var(--border)', fontWeight: 'bold', color: '#0f172a' }}>
                                            ALL COACHES
                                        </td>
                                        <td style={{ padding: '0.75rem' }}>
                                            <textarea
                                                className="form-input"
                                                rows={2}
                                                value={migrated.notes['ALL_COACHES'] || ''}
                                                onChange={(e) => handleUpdateNotes('ALL_COACHES', e.target.value)}
                                                placeholder="Enter notes visible to everyone..."
                                                style={{ width: '100%', resize: 'vertical', border: '1px solid #ccc', backgroundColor: '#fff', color: '#0f172a', fontFamily: 'inherit' }}
                                            />
                                        </td>
                                    </tr>

                                    {/* Coaches */}
                                    {coaches.length > 0 && (
                                        <>
                                            <tr style={{ background: 'var(--bg-main)', borderBottom: '1px solid var(--border)' }}>
                                                <td colSpan={2} style={{ padding: '0.5rem', fontWeight: 'bold', fontSize: '0.8rem', color: 'var(--text-secondary)' }}>COACHES</td>
                                            </tr>
                                            {coaches.map(coach => (
                                                <tr key={coach.id} style={{ borderBottom: '1px solid var(--border)', background: '#fff' }}>
                                                    <td style={{ padding: '0.75rem', borderRight: '1px solid var(--border)', fontWeight: 500, color: '#0f172a' }}>
                                                        {coach.name}
                                                    </td>
                                                    <td style={{ padding: '0.75rem' }}>
                                                        <textarea
                                                            className="form-input"
                                                            rows={1}
                                                            value={migrated.notes[coach.id] || ''}
                                                            onChange={(e) => handleUpdateNotes(coach.id, e.target.value)}
                                                            placeholder=""
                                                            style={{ width: '100%', resize: 'vertical', border: '1px solid #ccc', backgroundColor: '#fff', color: '#0f172a', fontFamily: 'inherit' }}
                                                        />
                                                    </td>
                                                </tr>
                                            ))}
                                        </>
                                    )}

                                    {/* Managers */}
                                    {managers.length > 0 && (
                                        <>
                                            <tr style={{ background: 'var(--bg-main)', borderBottom: '1px solid var(--border)' }}>
                                                <td colSpan={2} style={{ padding: '0.5rem', fontWeight: 'bold', fontSize: '0.8rem', color: 'var(--text-secondary)' }}>STAFF & MANAGERS</td>
                                            </tr>
                                            {managers.map(mgr => (
                                                <tr key={mgr.id} style={{ borderBottom: '1px solid var(--border)', background: '#fff' }}>
                                                    <td style={{ padding: '0.75rem', borderRight: '1px solid var(--border)', fontWeight: 500, color: '#0f172a' }}>
                                                        {mgr.name}
                                                    </td>
                                                    <td style={{ padding: '0.75rem' }}>
                                                        <textarea
                                                            className="form-input"
                                                            rows={1}
                                                            value={migrated.notes[mgr.id] || ''}
                                                            onChange={(e) => handleUpdateNotes(mgr.id, e.target.value)}
                                                            placeholder=""
                                                            style={{ width: '100%', resize: 'vertical', border: '1px solid #ccc', backgroundColor: '#fff', color: '#0f172a', fontFamily: 'inherit' }}
                                                        />
                                                    </td>
                                                </tr>
                                            ))}
                                        </>
                                    )}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            );
        };



        const ScriptRowNotesModal = ({ plan, updateSegment, staff, segmentId, rowId, onClose }) => {
            const segment = plan?.segments?.find(s => s.id === segmentId);
            if (!segment) return null;

            const scriptRow = segment.script?.find(r => r.id === rowId);
            if (!scriptRow) return null;

            const migratedRow = migrateScriptRowNotes(scriptRow);

            const handleUpdateNotes = (staffId, value) => {
                const newNotes = { ...migratedRow.notes, [staffId]: value };
                // Filter out empty notes
                if (!value || value.trim() === '') {
                    delete newNotes[staffId];
                }

                const newScript = segment.script.map(r =>
                    r.id === rowId ? { ...r, notes: newNotes } : r
                );
                updateSegment(segmentId, 'script', newScript);
            };

            const allStaff = staff || [];
            const coaches = allStaff.filter(s => !s.archived);

            return (
                <div
                    style={{
                        position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
                        backgroundColor: 'rgba(0, 0, 0, 0.5)', backdropFilter: 'blur(2px)',
                        display: 'flex', alignItems: 'center', justifyContent: 'center',
                        zIndex: 10001, padding: '2rem'
                    }}
                    onClick={onClose}
                >
                    <div
                        style={{
                            backgroundColor: 'var(--bg-panel)',
                            borderRadius: 'var(--radius)',
                            border: '1px solid var(--border)',
                            boxShadow: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',
                            width: '100%', maxWidth: '600px', maxHeight: '85vh',
                            display: 'flex', flexDirection: 'column', overflow: 'hidden'
                        }}
                        onClick={e => e.stopPropagation()}
                    >
                        <div style={{
                            padding: '1rem 1.5rem',
                            borderBottom: '1px solid var(--border)',
                            display: 'flex', justifyContent: 'space-between', alignItems: 'center',
                            background: 'var(--bg-main)'
                        }}>
                            <h3 style={{ margin: 0, fontSize: '1.1rem', fontWeight: 600 }}>
                                Notes for Play Row
                            </h3>
                            <button onClick={onClose} style={{ background: 'transparent', border: 'none', cursor: 'pointer' }}>
                                <Icon name="X" size={20} />
                            </button>
                        </div>

                        <div style={{ flex: 1, overflowY: 'auto', padding: '1.5rem' }}>
                            <div style={{ marginBottom: '1.5rem' }}>
                                <label style={{ display: 'block', fontWeight: 'bold', marginBottom: '0.5rem' }}>All Coaches</label>
                                <textarea
                                    className="form-input"
                                    style={{ width: '100%', minHeight: '80px' }}
                                    value={migratedRow.notes['ALL_COACHES'] || ''}
                                    onChange={e => handleUpdateNotes('ALL_COACHES', e.target.value)}
                                    placeholder="Shared notes..."
                                />
                            </div>
                            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}>
                                {coaches.map(coach => (
                                    <div key={coach.id}>
                                        <label style={{ fontWeight: 'bold', fontSize: '0.85rem' }}>{coach.name}</label>
                                        <textarea
                                            className="form-input"
                                            style={{ width: '100%', minHeight: '50px', fontSize: '0.85rem' }}
                                            value={migratedRow.notes[coach.id] || ''}
                                            onChange={e => handleUpdateNotes(coach.id, e.target.value)}
                                        />
                                    </div>
                                ))}
                            </div>
                        </div>
                        <div style={{ padding: '1rem', borderTop: '1px solid var(--border)', textAlign: 'right' }}>
                            <button className="btn btn-primary" onClick={onClose}>Done</button>
                        </div>
                    </div>
                </div>
            );
        };

        const MultiSelectDropdown = ({ options = [], value = [], onChange, placeholder = "Select...", className = "", center = false }) => {
            const [isOpen, setIsOpen] = useState(false);
            const [searchTerm, setSearchTerm] = useState("");
            const wrapperRef = useRef(null);

            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (wrapperRef.current && !wrapperRef.current.contains(event.target)) {
                        setIsOpen(false);
                    }
                };
                document.addEventListener("mousedown", handleClickOutside);
                return () => document.removeEventListener("mousedown", handleClickOutside);
            }, []);

            const toggleOption = (option) => {
                const newValue = value.includes(option)
                    ? value.filter(v => v !== option)
                    : [...value, option];
                onChange(newValue);
            };

            const filteredOptions = options.filter(opt => opt === '__ADD_CUSTOM__' ||
                opt.toLowerCase().includes(searchTerm.toLowerCase())
            );

            return (
                <div ref={wrapperRef} style={{ position: 'relative', width: '100%' }} className={className}>
                    <div
                        onClick={() => {
                            if (isOpen) setSearchTerm("");
                            setIsOpen(!isOpen);
                        }}
                        style={{
                            border: '1px solid #334155',
                            borderRadius: '0.375rem',
                            padding: '0.25rem 0.5rem',
                            fontSize: '0.875rem',
                            cursor: 'pointer',
                            background: 'var(--input-bg)',
                            minHeight: '30px',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: center ? 'center' : 'flex-start',
                            color: value.length === 0 ? '#9ca3af' : 'var(--text-primary)',
                            overflow: 'hidden',
                            textOverflow: 'ellipsis',
                            whiteSpace: 'nowrap'
                        }}
                    >
                        {value.length > 0 ? value.join(', ') : placeholder}
                    </div>
                    {isOpen && (
                        <div style={{
                            position: 'absolute',
                            zIndex: 50,
                            top: '100%',
                            left: 0,
                            right: 0,
                            marginTop: '0.25rem',
                            background: '#1e293b',
                            border: '1px solid #334155',
                            borderRadius: '0.375rem',
                            boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)',
                            maxHeight: '200px',
                            overflowY: 'auto'
                        }}>
                            <div style={{ position: 'sticky', top: 0, background: '#1e293b', zIndex: 10, borderBottom: '1px solid #334155' }}>
                                <input
                                    type="text"
                                    autoFocus
                                    placeholder="Search..."
                                    value={searchTerm}
                                    onClick={(e) => e.stopPropagation()}
                                    onChange={(e) => setSearchTerm(e.target.value)}
                                    style={{
                                        width: '100%',
                                        padding: '0.5rem',
                                        fontSize: '0.875rem',
                                        border: 'none',
                                        outline: 'none',
                                        background: '#1e293b',
                                        color: 'white'
                                    }}
                                />
                            </div>
                            {filteredOptions.length === 0 ? (
                                <div style={{ padding: '0.5rem', color: '#9ca3af', fontSize: '0.875rem' }}>
                                    No options found. {searchTerm && <span style={{ color: '#60a5fa', cursor: 'pointer' }} onClick={() => onChange([...value, searchTerm])}>Add "{searchTerm}"?</span>}
                                </div>
                            ) : (
                                filteredOptions.map(option => (
                                    <div
                                        key={option}
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            toggleOption(option);
                                        }}
                                        style={{
                                            padding: '0.5rem',
                                            cursor: 'pointer',
                                            fontSize: '0.875rem',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'space-between',
                                            background: value.includes(option) ? '#3b82f6' : 'transparent',
                                            color: value.includes(option) ? 'white' : '#cbd5e1',
                                        }}
                                        onMouseEnter={(e) => {
                                            if (!value.includes(option)) e.currentTarget.style.background = '#334155';
                                        }}
                                        onMouseLeave={(e) => {
                                            if (!value.includes(option)) e.currentTarget.style.background = 'transparent';
                                        }}
                                    >
                                        {option}
                                        {value.includes(option) && <span>✓</span>}
                                    </div>
                                ))
                            )}
                        </div>
                    )}
                </div>
            );
        };

        const PracticePlanPrintView = ({ plan, onBack, teamLogo = '🦅', weekData = {}, isBatchMode = false, coachFilter = 'ALL', roster, staff, selectedDay = null }) => {
            console.log('PracticePlanPrintView debug:', { plan, weekData, teamLogo });
            if (!plan) return <div className="p-4">No plan data available <button onClick={onBack} className="btn btn-secondary">Back</button></div>;

            const totalDuration = plan.segments.reduce((acc, seg) => acc + parseInt(seg.duration || 0), 0);

            const dateDisplay = React.useMemo(() => {
                // Priority 1: Use weekData.date (from currentWeek) with selectedDay offset
                if (weekData && weekData.date && selectedDay) {
                    let mondayDate = null;

                    // Try YYYY-MM-DD first (Split to avoid timezone shifts)
                    const parts = String(weekData.date).split('-');
                    if (parts.length === 3) {
                        const [y, m, d] = parts.map(Number);
                        if (y && m && d) {
                            mondayDate = new Date(y, m - 1, d);
                        }
                    }

                    // Fallback to standard parse if split failed
                    if (!mondayDate || isNaN(mondayDate.getTime())) {
                        const d = new Date(weekData.date);
                        if (!isNaN(d.getTime())) mondayDate = d;
                    }

                    if (mondayDate && !isNaN(mondayDate.getTime())) {
                        const dayOffsets = {
                            'Monday': 0, 'Tuesday': 1, 'Wednesday': 2, 'Thursday': 3, 'Friday': 4, 'Saturday': 5, 'Sunday': 6
                        };

                        const offset = dayOffsets[selectedDay] || 0;
                        const finalDate = new Date(mondayDate);
                        finalDate.setDate(mondayDate.getDate() + offset);

                        return finalDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });
                    }
                }

                // Priority 2: If selectedDay provided but no weekData.date, just show day name
                if (selectedDay) {
                    return selectedDay;
                }

                // Priority 3: Fallback to plan.date
                if (!plan.date) return 'Date TBD';
                let d = new Date(plan.date);
                if (!isNaN(d.getTime())) return d.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });
                if (/^\d{4}-\d{2}-\d{2}$/.test(plan.date)) {
                    d = new Date(plan.date + 'T12:00:00');
                    if (!isNaN(d.getTime())) return d.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });
                }
                return plan.date;
            }, [plan.date, selectedDay, weekData?.date]);

            // Time calculation helper
            let currentTime;
            if (plan.startTime) {
                currentTime = new Date(`2000-01-01T${plan.startTime}`);
                if (isNaN(currentTime.getTime())) currentTime = new Date('2000-01-01T00:00:00');
            } else {
                currentTime = new Date('2000-01-01T00:00:00');
            }
            const formatTime = (date) => date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' }).replace(' ', '');

            // Pre-practice notes
            const prePracticeNotes = plan.prePracticeNotes || plan.announcements;

            return (
                <div className="print-container" style={{ padding: '0.5in', background: 'white', minHeight: '100vh', color: 'black', fontFamily: 'sans-serif' }}>
                    <style>{`
                    @media print {
                        @page { margin: 0.3in; size: landscape; }
                        body { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
                        .no-print { display: none !important; }
                        .print-container { padding: 0 !important; width: 100% !important; max-width: none !important; margin: 0 !important; }
                        .page-break-avoid { break-inside: avoid; page-break-inside: avoid; }
                        .script-table-row { break-inside: avoid; page-break-inside: avoid; }
                    }
                    .compact-cell { padding: 2px 4px !important; font-size: 0.8rem; border: 1px solid #000; line-height: 1.2; }
                    .header-cell { padding: 2px 4px !important; background: #e5e7eb; border: 1px solid #000; font-weight: bold; font-size: 0.8rem; text-align: center; line-height: 1.2; }
                    `}</style>
                    {!isBatchMode && (
                        <div className="no-print" style={{ marginBottom: '1rem', display: 'flex', justifyContent: 'space-between' }}>
                            <button onClick={onBack} className="btn btn-secondary">
                                <Icon name="ArrowLeft" size={16} /> Back to Print Center
                            </button>
                            <button onClick={() => window.print()} className="btn btn-primary" style={{ display: 'flex', gap: '0.5rem', alignItems: 'center' }}>
                                <Icon name="Printer" size={16} /> Print Plan
                            </button>
                        </div>
                    )}
                    <header style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', borderBottom: '3px solid black', paddingBottom: '0.5rem', marginBottom: '0.5rem' }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                            <div style={{ height: '60px', display: 'flex', alignItems: 'center' }}>
                                {(teamLogo && (teamLogo.startsWith('http') || teamLogo.startsWith('data:'))) ? (
                                    <img src={teamLogo} alt="Logo" style={{ maxHeight: '100%', width: 'auto' }} />
                                ) : (
                                    <div style={{ fontSize: '2.5rem' }}>{teamLogo || '🦅'}</div>
                                )}
                            </div>
                            <div>
                                <h1 style={{ fontSize: '1.8rem', fontWeight: '800', margin: 0, textTransform: 'uppercase' }}>
                                    {`Week ${weekData?.weekNum || weekData?.week || '__'} vs. ${weekData?.opponent || '_______'} - ${dateDisplay}`}
                                </h1>
                            </div>
                        </div>
                        <div style={{ textAlign: 'right' }}>
                            <div style={{ fontSize: '1.2rem', fontWeight: 'bold' }}>Start: {formatTime(currentTime)}</div>
                            <div style={{ fontSize: '1rem' }}>Duration: {Math.floor(totalDuration / 60)}h {totalDuration % 60}m</div>
                        </div>
                    </header>

                    {/* Pre-Practice Notes */}
                    {
                        prePracticeNotes && (
                            <div style={{ border: '1px solid #000', padding: '0.5rem', marginBottom: '1rem', background: '#f9fafb', fontSize: '0.9rem' }}>
                                <strong>Pre-Practice Notes:</strong> <span style={{ whiteSpace: 'pre-wrap' }}>{prePracticeNotes}</span>
                            </div>
                        )
                    }

                    {/* Main Schedule Table */}
                    <table style={{ width: '100%', borderCollapse: 'collapse', marginBottom: '1rem' }}>
                        <thead>
                            <tr>
                                <th className="header-cell" style={{ width: '30px' }}>#</th>
                                <th className="header-cell" style={{ width: '60px' }}>Time</th>
                                <th className="header-cell" style={{ width: '40px' }}>Dur</th>
                                <th className="header-cell" style={{ width: '80px' }}>Phase</th>
                                <th className="header-cell" style={{ width: '100px' }}>Type</th>
                                <th className="header-cell" style={{ width: '120px' }}>Focus</th>
                                <th className="header-cell" style={{ width: '60px' }}>Contact</th>
                                <th className="header-cell">Notes</th>
                            </tr>
                        </thead>
                        <tbody>
                            {/* Period 0 / Warmup Row - Only show if showPeriodZero is enabled */}
                            {plan.showPeriodZero !== false && plan.warmupDuration > 0 && (
                                <tr style={{ breakInside: 'avoid', pageBreakInside: 'avoid' }}>
                                    <td className="compact-cell" style={{ textAlign: 'center', fontWeight: 'bold', color: '#f59e0b' }}>0</td>
                                    <td className="compact-cell" style={{ textAlign: 'center' }}>{formatTime(currentTime)}</td>
                                    <td className="compact-cell" style={{ textAlign: 'center' }}>{plan.warmupDuration}</td>
                                    <td className="compact-cell" style={{ textAlign: 'center' }}>{plan.warmupPhase || 'ALL'}</td>
                                    <td className="compact-cell" style={{ textAlign: 'center' }}>Warmup</td>
                                    <td className="compact-cell" style={{ textAlign: 'center' }}>
                                        {(() => {
                                            const parts = [];
                                            if (plan.warmupOffenseFocus) parts.push(`O: ${Array.isArray(plan.warmupOffenseFocus) ? plan.warmupOffenseFocus.join(', ') : plan.warmupOffenseFocus}`);
                                            if (plan.warmupDefenseFocus) parts.push(`D: ${Array.isArray(plan.warmupDefenseFocus) ? plan.warmupDefenseFocus.join(', ') : plan.warmupDefenseFocus}`);
                                            if (plan.warmupSituation && parts.length === 0) return Array.isArray(plan.warmupSituation) ? plan.warmupSituation.join(', ') : plan.warmupSituation;
                                            return parts.join(' / ') || '-';
                                        })()}
                                    </td>
                                    <td className="compact-cell" style={{ textAlign: 'center' }}>{plan.warmupContact || '-'}</td>
                                    <td className="compact-cell">
                                        {plan.warmupNotes && Object.entries(plan.warmupNotes)
                                            .filter(([_, note]) => note)
                                            .map(([coachId, note]) => (
                                                <div key={coachId}>{note}</div>
                                            ))}
                                    </td>
                                </tr>
                            )}
                            {/* Advance time past warmup if shown */}
                            {plan.showPeriodZero !== false && plan.warmupDuration > 0 && (() => { currentTime.setMinutes(currentTime.getMinutes() + parseInt(plan.warmupDuration)); return null; })()}
                            {plan.segments.map((seg, idx) => {
                                const startTimeStr = formatTime(currentTime);
                                currentTime.setMinutes(currentTime.getMinutes() + parseInt(seg.duration || 0));
                                const isRelevant = coachFilter === 'ALL' ||
                                    seg.staffId === coachFilter ||
                                    (seg.notes && typeof seg.notes === 'object' && seg.notes[coachFilter]);
                                if (!isRelevant) return null;

                                // Helper to format focus
                                const getFocusDisplay = (s) => {
                                    if (s.offenseFocus || s.defenseFocus) {
                                        const parts = [];
                                        if (s.offenseFocus) parts.push(`O: ${Array.isArray(s.offenseFocus) ? s.offenseFocus.join(', ') : s.offenseFocus}`);
                                        if (s.defenseFocus) parts.push(`D: ${Array.isArray(s.defenseFocus) ? s.defenseFocus.join(', ') : s.defenseFocus}`);
                                        return parts.join(' / ');
                                    }
                                    return Array.isArray(s.situation) ? s.situation.join(', ') : (s.situation || '-');
                                };

                                return (
                                    <tr key={idx} style={{ breakInside: 'avoid', pageBreakInside: 'avoid' }}>
                                        <td className="compact-cell" style={{ textAlign: 'center', fontWeight: 'bold' }}>{idx + 1}</td>
                                        <td className="compact-cell" style={{ textAlign: 'center' }}>{startTimeStr}</td>
                                        <td className="compact-cell" style={{ textAlign: 'center' }}>{seg.duration}</td>
                                        <td className="compact-cell" style={{ textAlign: 'center' }}>{seg.phase || 'ALL'}</td>
                                        <td className="compact-cell" style={{ textAlign: 'center' }}>{seg.type || '-'}</td>
                                        <td className="compact-cell" style={{ textAlign: 'center' }}>{getFocusDisplay(seg)}</td>
                                        <td className="compact-cell" style={{ textAlign: 'center' }}>{seg.contactLevel || '-'}</td>
                                        <td className="compact-cell">
                                            <div style={{ fontWeight: '600' }}>{seg.name}</div>
                                            {seg.notes ? (
                                                typeof seg.notes === 'string' ? (
                                                    <div>{seg.notes}</div>
                                                ) : (
                                                    Object.entries(seg.notes)
                                                        .filter(([coachId, note]) => {
                                                            const isGeneral = coachId === 'ALL_COACHES' || coachId === 'ALL';
                                                            if (coachFilter === 'ALL') return isGeneral;
                                                            return isGeneral || coachId === coachFilter;
                                                        })
                                                        .map(([coachId, note]) => (
                                                            <div key={coachId} style={{ marginTop: '2px' }}>
                                                                <strong style={{ color: '#666', marginRight: '4px' }}>
                                                                    {coachId === 'ALL_COACHES' || coachId === 'ALL' ? 'Staff' : (staff?.find(s => s.id === coachId)?.name || coachId)}:
                                                                </strong>
                                                                {note}
                                                            </div>
                                                        ))
                                                )
                                            ) : ''}
                                        </td>
                                    </tr>
                                );
                            })}
                        </tbody>
                    </table>

                    {/* Scripts Section */}
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                        {plan.segments.map((seg, idx) => {
                            // CRITICAL: Only show scripts if the "Script" checkbox is checked
                            if (!seg.hasScript) return null;

                            // Only show scripts if there's actual content (not just empty script arrays)
                            if (!seg.script || seg.script.length === 0) return null;

                            // Check if script has any actual content (playCall, situation, yardLine, etc.)
                            const hasActualContent = seg.script.some(row =>
                                row.playCall || row.situation || row.yardLine || row.hash
                            );
                            if (!hasActualContent) return null;

                            const isWarmup = seg.id === 'WARMUP';

                            return (
                                <div key={`script-${idx}`} className="page-break-avoid" style={{ border: '2px solid black', marginTop: '0.25rem', breakInside: 'avoid', pageBreakInside: 'avoid' }}>
                                    <div style={{ background: '#000', color: 'white', padding: '2px 6px', fontWeight: 'bold', display: 'flex', justifyContent: 'space-between', fontSize: '0.8rem' }}>
                                        <span>Script: {seg.name} ({seg.type})</span>
                                        <span>Phase: {seg.phase || seg.group || 'ALL'}</span>
                                    </div>
                                    <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '0.7rem' }}>
                                        <thead style={{ background: '#f3f4f6', borderBottom: '1px solid black' }}>
                                            <tr>
                                                <th style={{ padding: '2px', borderRight: '1px solid black', width: '25px', textAlign: 'center' }}>#</th>
                                                <th style={{ padding: '2px', borderRight: '1px solid black', width: '35px', textAlign: 'center' }}>Hash</th>
                                                <th style={{ padding: '2px', borderRight: '1px solid black', width: '50px', textAlign: 'center' }}>Dn</th>
                                                <th style={{ padding: '2px', borderRight: '1px solid black', width: '50px', textAlign: 'center' }}>Dist</th>
                                                <th style={{ padding: '2px', borderRight: '1px solid black', width: '80px', textAlign: 'center' }}>Situation</th>
                                                <th style={{ padding: '2px', borderRight: '1px solid black', textAlign: 'left' }}>Play Call</th>
                                                <th style={{ padding: '2px', borderRight: '1px solid black', width: '80px', textAlign: 'center' }}>Defense</th>
                                                <th style={{ padding: '2px', width: '280px', textAlign: 'left' }}>Notes</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {seg.script.map((row, rIdx) => {
                                                // Format notes for print
                                                let notesText = '';
                                                if (row.notes && typeof row.notes === 'object') {
                                                    const noteEntries = Object.entries(row.notes)
                                                        .filter(([_, note]) => note && note.trim())
                                                        .map(([coachId, note]) => {
                                                            const coachName = coachId === 'ALL_COACHES' || coachId === 'ALL'
                                                                ? 'Staff'
                                                                : (staff?.find(s => s.id === coachId)?.name || coachId);
                                                            return `${coachName}: ${note}`;
                                                        });
                                                    notesText = noteEntries.join('; ');
                                                } else if (typeof row.notes === 'string') {
                                                    notesText = row.notes;
                                                }

                                                return (
                                                    <tr key={rIdx} style={{ borderBottom: '1px solid #ddd' }}>
                                                        <td style={{ padding: '1px 2px', borderRight: '1px solid black', textAlign: 'center', fontWeight: 'bold' }}>{rIdx + 1}</td>
                                                        <td style={{ padding: '1px 2px', borderRight: '1px solid black', textAlign: 'center' }}>{row.hash || '-'}</td>
                                                        <td style={{ padding: '1px 2px', borderRight: '1px solid black', textAlign: 'center' }}>
                                                            {row.yardLine || '-'}
                                                        </td>
                                                        <td style={{ padding: '1px 2px', borderRight: '1px solid black', textAlign: 'center' }}>
                                                            {row.downDistance || '-'}
                                                        </td>
                                                        <td style={{ padding: '1px 2px', borderRight: '1px solid black', textAlign: 'center' }}>
                                                            {row.situation || '-'}
                                                        </td>
                                                        <td style={{ padding: '1px 2px', borderRight: '1px solid black', fontWeight: 'bold' }}>
                                                            {row.playName || row.playCall || '-'}
                                                        </td>
                                                        <td style={{ padding: '1px 2px', borderRight: '1px solid black', textAlign: 'center' }}>
                                                            {row.defense || '-'}
                                                        </td>
                                                        <td style={{ padding: '1px 2px', fontSize: '0.6rem', lineHeight: '1.1' }}>
                                                            {notesText || '-'}
                                                        </td>
                                                    </tr>
                                                );
                                            })}
                                        </tbody>
                                    </table>
                                </div>
                            );
                        })}
                    </div>

                    {/* Post-Practice Notes */}
                    {plan.postPracticeNotes && (
                        <div style={{ border: '1px solid #000', padding: '0.5rem', marginTop: '1rem', background: '#f9fafb', fontSize: '0.9rem' }}>
                            <strong>Post-Practice Notes:</strong> <span style={{ whiteSpace: 'pre-wrap' }}>{plan.postPracticeNotes}</span>
                        </div>
                    )}
                </div>
            );
        };

        const ScriptPrintView = ({ plan, onBack, teamLogo = '🦅', isBatchMode = false }) => {
            return (
                <div className="print-container" style={{ padding: '2rem', background: 'white', minHeight: '100vh', color: 'black' }}>
                    {!isBatchMode && (
                        <div className="no-print" style={{ marginBottom: '2rem', display: 'flex', justifyContent: 'space-between' }}>
                            <button onClick={onBack} className="btn btn-secondary">
                                <Icon name="ArrowLeft" size={16} /> Back
                            </button>
                            <button onClick={() => window.print()} className="btn btn-primary">
                                <Icon name="Printer" size={16} /> Print Script
                            </button>
                        </div>
                    )}
                    <h1 style={{ textAlign: 'center', fontSize: '2rem', textTransform: 'uppercase' }}>{teamLogo} {plan?.date ? new Date(plan.date + 'T12:00:00').toLocaleDateString('en-US', { weekday: 'long' }) : 'Day'} Practice Script</h1>
                    <div style={{ padding: '2rem', border: '1px solid black', textAlign: 'center', marginTop: '2rem', fontStyle: 'italic' }}>
                        Script content placeholder for {plan?.date || 'selected date'}...
                    </div>
                </div>
            );
        };

        const ScoutCardPrintView = ({ plan, onBack, teamLogo = '🦅', isBatchMode = false }) => {
            return (
                <div className="print-container" style={{ padding: '2rem', background: 'white', minHeight: '100vh', color: 'black' }}>
                    {!isBatchMode && (
                        <div className="no-print" style={{ marginBottom: '2rem', display: 'flex', justifyContent: 'space-between' }}>
                            <button onClick={onBack} className="btn btn-secondary">
                                <Icon name="ArrowLeft" size={16} /> Back
                            </button>
                            <button onClick={() => window.print()} className="btn btn-primary">
                                <Icon name="Printer" size={16} /> Print Cards
                            </button>
                        </div>
                    )}
                    <h1 style={{ textAlign: 'center', fontSize: '2rem', textTransform: 'uppercase' }}>{teamLogo} Scout Cards</h1>
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginTop: '2rem' }}>
                        {[1, 2, 3, 4].map(i => (
                            <div key={i} style={{ border: '2px dashed black', height: '300px', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                                CARD {i}
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        const BatchPrintContainer = ({ components, onBack }) => {
            return (
                <div style={{ width: '100%' }}>
                    <style>{`
        @media print {
            @page { margin: 0; }
                            body { -webkit - print - color - adjust: exact; }
                            .no - print { display: none!important; }
        }
        `}</style>
                    <div className="no-print" style={{ padding: '1rem', background: '#333', color: 'white', marginBottom: '1rem', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                        <div>
                            <strong>Batch Print Preview</strong> - {components.length} pages ready.
                        </div>
                        <div style={{ display: 'flex', gap: '1rem' }}>
                            <button onClick={onBack} className="btn btn-secondary"><Icon name="ArrowLeft" /> Back</button>
                            <button onClick={() => window.print()} className="btn btn-primary"><Icon name="Printer" /> Print Batch</button>
                        </div>
                    </div>
                    {components.map((Comp, idx) => (
                        <div key={idx} style={{ pageBreakAfter: 'always', display: 'block' }}>
                            {Comp}
                        </div>
                    ))}
                </div>
            );
        };

        const PracticeScriptBuilder = ({ mode = 'plan', plays, plans, onUpdatePlans, onUpdateGamePlan, onUpdatePlay, staff, customFocusItems, addCustomFocusItem, user, isLocked, isSiteAdmin, segmentTypes = [], focusItems = [], segmentTypesMap = {}, focusItemsMap = {}, segmentSettings = {}, scriptPresets = [], gamePlan = {}, gamePlanLayouts = {}, playBuckets = [], playCategories = [], weeks = [], currentWeek = {}, onQuickAddPlay, setAppSidebarCollapsed, appSidebarCollapsed, closeSideMenuRef, roster, teamLogo, addToNextSlotRef, onNavigate }) => {
            console.log('PracticeScriptBuilder debug:', { currentWeek, teamLogo });
            const { openPlayDetails } = usePlayDetailsModal();

            const [selectedDay, setSelectedDay] = useState('Monday');
            const [selectedSegmentId, setSelectedSegmentId] = useState(null);
            const [searchTerm, setSearchTerm] = useState('');
            const [selectedCoachFilter, setSelectedCoachFilter] = useState('ALL');
            const [selectedNotesCoach, setSelectedNotesCoach] = useState('ALL_COACHES');
            const [showSideMenu, setShowSideMenu] = useState(false);
            const [editingScriptRow, setEditingScriptRow] = useState(null);

            const [isFullScreen, setIsFullScreen] = useState(false);
            const [scoutCardUrls, setScoutCardUrls] = useState({}); // Session-only storage for blob URLs { [segmentId]: string }
            const [includePlayCards, setIncludePlayCards] = useState(false);
            const [customInputState, setCustomInputState] = useState(null); // { id: string, field: string }
            const [globalTemplates, setGlobalTemplates] = useState([]);
            const [notesModalSegmentId, setNotesModalSegmentId] = useState(null); // Track which segment's notes modal is open
            const [gameplanDropdownOpen, setGameplanDropdownOpen] = useState(false);

            // Effect to collapse global sidebar when local side menu is opened
            useEffect(() => {
                if (setAppSidebarCollapsed && showSideMenu) {
                    setAppSidebarCollapsed(true);
                }
            }, [showSideMenu, setAppSidebarCollapsed]);

            // Effect to close side menu when global sidebar is expanded
            useEffect(() => {
                console.log('Sidebar effect:', { appSidebarCollapsed, showSideMenu });
                if (appSidebarCollapsed === false && showSideMenu) {
                    console.log('Closing side menu because sidebar expanded');
                    setShowSideMenu(false);
                }
            }, [appSidebarCollapsed, showSideMenu]);

            // Register close function with ref if provided
            useEffect(() => {
                if (closeSideMenuRef) {
                    closeSideMenuRef.current = () => setShowSideMenu(false);
                }
                return () => {
                    if (closeSideMenuRef) closeSideMenuRef.current = null;
                };
            }, [closeSideMenuRef]);

            // Register "add to next slot" handler for sidebar
            useEffect(() => {
                if (addToNextSlotRef) {
                    addToNextSlotRef.current = (playIdOrIds, play) => {
                        // Support both single play and array of play IDs
                        const playIds = Array.isArray(playIdOrIds) ? playIdOrIds : [playIdOrIds];

                        // Get current day's plan
                        const dayPlan = Array.isArray(plans)
                            ? plans.find(p => p.day === selectedDay)
                            : plans[selectedDay];
                        if (!dayPlan) return;

                        // Find selected segment or first segment with script
                        let targetSegment = null;
                        if (selectedSegmentId) {
                            targetSegment = (dayPlan.segments || []).find(s => s.id === selectedSegmentId);
                        }
                        if (!targetSegment) {
                            targetSegment = (dayPlan.segments || []).find(s => s.hasScript && s.script);
                        }
                        if (!targetSegment || !targetSegment.script) return;

                        // Add each play to consecutive empty slots
                        const updatedScript = [...targetSegment.script];
                        let slotsAdded = 0;

                        for (const playId of playIds) {
                            // Find next empty row starting from where we left off
                            const emptyRowIndex = updatedScript.findIndex((row, idx) =>
                                idx >= slotsAdded && (!row.play || row.play.trim() === '')
                            );
                            if (emptyRowIndex === -1) break; // No more empty slots

                            // Look up play name if we have a play ID
                            const foundPlay = plays.find(p => p.id === playId);
                            const playName = play?.name || foundPlay?.name || playId;

                            updatedScript[emptyRowIndex] = {
                                ...updatedScript[emptyRowIndex],
                                play: playName
                            };
                            slotsAdded++;
                        }

                        if (slotsAdded === 0) return; // Nothing was added

                        const updatedSegment = { ...targetSegment, script: updatedScript };
                        const updatedSegments = (dayPlan.segments || []).map(s =>
                            s.id === targetSegment.id ? updatedSegment : s
                        );
                        const updatedPlan = { ...dayPlan, segments: updatedSegments };

                        if (Array.isArray(plans)) {
                            const updatedPlans = plans.map(p => p.day === selectedDay ? updatedPlan : p);
                            onUpdatePlans(updatedPlans);
                        } else {
                            onUpdatePlans({ ...plans, [selectedDay]: updatedPlan });
                        }
                    };
                }
                return () => {
                    if (addToNextSlotRef) addToNextSlotRef.current = null;
                };
            }, [addToNextSlotRef, plans, plays, selectedDay, selectedSegmentId, onUpdatePlans]);

            console.log('PracticeScriptBuilder render. notesModalSegmentId:', notesModalSegmentId);

            // Fetch global practice templates from Firestore
            useEffect(() => {
                const fetchGlobalTemplates = async () => {
                    try {
                        const snapshot = await window.db.collection('global_templates')
                            .where('type', '==', 'practice_plan')
                            .get();
                        const templates = snapshot.docs.map(doc => ({
                            id: doc.id,
                            name: doc.data().name,
                            category: doc.data().category,
                            segments: doc.data().data?.segments || []
                        }));
                        setGlobalTemplates(templates);
                    } catch (err) {
                        console.error("Error fetching global templates:", err);
                    }
                };
                fetchGlobalTemplates();
            }, []);

            // Helper to handle keyboard navigation in script inputs
            const handleScriptInputKeyDown = (e, segmentId, rowId, fieldName, rows, onUpdate) => {
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    // Find index of current row
                    const currentIndex = rows.findIndex(r => r.id === rowId);
                    if (currentIndex > 0) {
                        const prevRow = rows[currentIndex - 1];
                        const inputId = `input-${segmentId}-${prevRow.id}-${fieldName}`;
                        const el = document.getElementById(inputId);
                        if (el) el.focus();
                    }
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    const currentIndex = rows.findIndex(r => r.id === rowId);
                    if (currentIndex < rows.length - 1) {
                        const nextRow = rows[currentIndex + 1];
                        const inputId = `input-${segmentId}-${nextRow.id}-${fieldName}`;
                        const el = document.getElementById(inputId);
                        if (el) el.focus();
                    }
                } else if ((e.ctrlKey || e.metaKey) && (e.key === 'd' || e.key === 'D')) {
                    e.preventDefault(); // Prevent bookmark shortcut
                    const currentIndex = rows.findIndex(r => r.id === rowId);
                    if (currentIndex > 0) {
                        const prevRow = rows[currentIndex - 1];
                        // Copy value from previous row
                        const valueToCopy = prevRow[fieldName];
                        if (valueToCopy !== undefined) {
                            // Determine new script
                            const newScript = rows.map(r => r.id === rowId ? { ...r, [fieldName]: valueToCopy } : r);
                            if (onUpdate) onUpdate(newScript);
                        }
                    }
                }
            };

            const handlePlayDrop = (e, segmentId, rowId, rows, onUpdate) => {
                e.preventDefault();
                try {
                    const data = e.dataTransfer.getData('application/react-dnd');
                    if (data) {
                        const { playId, name } = JSON.parse(data);
                        const newScript = rows.map(r => r.id === rowId ? { ...r, playName: name, playId: playId } : r);
                        if (onUpdate) onUpdate(newScript);
                    }
                } catch (err) {
                    console.error('Failed to parse dropped play data:', err);
                }
            };

            // Merge hardcoded and global templates
            const allTemplates = [
                ...CALENDAR_CONSTANTS.PRACTICE_TEMPLATES,
                ...globalTemplates
            ];

            // const focusItems = ... (Removed, using prop)
            // Derive Game Plan Focus Items
            const gamePlanFocusItems = React.useMemo(() => {
                const items = new Set();

                // 1. From Layouts (Headers)
                if (gamePlanLayouts?.CALL_SHEET?.sections) {
                    gamePlanLayouts.CALL_SHEET.sections.forEach(section => {
                        if (section.boxes) {
                            section.boxes.forEach(box => {
                                if (box.header) items.add(`GP: ${box.header}`);
                            });
                        }
                    });
                }

                // 2. From Game Plan Data (Scripts & Sets created)
                if (gamePlan) {
                    if (gamePlan.miniScripts) {
                        Object.values(gamePlan.miniScripts).forEach(s => {
                            if (s.name) items.add(`GP: ${s.name}`);
                        });
                    }
                    if (gamePlan?.sets) {
                        Object.values(gamePlan?.sets).forEach(s => {
                            if (s.name) items.add(`GP: ${s.name}`);
                        });
                    }
                }
                return Array.from(items);
            }, [gamePlanLayouts, gamePlan]);

            const baseFocusItems = focusItems.length > 0 ? focusItems : ['Base Downs', 'Convert Downs', 'Red Zone', 'Gold Zone', 'Fringe', 'Goalline/Short YDG', 'Play Action', 'Motion', 'Tackling', 'Turnover', 'Pursuit', 'Board drill', 'Joust', 'Kickoff', 'Kick Return', 'Punt', 'Punt Return', 'Field Goal', 'Onside', 'Hands Team'];

            // Effect to manage body class for printing
            useEffect(() => {
                document.body.classList.add('allow-portal-print');
                return () => document.body.classList.remove('allow-portal-print');
            }, []);

            const availableFocusItems = [...new Set([...baseFocusItems, ...gamePlanFocusItems])];
            const availableSegmentTypes = segmentTypes.length > 0 ? segmentTypes : ['Competition', 'Take-Off', 'Fundi', '7-on-7', 'Inside Run', 'Team', 'Team Stationary', 'Circuit', 'Specials', 'Conditioning', 'Ghost Script', 'One-on-Ones'];

            // Scripts/Plays Data for Side Panel (Hoisted to top level)
            const gpPlays = React.useMemo(() => {
                const ids = new Set();
                if (gamePlan?.miniScripts) Object.values(gamePlan.miniScripts).forEach(s => s.assignedPlayIds?.forEach(id => ids.add(id)));
                if (gamePlan?.sets) Object.values(gamePlan.sets).forEach(s => s.assignedPlayIds?.forEach(id => ids.add(id)));
                return plays.filter(p => ids.has(p.id));
            }, [gamePlan, plays]);


            const priorityPlays = React.useMemo(() => plays.filter(p => p.priority), [plays]);

            // Replicated weekStats logic for Side Menu
            const weekStats = React.useMemo(() => {
                // Calculate unique plays in game plan
                const allGamePlanPlayIds = new Set();
                Object.values(gamePlan?.sets || {}).forEach(set => {
                    (set.playIds || []).forEach(item => {
                        const id = typeof item === 'object' ? item.id : item;
                        if (id) allGamePlanPlayIds.add(id);
                    });
                });
                Object.values(gamePlan?.miniScripts || {}).forEach(script => {
                    (script.playIds || []).forEach(item => {
                        const id = typeof item === 'object' ? item.id : item;
                        if (id) allGamePlanPlayIds.add(id);
                    });
                });
                const uniquePlaysCount = allGamePlanPlayIds.size;

                // Calculate new plays (plays added this week that weren't in previous weeks)
                const previousWeekPlayIds = new Set();
                weeks.forEach(w => {
                    if (w.weekNumber < currentWeek.weekNumber) {
                        const prevGamePlan = w.gamePlan || {};
                        Object.values(prevGamePlan.sets || {}).forEach(set => {
                            (set.playIds || []).forEach(item => {
                                const id = typeof item === 'object' ? item.id : item;
                                if (id) previousWeekPlayIds.add(id);
                            });
                        });
                        Object.values(prevGamePlan.miniScripts || {}).forEach(script => {
                            (script.playIds || []).forEach(item => {
                                const id = typeof item === 'object' ? item.id : item;
                                if (id) previousWeekPlayIds.add(id);
                            });
                        });
                    }
                });
                const newPlaysCount = Array.from(allGamePlanPlayIds).filter(id => !previousWeekPlayIds.has(id)).length;

                // Calculate total practice script slots for the week
                let totalScriptSlots = 0;
                const plansList = Array.isArray(plans) ? plans : Object.values(plans || {});

                plansList.forEach(p => {
                    (p.segments || []).forEach(seg => {
                        if (seg.hasScript && seg.script) {
                            totalScriptSlots += seg.script.length;
                        }
                    });
                });

                return { uniquePlaysCount, newPlaysCount, totalScriptSlots };
            }, [gamePlan, weeks, currentWeek, plans]);

            // Helper functions for phase-based filtering
            const getSegmentTypesForPhase = (phase) => {
                if (!phase || phase === 'ALL' || phase === 'C') {
                    // Return all types combined
                    const all = new Set([
                        ...(segmentTypesMap.OFFENSE || []),
                        ...(segmentTypesMap.DEFENSE || []),
                        ...(segmentTypesMap.SPECIAL_TEAMS || [])
                    ]);
                    // Add defaults if custom types are empty/missing, or use availableSegmentTypes as fallback
                    if (all.size === 0) return availableSegmentTypes;
                    return Array.from(all).sort();
                }

                let types = [];
                if (phase === 'O') types = segmentTypesMap.OFFENSE || [];
                else if (phase === 'D') types = segmentTypesMap.DEFENSE || [];
                else if (phase === 'K') types = segmentTypesMap.SPECIAL_TEAMS || [];

                return types.length > 0 ? types : availableSegmentTypes;
            };

            const getFocusItemsForPhase = (phase) => {
                let items = [];
                if (!phase || phase === 'ALL' || phase === 'C') {
                    // Return all items combined
                    const all = new Set([
                        ...(focusItemsMap.OFFENSE || []),
                        ...(focusItemsMap.DEFENSE || []),
                        ...(focusItemsMap.SPECIAL_TEAMS || []),
                        // Add All Play Buckets to ALL view
                        ...(playBuckets.map(b => b.label) || [])
                    ]);
                    items = Array.from(all);
                } else {
                    if (phase === 'O') {
                        items = focusItemsMap.OFFENSE || [];
                        // Add Play Buckets only to Offense phase
                        const bucketLabels = playBuckets.map(b => b.label);
                        items = [...items, ...bucketLabels];
                    }
                    else if (phase === 'D') items = focusItemsMap.DEFENSE || [];
                    else if (phase === 'K') items = focusItemsMap.SPECIAL_TEAMS || [];
                }

                // Always add Game Plan items
                const combined = new Set([...items, ...gamePlanFocusItems]);
                if (combined.size === 0) return availableFocusItems;

                return Array.from(combined).sort();
            };



            const saveAsGlobalTemplate = async () => {
                const name = prompt("Enter a name for this Template:");
                if (!name) return;

                const category = prompt("Enter a category (e.g. 'Monday', 'Situations', 'Base Install'):", selectedDay);

                try {
                    // Sanitize segments for template (only keeping structure, not specific data like staffId or scripts if they are too specific, 
                    // though user asked to save "it", so we keep types and durations and hasScript flag)
                    const templateSegments = plan.segments.map(seg => ({
                        type: seg.type,
                        duration: seg.duration,
                        situation: seg.situation || '',
                        hasScript: !!seg.hasScript
                    }));

                    await window.db.collection('global_templates').add({
                        type: 'practice_plan',
                        name: name,
                        category: category || '',
                        data: {
                            segments: templateSegments
                        },
                        createdAt: new Date().toISOString(),
                        createdBy: user?.email || 'Admin'
                    });

                    alert(`Template "${name}" saved successfully!`);

                    // Trigger a re-fetch of global templates to update the dropdown immediately
                    const fetchGlobalTemplates = async () => {
                        const snapshot = await window.db.collection('global_templates')
                            .where('type', '==', 'practice_plan')
                            .get();
                        const templates = snapshot.docs.map(doc => ({
                            id: doc.id,
                            name: doc.data().name,
                            category: doc.data().category,
                            segments: doc.data().data?.segments || []
                        }));
                        setGlobalTemplates(templates);
                    };
                    fetchGlobalTemplates();

                } catch (err) {
                    console.error("Error saving global template:", err);
                    alert("Error saving template. Check console for details.");
                }
            };

            const loadTemplate = (templateName) => {
                if (!templateName) return;
                const template = allTemplates.find(t => t.name === templateName);
                if (!template) return;

                if (confirm(`Load "${templateName}"? This will overwrite the current segments for ${selectedDay}.`)) {
                    const newSegments = template.segments.map(seg => ({
                        id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                        duration: seg.duration,
                        type: seg.type,
                        situation: seg.situation || '',
                        notes: {},
                        script: [],
                        staffId: '',
                        hasScript: !!seg.hasScript,
                        hasScoutCards: false
                    }));

                    updateCurrentPlan({
                        ...plan,
                        segments: newSegments
                    });
                }
            };

            const defaultPlan = {
                id: Date.now().toString(),
                date: new Date().toISOString().split('T')[0],
                startTime: '15:40',
                warmupDuration: 5,
                warmupNotes: {},
                warmupScript: [],
                warmupStaffId: '',
                prePracticeNotes: '',
                postPracticeNotes: '',
                segments: []
            };

            const plan = plans[selectedDay] ? { ...defaultPlan, ...plans[selectedDay] } : defaultPlan;

            // Helper to update the specific day's plan
            const updateCurrentPlan = (newPlan) => {
                onUpdatePlans({
                    ...plans,
                    [selectedDay]: newPlan
                });
            };

            // Helper to find preset based on Type and Situation (Focus)
            const findPreset = (type, situation) => {
                const normalize = (str) => (str || '').trim().toLowerCase().replace(/s$/, ''); // Remove trailing s
                const t = (type || '').trim().toLowerCase();
                const sitVal = Array.isArray(situation) ? (situation[0] || '') : situation;
                const s = normalize(sitVal);

                // 0. Explicit Type + Focus Match
                const exactExplicit = scriptPresets.find(p =>
                    p.type && p.type.toLowerCase() === t &&
                    p.focus && normalize(p.focus) === s
                );
                if (exactExplicit) return exactExplicit;

                // 1. Try Specific Combos (Legacy Name)
                if (t && s) {
                    const match = scriptPresets.find(p => {
                        const n = p.name.trim().toLowerCase();
                        // Use sitVal (first item) for matching, avoid calling toLowerCase on array
                        const val = typeof sitVal === 'string' ? sitVal.toLowerCase() : '';
                        return n === `${t} - ${val}` || n.includes(s);
                    });
                    if (match) return match;
                }

                // 2. Explicit Focus Match (Rare but possible)
                if (s) {
                    const focusExplicit = scriptPresets.find(p =>
                        p.focus && normalize(p.focus) === s && (!p.type || !p.type.trim())
                    );
                    if (focusExplicit) return focusExplicit;
                }

                // 3. Try Situation (Legacy Name)
                if (s) {
                    const match = scriptPresets.find(p => {
                        const n = normalize(p.name);
                        return n === s;
                    });
                    if (match) return match;
                }

                // 4. Explicit Type Match (Generic)
                if (t) {
                    const typeExplicit = scriptPresets.find(p =>
                        p.type && p.type.toLowerCase() === t && (!p.focus || !p.focus.trim())
                    );
                    if (typeExplicit) return typeExplicit;
                }

                // 5. Try Type (Legacy Name)
                if (t) {
                    const match = scriptPresets.find(p => p.name.trim().toLowerCase() === t);
                    if (match) return match;
                }

                return null;
            };

            const ensureScriptSlots = (currentScript, duration, segmentType = '', segmentSituation = '') => {
                const targetCount = Math.round((parseInt(duration) || 0) * 1.6) || 0;

                // Find matching preset
                // Note: scriptPresets is available in scope (passed as prop)
                const preset = findPreset(segmentType, segmentSituation);

                const PATTERN_A = ['L', 'LM', 'M', 'RM', 'R', 'RM', 'M', 'LM'];
                const PATTERN_B = ['R', 'RM', 'M', 'LM', 'L', 'LM', 'M', 'RM'];

                let pattern = Math.random() > 0.5 ? PATTERN_A : PATTERN_B;
                if (currentScript && currentScript.length > 0 && currentScript[0].hash) {
                    if (currentScript[0].hash === 'L') pattern = PATTERN_A;
                    else if (currentScript[0].hash === 'R') pattern = PATTERN_B;
                }

                const GHOST_SEQUENCE = [
                    'COIN TOSS', 'KICKOFF', 'TEAM D', 'PUNT RETURN', 'TEAM O', 'PAT',
                    'BACKED-UP PUNT', 'TEAM D', 'PAT BLOCK', 'KICKOFF RET', 'TEAM O',
                    'PUNT', 'HALFTIME', 'HANDS TEAM', 'HAIL MARY', '2-PT PLAY',
                    'ONSIDE KICK', 'PREVENT DEFENSE', 'VICTORY'
                ];

                let processedScript = [...(currentScript || [])];

                processedScript = processedScript.map((slot, i) => {
                    let newSlot = { ...slot };
                    let changed = false;

                    // Apply Preset Data (YardLines, Hashes, Situations from preset)
                    if (preset && preset.items && preset.items.length > 0) {
                        const pItem = preset.items[i % preset.items.length];

                        if (preset.useYardLine) {
                            if (pItem.yardLine && !newSlot.yardLine) { newSlot.yardLine = pItem.yardLine; changed = true; }
                            if (pItem.hash && !newSlot.hash) { newSlot.hash = pItem.hash; changed = true; }
                            if (pItem.down && !newSlot.downDistance) { newSlot.downDistance = pItem.down; changed = true; }
                            if (newSlot.situation) { delete newSlot.situation; changed = true; }
                        } else {
                            if (pItem.situation && !newSlot.situation) { newSlot.situation = pItem.situation; changed = true; }
                            if (newSlot.yardLine) { delete newSlot.yardLine; changed = true; }
                        }
                    }

                    // Fallback Defaults
                    if (!newSlot.hash) {
                        newSlot.hash = pattern[i % 8];
                        changed = true;
                    }

                    // Ghost Script Legacy Fallback
                    if (segmentType === 'Ghost Script' && !preset) {
                        if (!newSlot.situation && i < GHOST_SEQUENCE.length) {
                            newSlot.situation = GHOST_SEQUENCE[i];
                            changed = true;
                        }
                    }

                    return changed ? newSlot : slot;
                });

                let needed = targetCount - processedScript.length;
                if (segmentType === 'Ghost Script' && !preset && processedScript.length < GHOST_SEQUENCE.length) {
                    needed = GHOST_SEQUENCE.length - processedScript.length;
                }

                if (needed <= 0) return processedScript;

                const newSlots = Array(needed).fill(0).map((_, i) => {
                    const seqIndex = processedScript.length + i;
                    const slot = {
                        id: Date.now().toString() + Math.random(),
                        playId: '',
                        playName: '',
                        hash: pattern[seqIndex % 8]
                    };

                    if (preset && preset.items && preset.items.length > 0) {
                        const pItem = preset.items[seqIndex % preset.items.length];
                        if (preset.useYardLine) {
                            slot.yardLine = pItem.yardLine || '';
                            slot.downDistance = pItem.down || '';
                            if (pItem.hash) slot.hash = pItem.hash;
                        } else {
                            slot.situation = pItem.situation || '';
                            if (pItem.hash) slot.hash = pItem.hash;
                        }
                    } else if (segmentType === 'Ghost Script') {
                        slot.situation = seqIndex < GHOST_SEQUENCE.length ? GHOST_SEQUENCE[seqIndex] : '';
                    } else {
                        slot.situation = '';
                    }

                    return slot;
                });

                return [...processedScript, ...newSlots];
            };










            // Calculate segment times and ensure script consistency automatically
            useEffect(() => {
                if (!plan) return;

                let currentTime = new Date(`2000-01-01T${plan.startTime}`);

                // Add warmup offset
                if (plan.warmupDuration) {
                    currentTime.setMinutes(currentTime.getMinutes() + parseInt(plan.warmupDuration));
                }

                const updatedSegments = plan.segments.map((seg, index) => {
                    // Format as 12-hour time without AM/PM (e.g. 3:40)
                    let hours = currentTime.getHours();
                    const minutes = currentTime.getMinutes();
                    hours = hours % 12 || 12; // Convert to 12-hour format
                    const segStartTime = `${hours}:${minutes.toString().padStart(2, '0')}`;

                    // Add duration for next segment
                    currentTime.setMinutes(currentTime.getMinutes() + parseInt(seg.duration || 0));

                    // Ensure script slots are correct (including Take-Off yardlines)
                    const updatedScript = ensureScriptSlots(seg.script || [], parseInt(seg.duration || 0), seg.type, seg.situation);

                    // Force clear situation/focus for Ghost Script to resolve rendering issues
                    if (seg.type === 'Ghost Script' && seg.situation) {
                        return { ...seg, startTime: segStartTime, script: updatedScript, situation: '' };
                    }

                    return { ...seg, startTime: segStartTime, script: updatedScript };
                });

                // Only update if times actually changed to avoid infinite loop
                if (JSON.stringify(updatedSegments) !== JSON.stringify(plan.segments)) {
                    updateCurrentPlan({ ...plan, segments: updatedSegments });
                }
            }, [plan?.startTime, plan?.warmupDuration, plan?.segments.map(s => s.duration).join(','), plan?.segments.length]);



            const addSegment = () => {
                const duration = 5;
                const script = ensureScriptSlots([], duration, 'NEW SEGMENT', '');

                updateCurrentPlan({
                    ...plan,
                    segments: [
                        ...plan.segments,
                        {
                            id: Date.now().toString(),
                            duration,
                            type: 'NEW SEGMENT',
                            situation: '',
                            notes: {},
                            script,
                            staffId: '',
                            hasScript: false,
                            hasScoutCards: false
                        }
                    ]
                });
            };

            const updateSegment = (id, field, value) => {
                if (id === 'WARMUP') {
                    if (field === 'script') updateCurrentPlan({ ...plan, warmupScript: value });
                    if (field === 'staffId') updateCurrentPlan({ ...plan, warmupStaffId: value });
                    return;
                }

                if (field === 'duration') {
                    const segment = plan.segments.find(s => s.id === id);
                    const newScript = ensureScriptSlots(segment.script, value, segment.type, segment.situation);
                    updateCurrentPlan({
                        ...plan,
                        segments: plan.segments.map(s => s.id === id ? { ...s, duration: value, script: newScript } : s)
                    });
                    return;
                }

                if (field === 'type') {
                    const segment = plan.segments.find(s => s.id === id);
                    const newPreset = findPreset(value, segment.situation);

                    if (newPreset && segment.script && segment.script.length > 0) {
                        // Migrate compatible fields
                        const migratedScript = segment.script.map((slot, index) => {
                            const newSlot = { ...slot };
                            const pItem = newPreset.items[index % newPreset.items.length] || {};

                            if (newPreset.useYardLine) {
                                newSlot.yardLine = pItem.yardLine || '';
                                newSlot.downDistance = pItem.down || '';
                                if (pItem.hash) newSlot.hash = pItem.hash;
                                delete newSlot.situation;
                            } else {
                                newSlot.situation = pItem.situation || '';
                                delete newSlot.yardLine;
                                delete newSlot.downDistance;
                            }
                            return newSlot;
                        });

                        updateCurrentPlan({
                            ...plan,
                            segments: plan.segments.map(s => s.id === id ? { ...s, type: value, script: migratedScript } : s)
                        });
                        return;
                    }
                }

                updateCurrentPlan({
                    ...plan,
                    segments: plan.segments.map(s => s.id === id ? { ...s, [field]: value } : s)
                });
            };

            const handleAddSection = (sectionId) => {
                const activeSegment = plan?.segments?.find(s => s.id === selectedSegmentId);
                if (!activeSegment) return;

                let itemsToAdd = [];

                if (Array.isArray(sectionId)) {
                    // Direct play IDs passed
                    itemsToAdd = sectionId.map(id => plays.find(p => p.id === id)).filter(Boolean);
                } else {
                    // 1. Check Matrix Formation
                const matrixFormation = gamePlanLayouts?.MATRIX?.formations?.find(f => f.id === sectionId);
                if (matrixFormation) {
                    const playIds = new Set();
                    const layout = gamePlanLayouts.MATRIX;
                    layout.playTypes.forEach(pt => {
                        layout.cols.forEach(col => {
                            const setId = `matrix_${matrixFormation.id}_${pt.id}_${col.id}`;
                            const cellData = gamePlan?.sets?.[setId];
                            if (cellData && cellData.assignedPlayIds) {
                                cellData.assignedPlayIds.forEach(id => playIds.add(id));
                            } else if (cellData && cellData.playIds) {
                                cellData.playIds.forEach(id => playIds.add(id));
                            }
                        });
                    });
                    itemsToAdd = Array.from(playIds).map(id => plays.find(p => p.id === id)).filter(Boolean);
                } else {
                    let rawIds = [];

                    // 2. Standard Set/Script Lookup
                    let setData = gamePlan?.sets?.[sectionId] || (Array.isArray(gamePlan?.sets) ? gamePlan.sets.find(s => s.id === sectionId) : null) || gamePlan?.miniScripts?.[sectionId] || (Array.isArray(gamePlan?.miniScripts) ? gamePlan.miniScripts.find(s => s.id === sectionId) : null);

                    if (setData) {
                        rawIds = setData.assignedPlayIds || setData.playIds || [];
                    }

                    // 3. Fallback: Call Sheet Layouts
                    if (rawIds.length === 0 && gamePlanLayouts?.CALL_SHEET?.sections) {
                        for (const sec of gamePlanLayouts.CALL_SHEET.sections) {
                            if (!sec.boxes) continue;
                            const box = sec.boxes.find(b => b.setId === sectionId);
                            if (box) {
                                if (box.assignedPlayIds && box.assignedPlayIds.length > 0) {
                                    rawIds = box.assignedPlayIds;
                                } else if (box.rows) {
                                    const scriptIds = [];
                                    box.rows.forEach(r => {
                                        if (r.content) scriptIds.push(r.content);
                                        if (r.contentRight) scriptIds.push(r.contentRight);
                                    });
                                    rawIds = [...new Set(scriptIds)];
                                }
                                break;
                            }
                        }
                    }

                    // 4. Play Buckets Lookup
                    if (rawIds.length === 0) {
                        const bucket = playBuckets?.find(b => b.id === sectionId);
                        if (bucket && bucket.plays) {
                            rawIds = bucket.plays;
                        }
                    }

                    itemsToAdd = rawIds.map(id => {
                        const pid = typeof id === 'object' ? id.id : id;
                        return plays.find(p => p.id === pid);
                    }).filter(Boolean);
                }
            }

                if (itemsToAdd.length === 0) return;

                const currentScript = [...(activeSegment.script || [])];

                itemsToAdd.forEach(playDef => {
                    const name = playDef ? playDef.name : 'Unknown Play';
                    const emptyIndex = currentScript.findIndex(row => !row.playName && !row.playId);

                    const preset = findPreset(activeSegment.type, activeSegment.situation);
                    const showYardLine = preset ? preset.useYardLine : activeSegment.type === 'Take-Off';

                    if (emptyIndex !== -1) {
                        // Fill empty slot
                        currentScript[emptyIndex] = {
                            ...currentScript[emptyIndex],
                            playName: name,
                            playId: playDef ? playDef.id : ''
                        };
                    } else {
                        // Append new row
                        const newItem = {
                            id: `row_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                            hash: 'M',
                            playName: name,
                            playId: playDef ? playDef.id : ''
                        };

                        if (showYardLine) {
                            newItem.yardLine = '';
                            newItem.downDistance = '';
                        } else {
                            newItem.situation = '';
                        }
                        currentScript.push(newItem);
                    }
                });

                updateSegment(selectedSegmentId, 'script', currentScript);
            };

            const handleFocusChange = (segmentId, field, value) => {
                let updatedPlan = { ...plan };

                // 1. Update the Focus Field
                if (segmentId === 'WARMUP') {
                    updatedPlan[field] = value;
                } else {
                    updatedPlan.segments = updatedPlan.segments.map(s => s.id === segmentId ? { ...s, [field]: value } : s);
                }

                // 2. Check for Game Plan match
                let shouldUpdateScript = false;
                let newScript = [];

                if (value && gamePlanLayouts?.CALL_SHEET?.sections) {
                    let foundBox = null;
                    gamePlanLayouts.CALL_SHEET.sections.forEach(section => {
                        if (!foundBox && section.boxes) {
                            foundBox = section.boxes.find(b => b.header === value);
                        }
                    });

                    if (foundBox && foundBox.setId) {
                        if (window.confirm(`Populate script from Game Plan section "${value}"?`)) {
                            const safeGamePlan = gamePlan || {};
                            const isScript = foundBox.type === 'script';
                            const collectionList = isScript ? (safeGamePlan.miniScripts || []) : (safeGamePlan.sets || []);
                            const data = Array.isArray(collectionList) ? collectionList.find(item => item.id === foundBox.setId) : null;

                            if (data && data.assignedPlayIds && data.assignedPlayIds.length > 0) {
                                shouldUpdateScript = true;
                                newScript = data.assignedPlayIds.map(pid => {
                                    const p = plays.find(x => x.id === pid);
                                    return {
                                        id: Date.now().toString() + Math.random(),
                                        playId: pid,
                                        playName: p ? p.name : 'Unknown Play',
                                        hash: 'M',
                                        situation: value
                                    };
                                });
                            } else {
                                alert("No plays found in that Game Plan section.");
                            }
                        }
                    }
                }

                // 3. Apply Script Update if needed
                if (shouldUpdateScript) {
                    if (segmentId === 'WARMUP') {
                        updatedPlan.warmupScript = newScript;
                        updatedPlan.warmupHasScript = true;
                    } else {
                        updatedPlan.segments = updatedPlan.segments.map(s => s.id === segmentId ? { ...s, script: newScript, hasScript: true } : s);
                    }
                }

                updateCurrentPlan(updatedPlan);
            };

            const applyHashPreset = (segmentId, preset) => {
                const segment = plan.segments.find(s => s.id === segmentId);
                if (!segment) return;

                const currentScript = ensureScriptSlots(segment.script, parseInt(segment.duration || 0), segment.type, segment.situation);

                let newScript = [...currentScript];
                const count = newScript.length;

                if (preset === 'SERPENTINE_LR' || preset === 'SERPENTINE_RL') {
                    const patternLR = ['L', 'LM', 'M', 'RM', 'R', 'RM', 'M', 'LM'];
                    const patternRL = ['R', 'RM', 'M', 'LM', 'L', 'LM', 'M', 'RM'];
                    const pattern = preset === 'SERPENTINE_LR' ? patternLR : patternRL;

                    newScript = newScript.map((slot, idx) => ({
                        ...slot,
                        hash: pattern[idx % pattern.length]
                    }));
                } else if (preset === 'ZONES_LR' || preset === 'ZONES_RL') {
                    newScript = newScript.map((slot, idx) => {
                        const progress = idx / count;
                        let h = 'M';
                        if (progress < 0.33) h = (preset === 'ZONES_LR') ? 'L' : 'R';
                        else if (progress < 0.66) h = 'M';
                        else h = (preset === 'ZONES_LR') ? 'R' : 'L';
                        return { ...slot, hash: h };
                    });
                } else if (preset === 'RANDOM') {
                    const opts = ['L', 'LM', 'M', 'RM', 'R'];
                    newScript = newScript.map(slot => ({
                        ...slot,
                        hash: opts[Math.floor(Math.random() * opts.length)]
                    }));
                }

                updateSegment(segmentId, 'script', newScript);
            };

            // Special handler for notes to support coach-specific notes
            const updateSegmentNotes = (segmentId, coachId, noteText) => {
                if (segmentId === 'WARMUP') {
                    const currentNotes = plan.warmupNotes || {};
                    const updated = { ...currentNotes, [coachId]: noteText };
                    if (!noteText || noteText.trim() === '') {
                        delete updated[coachId];
                    }
                    updateCurrentPlan({ ...plan, warmupNotes: updated });
                    return;
                }

                const segment = plan.segments.find(s => s.id === segmentId);
                const migratedSegment = migrateSegmentNotes(segment);
                const updatedNotes = {
                    ...migratedSegment.notes,
                    [coachId]: noteText
                };
                // If note is empty, remove the key
                if (!noteText || noteText.trim() === '') {
                    delete updatedNotes[coachId];
                }
                updateSegment(segmentId, 'notes', updatedNotes);
            };

            const removeSegment = (id) => {
                updateCurrentPlan({
                    ...plan,
                    segments: plan.segments.filter(s => s.id !== id)
                });
            };







            const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];

            if (mode === 'script') {
                const scriptedSegments = plan.segments.filter(s => s.hasScript && s.script && s.script.length > 0);
                // Also check warmup
                if (plan.warmupHasScript && plan.warmupScript && plan.warmupScript.length > 0) {
                    scriptedSegments.unshift({
                        id: 'WARMUP',
                        type: 'Warmup',
                        duration: plan.warmupDuration,
                        hasScript: true,
                        script: plan.warmupScript,
                        startTime: plan.startTime // Approximate, start of practice
                    });
                }

                return (
                    <div style={{ display: 'flex', flexDirection: 'column', height: 'calc(100vh - 100px)', border: 'none', outline: 'none' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem', paddingBottom: '0.5rem', border: 'none', outline: 'none', boxShadow: 'none' }}>
                            <div style={{ display: 'flex', gap: '0.5rem' }}>
                                {days.map(day => (
                                    <button
                                        key={day}
                                        className={`btn ${selectedDay === day ? 'btn-primary' : 'btn-secondary'}`}
                                        onClick={() => setSelectedDay(day)}
                                        style={{ textDecoration: 'none', border: 'none', outline: 'none', boxShadow: 'none' }}
                                    >
                                        {day}
                                    </button>
                                ))}
                            </div>
                            <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center' }}>
                                <button className="btn btn-secondary" onClick={() => window.print()}>🖨️ Print Scripts</button>
                            </div>
                        </div>

                        <div style={{ display: 'flex', flex: 1, overflow: 'hidden' }}>
                            <div className="script-grid-container" style={{ flex: 1, overflowY: 'auto', padding: '1rem', display: 'grid', gridTemplateColumns: '1fr', gap: '2rem', alignContent: 'start' }}>
                                {scriptedSegments.length === 0 && (
                                    <div style={{ gridColumn: '1 / -1', textAlign: 'center', padding: '3rem', color: 'var(--text-secondary)' }}>
                                        No scripted segments for this day. Go to the "Plans" tab to enable scripting for segments.
                                    </div>
                                )}
                                {scriptedSegments.map(seg => {
                                    const settings = segmentSettings[seg.type] || { showHash: true, showDefense: true };
                                    const visibleCols = seg.visibleColumns || {
                                        hash: true,
                                        situation: true,
                                        tempo: true,
                                        defense: true,
                                        notes: true,
                                        actions: true
                                    };
                                    const preset = findPreset(seg.type, seg.situation);
                                    const segShowYardLine = preset ? preset.useYardLine : seg.type === 'Take-Off';
                                    const segSituationDropdown = (seg.situation || '').toLowerCase().includes('3rd');

                                    // Smart row creation helper
                                    const createSmartRow = (idx) => {
                                        const PATTERN_A = ['L', 'LM', 'M', 'RM', 'R', 'RM', 'M', 'LM'];
                                        const PATTERN_B = ['R', 'RM', 'M', 'LM', 'L', 'LM', 'M', 'RM'];
                                        let pattern = PATTERN_A;
                                        if (seg.script.length > 0 && seg.script[0].hash === 'R') pattern = PATTERN_B;

                                        let scriptItem = {
                                            id: Date.now().toString() + Math.random(),
                                            playId: '',
                                            playName: '',
                                            hash: pattern[idx % 8]
                                        };

                                        if (preset && preset.items && preset.items.length > 0) {
                                            const pItem = preset.items[idx % preset.items.length] || {};
                                            if (preset.useYardLine) {
                                                scriptItem.yardLine = pItem.yardLine || '';
                                                scriptItem.downDistance = pItem.down || '';
                                                if (pItem.hash) scriptItem.hash = pItem.hash;
                                            } else {
                                                scriptItem.situation = pItem.situation || '';
                                                if (pItem.hash) scriptItem.hash = pItem.hash;
                                            }
                                        } else if (seg.type === 'Take-Off') {
                                            const yardlines = ['-30', '-40', '50', '40', '30', '20', '10', '5'];
                                            scriptItem.yardLine = yardlines[idx % 8] || '';
                                            scriptItem.downDistance = '';
                                        } else {
                                            scriptItem.situation = '';
                                        }
                                        return scriptItem;
                                    };

                                    return (
                                        <PracticeScriptTable
                                            key={seg.id}
                                            script={ensureScriptSlots(seg.script, parseInt(seg.duration || 0), seg.type, seg.situation)}
                                            onUpdateScript={(newScript) => updateSegment(seg.id, 'script', newScript)}
                                            plays={plays}
                                            playCategories={playCategories}
                                            isLocked={isLocked}
                                            onQuickAddPlay={onQuickAddPlay}
                                            segment={seg}
                                            showHeader={true}
                                            visibleColumns={{
                                                hash: visibleCols.hash && settings.showHash !== false,
                                                down: visibleCols.situation,
                                                dist: visibleCols.situation,
                                                situation: visibleCols.situation && !segShowYardLine,
                                                playCall: true,
                                                defense: visibleCols.defense && settings.showDefense !== false,
                                                notes: visibleCols.notes,
                                                actions: visibleCols.actions
                                            }}
                                            downAsDropdown={true}
                                            situationDropdown={segSituationDropdown}
                                            showYardLine={segShowYardLine}
                                            compact={true}
                                            tableId={seg.id}
                                            notesAsButton={true}
                                            onEditNotes={(segId, rowId) => setEditingScriptRow({ segmentId: segId, rowId: rowId })}
                                            getNotesDisplay={(slot) => {
                                                const migrated = migrateScriptRowNotes(slot);
                                                const hasNotes = migrated.notes && Object.keys(migrated.notes).length > 0;
                                                return { hasNotes, label: hasNotes ? '📝 Notes' : 'Add Note...' };
                                            }}
                                            onInsertRow={(idx, currentScript) => {
                                                const newScript = [...currentScript];
                                                newScript.splice(idx + 1, 0, createSmartRow(idx));
                                                return newScript;
                                            }}
                                            onDeleteRow={(idx, slot, currentScript) => {
                                                if (confirm('Delete this play?')) {
                                                    const newScript = currentScript.filter(s => s.id !== slot.id);
                                                    updateSegment(seg.id, 'script', newScript);
                                                }
                                            }}
                                        />
                                    );
                                })}
                            </div>
                            {editingScriptRow && (
                                <ScriptRowNotesModal
                                    plan={plan}
                                    segmentId={editingScriptRow.segmentId}
                                    rowId={editingScriptRow.rowId}
                                    staff={staff}
                                    onClose={() => setEditingScriptRow(null)}
                                    updateSegment={updateSegment}
                                />
                            )}
                        </div>
                    </div>
                );
            }

            const renderNotesModal = () => {
                const plan = plans[selectedDay];
                if (!plan) return null;
                const segment = plan.segments.find(s => s.id === notesModalSegmentId);
                if (!segment) return null;

                return (
                    <div style={{
                        position: 'fixed',
                        top: 0,
                        left: 0,
                        right: 0,
                        bottom: 0,
                        backgroundColor: 'rgba(0,0,0,0.5)',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        zIndex: 1000
                    }} onClick={() => setNotesModalSegmentId(null)}>
                        <div style={{
                            backgroundColor: 'white',
                            padding: '2rem',
                            borderRadius: '8px',
                            width: '90%',
                            maxWidth: '600px',
                            maxHeight: '80vh',
                            overflowY: 'auto'
                        }} onClick={e => e.stopPropagation()}>
                            <h2 style={{ marginBottom: '1rem', color: 'black' }}>Notes for {segment.name}</h2>
                            <textarea
                                value={segment.notes || ''}
                                onChange={(e) => updateSegment(segment.id, 'notes', e.target.value)}
                                style={{
                                    width: '100%',
                                    height: '200px',
                                    marginBottom: '1rem',
                                    padding: '0.5rem',
                                    border: '1px solid #ddd',
                                    borderRadius: '4px',
                                    resize: 'vertical'
                                }}
                                placeholder="Enter segment notes..."
                            />
                            <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '1rem' }}>
                                <button
                                    onClick={() => setNotesModalSegmentId(null)}
                                    className="btn btn-secondary"
                                >
                                    Close
                                </button>
                            </div>
                        </div>
                    </div>
                );
            };

            // State for Side Menu


            return (
                <div style={{ display: 'flex', flexDirection: 'column', height: 'calc(100vh - 100px)' }}>
                    {mode === 'plan' && plans && plans[selectedDay] && ReactDOM.createPortal(
                        <div className="print-portal">
                            <PracticePlanPrintView
                                plan={plans[selectedDay]}
                                onBack={() => { }}
                                teamLogo={teamLogo}
                                weekData={currentWeek}
                                isBatchMode={false}
                                coachFilter={selectedCoachFilter}
                                roster={roster}
                                staff={staff}
                                selectedDay={selectedDay}
                            />
                        </div>,
                        document.body
                    )}
                    {/* Day Tabs */}
                    <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '1rem', paddingBottom: '0.5rem', border: 'none', outline: 'none', boxShadow: 'none' }}>
                        {days.map(day => (
                            <button
                                key={day}
                                className={`btn ${selectedDay === day ? 'btn-primary' : 'btn-secondary'}`}
                                onClick={() => { setSelectedDay(day); setSelectedSegmentId(null); }}
                                style={{ textDecoration: 'none', border: 'none', outline: 'none', boxShadow: 'none' }}
                            >
                                {day}
                            </button>
                        ))}
                    </div>

                    <div className="practice-flex-container" style={{ display: 'flex', flex: 1, overflow: 'hidden' }}>
                        {/* Left: Schedule View */}
                        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', overflowY: 'auto' }}>
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem', flexWrap: 'wrap', gap: '1rem' }}>
                                <h2>{selectedDay} Schedule</h2>
                                <div style={{ display: 'flex', gap: '0.75rem', alignItems: 'center', flexWrap: 'wrap' }}>
                                    {/* Side Menu Toggle */}
                                    <button
                                        className={`btn ${showSideMenu ? 'btn-primary' : 'btn-secondary'}`}
                                        onClick={() => setShowSideMenu(!showSideMenu)}
                                    >
                                        {showSideMenu ? 'Hide Plays' : 'Play Menu'}
                                    </button>

                                    {/* Template & Global Admin */}
                                    {!isLocked && (
                                        <div style={{ display: 'flex', gap: '0.25rem' }}>
                                            <select
                                                className="form-select"
                                                style={{
                                                    height: '36px',
                                                    width: 'auto',
                                                    backgroundColor: 'var(--bg-panel)',
                                                    border: '1px solid var(--accent)',
                                                    fontSize: '0.85rem',
                                                    padding: '0 2rem 0 0.75rem',
                                                    borderRadius: '6px'
                                                }}
                                                onChange={(e) => {
                                                    loadTemplate(e.target.value);
                                                    e.target.value = ""; // Reset
                                                }}
                                                defaultValue=""
                                            >
                                                <option value="" disabled>Load Template...</option>
                                                {allTemplates.map(t => (
                                                    <option key={t.name} value={t.name}>
                                                        {t.id ? '🌐 ' : '📋 '}{t.name}{t.category ? ` (${t.category})` : ''}
                                                    </option>
                                                ))}
                                            </select>
                                            <button
                                                className="btn btn-secondary"
                                                onClick={saveAsGlobalTemplate}
                                                title="Save as Template"
                                                style={{
                                                    height: '36px',
                                                    padding: '0 0.75rem',
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    gap: '0.25rem',
                                                    fontSize: '0.85rem',
                                                    borderRadius: '6px'
                                                }}
                                            >
                                                <Icon name="Save" size={14} />
                                            </button>
                                        </div>
                                    )}

                                    {/* 2-Platoon Toggle */}
                                    <div style={{
                                        height: '36px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '0.5rem',
                                        backgroundColor: 'var(--bg-panel)',
                                        padding: '0 0.75rem',
                                        borderRadius: '6px',
                                        border: '1px solid var(--border)'
                                    }}>
                                        <input
                                            type="checkbox"
                                            checked={plan.isTwoPlatoon || false}
                                            onChange={e => updateCurrentPlan({ ...plan, isTwoPlatoon: e.target.checked })}
                                            id="two-platoon-check"
                                            style={{ cursor: 'pointer' }}
                                        />
                                        <label htmlFor="two-platoon-check" style={{ fontSize: '0.85rem', cursor: 'pointer', userSelect: 'none', fontWeight: 'bold' }}>2-Platoon</label>
                                    </div>

                                    {/* Period Zero Toggle */}
                                    <div style={{
                                        height: '36px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '0.5rem',
                                        backgroundColor: 'var(--bg-panel)',
                                        padding: '0 0.75rem',
                                        borderRadius: '6px',
                                        border: '1px solid var(--border)'
                                    }}>
                                        <input
                                            type="checkbox"
                                            checked={plan.showPeriodZero !== false}
                                            onChange={e => updateCurrentPlan({ ...plan, showPeriodZero: e.target.checked })}
                                            id="period-zero-check"
                                            style={{ cursor: 'pointer' }}
                                        />
                                        <label htmlFor="period-zero-check" style={{ fontSize: '0.85rem', cursor: 'pointer', userSelect: 'none', fontWeight: 'bold' }}>Period 0</label>
                                    </div>

                                    {/* Time Control */}
                                    <div style={{
                                        height: '36px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '0.5rem',
                                        backgroundColor: 'var(--bg-panel)',
                                        padding: '0 0.75rem',
                                        borderRadius: '6px',
                                        border: '1px solid var(--border)'
                                    }}>
                                        <label style={{ fontSize: '0.85rem', fontWeight: 'bold' }}>Start:</label>
                                        <input
                                            type="time"
                                            className="form-input"
                                            style={{
                                                width: 'auto',
                                                padding: '0',
                                                border: 'none',
                                                background: 'transparent',
                                                fontSize: '0.85rem',
                                                fontFamily: 'inherit',
                                                height: 'auto'
                                            }}
                                            value={plan.startTime}
                                            onChange={e => updateCurrentPlan({ ...plan, startTime: e.target.value })}
                                            disabled={isLocked}
                                        />
                                    </div>

                                    {/* Transition Time Input */}
                                    <div style={{
                                        height: '36px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '0.5rem',
                                        backgroundColor: 'var(--bg-panel)',
                                        padding: '0 0.75rem',
                                        borderRadius: '6px',
                                        border: '1px solid var(--border)'
                                    }}>
                                        <label style={{ fontSize: '0.85rem', fontWeight: 'bold' }}>Trans:</label>
                                        <input
                                            type="number"
                                            className="form-input"
                                            style={{
                                                width: '40px',
                                                padding: '0',
                                                border: 'none',
                                                background: 'transparent',
                                                fontSize: '0.85rem',
                                                fontFamily: 'inherit',
                                                height: 'auto'
                                            }}
                                            value={plan.transitionTime || 0}
                                            onChange={e => updateCurrentPlan({ ...plan, transitionTime: Math.max(0, parseInt(e.target.value) || 0) })}
                                            disabled={isLocked}
                                            min="0"
                                        />
                                        <span style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>m</span>
                                    </div>

                                    {/* Filters: Staff & Notes */}
                                    <div style={{ display: 'flex', gap: '0.5rem' }}>
                                        <select
                                            className="form-select"
                                            style={{
                                                height: '36px',
                                                width: 'auto',
                                                padding: '0 2rem 0 0.75rem',
                                                fontSize: '0.85rem',
                                                borderRadius: '6px'
                                            }}
                                            value={selectedCoachFilter}
                                            onChange={e => setSelectedCoachFilter(e.target.value)}
                                            title="Filter Schedule by Coach"
                                        >
                                            <option value="ALL">All Staff</option>
                                            {staff && staff.map(s => (
                                                <option key={s.id} value={s.id}>{s.name}</option>
                                            ))}
                                        </select>

                                        <select
                                            className="form-select"
                                            style={{
                                                height: '36px',
                                                width: 'auto',
                                                padding: '0 2rem 0 0.75rem',
                                                fontSize: '0.85rem',
                                                borderRadius: '6px'
                                            }}
                                            value={selectedNotesCoach}
                                            onChange={e => setSelectedNotesCoach(e.target.value)}
                                            title="View Notes For"
                                        >
                                            <option value="ALL_COACHES">All Notes</option>
                                            <optgroup label="Coaches">
                                                {staff && staff.map(s => (
                                                    <option key={`note-${s.id}`} value={s.id}>{s.name} Notes</option>
                                                ))}
                                            </optgroup>
                                        </select>
                                    </div>

                                    {/* "Include Play Cards" Checkbox - Only for Scout Offense/Defense */}
                                    {(() => {
                                        const coach = staff?.find(s => s.id === selectedCoachFilter);
                                        if (selectedCoachFilter === 'ALL') return null;

                                        const isDefensePos = coach?.positions?.defense;

                                        if (isDefensePos) {
                                            return (
                                                <div style={{
                                                    height: '36px',
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    gap: '0.5rem',
                                                    backgroundColor: 'var(--bg-panel)',
                                                    padding: '0 0.75rem',
                                                    borderRadius: '6px',
                                                    border: '1px solid var(--border)'
                                                }}>
                                                    <input
                                                        type="checkbox"
                                                        checked={includePlayCards}
                                                        onChange={e => setIncludePlayCards(e.target.checked)}
                                                        id="print-cards-check"
                                                        style={{ cursor: 'pointer' }}
                                                    />
                                                    <label htmlFor="print-cards-check" style={{ fontSize: '0.85rem', cursor: 'pointer', userSelect: 'none' }}>Cards</label>
                                                </div>
                                            );
                                        }
                                        return null;
                                    })()}

                                    <button className="btn btn-secondary"
                                        style={{
                                            height: '36px',
                                            padding: '0 1rem',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            borderRadius: '6px'
                                        }}
                                        onClick={() => {
                                            if (typeof includePlayCards !== 'undefined' && includePlayCards) {
                                                const visibleSegments = plan.segments.filter(seg => selectedCoachFilter === 'ALL' || seg.staffId === selectedCoachFilter);
                                                const urlsToOpen = new Set();
                                                visibleSegments.forEach(seg => {
                                                    if (scoutCardUrls[seg.id]) {
                                                        urlsToOpen.add(scoutCardUrls[seg.id]);
                                                    }
                                                });
                                                if (plan.warmupScoutCard && scoutCardUrls['WARMUP'] && (selectedCoachFilter === 'ALL' || plan.warmupStaffId === selectedCoachFilter)) {
                                                    urlsToOpen.add(scoutCardUrls['WARMUP']);
                                                }
                                                urlsToOpen.forEach(url => window.open(url, '_blank'));
                                            }
                                            window.print();
                                        }} title="Print Schedule">🖨️</button>
                                </div>
                            </div>



                            {/* Pre-Practice Notes */}
                            <div style={{ marginBottom: '1rem' }}>
                                <label style={{ fontWeight: 'bold', display: 'block', marginBottom: '0.25rem' }}>Pre-Practice Notes:</label>
                                <textarea
                                    className="form-input"
                                    style={{ width: '100%', minHeight: '60px', fontFamily: 'inherit' }}
                                    value={plan.prePracticeNotes || ''}
                                    onChange={e => updateCurrentPlan({ ...plan, prePracticeNotes: e.target.value })}
                                    placeholder="Announcements, weather, focus points..."
                                />
                            </div>


                            <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '0.9rem' }}>
                                <thead>
                                    <tr style={{ borderBottom: '2px solid var(--border)', textAlign: 'center' }}>
                                        <th style={{ padding: '0.5rem' }}>#</th>
                                        <th style={{ padding: '0.5rem' }}>Time</th>
                                        <th style={{ padding: '0.5rem' }}>Dur</th>
                                        <th style={{ padding: '0.5rem' }}>Phase</th>
                                        <th style={{ padding: '0.5rem' }}>Type</th>
                                        {plan.isTwoPlatoon ? (
                                            <>
                                                <th style={{ padding: '0.5rem' }}>Offense Focus</th>
                                                <th style={{ padding: '0.5rem' }}>Defense Focus</th>
                                            </>
                                        ) : (
                                            <th style={{ padding: '0.5rem' }}>Focus</th>
                                        )}
                                        <th style={{ padding: '0.5rem' }}>Contact</th>
                                        <th style={{ padding: '0.5rem' }}>Notes</th>
                                        <th style={{ padding: '0.5rem' }}>Script</th>
                                        <th className="no-print" style={{ padding: '0.5rem' }}>Scout Cards</th>
                                        <th className="no-print" style={{ padding: '0.5rem' }}>Delete</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {/* Warmup Row (Period 0) - Only show if showPeriodZero is enabled */}
                                    {plan.showPeriodZero !== false && (
                                    <tr
                                        style={{
                                            borderBottom: '1px solid var(--border)',
                                            backgroundColor: selectedSegmentId === 'WARMUP' ? 'rgba(56, 189, 248, 0.1)' : 'var(--surface)',
                                            cursor: 'pointer'
                                        }}
                                        onClick={() => setSelectedSegmentId('WARMUP')}
                                    >
                                        <td style={{ padding: '0.5rem', fontWeight: 'bold', color: 'var(--accent)', textAlign: 'center' }}>0</td>
                                        <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                            {plan.startTime ? (() => {
                                                const date = new Date(`2000-01-01T${plan.startTime}`);
                                                let hours = date.getHours();
                                                const minutes = date.getMinutes();
                                                hours = hours % 12 || 12;
                                                return `${hours}:${minutes.toString().padStart(2, '0')}`;
                                            })() : ''}
                                        </td>
                                        <td style={{ padding: '0.5rem' }}>
                                            <input
                                                type="number"
                                                className="form-input"
                                                style={{ width: '50px', padding: '0.25rem', textAlign: 'center' }}
                                                value={plan.warmupDuration || 0}
                                                onChange={e => updateCurrentPlan({ ...plan, warmupDuration: parseInt(e.target.value) || 0 })}
                                                onClick={e => e.stopPropagation()}
                                            />
                                        </td>
                                        <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                            <select
                                                className="form-select"
                                                value={plan.warmupPhase || 'ALL'}
                                                onChange={e => updateCurrentPlan({ ...plan, warmupPhase: e.target.value })}
                                                onClick={e => e.stopPropagation()}
                                                style={{ width: '70px', padding: '0.25rem', fontSize: '0.85rem', textAlign: 'center' }}
                                            >
                                                <option value="ALL">ALL</option>
                                                <option value="O">O</option>
                                                <option value="D">D</option>
                                                <option value="K">K</option>
                                                <option value="C">C</option>
                                            </select>
                                        </td>
                                        <td style={{ padding: '0.5rem', fontStyle: 'italic', textAlign: 'center' }}>Warmup</td>
                                        {plan.isTwoPlatoon ? (
                                            <>
                                                <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                    <MultiSelectDropdown
                                                        center
                                                        options={getFocusItemsForPhase('O')}
                                                        value={Array.isArray(plan.warmupOffenseFocus) ? plan.warmupOffenseFocus : (plan.warmupOffenseFocus ? [plan.warmupOffenseFocus] : [])}
                                                        onChange={vals => handleFocusChange('WARMUP', 'warmupOffenseFocus', vals)}
                                                        placeholder="-- Offense --"
                                                    />
                                                </td>
                                                <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                    <MultiSelectDropdown
                                                        center
                                                        options={getFocusItemsForPhase('D')}
                                                        value={Array.isArray(plan.warmupDefenseFocus) ? plan.warmupDefenseFocus : (plan.warmupDefenseFocus ? [plan.warmupDefenseFocus] : [])}
                                                        onChange={vals => handleFocusChange('WARMUP', 'warmupDefenseFocus', vals)}
                                                        placeholder="-- Defense --"
                                                    />
                                                </td>
                                            </>
                                        ) : (
                                            <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                {customInputState?.id === 'WARMUP' ? (
                                                    <input
                                                        autoFocus
                                                        className="form-input"
                                                        style={{ padding: '0.25rem', width: '100%', textAlign: 'center' }}
                                                        defaultValue=""
                                                        placeholder="Custom focus..."
                                                        onBlur={(e) => {
                                                            const val = e.target.value.trim();
                                                            if (val) {
                                                                addCustomFocusItem(val);
                                                                updateCurrentPlan({ ...plan, warmupSituation: val });
                                                            }
                                                            setCustomInputState(null);
                                                        }}
                                                        onKeyDown={(e) => {
                                                            if (e.key === 'Enter') e.target.blur();
                                                            if (e.key === 'Escape') setCustomInputState(null);
                                                        }}
                                                        onClick={e => e.stopPropagation()}
                                                    />
                                                ) : (
                                                    <MultiSelectDropdown
                                                        center
                                                        options={[...getFocusItemsForPhase(plan.warmupPhase || 'ALL'), '__ADD_CUSTOM__']}
                                                        value={Array.isArray(plan.warmupSituation) ? plan.warmupSituation : (plan.warmupSituation ? [plan.warmupSituation] : [])}
                                                        onChange={(vals) => {
                                                            if (vals.includes('__ADD_CUSTOM__')) {
                                                                setCustomInputState({ id: 'WARMUP' });
                                                            } else {
                                                                updateCurrentPlan({ ...plan, warmupSituation: vals });
                                                            }
                                                        }}
                                                        placeholder="-- Select Focus --"
                                                    />
                                                )}
                                            </td>
                                        )}
                                        <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                            <select
                                                className="form-select"
                                                style={{ padding: '0.25rem', width: '90px' }}
                                                value={plan.warmupContact || ''}
                                                onChange={e => updateCurrentPlan({ ...plan, warmupContact: e.target.value })}
                                                onClick={e => e.stopPropagation()}
                                            >
                                                <option value="">--</option>
                                                <option value="Install">Install</option>
                                                <option value="On-Air">On-Air</option>
                                                <option value="Shields/Bags">Shields/Bags</option>
                                                <option value="Touch">Touch</option>
                                                <option value="Slight Resist">Slight Resist</option>
                                                <option value="Thud">Thud</option>
                                                <option value="Live">Live</option>
                                            </select>
                                        </td>
                                        <td style={{ padding: '0.5rem' }}>
                                            {(() => {
                                                const warmupNotes = plan.warmupNotes || {};
                                                const hasAnyNotes = Object.keys(warmupNotes).some(key => warmupNotes[key]);
                                                const allNotes = warmupNotes['ALL_COACHES'];

                                                return (
                                                    <button
                                                        className="form-input"
                                                        style={{
                                                            padding: '0.25rem 0.5rem',
                                                            textAlign: 'left',
                                                            cursor: 'pointer',
                                                            width: '100%',
                                                            backgroundColor: hasAnyNotes ? 'var(--bg-input)' : 'transparent',
                                                            border: hasAnyNotes ? '1px solid var(--accent)' : '1px solid var(--border)',
                                                            color: hasAnyNotes ? 'var(--text-primary)' : 'var(--text-secondary)',
                                                            fontStyle: hasAnyNotes ? 'normal' : 'italic',
                                                            overflow: 'hidden',
                                                            textOverflow: 'ellipsis',
                                                            whiteSpace: 'nowrap'
                                                        }}
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            setNotesModalSegmentId('WARMUP');
                                                        }}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                    >
                                                        {hasAnyNotes
                                                            ? (allNotes || Object.values(warmupNotes).find(n => n) || 'Click to view notes...')
                                                            : 'Click to add notes...'
                                                        }
                                                    </button>
                                                );
                                            })()}
                                        </td>
                                        <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                            {plan.warmupHasScript ? (
                                                <div style={{ display: 'flex', gap: '0.25rem', justifyContent: 'center', alignItems: 'center' }}>
                                                    <button
                                                        className="btn btn-primary"
                                                        style={{ padding: '0.25rem 0.5rem', fontSize: '0.8rem' }}
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            if (onNavigate) onNavigate('practice-scripts');
                                                        }}
                                                    >
                                                        See Script
                                                    </button>
                                                    {!isLocked && (
                                                        <button
                                                            className="btn"
                                                            style={{ padding: '0.25rem 0.4rem', fontSize: '0.7rem', color: '#ef4444' }}
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                if (confirm('Disable scripting for warmup? This will clear the script.')) {
                                                                    updateCurrentPlan({ ...plan, warmupHasScript: false, warmupScript: [] });
                                                                    if (selectedSegmentId === 'WARMUP') {
                                                                        setSelectedSegmentId(null);
                                                                    }
                                                                }
                                                            }}
                                                            title="Disable scripting"
                                                        >
                                                            ×
                                                        </button>
                                                    )}
                                                </div>
                                            ) : (
                                                !isLocked ? (
                                                    <input
                                                        type="checkbox"
                                                        checked={false}
                                                        onChange={e => {
                                                            updateCurrentPlan({ ...plan, warmupHasScript: e.target.checked });
                                                            if (e.target.checked) {
                                                                setSelectedSegmentId('WARMUP');
                                                                // setShowScriptView(true); // Removed auto-popout
                                                            }
                                                        }}
                                                        onClick={e => e.stopPropagation()}
                                                        style={{ cursor: 'pointer' }}
                                                    />
                                                ) : null
                                            )}
                                        </td>
                                        <td className="no-print" style={{ padding: '0.5rem', textAlign: 'center' }}>
                                            <input
                                                type="file"
                                                id="warmup-scout-card"
                                                style={{ display: 'none' }}
                                                accept="application/pdf"
                                                onChange={(e) => {
                                                    const file = e.target.files[0];
                                                    if (file) {
                                                        const url = URL.createObjectURL(file);
                                                        setScoutCardUrls(prev => ({ ...prev, WARMUP: url }));
                                                        updateCurrentPlan({
                                                            ...plan,
                                                            warmupScoutCard: { name: file.name }
                                                        });
                                                    }
                                                }}
                                                disabled={isLocked}
                                            />
                                            <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '0.25rem' }}>
                                                {!isLocked && (
                                                    <button
                                                        className="btn btn-secondary"
                                                        style={{ padding: '0.25rem 0.5rem', fontSize: '0.7rem' }}
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            document.getElementById('warmup-scout-card').click();
                                                        }}
                                                        title="Upload PDF Card"
                                                    >
                                                        {plan.warmupScoutCard ? '📎 Replace' : '📎 Upload'}
                                                    </button>
                                                )}
                                                {plan.warmupScoutCard && (
                                                    <div style={{ fontSize: '0.7rem', maxWidth: '100px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                                                        {scoutCardUrls['WARMUP'] ? (
                                                            <a
                                                                href={scoutCardUrls['WARMUP']}
                                                                target="_blank"
                                                                rel="noopener noreferrer"
                                                                onClick={e => e.stopPropagation()}
                                                                style={{ color: 'var(--accent)', textDecoration: 'none' }}
                                                            >
                                                                {plan.warmupScoutCard.name}
                                                            </a>
                                                        ) : (
                                                            <span style={{ color: 'var(--text-secondary)', cursor: 'help' }} title="File lost on refresh. Re-upload to view.">
                                                                {plan.warmupScoutCard.name}
                                                            </span>
                                                        )}
                                                    </div>
                                                )}
                                            </div>
                                        </td>
                                        <td className="no-print" style={{ padding: '0.5rem' }}></td>
                                    </tr>
                                    )}

                                    {plan.segments
                                        .map((seg, index) => (
                                            <tr
                                                key={seg.id}
                                                style={{
                                                    borderBottom: '1px solid var(--border)',
                                                    backgroundColor: selectedSegmentId === seg.id ? 'rgba(56, 189, 248, 0.1)' : 'transparent',
                                                    cursor: 'pointer'
                                                }}
                                                onClick={() => setSelectedSegmentId(seg.id)}
                                            >
                                                <td style={{ padding: '0.5rem', fontWeight: 'bold', color: 'var(--accent)', textAlign: 'center' }}>
                                                    {index + 1}
                                                    {/* Insert Segment Button */}
                                                    {!isLocked && (
                                                        <button
                                                            className="btn btn-secondary no-print"
                                                            style={{ marginLeft: '4px', padding: '0 4px', fontSize: '0.7rem', height: '20px', lineHeight: '20px' }}
                                                            title="Insert new segment below"
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                const newSegment = {
                                                                    id: Date.now().toString(),
                                                                    type: 'Competition',
                                                                    duration: 5,
                                                                    startTime: '',
                                                                    phase: 'ALL',
                                                                    hasScript: false,
                                                                    script: [],
                                                                    notes: user?.role === 'HC' ? { 'ALL_COACHES': '' } : {}
                                                                };

                                                                const newSegments = [...plan.segments];
                                                                newSegments.splice(index + 1, 0, newSegment);

                                                                updateCurrentPlan({ ...plan, segments: newSegments });
                                                            }}
                                                        >
                                                            +
                                                        </button>
                                                    )}
                                                </td>
                                                <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                    {plan.startTime ? (() => {
                                                        const [startH, startM] = plan.startTime.split(':').map(Number);
                                                        const warmup = parseInt(plan.warmupDuration) || 0;
                                                        const transition = parseInt(plan.transitionTime) || 0;

                                                        // Calculate time elapsed before this segment
                                                        let elapsedMinutes = warmup;

                                                        // Add durations of prior segments
                                                        for (let i = 0; i < index; i++) {
                                                            elapsedMinutes += (parseInt(plan.segments[i].duration) || 0);
                                                        }

                                                        // Add transitions:
                                                        // User req: No transition between Warmup (Seg 0) and Seg 1.
                                                        // So transitions start applying AFTER Seg 1 (between 1 and 2, etc.)
                                                        // If index is 0 (Seg 1), 0 transitions.
                                                        // If index is 1 (Seg 2), 1 transition (between 1 and 2).
                                                        // Transitions = index.
                                                        if (index > 0) {
                                                            elapsedMinutes += (index * transition);
                                                        }

                                                        const date = new Date();
                                                        date.setHours(startH, startM + elapsedMinutes);

                                                        let hours = date.getHours();
                                                        const minutes = date.getMinutes();
                                                        hours = hours % 12 || 12;
                                                        return `${hours}:${minutes.toString().padStart(2, '0')}`;
                                                    })() : seg.startTime}
                                                </td>
                                                <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                    <span className="print-only-text">{seg.duration}</span>
                                                    {!isLocked && (
                                                        <input
                                                            type="number"
                                                            className="form-input no-print"
                                                            style={{ width: '60px', padding: '0.25rem', textAlign: 'center' }}
                                                            value={seg.duration}
                                                            onChange={e => updateSegment(seg.id, 'duration', parseInt(e.target.value))}
                                                            onClick={e => e.stopPropagation()}
                                                        />
                                                    )}
                                                </td>
                                                <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                    <span className="print-only-text">{seg.phase || 'ALL'}</span>
                                                    {!isLocked && (
                                                        <select
                                                            className="form-select no-print"
                                                            style={{ width: '70px', padding: '0.25rem', fontSize: '0.85rem', textAlign: 'center' }}
                                                            value={seg.phase || 'ALL'}
                                                            onChange={e => updateSegment(seg.id, 'phase', e.target.value)}
                                                            onClick={e => e.stopPropagation()}
                                                        >
                                                            <option value="ALL">ALL</option>
                                                            <option value="O">O</option>
                                                            <option value="D">D</option>
                                                            <option value="K">K</option>
                                                            <option value="C">C</option>
                                                        </select>
                                                    )}
                                                </td>
                                                <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                    <span className="print-only-text">{seg.type}</span>
                                                    {!isLocked && (
                                                        <select
                                                            className="form-select no-print"
                                                            style={{ width: '130px', padding: '0.25rem', textAlign: 'center' }}
                                                            value={seg.type}
                                                            onChange={e => {
                                                                const newType = e.target.value;
                                                                if (newType === 'Ghost Script') {
                                                                    const ghostSequence = [
                                                                        'COIN TOSS', 'KICKOFF', 'TEAM D', 'PUNT RETURN', 'TEAM O', 'PAT',
                                                                        'BACKED-UP PUNT', 'TEAM D', 'PAT BLOCK', 'KICKOFF RET', 'TEAM O',
                                                                        'PUNT', 'HALFTIME', 'HANDS TEAM', 'HAIL MARY', '2-PT PLAY',
                                                                        'ONSIDE KICK', 'PREVENT DEFENSE', 'VICTORY'
                                                                    ];

                                                                    const PATTERN_A = ['L', 'LM', 'RM', 'R', 'R', 'RM', 'LM', 'L'];
                                                                    const PATTERN_B = ['R', 'RM', 'LM', 'L', 'L', 'LM', 'RM', 'R'];
                                                                    const pattern = Math.random() > 0.5 ? PATTERN_A : PATTERN_B;

                                                                    const ghostScript = ghostSequence.map((situation, i) => ({
                                                                        id: Date.now().toString() + i,
                                                                        playId: '',
                                                                        playName: '',
                                                                        hash: pattern[i % 8],
                                                                        situation: situation
                                                                    }));

                                                                    updateCurrentPlan({
                                                                        ...plan,
                                                                        segments: plan.segments.map(s => s.id === seg.id ? {
                                                                            ...s,
                                                                            type: newType,
                                                                            hasScript: true,
                                                                            script: ghostScript,
                                                                            situation: '' // Clear focus to avoid 3rd down dropdown logic interactions
                                                                        } : s)
                                                                    });
                                                                } else {
                                                                    updateSegment(seg.id, 'type', newType);
                                                                }
                                                            }}
                                                            onClick={e => e.stopPropagation()}
                                                        // The onChange handler was duplicated, removed the second one.
                                                        >
                                                            <option value="">-- Select Type --</option>
                                                            {getSegmentTypesForPhase(seg.phase).map(t => (
                                                                <option key={t} value={t}>{t}</option>
                                                            ))}
                                                        </select>
                                                    )}
                                                </td>
                                                {plan.isTwoPlatoon ? (
                                                    <>
                                                        <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                            <span className="print-only-text">{Array.isArray(seg.offenseFocus || seg.situation) ? (seg.offenseFocus || seg.situation).join(', ') : (seg.offenseFocus || seg.situation)}</span>
                                                            {!isLocked && (
                                                                <MultiSelectDropdown
                                                                    center
                                                                    className="no-print"
                                                                    options={segmentSettings[seg.type]?.allowedFocusItems?.length > 0
                                                                        ? segmentSettings[seg.type].allowedFocusItems.filter(f => getFocusItemsForPhase('O').includes(f))
                                                                        : getFocusItemsForPhase('O')}
                                                                    value={Array.isArray(seg.offenseFocus || seg.situation) ? (seg.offenseFocus || seg.situation) : (seg.offenseFocus || seg.situation ? [seg.offenseFocus || seg.situation] : [])}
                                                                    onChange={vals => handleFocusChange(seg.id, 'offenseFocus', vals)}
                                                                    placeholder="-- Offense --"
                                                                />
                                                            )}
                                                        </td>
                                                        <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                            <span className="print-only-text">{Array.isArray(seg.defenseFocus) ? seg.defenseFocus.join(', ') : seg.defenseFocus}</span>
                                                            {!isLocked && (
                                                                <MultiSelectDropdown
                                                                    center
                                                                    className="no-print"
                                                                    options={segmentSettings[seg.type]?.allowedFocusItems?.length > 0
                                                                        ? segmentSettings[seg.type].allowedFocusItems.filter(f => getFocusItemsForPhase('D').includes(f))
                                                                        : getFocusItemsForPhase('D')}
                                                                    value={Array.isArray(seg.defenseFocus) ? seg.defenseFocus : (seg.defenseFocus ? [seg.defenseFocus] : [])}
                                                                    onChange={vals => handleFocusChange(seg.id, 'defenseFocus', vals)}
                                                                    placeholder="-- Defense --"
                                                                />
                                                            )}
                                                        </td>
                                                    </>
                                                ) : (
                                                    <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                        <span className="print-only-text">{Array.isArray(seg.situation) ? seg.situation.join(', ') : seg.situation}</span>
                                                        {!isLocked && (
                                                            customInputState?.id === seg.id ? (
                                                                <input
                                                                    autoFocus
                                                                    className="form-input no-print"
                                                                    style={{ padding: '0.25rem', width: '100%', textAlign: 'center' }}
                                                                    defaultValue=""
                                                                    placeholder="Custom focus..."
                                                                    onBlur={(e) => {
                                                                        const val = e.target.value.trim();
                                                                        if (val) {
                                                                            addCustomFocusItem(val);
                                                                            updateSegment(seg.id, 'situation', val);
                                                                        }
                                                                        setCustomInputState(null);
                                                                    }}
                                                                    onKeyDown={(e) => {
                                                                        if (e.key === 'Enter') e.target.blur();
                                                                        if (e.key === 'Escape') setCustomInputState(null);
                                                                    }}
                                                                    onClick={e => e.stopPropagation()}
                                                                />
                                                            ) : (
                                                                <MultiSelectDropdown
                                                                    center
                                                                    className="no-print"
                                                                    options={[
                                                                        ...(segmentSettings[seg.type]?.allowedFocusItems?.length > 0
                                                                            ? segmentSettings[seg.type].allowedFocusItems.filter(f => getFocusItemsForPhase(seg.phase).includes(f))
                                                                            : getFocusItemsForPhase(seg.phase)),
                                                                        '__ADD_CUSTOM__'
                                                                    ]}
                                                                    value={Array.isArray(seg.situation) ? seg.situation : (seg.situation ? [seg.situation] : [])}
                                                                    onChange={vals => {
                                                                        if (vals.includes('__ADD_CUSTOM__')) {
                                                                            setCustomInputState({ id: seg.id });
                                                                        } else {
                                                                            handleFocusChange(seg.id, 'situation', vals);
                                                                        }
                                                                    }}
                                                                    placeholder="-- Focus --"
                                                                />
                                                            )
                                                        )}
                                                    </td>
                                                )}
                                                <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                    <span className="print-only-text">{seg.contactLevel}</span>
                                                    {!isLocked && (
                                                        <select
                                                            className="form-select no-print"
                                                            style={{ padding: '0.25rem', width: '90px', textAlign: 'center' }}
                                                            value={seg.contactLevel || ''}
                                                            onChange={e => updateSegment(seg.id, 'contactLevel', e.target.value)}
                                                            onClick={e => e.stopPropagation()}
                                                        >
                                                            <option value="">--</option>
                                                            <option value="Install">Install</option>
                                                            <option value="On-Air">On-Air</option>
                                                            <option value="Shields/Bags">Shields/Bags</option>
                                                            <option value="Touch">Touch</option>
                                                            <option value="Slight Resist">Slight Resist</option>
                                                            <option value="Thud">Thud</option>
                                                            <option value="Live">Live</option>
                                                        </select>
                                                    )}
                                                </td>
                                                <td style={{ padding: '0.5rem', whiteSpace: 'pre-wrap' }}>
                                                    {(() => {
                                                        const migrated = migrateSegmentNotes(seg);
                                                        const allNotes = migrated.notes['ALL_COACHES'];
                                                        const hasAnyNotes = Object.keys(migrated.notes).some(key => migrated.notes[key]);

                                                        return (
                                                            <button
                                                                className="form-input"
                                                                style={{
                                                                    padding: '0.25rem 0.5rem',
                                                                    textAlign: 'left',
                                                                    cursor: 'pointer',
                                                                    backgroundColor: hasAnyNotes ? 'var(--bg-input)' : 'transparent',
                                                                    border: hasAnyNotes ? '1px solid var(--accent)' : '1px solid var(--border)',
                                                                    color: hasAnyNotes ? 'var(--text-primary)' : 'var(--text-secondary)',
                                                                    fontStyle: hasAnyNotes ? 'normal' : 'italic',
                                                                    overflow: 'hidden',
                                                                    textOverflow: 'ellipsis',
                                                                    whiteSpace: 'nowrap'
                                                                }}
                                                                onClick={(e) => {
                                                                    e.stopPropagation();
                                                                    setNotesModalSegmentId(seg.id);
                                                                }}
                                                                onMouseDown={(e) => e.stopPropagation()}
                                                            >
                                                                {hasAnyNotes
                                                                    ? (allNotes || Object.values(migrated.notes).find(n => n) || 'Click to view notes...')
                                                                    : 'Click to add notes...'
                                                                }
                                                            </button>
                                                        );
                                                    })()}
                                                </td>
                                                <td style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                    {seg.hasScript ? (
                                                        <div style={{ display: 'flex', gap: '0.25rem', justifyContent: 'center', alignItems: 'center' }}>
                                                            <button
                                                                className="btn btn-primary"
                                                                style={{ padding: '0.25rem 0.5rem', fontSize: '0.8rem' }}
                                                                onClick={(e) => {
                                                                    e.stopPropagation();
                                                                    if (onNavigate) onNavigate('practice-scripts');
                                                                }}
                                                            >
                                                                See Script
                                                            </button>
                                                            {!isLocked && (
                                                                <button
                                                                    className="btn"
                                                                    style={{ padding: '0.25rem 0.4rem', fontSize: '0.7rem', color: '#ef4444' }}
                                                                    onClick={(e) => {
                                                                        e.stopPropagation();
                                                                        if (confirm('Disable scripting for this segment? This will clear the script.')) {
                                                                            // Perform single atomic update to avoid race condition
                                                                            updateCurrentPlan({
                                                                                ...plan,
                                                                                segments: plan.segments.map(s => s.id === seg.id ? { ...s, hasScript: false, script: [] } : s)
                                                                            });

                                                                            if (selectedSegmentId === seg.id) {
                                                                                setSelectedSegmentId(null);
                                                                            }
                                                                        }
                                                                    }}
                                                                    title="Disable scripting"
                                                                >
                                                                    ×
                                                                </button>
                                                            )}
                                                        </div>
                                                    ) : (
                                                        !isLocked ? (
                                                            <input
                                                                type="checkbox"
                                                                checked={false}
                                                                onChange={e => {
                                                                    if (e.target.checked) {
                                                                        // Atomically enable script AND populate slots based on duration/type
                                                                        const initializedScript = ensureScriptSlots([], parseInt(seg.duration || 0), seg.type);

                                                                        updateCurrentPlan({
                                                                            ...plan,
                                                                            segments: plan.segments.map(s => s.id === seg.id ? {
                                                                                ...s,
                                                                                hasScript: true,
                                                                                script: initializedScript
                                                                            } : s)
                                                                        });

                                                                        setSelectedSegmentId(seg.id);
                                                                        // setShowScriptView(true); // Removed auto-popout
                                                                    } else {
                                                                        // Should not happen as unchecked state renders button, but for safety:
                                                                        updateSegment(seg.id, 'hasScript', false);
                                                                    }
                                                                }}
                                                                onClick={e => e.stopPropagation()}
                                                                style={{ cursor: 'pointer' }}
                                                            />
                                                        ) : null
                                                    )}
                                                </td>
                                                <td className="no-print" style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                    <input
                                                        type="file"
                                                        id={`scout-card-${seg.id}`}
                                                        style={{ display: 'none' }}
                                                        accept="application/pdf"
                                                        onChange={(e) => {
                                                            const file = e.target.files[0];
                                                            if (file) {
                                                                const url = URL.createObjectURL(file);
                                                                setScoutCardUrls(prev => ({ ...prev, [seg.id]: url }));
                                                                updateSegment(seg.id, 'scoutCard', { name: file.name });
                                                            }
                                                        }}
                                                        disabled={isLocked}
                                                    />
                                                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '0.25rem' }}>
                                                        {!isLocked && (
                                                            <button
                                                                className="btn btn-secondary"
                                                                style={{ padding: '0.25rem 0.5rem', fontSize: '0.7rem' }}
                                                                onClick={(e) => {
                                                                    e.stopPropagation();
                                                                    document.getElementById(`scout-card-${seg.id}`).click();
                                                                }}
                                                                title="Upload PDF Card"
                                                            >
                                                                {seg.scoutCard ? '📎 Replace' : '📎 Upload'}
                                                            </button>
                                                        )}
                                                        {seg.scoutCard && (
                                                            <div style={{ fontSize: '0.7rem', maxWidth: '100px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                                                                {scoutCardUrls[seg.id] ? (
                                                                    <a
                                                                        href={scoutCardUrls[seg.id]}
                                                                        target="_blank"
                                                                        rel="noopener noreferrer"
                                                                        onClick={e => e.stopPropagation()}
                                                                        style={{ color: 'var(--accent)', textDecoration: 'none' }}
                                                                    >
                                                                        {seg.scoutCard.name}
                                                                    </a>
                                                                ) : (
                                                                    <span style={{ color: 'var(--text-secondary)', cursor: 'help' }} title="File lost on refresh. Re-upload to view.">
                                                                        {seg.scoutCard.name}
                                                                    </span>
                                                                )}
                                                            </div>
                                                        )}
                                                    </div>
                                                </td>
                                                <td className="no-print" style={{ padding: '0.5rem' }}>
                                                    {!isLocked && (
                                                        <button
                                                            className="btn"
                                                            style={{ padding: '0.25rem 0.5rem', fontSize: '0.8rem', color: '#ef4444' }}
                                                            onClick={(e) => { e.stopPropagation(); removeSegment(seg.id); }}
                                                        >
                                                            ×
                                                        </button>
                                                    )}
                                                </td>
                                            </tr>
                                        ))}
                                    {/* Shake it up Segment - Static unnumbered */}
                                    <tr>
                                        <td colSpan={12} style={{ padding: '0' }}>
                                            <div style={{
                                                border: '2px dashed var(--border)',
                                                borderRadius: 'var(--radius)',
                                                display: 'flex',
                                                alignItems: 'center',
                                                justifyContent: 'center',
                                                padding: '0.5rem',
                                                color: 'var(--text-secondary)',
                                                fontStyle: 'italic',
                                                marginTop: '1rem',
                                                marginBottom: '1rem',
                                                background: 'var(--bg-app)'
                                            }}>
                                                <div style={{ marginRight: '1rem', color: 'var(--accent)' }}>---</div>
                                                <div style={{ fontWeight: 'bold' }}>
                                                    Shake it up
                                                    {plan.startTime && (() => {
                                                        const [startH, startM] = plan.startTime.split(':').map(Number);
                                                        const warmup = parseInt(plan.warmupDuration) || 0;
                                                        const transition = parseInt(plan.transitionTime) || 0;

                                                        const segments = plan.segments || [];
                                                        const segmentCount = segments.length;
                                                        const segmentsDuration = segments.reduce((acc, s) => acc + (parseInt(s.duration) || 0), 0);

                                                        // Transitions:
                                                        // 0 -> 1: No
                                                        // 1 -> 2: Yes
                                                        // ...
                                                        // Last Seg -> Shake it up: Yes (User implied it adheres to space between *each* segment, usually applies to shake it up too as a block)
                                                        // User said "Universal between periods".
                                                        // If we have N segments (1..N).
                                                        // Transitions exist after 1, 2, ..., N-1.
                                                        // Does it exist after N (before Shake it up)?
                                                        // Assuming "Shake it up" is a segment-like block, there should probably be a transition into it.
                                                        // Let's assume standard practice: Period 1 -> Trans -> Period 2.
                                                        // If Shake it up follows last period, it likely needs a transition too.
                                                        // Total transitions = (segmentCount > 0 ? segmentCount : 0) ? - Wait, 0->1 is NO.
                                                        // Seg 1 -> Seg 2 (1 trans).
                                                        // Seg 2 -> Seg 3 (2 trans).
                                                        // Seg N -> Shake it up (N trans).
                                                        // If N=1: Warmup->Seg1->(Trans)->Shake. 1 Transition?
                                                        // If N=2: Warmup->Seg1->(Trans)->Seg2->(Trans)->Shake. 2 Transitions.
                                                        // So Total Transitions = segmentCount.

                                                        const totalTransitionTime = segmentCount * transition;

                                                        const totalMinutes = warmup + segmentsDuration + totalTransitionTime;

                                                        const date = new Date();
                                                        date.setHours(startH, startM + totalMinutes);

                                                        let hours = date.getHours();
                                                        const minutes = date.getMinutes();
                                                        hours = hours % 12 || 12;
                                                        return ` (End: ${hours}:${minutes.toString().padStart(2, '0')})`;
                                                    })()}
                                                </div>
                                                <div style={{ marginLeft: '1rem', color: 'var(--accent)' }}>---</div>
                                            </div>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>



                            {/* Add Segment Button */}
                            <div style={{ padding: '1rem', textAlign: 'center', marginTop: '1rem' }}>
                                <button
                                    className="btn btn-primary"
                                    onClick={addSegment}
                                    disabled={isLocked}
                                >
                                    + Add Segment
                                </button>
                            </div>

                            {/* Post Practice Notes Section */}
                            <div style={{ marginTop: '2rem', borderTop: '2px solid var(--border)', paddingTop: '1rem' }}>
                                <label style={{ fontWeight: 'bold', display: 'block', marginBottom: '0.5rem' }}>Post Practice Notes</label>
                                <div className="print-only-text screen-hidden" style={{ minHeight: '100px', whiteSpace: 'pre-wrap', border: '1px solid #ddd', padding: '0.5rem', borderRadius: '4px' }}>
                                    {plan.postPracticeNotes}
                                </div>
                                <textarea
                                    className="form-input no-print"
                                    style={{ width: '100%', minHeight: '100px', fontFamily: 'inherit' }}
                                    value={plan.postPracticeNotes || ''}
                                    onChange={e => updateCurrentPlan({ ...plan, postPracticeNotes: e.target.value })}
                                    placeholder="Post-practice thoughts or ideas for tomorrow..."
                                    disabled={isLocked}
                                />
                            </div>
                        </div> {/* Close Right Column */}

                    </div> {/* Close Practice Flex Container */}

                    {/* Print Only: Scripts View (Page 2) */}
                    <div className="print-only-scripts" style={{ display: 'none' }}>
                        <div style={{ pageBreakBefore: 'always', breakBefore: 'page' }}>
                            <h2 style={{ textAlign: 'center', marginBottom: '1rem', borderBottom: '2px solid black', paddingBottom: '0.5rem' }}>PRACTICE SCRIPTS</h2>
                            {plan.segments.filter(s => s.hasScript && s.script && s.script.length > 0).map(seg => (
                                <div key={seg.id} style={{ marginBottom: '2rem', pageBreakInside: 'avoid' }}>
                                    <div style={{
                                        borderBottom: '1px solid black',
                                        marginBottom: '0.5rem',
                                        display: 'flex', justifyContent: 'space-between', alignItems: 'center'
                                    }}>
                                        <h3 style={{ margin: 0 }}>{seg.name}</h3>
                                        <div style={{ fontStyle: 'italic' }}>{seg.duration} min</div>
                                        {/* Show Coach Notes for this segment if helpful. */}
                                    </div>
                                    <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '0.8rem' }}>
                                        <thead>
                                            <tr>
                                                <th style={{ textAlign: 'left', padding: '2px', width: '30px' }}>#</th>
                                                <th style={{ textAlign: 'left', padding: '2px' }}>Hash</th>
                                                {(() => {
                                                    const preset = findPreset(seg.type, seg.situation);
                                                    const showYardLine = preset ? preset.useYardLine : seg.type === 'Take-Off';
                                                    if (showYardLine) return (
                                                        <>
                                                            <th style={{ textAlign: 'left', padding: '2px' }}>YL</th>
                                                            <th style={{ textAlign: 'left', padding: '2px' }}>Dn/Dist</th>
                                                        </>
                                                    );
                                                    if (seg.type === 'Ghost Script') return null;
                                                    return <th style={{ textAlign: 'left', padding: '2px' }}>Situation</th>;
                                                })()}
                                                <th style={{ textAlign: 'left', padding: '2px' }}>Play</th>
                                                <th style={{ textAlign: 'left', padding: '2px', width: '150px' }}>Notes</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {seg.script.map((slot, idx) => (
                                                <tr key={idx} style={{ borderBottom: '1px solid #ddd' }}>
                                                    <td style={{ padding: '2px', width: '30px' }}>{idx + 1}</td>
                                                    <td style={{ padding: '2px', width: '40px' }}>{slot.hash}</td>
                                                    {(() => {
                                                        const preset = findPreset(seg.type, seg.situation);
                                                        const showYardLine = preset ? preset.useYardLine : seg.type === 'Take-Off';
                                                        if (showYardLine) return (
                                                            <>
                                                                <td style={{ padding: '2px', width: '50px' }}>{slot.yardLine}</td>
                                                                <td style={{ padding: '2px', width: '60px' }}>{slot.downDistance}</td>
                                                            </>
                                                        );
                                                        if (seg.type === 'Ghost Script') return null;
                                                        return <td style={{ padding: '2px' }}>{slot.situation}</td>;
                                                    })()}
                                                    <td style={{ padding: '2px', fontWeight: 'bold' }}>{slot.playName}</td>
                                                    <td style={{ padding: '2px', fontSize: '0.75rem', fontStyle: 'italic', color: '#555' }}>
                                                        {(() => {
                                                            const notes = migrateScriptRowNotes(slot).notes;
                                                            if (!notes || Object.keys(notes).length === 0) return '';
                                                            return Object.entries(notes).map(([k, v]) => {
                                                                const label = k === 'ALL_COACHES' ? '' : ((staff && staff.find(s => s.id === k)?.name) || k) + ': ';
                                                                return label + v;
                                                            }).join(' | ');
                                                        })()}
                                                    </td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>
                            ))}
                        </div>
                    </div>

                    {/* Modals */}
                    {notesModalSegmentId && renderNotesModal()}
                </div>
            );
        };

        const GamedayDashboard = ({ plays }) => {
            const [filters, setFilters] = useState({
                down: 'Any',
                distance: 'Any',
                fieldPos: 'Any',
                hash: 'Any'
            });

            const filteredPlays = React.useMemo(() => {
                return plays.filter(play => {
                    if (filters.down === 'Any' && filters.distance === 'Any' && filters.fieldPos === 'Any' && filters.hash === 'Any') return true;
                    let targetTags = [];
                    if (filters.down !== 'Any' && filters.distance !== 'Any') {
                        targetTags.push(`${filters.down} & ${filters.distance}`);
                    }
                    if (filters.fieldPos !== 'Any') targetTags.push(filters.fieldPos);

                    if (targetTags.length === 0) return true;
                    return targetTags.some(t => play.tags.includes(t));
                });
            }, [plays, filters]);

            return (
                <div>
                    <h2 style={{ marginBottom: '1.5rem' }}>Gameday Dashboard</h2>

                    <div className="gameday-header">
                        <div>
                            <label className="form-label">Down</label>
                            <div className="situation-toggle">
                                {['Any', '1st', '2nd', '3rd', '4th'].map(opt => (
                                    <button
                                        key={opt}
                                        className={filters.down === opt ? 'active' : ''}
                                        onClick={() => setFilters({ ...filters, down: opt })}
                                    >
                                        {opt}
                                    </button>
                                ))}
                            </div>
                        </div>
                        <div>
                            <label className="form-label">Distance</label>
                            <div className="situation-toggle">
                                {['Any', 'Short', 'Med', 'Long', 'XL'].map(opt => (
                                    <button
                                        key={opt}
                                        className={filters.distance === opt ? 'active' : ''}
                                        onClick={() => setFilters({ ...filters, distance: opt })}
                                    >
                                        {opt}
                                    </button>
                                ))}
                            </div>
                        </div>
                        <div>
                            <label className="form-label">Field Position</label>
                            <select
                                className="form-select"
                                style={{ minWidth: '200px' }}
                                value={filters.fieldPos}
                                onChange={e => setFilters({ ...filters, fieldPos: e.target.value })}
                            >
                                <option value="Any">Any</option>
                                {(TAG_CATEGORIES["Field Position"] || []).map(pos => (
                                    <option key={pos} value={pos}>{pos}</option>
                                ))}
                            </select>
                        </div>
                    </div>

                    <div style={{ marginBottom: '1rem', color: 'var(--text-secondary)' }}>
                        Found {matchingPlays.length} plays matching situation...
                    </div>

                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))', gap: '1.5rem' }}>
                        {matchingPlays.map(play => (
                            <PlayCard key={play.id} play={play} onEdit={() => { }} />
                        ))}
                    </div>
                </div>
            );
        };


        const PregameTimeline = ({ plan = {}, onUpdatePlan, teamLogo, staff, user, isLocked }) => {
            const [kickoffTime, setKickoffTime] = useState(plan?.kickoffTime || '19:00');
            const [selectedCoachFilter, setSelectedCoachFilter] = useState('ALL');
            const [selectedNotesCoach, setSelectedNotesCoach] = useState('ALL_COACHES');
            const [notesModalSegmentId, setNotesModalSegmentId] = useState(null);

            // Helper function to migrate old notes format to new format
            const migrateSegmentNotes = (segment) => {
                if (!segment.notes) {
                    return { ...segment, notes: {} };
                }
                if (typeof segment.notes === 'string') {
                    return {
                        ...segment,
                        notes: segment.notes ? { 'ALL_COACHES': segment.notes } : {}
                    };
                }
                return segment;
            };

            const updateKickoff = (time) => {
                setKickoffTime(time);
                onUpdatePlan({ ...plan, kickoffTime: time });
            };

            const addSegment = () => {
                const newSegment = {
                    id: Date.now().toString(),
                    startTime: '17:00',
                    duration: 15,
                    activity: 'New Activity',
                    location: 'Field',
                    notes: {},
                    staffId: ''
                };
                onUpdatePlan({ ...plan, segments: [...(plan.segments || []), newSegment] });
            };

            const updateSegment = (id, field, value) => {
                onUpdatePlan({
                    ...plan,
                    segments: (plan.segments || []).map(s => s.id === id ? { ...s, [field]: value } : s)
                });
            };

            // Special handler for notes to support coach-specific notes
            const updateSegmentNotes = (segmentId, coachId, noteText) => {
                const segment = (plan.segments || []).find(s => s.id === segmentId);
                if (!segment) return;

                const migratedSegment = migrateSegmentNotes(segment);
                const updatedNotes = {
                    ...migratedSegment.notes,
                    [coachId]: noteText
                };
                // If note is empty, remove the key
                if (!noteText || noteText.trim() === '') {
                    delete updatedNotes[coachId];
                }
                updateSegment(segmentId, 'notes', updatedNotes);
            };

            const deleteSegment = (id) => {
                onUpdatePlan({ ...plan, segments: (plan.segments || []).filter(s => s.id !== id) });
            };

            // Auto-calculate segment times based on duration
            useEffect(() => {
                if (!plan || !plan.segments || plan.segments.length === 0) return;

                // Sort segments by their current start time to maintain order
                const sortedSegments = [...plan.segments].sort((a, b) =>
                    (a?.startTime || '').localeCompare(b?.startTime || '')
                );

                // Calculate times starting from the first segment
                let hasChanges = false;
                const updatedSegments = plan.segments.map(seg => {
                    // Find this segment's position in the sorted array
                    const sortedIndex = sortedSegments.findIndex(s => s.id === seg.id);

                    if (sortedIndex === 0) {
                        // Keep the first segment's time as-is
                        return seg;
                    }

                    // Calculate this segment's start time based on previous segment in sorted order
                    const prevSeg = sortedSegments[sortedIndex - 1];
                    const prevStartTime = new Date(`2000-01-01T${prevSeg.startTime}`);
                    prevStartTime.setMinutes(prevStartTime.getMinutes() + parseInt(prevSeg.duration || 0));

                    const calculatedTime = prevStartTime.toTimeString().slice(0, 5); // HH:MM format

                    if (seg.startTime !== calculatedTime) {
                        hasChanges = true;
                        return { ...seg, startTime: calculatedTime };
                    }
                    return seg;
                });

                // Only update if there are actual changes to avoid infinite loop
                if (hasChanges) {
                    onUpdatePlan({ ...plan, segments: updatedSegments });
                }
            }, [JSON.stringify(plan?.segments?.map(s => ({ id: s.id, duration: s.duration, startTime: s.startTime })))]);

            const calculateTMinus = (startTime) => {
                const start = new Date(`2000-01-01T${startTime}`);
                const kick = new Date(`2000-01-01T${kickoffTime}`);
                const diff = (kick - start) / 60000; // minutes
                return diff > 0 ? `T-${diff}` : `T+${Math.abs(diff)}`;
            };

            return (
                <div style={{ display: 'flex', flexDirection: 'column', height: 'calc(100vh - 100px)' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '2rem' }}>
                        <h2>Pre-game Timeline</h2>
                        <div style={{ display: 'flex', gap: '1rem', alignItems: 'center' }}>
                            <div>
                                <label style={{ marginRight: '0.5rem', fontWeight: 'bold' }}>Kickoff:</label>
                                <input
                                    type="time"
                                    className="form-input"
                                    style={{ width: 'auto', display: 'inline-block' }}
                                    value={kickoffTime}
                                    onChange={e => updateKickoff(e.target.value)}
                                    disabled={isLocked}
                                />
                            </div>
                            <button className="btn btn-secondary" onClick={() => window.print()}>🖨️ Print</button>
                        </div>
                    </div>

                    {/* Notes Modal */}
                    {notesModalSegmentId && (
                        <NotesModal
                            segmentId={notesModalSegmentId}
                            plan={plan}
                            staff={staff}
                            onClose={() => setNotesModalSegmentId(null)}
                            onUpdateNotes={(segmentId, coachId, note) => updateSegmentNotes(segmentId, coachId, note)}
                        />
                    )}

                    {/* Coach Filter */}
                    <div style={{ display: 'flex', gap: '1rem', marginBottom: '1rem', alignItems: 'center' }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                            <label style={{ fontWeight: 'bold' }}>Notes for:</label>
                            <select
                                className="form-select"
                                style={{ width: 'auto' }}
                                value={selectedNotesCoach}
                                onChange={e => setSelectedNotesCoach(e.target.value)}
                            >
                                <option value="ALL_COACHES">All Coaches</option>
                                {staff && staff.map(s => (
                                    <option key={s.id} value={s.id}>{s.name}</option>
                                ))}
                            </select>
                        </div>
                    </div>

                    <div style={{ flex: 1, overflowY: 'auto' }}>
                        <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                            <thead>
                                <tr style={{ borderBottom: '2px solid var(--border)', textAlign: 'left', color: 'var(--text-secondary)', fontSize: '0.9rem' }}>
                                    <th style={{ padding: '0.5rem' }}>Time</th>
                                    <th style={{ padding: '0.5rem' }}>Dur</th>
                                    <th style={{ padding: '0.5rem' }}>T-Minus</th>
                                    <th style={{ padding: '0.5rem' }}>Activity</th>
                                    <th style={{ padding: '0.5rem' }}>Location</th>
                                    <th style={{ padding: '0.5rem' }}>Notes</th>
                                    <th style={{ padding: '0.5rem', textAlign: 'right' }}>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {((plan.segments || [])).filter(segment => selectedCoachFilter === 'ALL' || segment.staffId === selectedCoachFilter)
                                    .sort((a, b) => (a?.startTime || '').localeCompare(b?.startTime || ''))
                                    .map(segment => (
                                        <tr key={segment.id} style={{ borderBottom: '1px solid var(--border)' }}>
                                            <td style={{ padding: '0.5rem' }}>
                                                <input
                                                    type="time"
                                                    className="form-input"
                                                    value={segment.startTime}
                                                    onChange={e => updateSegment(segment.id, 'startTime', e.target.value)}
                                                    disabled={isLocked}
                                                />
                                            </td>
                                            <td style={{ padding: '0.5rem' }}>
                                                <input
                                                    type="number"
                                                    className="form-input"
                                                    style={{ width: '60px', padding: '0.25rem' }}
                                                    value={segment.duration || 15}
                                                    onChange={e => updateSegment(segment.id, 'duration', parseInt(e.target.value))}
                                                    disabled={isLocked}
                                                />
                                            </td>
                                            <td style={{ padding: '0.5rem', fontWeight: 'bold', color: 'var(--accent)' }}>
                                                {calculateTMinus(segment.startTime)}
                                            </td>
                                            <td style={{ padding: '0.5rem' }}>
                                                <input
                                                    type="text"
                                                    className="form-input"
                                                    value={segment.activity}
                                                    onChange={e => updateSegment(segment.id, 'activity', e.target.value)}
                                                    disabled={isLocked}
                                                />
                                            </td>
                                            <td style={{ padding: '0.5rem' }}>
                                                <input
                                                    type="text"
                                                    className="form-input"
                                                    value={segment.location}
                                                    onChange={e => updateSegment(segment.id, 'location', e.target.value)}
                                                    disabled={isLocked}
                                                />
                                            </td>
                                            <td style={{ padding: '0.5rem' }}>
                                                {(() => {
                                                    const migrated = migrateSegmentNotes(segment);
                                                    const allNotes = migrated.notes['ALL_COACHES'];
                                                    const hasAnyNotes = Object.keys(migrated.notes).some(key => migrated.notes[key]);
                                                    const displayNote = selectedNotesCoach === 'ALL_COACHES'
                                                        ? (allNotes || (hasAnyNotes ? 'View Notes...' : ''))
                                                        : (migrated.notes[selectedNotesCoach] || '');

                                                    return (
                                                        <button
                                                            className="form-input"
                                                            style={{
                                                                padding: '0.25rem 0.5rem',
                                                                textAlign: 'left',
                                                                cursor: 'pointer',
                                                                width: '100%',
                                                                backgroundColor: hasAnyNotes ? 'var(--bg-input)' : 'transparent',
                                                                border: hasAnyNotes ? '1px solid var(--accent)' : '1px solid var(--border)',
                                                                color: hasAnyNotes ? 'var(--text-primary)' : 'var(--text-secondary)',
                                                                fontStyle: hasAnyNotes ? 'normal' : 'italic',
                                                                overflow: 'hidden',
                                                                textOverflow: 'ellipsis',
                                                                whiteSpace: 'nowrap'
                                                            }}
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                setNotesModalSegmentId(segment.id);
                                                            }}
                                                        >
                                                            {hasAnyNotes
                                                                ? (displayNote || 'Click to view notes...')
                                                                : 'Click to add notes...'
                                                            }
                                                        </button>
                                                    );
                                                })()}
                                            </td>
                                            <td style={{ padding: '0.5rem', textAlign: 'right' }}>
                                                {!isLocked && (
                                                    <button className="btn" style={{ color: '#ef4444' }} onClick={() => deleteSegment(segment.id)}>
                                                        <Icon name="PlusCircle" style={{ transform: 'rotate(45deg)' }} />
                                                    </button>
                                                )}

                                                {!isLocked && (
                                                    <button
                                                        className="btn btn-secondary no-print"
                                                        style={{ marginLeft: '4px', padding: '0.25rem 0.5rem', fontSize: '0.8rem' }}
                                                        title="Insert new item below"
                                                        onClick={(e) => {
                                                            e.stopPropagation();

                                                            let nextTime = '';
                                                            if (segment.startTime) {
                                                                const [hours, minutes] = segment.startTime.split(':').map(Number);
                                                                const date = new Date();
                                                                date.setHours(hours);
                                                                date.setMinutes(minutes + (segment.duration || 15));
                                                                nextTime = date.toTimeString().slice(0, 5);
                                                            }

                                                            const newSegment = {
                                                                id: Date.now().toString(),
                                                                type: 'Pregame',
                                                                duration: 15,
                                                                startTime: nextTime,
                                                                activity: '',
                                                                location: '',
                                                                staffId: user?.id,
                                                                notes: user?.role === 'HC' ? { 'ALL_COACHES': '' } : {}
                                                            };

                                                            const newSegments = [...(plan.segments || []), newSegment];
                                                            onUpdatePlan({ ...plan, segments: newSegments });
                                                        }}
                                                    >
                                                        + Below
                                                    </button>
                                                )}
                                            </td>
                                        </tr>
                                    ))}
                            </tbody>
                        </table>

                        {!isLocked && (
                            <div style={{ marginTop: '1rem' }}>
                                <button className="btn btn-primary" onClick={addSegment}>+ Add Segment</button>
                            </div>
                        )}

                        {/* Hidden Print Container */}
                        <div className="pregame-print-container" style={{ display: 'none' }}>
                            <div className="practice-print-header">
                                <h1>Pre-game Timeline</h1>
                                <div className="practice-print-meta">
                                    <span>Kickoff: {kickoffTime}</span>
                                </div>
                            </div>

                            <table className="practice-schedule-table">
                                <thead>
                                    <tr>
                                        <th>Real Time</th>
                                        <th>Dur</th>
                                        <th>Clock</th>
                                        <th>Activity</th>
                                        <th>Location</th>
                                        <th>Staff</th>
                                        <th>Notes</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {(plan.segments || [])
                                        .sort((a, b) => (a?.startTime || '').localeCompare(b?.startTime || ''))
                                        .map(seg => (
                                            <tr key={seg.id}>
                                                <td>{seg.startTime}</td>
                                                <td>{seg.duration || 15}</td>
                                                <td style={{ fontWeight: 'bold' }}>{calculateTMinus(seg.startTime)}</td>
                                                <td>{seg.activity}</td>
                                                <td>{seg.location}</td>
                                                <td>{staff && staff.find(s => s.id === seg.staffId)?.name || ''}</td>
                                                <td>{(() => {
                                                    const migrated = migrateSegmentNotes(seg);
                                                    const notes = migrated.notes;
                                                    const allCoachesNotes = notes['ALL_COACHES'] || '';
                                                    const coachNotes = selectedCoachFilter !== 'ALL' ? (notes[selectedCoachFilter] || '') : '';

                                                    // Combine notes: All Coaches first, then coach-specific
                                                    const combined = [];
                                                    if (allCoachesNotes) combined.push(`[All] ${allCoachesNotes}`);
                                                    if (coachNotes) combined.push(coachNotes);
                                                    return combined.join(' | ');
                                                })()}</td>
                                            </tr>
                                        ))}
                                </tbody>
                            </table>
                        </div>
                    </div>

                </div>
            );
        };


        // REMOVED: PlayerProfileView and PlayerProfileGallery (~1,148 lines)
        // Available in git history for restoration

        const RosterManager = ({ roster, onUpdateRoster, depthChart }) => {
            const { isFree } = useSchoolPlan(); // School Plan Hook
            const [newPlayer, setNewPlayer] = useState({
                number: '', name: '', position: 'QB/LB', offPosition: 'QB', defPosition: 'LB', year: 'Fr', height: '', weight: '',
                helmetSize: '', shoulderPadSize: '', pantSize: '',
                injured: false, traveling: true, captain: false,
                offenseRoles: [], defenseRoles: [], specialRoles: []
            });
            const [isEditing, setIsEditing] = useState(null);
            const [showArchived, setShowArchived] = useState(false);
            const [showImportHelp, setShowImportHelp] = useState(false);
            const fileInputRef = useRef(null);

            const downloadTemplate = () => {
                const template = `Number,Name,OffPos,DefPos,Year,Height,Weight
1,John Smith,QB,LB,Sr,6'2",185
2,Mike Johnson,RB,LB,Jr,5'11",175
3,Chris Davis,WR,DB,So,6'0",170`;

                const blob = new Blob([template], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'roster_template.csv';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            };

            const handleImportClick = () => {
                if (fileInputRef.current) fileInputRef.current.click();
            };

            const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const text = event.target.result;
                    processCSV(text);
                };
                reader.readAsText(file);
                // Reset input
                e.target.value = '';
            };

            const processCSV = (csvText) => {
                // detailed parser to handle quotes
                const rows = [];
                let currentRow = [];
                let currentCell = '';
                let inQuotes = false;

                for (let i = 0; i < csvText.length; i++) {
                    const char = csvText[i];
                    const nextChar = csvText[i + 1];

                    if (char === '"') {
                        if (inQuotes && nextChar === '"') {
                            currentCell += '"';
                            i++; // skip escaped quote
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (char === ',' && !inQuotes) {
                        currentRow.push(currentCell.trim());
                        currentCell = '';
                    } else if ((char === '\r' || char === '\n') && !inQuotes) {
                        if (currentCell || currentRow.length > 0) {
                            currentRow.push(currentCell.trim());
                            rows.push(currentRow);
                        }
                        currentRow = [];
                        currentCell = '';
                        if (char === '\r' && nextChar === '\n') i++;
                    } else {
                        currentCell += char;
                    }
                }
                if (currentCell || currentRow.length > 0) {
                    currentRow.push(currentCell.trim());
                    rows.push(currentRow);
                }

                if (rows.length < 2) {
                    alert("Invalid CSV format or empty file.");
                    return;
                }

                const headers = rows[0].map(h => h.toLowerCase().replace(/[^a-z0-9]/g, ''));
                const map = {};

                // Smart Mapping
                headers.forEach((h, i) => {
                    if (['number', 'jersey', 'no', '#'].includes(h)) map.number = i;
                    if (['name', 'fullname', 'player'].includes(h)) map.name = i;
                    if (['firstname', 'first'].includes(h)) map.firstName = i;
                    if (['lastname', 'last'].includes(h)) map.lastName = i;
                    if (['position', 'pos'].includes(h)) map.pos = i;
                    if (['offpos', 'offense'].includes(h)) map.offPos = i;
                    if (['defpos', 'defense'].includes(h)) map.defPos = i;
                    if (['year', 'grade', 'class', 'yr', 'gr'].includes(h)) map.year = i;
                    if (['height', 'ht'].includes(h)) map.height = i;
                    if (['weight', 'wt'].includes(h)) map.weight = i;
                });

                if (map.name === undefined && (map.firstName === undefined || map.lastName === undefined)) {
                    alert("Could not detect Name column. Please ensure header contains 'Name' or 'First Name'/'Last Name'.");
                    return;
                }

                const newPlayers = rows.slice(1).map(row => {
                    const p = {};

                    // Number
                    p.number = map.number !== undefined ? row[map.number] : '';

                    // Name
                    if (map.name !== undefined) p.name = row[map.name];
                    else if (map.firstName !== undefined && map.lastName !== undefined) {
                        p.name = `${row[map.firstName]} ${row[map.lastName]}`;
                    }

                    // Parse Name if strictly Last, First? (Simple check)
                    if (p.name && p.name.includes(',')) {
                        const parts = p.name.split(',');
                        if (parts.length === 2) p.name = `${parts[1].trim()} ${parts[0].trim()}`;
                    }

                    // Position
                    let offPos = 'NA';
                    let defPos = 'NA';

                    if (map.offPos !== undefined) offPos = row[map.offPos] || 'NA';
                    if (map.defPos !== undefined) defPos = row[map.defPos] || 'NA';

                    if (map.pos !== undefined) {
                        // Try to split generic 'QB/LB'
                        const rawPos = row[map.pos] || '';
                        if (rawPos.includes('/')) {
                            const parts = rawPos.split('/');
                            offPos = parts[0].trim();
                            defPos = parts[1].trim();
                        } else {
                            // Assign to Offense by default if known offense pos, else defense
                            if (['QB', 'RB', 'WR', 'TE', 'OL', 'T', 'G', 'C'].includes(rawPos)) offPos = rawPos;
                            else if (['DL', 'DE', 'DT', 'LB', 'CB', 'S', 'DB', 'SS', 'FS'].includes(rawPos)) defPos = rawPos;
                            else offPos = rawPos; // Fallback
                        }
                    }

                    p.offPosition = offPos;
                    p.defPosition = defPos;
                    p.position = `${offPos}/${defPos}`;

                    // Year
                    let rawYear = map.year !== undefined ? row[map.year] : 'Fr';
                    // Normalize Year
                    if (rawYear.toUpperCase() === 'SR' || rawYear === '12') p.year = 'Sr';
                    else if (rawYear.toUpperCase() === 'JR' || rawYear === '11') p.year = 'Jr';
                    else if (rawYear.toUpperCase() === 'SO' || rawYear === '10') p.year = 'So';
                    else if (rawYear.toUpperCase() === 'FR' || rawYear === '9') p.year = 'Fr';
                    else p.year = rawYear;

                    // Height/Weight
                    p.height = map.height !== undefined ? row[map.height] : '';
                    p.weight = map.weight !== undefined ? row[map.weight] : '';

                    // Defaults
                    p.id = 'import_' + Date.now() + Math.random().toString(36).substr(2, 9);
                    p.active = true;
                    p.archived = false;

                    // Init structures
                    p.profile = { favorites: {}, goals: {} };
                    p.metrics = { attendanceStreak: 0, awards: [] };

                    return p;
                }).filter(p => p.name); // valid players only

                if (confirm(`Found ${newPlayers.length} players. Import them to roster?`)) {
                    // Check for existing numbers to avoid total duplicates? 
                    // For now, simple append or maybe filter by existing number?
                    // Let's Append but warn logic is typically preferred.
                    // The user usually wants to bulk add.
                    onUpdateRoster([...roster, ...newPlayers]);
                    alert("Import successful!");
                }
            };



            const positions = ['QB', 'RB', 'WR', 'TE', 'OL', 'OT', 'OG', 'C', 'DE', 'DT', 'LB', 'CB', 'S', 'K', 'P', 'LS']; // Expanded primary list
            const years = ['Fr', 'So', 'Jr', 'Sr'];

            const OFFENSE_TAGS = ['QB', 'RB', 'WR', 'TE', 'OL'];
            const DEFENSE_TAGS = ['DL', 'LB', 'DB'];
            const SPECIAL_TAGS = ['K', 'P', 'LS', 'H', 'KR', 'PR'];

            const toggleTag = (category, tag) => {
                setNewPlayer(prev => {
                    const current = prev[category];
                    if (current.includes(tag)) {
                        return { ...prev, [category]: current.filter(t => t !== tag) };
                    } else {
                        return { ...prev, [category]: [...current, tag] };
                    }
                });
            };

            const addPlayer = () => {
                // Free Plan Guardrail
                if (isFree && roster.length >= 50) {
                    alert("Free Plan Limit Reached (50 Players). Upgrade to Premium to add more players.");
                    return;
                }

                if (!newPlayer.number || !newPlayer.name) return;
                const position = `${newPlayer.offPosition}/${newPlayer.defPosition}`;
                onUpdateRoster([...roster, { ...newPlayer, position, id: Date.now().toString() }]);
                setNewPlayer({
                    number: '', name: '', position: 'QB/LB', offPosition: 'QB', defPosition: 'LB', year: 'Fr', height: '', weight: '',
                    helmetSize: '', shoulderPadSize: '', pantSize: '',
                    injured: false, traveling: true, captain: false,
                    offenseRoles: [], defenseRoles: [], specialRoles: []
                });
            };

            const updatePlayer = (id, field, value) => {
                // If updating off/def pos, also update the combined string for compat
                let updatedPlayer = roster.find(p => p.id === id);
                if (field === 'offPosition') {
                    const newPos = `${value}/${updatedPlayer.defPosition || 'NA'}`;
                    onUpdateRoster(roster.map(p => p.id === id ? { ...p, [field]: value, position: newPos } : p));
                } else if (field === 'defPosition') {
                    const newPos = `${updatedPlayer.offPosition || 'NA'}/${value}`;
                    onUpdateRoster(roster.map(p => p.id === id ? { ...p, [field]: value, position: newPos } : p));
                } else {
                    onUpdateRoster(roster.map(p => p.id === id ? { ...p, [field]: value } : p));
                }
            };

            const archivePlayer = (id) => {
                if (window.confirm("Are you sure you want to archive this player? They will be hidden from the active roster but can be restored.")) {
                    onUpdateRoster(roster.map(p => p.id === id ? { ...p, archived: true } : p));
                }
            };

            const restorePlayer = (id) => {
                onUpdateRoster(roster.map(p => p.id === id ? { ...p, archived: false } : p));
            };

            const deletePlayer = (id) => {
                if (window.confirm("PERMANENT DELETE: This cannot be undone. Are you sure?")) {
                    onUpdateRoster(roster.filter(p => p.id !== id));
                }
            };





            // Sort by number
            // Sort by number and filter
            const visibleRoster = roster.filter(p => showArchived ? p.archived : !p.archived);
            const sortedRoster = [...visibleRoster].sort((a, b) => parseInt(a.number) - parseInt(b.number));

            return (
                <div style={{ height: 'calc(100vh - 100px)', display: 'flex', flexDirection: 'column' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '2rem' }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                            <h2>Roster Management</h2>
                        </div>
                        <div style={{ display: 'flex', gap: '1rem' }}>

                            <button className={`btn ${showArchived ? 'btn-danger' : 'btn-secondary'}`} onClick={() => setShowArchived(!showArchived)}>
                                {showArchived ? 'Back to Active Roster' : 'View Archive'}
                            </button>
                            <button className="btn btn-secondary" onClick={downloadTemplate} title="Download CSV Template">
                                <Icon name="Download" size={16} /> Download Template
                            </button>
                            <button className="btn btn-secondary" onClick={handleImportClick}>
                                <Icon name="Upload" size={16} /> Import CSV
                            </button>
                            <button className="btn btn-secondary" onClick={() => setShowImportHelp(true)} title="How to import roster">
                                <Icon name="HelpCircle" size={16} />
                            </button>
                            <input
                                type="file"
                                ref={fileInputRef}
                                style={{ display: 'none' }}
                                accept=".csv"
                                onChange={handleFileChange}
                            />
                            <button className="btn btn-secondary" onClick={() => window.print()}>🖨️ Print Attendance</button>
                        </div>
                    </div>

                    <div className="card" style={{ marginBottom: '2rem', border: showArchived ? '2px dashed #f59e0b' : '1px solid var(--border)' }}>
                        {showArchived && <div style={{ marginBottom: '1rem', color: '#f59e0b', fontWeight: 'bold' }}>⚠️ VIEWING ARCHIVED PLAYERS</div>}
                        {!showArchived && (
                            <>
                                <h4 style={{ marginBottom: '1rem', borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem' }}>Add New Athlete</h4>

                                {/* Row 1: Basic Info */}
                                <div style={{ display: 'flex', gap: '1rem', marginBottom: '1rem' }}>
                                    <div style={{ width: '80px' }}>
                                        <label className="form-label">#</label>
                                        <input type="number" className="form-input" value={newPlayer.number} onChange={e => setNewPlayer({ ...newPlayer, number: e.target.value })} placeholder="#" />
                                    </div>
                                    <div style={{ flex: 2 }}>
                                        <label className="form-label">Name</label>
                                        <input type="text" className="form-input" value={newPlayer.name} onChange={e => setNewPlayer({ ...newPlayer, name: e.target.value })} placeholder="Player Name" />
                                    </div>
                                    <div style={{ flex: 1 }}>
                                        <label className="form-label">Off Pos</label>
                                        <select className="form-select" value={newPlayer.offPosition} onChange={e => setNewPlayer({ ...newPlayer, offPosition: e.target.value })}>
                                            <option value="NA">--</option>
                                            {positions.map(p => <option key={p}>{p}</option>)}
                                        </select>
                                    </div>
                                    <div style={{ flex: 1 }}>
                                        <label className="form-label">Def Pos</label>
                                        <select className="form-select" value={newPlayer.defPosition} onChange={e => setNewPlayer({ ...newPlayer, defPosition: e.target.value })}>
                                            <option value="NA">--</option>
                                            {positions.map(p => <option key={p}>{p}</option>)}
                                        </select>
                                    </div>
                                    <div style={{ flex: 1 }}>
                                        <label className="form-label">Year</label>
                                        <select className="form-select" value={newPlayer.year} onChange={e => setNewPlayer({ ...newPlayer, year: e.target.value })}>
                                            {years.map(y => <option key={y}>{y}</option>)}
                                        </select>
                                    </div>
                                    <div style={{ width: '80px' }}>
                                        <label className="form-label">Ht</label>
                                        <input type="text" className="form-input" value={newPlayer.height} onChange={e => setNewPlayer({ ...newPlayer, height: e.target.value })} placeholder="6'2" />
                                    </div>
                                    <div style={{ width: '80px' }}>
                                        <label className="form-label">Wt</label>
                                        <input type="text" className="form-input" value={newPlayer.weight} onChange={e => setNewPlayer({ ...newPlayer, weight: e.target.value })} placeholder="210" />
                                    </div>
                                </div>

                                {/* Row 1.5: Equipment Sizes */}
                                <div style={{ display: 'flex', gap: '1rem', marginBottom: '1rem' }}>
                                    <div style={{ flex: 1 }}>
                                        <label className="form-label">Helmet Size</label>
                                        <select className="form-select" value={newPlayer.helmetSize} onChange={e => setNewPlayer({ ...newPlayer, helmetSize: e.target.value })}>
                                            <option value="">Select...</option>
                                            {['S', 'M', 'L', 'XL', '2XL'].map(s => <option key={s}>{s}</option>)}
                                        </select>
                                    </div>
                                    <div style={{ flex: 1 }}>
                                        <label className="form-label">Shoulder Pad</label>
                                        <select className="form-select" value={newPlayer.shoulderPadSize} onChange={e => setNewPlayer({ ...newPlayer, shoulderPadSize: e.target.value })}>
                                            <option value="">Select...</option>
                                            {['S', 'M', 'L', 'XL', '2XL', '3XL'].map(s => <option key={s}>{s}</option>)}
                                        </select>
                                    </div>
                                    <div style={{ flex: 1 }}>
                                        <label className="form-label">Pant Size</label>
                                        <select className="form-select" value={newPlayer.pantSize} onChange={e => setNewPlayer({ ...newPlayer, pantSize: e.target.value })}>
                                            <option value="">Select...</option>
                                            {['S', 'M', 'L', 'XL', '2XL', '3XL'].map(s => <option key={s}>{s}</option>)}
                                        </select>
                                    </div>
                                </div>

                                {/* Row 2: Tagging */}
                                <div style={{ display: 'flex', gap: '2rem', marginBottom: '1rem', flexWrap: 'wrap' }}>
                                    <div style={{ flex: 1, minWidth: '200px' }}>
                                        <label className="form-label" style={{ color: 'var(--accent)' }}>Offense Roles</label>
                                        <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                                            {OFFENSE_TAGS.map(tag => (
                                                <label key={tag} style={{ display: 'flex', alignItems: 'center', gap: '4px', fontSize: '0.85rem', cursor: 'pointer', background: newPlayer.offenseRoles.includes(tag) ? 'var(--highlight)' : 'var(--surface)', padding: '4px 8px', borderRadius: '4px', border: newPlayer.offenseRoles.includes(tag) ? '1px solid var(--accent)' : '1px solid transparent' }}>
                                                    <input type="checkbox" checked={newPlayer.offenseRoles.includes(tag)} onChange={() => toggleTag('offenseRoles', tag)} style={{ display: 'none' }} />
                                                    {tag}
                                                </label>
                                            ))}
                                        </div>
                                    </div>
                                    <div style={{ flex: 1, minWidth: '200px' }}>
                                        <label className="form-label" style={{ color: 'var(--accent)' }}>Defense Roles</label>
                                        <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                                            {DEFENSE_TAGS.map(tag => (
                                                <label key={tag} style={{ display: 'flex', alignItems: 'center', gap: '4px', fontSize: '0.85rem', cursor: 'pointer', background: newPlayer.defenseRoles.includes(tag) ? 'var(--highlight)' : 'var(--surface)', padding: '4px 8px', borderRadius: '4px', border: newPlayer.defenseRoles.includes(tag) ? '1px solid var(--accent)' : '1px solid transparent' }}>
                                                    <input type="checkbox" checked={newPlayer.defenseRoles.includes(tag)} onChange={() => toggleTag('defenseRoles', tag)} style={{ display: 'none' }} />
                                                    {tag}
                                                </label>
                                            ))}
                                        </div>
                                    </div>
                                    <div style={{ flex: 1, minWidth: '200px' }}>
                                        <label className="form-label" style={{ color: 'var(--accent)' }}>Special Teams</label>
                                        <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                                            {SPECIAL_TAGS.map(tag => (
                                                <label key={tag} style={{ display: 'flex', alignItems: 'center', gap: '4px', fontSize: '0.85rem', cursor: 'pointer', background: newPlayer.specialRoles.includes(tag) ? 'var(--highlight)' : 'var(--surface)', padding: '4px 8px', borderRadius: '4px', border: newPlayer.specialRoles.includes(tag) ? '1px solid var(--accent)' : '1px solid transparent' }}>
                                                    <input type="checkbox" checked={newPlayer.specialRoles.includes(tag)} onChange={() => toggleTag('specialRoles', tag)} style={{ display: 'none' }} />
                                                    {tag}
                                                </label>
                                            ))}
                                        </div>
                                    </div>
                                </div>

                                {/* Row 3: Actions */}
                                <div style={{ display: 'flex', justifyContent: 'flex-end', alignItems: 'center', gap: '1rem', borderTop: '1px solid var(--border)', paddingTop: '1rem' }}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                        <input type="checkbox" checked={newPlayer.captain} onChange={e => setNewPlayer({ ...newPlayer, captain: e.target.checked })} style={{ width: '18px', height: '18px', accentColor: 'var(--accent)' }} />
                                        <label>Team Captain</label>
                                    </div>
                                    <button className="btn btn-primary" onClick={addPlayer}>
                                        <Icon name="PlusCircle" /> Add Athlete
                                    </button>
                                </div>
                            </>
                        )}
                    </div>

                    <div style={{ flex: 1, overflowY: 'auto' }}>
                        <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                            <thead>
                                <tr style={{ borderBottom: '2px solid var(--border)', textAlign: 'left', color: 'var(--text-secondary)', fontSize: '0.9rem' }}>
                                    <th style={{ padding: '0.5rem' }}>#</th>
                                    <th style={{ padding: '0.5rem' }}>Name</th>
                                    <th style={{ padding: '0.5rem' }}>Pos (Off/Def)</th>
                                    <th style={{ padding: '0.5rem' }}>Roles / Tags</th>
                                    <th style={{ padding: '0.5rem' }}>Year</th>
                                    <th style={{ padding: '0.5rem' }}>Ht</th>
                                    <th style={{ padding: '0.5rem' }}>Ht</th>
                                    <th style={{ padding: '0.5rem' }}>Wt</th>
                                    <th style={{ padding: '0.5rem' }}>Equipment</th>
                                    <th style={{ padding: '0.5rem', textAlign: 'center' }}>Cpt</th>
                                    <th style={{ padding: '0.5rem', textAlign: 'center' }}>Traveling</th>
                                    <th style={{ padding: '0.5rem', textAlign: 'center' }}>Load</th>
                                    <th style={{ padding: '0.5rem', textAlign: 'right' }}>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {sortedRoster.map(player => (
                                    <tr key={player.id} style={{ borderBottom: '1px solid var(--border)' }}>
                                        <td style={{ padding: '0.75rem 0.5rem', fontWeight: 'bold', color: 'var(--accent)' }}>
                                            {isEditing === player.id ? (
                                                <input
                                                    type="number"
                                                    className="form-input"
                                                    style={{ width: '50px' }}
                                                    value={player.number}
                                                    onChange={e => updatePlayer(player.id, 'number', e.target.value)}
                                                />
                                            ) : `#${player.number}`}
                                        </td>
                                        <td style={{ padding: '0.75rem 0.5rem', fontWeight: 'bold' }}>
                                            {isEditing === player.id ? (
                                                <input
                                                    type="text"
                                                    className="form-input"
                                                    value={player.name}
                                                    onChange={e => updatePlayer(player.id, 'name', e.target.value)}
                                                />
                                            ) : (
                                                <span>
                                                    {player.name}
                                                    {player.captain && <span style={{ marginLeft: '0.5rem', fontSize: '0.8rem' }}>©️</span>}
                                                </span>
                                            )}
                                        </td>
                                        <td style={{ padding: '0.75rem 0.5rem' }}>
                                            {isEditing === player.id ? (
                                                <div style={{ display: 'flex', gap: '4px', flexDirection: 'column' }}>
                                                    <select
                                                        className="form-select"
                                                        style={{ padding: '2px', fontSize: '0.8rem' }}
                                                        value={player.offPosition || 'NA'}
                                                        onChange={e => updatePlayer(player.id, 'offPosition', e.target.value)}
                                                    >
                                                        <option value="NA">--</option>
                                                        {positions.map(p => <option key={p}>{p}</option>)}
                                                    </select>
                                                    <select
                                                        className="form-select"
                                                        style={{ padding: '2px', fontSize: '0.8rem' }}
                                                        value={player.defPosition || 'NA'}
                                                        onChange={e => updatePlayer(player.id, 'defPosition', e.target.value)}
                                                    >
                                                        <option value="NA">--</option>
                                                        {positions.map(p => <option key={p}>{p}</option>)}
                                                    </select>
                                                </div>
                                            ) : (
                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '2px' }}>
                                                    <span style={{ fontWeight: 'bold', color: 'var(--text-primary)' }}>{player.offPosition}</span>
                                                    <span style={{ color: 'var(--text-secondary)', fontSize: '0.85rem' }}>{player.defPosition}</span>
                                                </div>
                                            )}
                                        </td>
                                        <td style={{ padding: '0.75rem 0.5rem' }}>
                                            <div style={{ display: 'flex', gap: '4px', flexWrap: 'wrap' }}>
                                                {(player.offenseRoles || []).map(t => (
                                                    <span key={t} style={{ fontSize: '0.7rem', background: 'var(--surface)', padding: '2px 6px', borderRadius: '4px' }}>{t}</span>
                                                ))}
                                                {(player.defenseRoles || []).map(t => (
                                                    <span key={t} style={{ fontSize: '0.7rem', background: 'rgba(239, 68, 68, 0.2)', padding: '2px 6px', borderRadius: '4px', color: '#fca5a5' }}>{t}</span>
                                                ))}
                                                {(player.specialRoles || []).map(t => (
                                                    <span key={t} style={{ fontSize: '0.7rem', background: 'rgba(59, 130, 246, 0.2)', padding: '2px 6px', borderRadius: '4px', color: '#93c5fd' }}>{t}</span>
                                                ))}
                                            </div>
                                        </td>
                                        <td style={{ padding: '0.75rem 0.5rem' }}>
                                            {isEditing === player.id ? (
                                                <select
                                                    className="form-select"
                                                    value={player.year}
                                                    onChange={e => updatePlayer(player.id, 'year', e.target.value)}
                                                >
                                                    {years.map(y => <option key={y}>{y}</option>)}
                                                </select>
                                            ) : player.year}
                                        </td>
                                        <td style={{ padding: '0.75rem 0.5rem' }}>
                                            {isEditing === player.id ? (
                                                <input
                                                    type="text"
                                                    className="form-input"
                                                    style={{ width: '60px' }}
                                                    value={player.height || ''}
                                                    onChange={e => updatePlayer(player.id, 'height', e.target.value)}
                                                />
                                            ) : player.height}
                                        </td>
                                        <td style={{ padding: '0.75rem 0.5rem' }}>
                                            {isEditing === player.id ? (
                                                <input
                                                    type="text"
                                                    className="form-input"
                                                    style={{ width: '60px' }}
                                                    value={player.weight || ''}
                                                    onChange={e => updatePlayer(player.id, 'weight', e.target.value)}
                                                />
                                            ) : player.weight}
                                        </td>
                                        <td style={{ padding: '0.75rem 0.5rem', fontSize: '0.85rem' }}>
                                            {isEditing === player.id ? (
                                                <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center' }}>
                                                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
                                                        <span style={{ fontSize: '0.6rem', color: 'var(--text-secondary)' }}>H</span>
                                                        <select className="form-select" style={{ padding: '2px', width: '50px' }} value={player.helmetSize || ''} onChange={e => updatePlayer(player.id, 'helmetSize', e.target.value)}>
                                                            <option value="">-</option>
                                                            {['S', 'M', 'L', 'XL', '2XL'].map(s => <option key={s} value={s}>{s}</option>)}
                                                        </select>
                                                    </div>
                                                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
                                                        <span style={{ fontSize: '0.6rem', color: 'var(--text-secondary)' }}>Pd</span>
                                                        <select className="form-select" style={{ padding: '2px', width: '50px' }} value={player.shoulderPadSize || ''} onChange={e => updatePlayer(player.id, 'shoulderPadSize', e.target.value)}>
                                                            <option value="">-</option>
                                                            {['S', 'M', 'L', 'XL', '2XL', '3XL'].map(s => <option key={s} value={s}>{s}</option>)}
                                                        </select>
                                                    </div>
                                                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
                                                        <span style={{ fontSize: '0.6rem', color: 'var(--text-secondary)' }}>Pt</span>
                                                        <select className="form-select" style={{ padding: '2px', width: '50px' }} value={player.pantSize || ''} onChange={e => updatePlayer(player.id, 'pantSize', e.target.value)}>
                                                            <option value="">-</option>
                                                            {['S', 'M', 'L', 'XL', '2XL', '3XL'].map(s => <option key={s} value={s}>{s}</option>)}
                                                        </select>
                                                    </div>
                                                </div>
                                            ) : (
                                                <div style={{ color: 'var(--text-secondary)', display: 'flex', gap: '0.5rem', fontSize: '0.8rem' }}>
                                                    <div title="Helmet">H: <span style={{ color: 'var(--text-primary)', fontWeight: 'bold' }}>{player.helmetSize || '-'}</span></div>
                                                    <div title="Pads">P: <span style={{ color: 'var(--text-primary)', fontWeight: 'bold' }}>{player.shoulderPadSize || '-'}</span></div>
                                                    <div title="Pants">Pa: <span style={{ color: 'var(--text-primary)', fontWeight: 'bold' }}>{player.pantSize || '-'}</span></div>
                                                </div>
                                            )}
                                        </td>
                                        <td style={{ padding: '0.75rem 0.5rem', textAlign: 'center' }}>
                                            <input
                                                type="checkbox"
                                                checked={player.captain || false}
                                                onChange={e => updatePlayer(player.id, 'captain', e.target.checked)}
                                                style={{ width: '18px', height: '18px', accentColor: 'var(--accent)' }}
                                            />
                                        </td>
                                        <td style={{ padding: '0.75rem 0.5rem', textAlign: 'center' }}>
                                            <input
                                                type="checkbox"
                                                checked={player.traveling}
                                                onChange={e => updatePlayer(player.id, 'traveling', e.target.checked)}
                                            />
                                        </td>

                                        {/* Load Column */}
                                        <td style={{ padding: '0.75rem 0.5rem', textAlign: 'center' }}>
                                            {(() => {
                                                const { totalScore } = calculatePlayerLoad(player.id, depthChart);
                                                let color = '#10b981'; // Green
                                                if (totalScore >= 9) color = '#ef4444'; // Red
                                                else if (totalScore >= 6) color = '#eab308'; // Yellow

                                                return (
                                                    <span style={{
                                                        background: color,
                                                        color: '#fff',
                                                        padding: '2px 8px',
                                                        borderRadius: '12px',
                                                        fontSize: '0.8rem',
                                                        fontWeight: 'bold'
                                                    }}>
                                                        {totalScore}
                                                    </span>
                                                );
                                            })()}
                                        </td>
                                        <td style={{ padding: '0.75rem 1rem', textAlign: 'right' }}>
                                            {isEditing === player.id ? (
                                                <button className="btn btn-primary" style={{ padding: '0.25rem 0.75rem', fontSize: '0.8rem' }} onClick={() => setIsEditing(null)}>Done</button>
                                            ) : (
                                                <div style={{ display: 'flex', gap: '0.5rem', justifyContent: 'flex-end' }}>
                                                    <button className="btn btn-secondary" style={{ padding: '0.25rem 0.5rem', fontSize: '0.8rem' }} onClick={() => setIsEditing(player.id)}>Edit</button>
                                                    {showArchived ? (
                                                        <>
                                                            <button className="btn" style={{ padding: '0.25rem 0.5rem', fontSize: '0.8rem', backgroundColor: '#10b981', color: '#fff', border: 'none' }} onClick={() => restorePlayer(player.id)}>Restore</button>
                                                            <button className="btn" style={{ padding: '0.25rem 0.5rem', fontSize: '0.8rem', color: '#ef4444' }} onClick={() => deletePlayer(player.id)}>Delete</button>
                                                        </>
                                                    ) : (
                                                        <button className="btn" style={{ padding: '0.25rem 0.5rem', fontSize: '0.8rem', backgroundColor: 'transparent', border: '1px solid #f59e0b', color: '#f59e0b' }} onClick={() => archivePlayer(player.id)}>Archive</button>
                                                    )}
                                                </div>
                                            )}
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>

                    {/* Import Help Modal */}
                    {showImportHelp && (
                        <div className="modal-overlay" onClick={() => setShowImportHelp(false)}>
                            <div className="modal-content" onClick={e => e.stopPropagation()} style={{ maxWidth: '700px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                                    <h3 style={{ margin: 0 }}>📋 How to Import Your Roster</h3>
                                    <button onClick={() => setShowImportHelp(false)} style={{ background: 'none', border: 'none', fontSize: '1.5rem', cursor: 'pointer', color: 'var(--text-secondary)' }}>×</button>
                                </div>

                                <div style={{ marginBottom: '1.5rem' }}>
                                    <h4 style={{ color: 'var(--accent)', marginBottom: '0.75rem' }}>Step 1: Download the Template</h4>
                                    <p style={{ marginBottom: '0.5rem' }}>Click the <strong>"Download Template"</strong> button to get a sample CSV file with the correct format.</p>
                                </div>

                                <div style={{ marginBottom: '1.5rem' }}>
                                    <h4 style={{ color: 'var(--accent)', marginBottom: '0.75rem' }}>Step 2: Fill in Your Data</h4>
                                    <p style={{ marginBottom: '0.5rem' }}>Open the template in Excel, Google Sheets, or any spreadsheet program and fill in your roster data.</p>

                                    <div style={{ marginTop: '1rem' }}>
                                        <div style={{ marginBottom: '0.5rem', fontWeight: 'bold' }}>Expected Spreadsheet Columns:</div>
                                        <div style={{
                                            display: 'flex',
                                            overflowX: 'auto',
                                            border: '1px solid var(--border)',
                                            borderRadius: '6px',
                                            background: 'white',
                                            boxShadow: 'inset 0 2px 4px rgba(0,0,0,0.05)'
                                        }}>
                                            {[
                                                { header: 'Number', alias: 'Jersey, #, No', example: '12' },
                                                { header: 'Name', alias: 'Full Name, Player', example: 'John Doe' },
                                                { header: 'OffPos', alias: 'Offense', example: 'QB' },
                                                { header: 'DefPos', alias: 'Defense', example: 'LB' },
                                                { header: 'Year', alias: 'Grade, Class, Yr', example: 'Fr, 9' },
                                                { header: 'Height', alias: 'Ht', example: '6\'2"' },
                                                { header: 'Weight', alias: 'Wt', example: '185' },
                                            ].map((col, idx) => (
                                                <div key={idx} style={{
                                                    minWidth: '130px',
                                                    flexShrink: 0,
                                                    borderRight: '1px solid var(--border)',
                                                    display: 'flex',
                                                    flexDirection: 'column'
                                                }}>
                                                    {/* Header Cell */}
                                                    <div style={{
                                                        background: '#f8fafc',
                                                        padding: '8px',
                                                        borderBottom: '1px solid var(--border)',
                                                        fontWeight: 'bold',
                                                        textAlign: 'center',
                                                        color: '#334155',
                                                        fontSize: '0.9rem'
                                                    }}>
                                                        {col.header}
                                                    </div>
                                                    {/* Body Cell */}
                                                    <div style={{ padding: '8px', fontSize: '0.8rem', flex: 1, display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                                        <div style={{ color: 'var(--text-secondary)' }}>
                                                            <span style={{ fontSize: '0.7rem', textTransform: 'uppercase', opacity: 0.7 }}>Accepts:</span><br />
                                                            {col.alias}
                                                        </div>
                                                        <div style={{ marginTop: 'auto', paddingTop: '4px', borderTop: '1px dashed var(--border)', color: 'var(--accent)', fontFamily: 'monospace' }}>
                                                            Ex: {col.example}
                                                        </div>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                        <div style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', marginTop: '4px', textAlign: 'right', fontStyle: 'italic' }}>
                                            Scroll horizontally to see more labels &rarr;
                                        </div>
                                    </div>
                                </div>

                                <div style={{ marginBottom: '1.5rem' }}>
                                    <h4 style={{ color: 'var(--accent)', marginBottom: '0.75rem' }}>Step 3: Save as CSV</h4>
                                    <p style={{ marginBottom: '0.5rem' }}>Save your file as a <strong>.csv</strong> (Comma Separated Values) file.</p>
                                    <p style={{ fontSize: '0.9rem', color: 'var(--text-secondary)' }}>In Excel: File → Save As → Choose "CSV (Comma delimited)"</p>
                                </div>

                                <div style={{ marginBottom: '1.5rem' }}>
                                    <h4 style={{ color: 'var(--accent)', marginBottom: '0.75rem' }}>Step 4: Import</h4>
                                    <p style={{ marginBottom: '0.5rem' }}>Click <strong>"Import CSV"</strong> and select your file. The system will automatically map the columns and import your players!</p>
                                </div>

                                <div style={{ background: '#dbeafe', border: '1px solid #3b82f6', borderRadius: '8px', padding: '1rem', marginTop: '1.5rem' }}>
                                    <strong style={{ color: '#1e40af' }}>💡 Pro Tip:</strong>
                                    <p style={{ margin: '0.5rem 0 0 0', color: '#1e3a8a' }}>The importer is smart! It will recognize common column names even if they don't match exactly. Just make sure you have at least a Name column (or First Name + Last Name).</p>
                                </div>

                                <div style={{ marginTop: '1.5rem', textAlign: 'right' }}>
                                    <button className="btn btn-primary" onClick={() => setShowImportHelp(false)}>Got it!</button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };



        // --- VALHALLA UI COMPONENTS ---

        // --- VALHALLA 2.0 CONSTANTS & HELPERS ---
        // Colors
        // Football team colors (NFL & College inspired)
        const PRESET_COLORS = [
            '#002244', // Navy (Patriots, Cowboys)
            '#0B162A', // Dark Navy (Bears)
            '#003594', // Royal Blue (Giants, Bills)
            '#0076B6', // Powder Blue (Chargers, UNC)
            '#203731', // Green Bay Green
            '#004C54', // Eagles Green
            '#006778', // Jaguars Teal
            '#E31837', // Chiefs Red
            '#C8102E', // 49ers Red
            '#9E1B32', // Crimson (Alabama)
            '#500000', // Maroon (Texas A&M)
            '#4F2683', // Vikings Purple
            '#241773', // Ravens Purple
            '#FB4F14', // Broncos Orange
            '#FF7900', // Bengals Orange
            '#FFB612', // Steelers Gold
            '#B3995D', // Saints Gold
            '#000000', // Raiders Black
            '#A5ACAF', // Silver
            '#5A5A5A', // Charcoal
        ];

        const CALENDAR_CONSTANTS = {
            PRACTICE_TEMPO_PROTOCOLS: [
                { id: 'thud', code: 'THUD', label: 'Thud' },
                { id: 'tag', code: 'TAG', label: 'Tag' },
                { id: 'live', code: 'LIVE', label: 'Live' },
                { id: 'wrap', code: 'WRAP', label: 'Wrap' },
                { id: 'air', code: 'AIR', label: 'Air' }
            ],
            PRACTICE_TEMPLATES: [],
            SEGMENT_TYPE_SETTINGS: {
                'Take-Off': { showHash: false, showDefense: false },
                'Conditioning': { showHash: false, showDefense: false },
                'On-Air': { showHash: true, showDefense: false },
                'Air': { showHash: true, showDefense: false },
                'Routes on Air': { showHash: true, showDefense: false },
                'Pat-n-Go': { showHash: true, showDefense: false },
                'Walkthrough': { showHash: true, showDefense: false }
            }
        };
        const StaffTasksView = ({ tasks, onUpdateTasks, staff, currentUserRole = 'Head Coach', currentUserName = 'Coach Finn' }) => {
            const [viewContext, setViewContext] = useState('MY_TASKS'); // MY_TASKS, ROLE, STAFF, ALL
            const [filterRole, setFilterRole] = useState('ALL');
            const [filterStaffId, setFilterStaffId] = useState('ALL');

            // Quick Filters
            const quickFilters = [
                { id: 'MY_TASKS', label: 'My Tasks', icon: 'User' },
                { id: 'ROLE', label: 'By Role', icon: 'Users' },
                { id: 'STAFF', label: 'By Staff Member', icon: 'Search' },
                { id: 'ALL', label: 'All Tasks', icon: 'List' }
            ];

            // Helper to check if a task belongs to "My Tasks"
            // Simulating "My Tasks" based on matching role or name for now
            const isMyTask = (task) => {
                const assigned = task.assignTo || [];
                return assigned.includes(currentUserRole) || assigned.includes(currentUserName);
            };

            const getFilteredTasks = () => {
                let filtered = tasks;

                if (viewContext === 'MY_TASKS') {
                    filtered = tasks.filter(isMyTask);
                } else if (viewContext === 'ROLE') {
                    if (filterRole !== 'ALL') {
                        filtered = tasks.filter(t => t.assignTo && t.assignTo.includes(filterRole));
                    }
                } else if (viewContext === 'STAFF') {
                    if (filterStaffId !== 'ALL') {
                        // Match against Staff Name
                        const staffMember = staff.find(s => s.id === filterStaffId);
                        if (staffMember) {
                            filtered = tasks.filter(t => t.assignTo && t.assignTo.includes(staffMember.name));
                        }
                    }
                }

                // Sort by deadline (urgent first) or priority
                return filtered.sort((a, b) => {
                    const statusA = getDeadlineStatus(a.deadline, a.deadlineTime);
                    const statusB = getDeadlineStatus(b.deadline, b.deadlineTime);
                    const prioScore = { 'High': 3, 'Medium': 2, 'Low': 1 };

                    // Overdue/Urgent on top
                    if (statusA === 'overdue' && statusB !== 'overdue') return -1;
                    if (statusB === 'overdue' && statusA !== 'overdue') return 1;

                    if (statusA === 'urgent' && statusB !== 'urgent') return -1;
                    if (statusB === 'urgent' && statusA !== 'urgent') return 1;

                    // Then Priority
                    if (prioScore[a.priority] !== prioScore[b.priority]) {
                        return prioScore[b.priority] - prioScore[a.priority];
                    }
                    return 0;
                });
            };

            const toggleTaskComplete = (taskId) => {
                const newTasks = tasks.map(t =>
                    t.id === taskId ? { ...t, completed: !t.completed, completedAt: !t.completed ? new Date().toISOString() : null } : t
                );
                onUpdateTasks(newTasks);
            };

            const visibleTasks = getFilteredTasks();



            return (
                <div style={{ height: '100%', display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                    {/* Header & Context Switcher */}
                    <div className="card" style={{ padding: '1rem', display: 'flex', alignItems: 'center', justifyContent: 'space-between', flexWrap: 'wrap', gap: '1rem' }}>
                        <div style={{ display: 'flex', gap: '0.5rem' }}>
                            {quickFilters.map(filter => (
                                <button
                                    key={filter.id}
                                    className={`btn ${viewContext === filter.id ? 'btn-primary' : 'btn-secondary'}`}
                                    onClick={() => setViewContext(filter.id)}
                                >
                                    <Icon name={filter.icon} size={16} /> {filter.label}
                                </button>
                            ))}
                        </div>

                        {/* Secondary Filters based on Context */}
                        {viewContext === 'ROLE' && (
                            <select className="form-select" style={{ width: '200px' }} value={filterRole} onChange={e => setFilterRole(e.target.value)}>
                                <option value="ALL">All Roles</option>
                                <option value="Head Coach">Head Coach</option>
                                <option value="OC">Offensive Coord</option>
                                <option value="DC">Defensive Coord</option>
                                <option value="STC">Special Teams</option>
                                <option value="Position Coach">Position Coaches</option>
                            </select>
                        )}
                        {viewContext === 'STAFF' && (
                            <select className="form-select" style={{ width: '200px' }} value={filterStaffId} onChange={e => setFilterStaffId(e.target.value)}>
                                <option value="ALL">All Staff</option>
                                {staff.map(s => <option key={s.id} value={s.id}>{s.name}</option>)}
                            </select>
                        )}
                    </div>

                    {/* Task List */}
                    <div className="card" style={{ flex: 1, overflowY: 'auto', padding: '0' }}>
                        {visibleTasks.length === 0 ? (
                            <div style={{ padding: '3rem', textAlign: 'center', color: 'var(--text-secondary)' }}>
                                <Icon name="Check" size={48} color="var(--success)" style={{ opacity: 0.5, marginBottom: '1rem' }} />
                                <h3>All Caught Up!</h3>
                                <p>No tasks found for this view.</p>
                            </div>
                        ) : (
                            <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                                <thead style={{ background: 'var(--surface)', position: 'sticky', top: 0 }}>
                                    <tr>
                                        <th style={{ padding: '1rem', textAlign: 'left', width: '50px' }}></th>
                                        <th style={{ padding: '1rem', textAlign: 'left' }}>Task</th>
                                        <th style={{ padding: '1rem', textAlign: 'left' }}>Assigned To</th>
                                        <th style={{ padding: '1rem', textAlign: 'right' }}>Deadline</th>
                                        <th style={{ padding: '1rem', textAlign: 'center' }}>Status</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {visibleTasks.map(task => {
                                        const status = getDeadlineStatus(task.deadline, task.deadlineTime);
                                        const isOverdue = status === 'overdue' && !task.completed;
                                        const isUrgent = status === 'urgent' && !task.completed;

                                        return (
                                            <tr key={task.id} style={{ borderBottom: '1px solid var(--border)', opacity: task.completed ? 0.6 : 1, background: isOverdue ? 'rgba(239, 68, 68, 0.05)' : 'transparent' }}>
                                                <td style={{ padding: '1rem' }}>
                                                    <input
                                                        type="checkbox"
                                                        checked={task.completed || false}
                                                        onChange={() => toggleTaskComplete(task.id)}
                                                        style={{ width: '20px', height: '20px', cursor: 'pointer', accentColor: 'var(--success)' }}
                                                    />
                                                </td>
                                                <td style={{ padding: '1rem' }}>
                                                    <div style={{ fontWeight: 'bold', textDecoration: task.completed ? 'line-through' : 'none' }}>
                                                        {task.task}
                                                    </div>
                                                    <div style={{ display: 'flex', gap: '0.5rem', fontSize: '0.8rem', marginTop: '0.25rem' }}>
                                                        <span style={{
                                                            background: task.priority === 'High' ? '#fee2e2' : 'var(--bg-body)',
                                                            color: task.priority === 'High' ? '#991b1b' : 'var(--text-secondary)',
                                                            padding: '2px 6px', borderRadius: '4px'
                                                        }}>
                                                            {task.priority}
                                                        </span>
                                                        <span style={{ color: 'var(--text-secondary)' }}>{task.category}</span>
                                                        {task.estimatedTime && <span style={{ color: 'var(--text-secondary)' }}>⏱ {task.estimatedTime}</span>}
                                                    </div>
                                                    {task.notes && (
                                                        <div style={{ marginTop: '0.5rem', fontSize: '0.85rem', color: 'var(--text-secondary)', fontStyle: 'italic', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                            <Icon name="FileText" size={12} /> {task.notes.substring(0, 50)}{task.notes.length > 50 ? '...' : ''}
                                                        </div>
                                                    )}
                                                </td>
                                                <td style={{ padding: '1rem' }}>
                                                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.25rem' }}>
                                                        {task.assignTo && task.assignTo.map((a, idx) => (
                                                            <span key={idx} style={{ fontSize: '0.8rem', background: 'var(--bg-body)', padding: '2px 6px', borderRadius: '4px', border: '1px solid var(--border)' }}>
                                                                {a}
                                                            </span>
                                                        ))}
                                                    </div>
                                                </td>
                                                <td style={{ padding: '1rem', textAlign: 'right' }}>
                                                    {task.deadline ? (
                                                        <div style={{
                                                            color: isOverdue ? '#ef4444' : isUrgent ? '#f97316' : 'var(--text-primary)',
                                                            fontWeight: (isOverdue || isUrgent) ? 'bold' : 'normal'
                                                        }}>
                                                            {new Date(task.deadline).toLocaleDateString(undefined, { month: 'short', day: 'numeric' })}
                                                            {task.deadlineTime && <div style={{ fontSize: '0.8rem' }}>{task.deadlineTime}</div>}
                                                        </div>
                                                    ) : <span style={{ color: 'var(--text-secondary)' }}>-</span>}
                                                </td>
                                                <td style={{ padding: '1rem', textAlign: 'center' }}>
                                                    {task.completed ? (
                                                        <span style={{ color: 'var(--success)', fontWeight: 'bold', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '0.25rem' }}>
                                                            <Icon name="Check" size={14} /> Done
                                                        </span>
                                                    ) : isOverdue ? (
                                                        <span style={{ color: '#ef4444', fontWeight: 'bold' }}>Overdue</span>
                                                    ) : (
                                                        <span style={{ color: 'var(--text-secondary)' }}>Active</span>
                                                    )}
                                                </td>
                                            </tr>
                                        );
                                    })}
                                </tbody>
                            </table>
                        )}
                    </div>
                </div>
            );
        };

        const ArchiveManager = ({ roster, staff, onUpdateRoster, onUpdateStaff }) => {
            const [tab, setTab] = useState('players'); // players | staff
            const archivedPlayers = roster.filter(p => p.archived);
            const archivedStaff = staff.filter(s => s.archived);

            const restorePlayer = (id) => {
                onUpdateRoster(roster.map(p => p.id === id ? { ...p, archived: false } : p));
            };

            const deletePlayerForever = (id) => {
                if (confirm("PERMANENT DELETE: This cannot be undone. Are you sure?")) {
                    onUpdateRoster(roster.filter(p => p.id !== id));
                }
            };

            const restoreStaff = (id) => {
                onUpdateStaff(staff.map(s => s.id === id ? { ...s, archived: false } : s));
            };

            const deleteStaffForever = (id) => {
                if (confirm("PERMANENT DELETE: This cannot be undone. Are you sure?")) {
                    onUpdateStaff(staff.filter(s => s.id !== id));
                }
            };

            return (
                <div style={{ height: 'calc(100vh - 100px)', display: 'flex', flexDirection: 'column' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '2rem' }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                            <h2>Archive Management</h2>
                        </div>
                        <div style={{ display: 'flex', gap: '1rem' }}>
                            <button className={`btn ${tab === 'players' ? 'btn-primary' : 'btn-secondary'}`} onClick={() => setTab('players')}>
                                Players ({archivedPlayers.length})
                            </button>
                            <button className={`btn ${tab === 'staff' ? 'btn-primary' : 'btn-secondary'}`} onClick={() => setTab('staff')}>
                                Staff ({archivedStaff.length})
                            </button>
                        </div>
                    </div>

                    <div className="card">
                        {tab === 'players' && (
                            <table className="table" style={{ width: '100%', borderCollapse: 'collapse' }}>
                                <thead>
                                    <tr style={{ borderBottom: '2px solid var(--border)' }}>
                                        <th style={{ textAlign: 'left', padding: '1rem' }}>Name</th>
                                        <th style={{ textAlign: 'left', padding: '1rem' }}>Position</th>
                                        <th style={{ textAlign: 'left', padding: '1rem' }}>Year</th>
                                        <th style={{ textAlign: 'right', padding: '1rem' }}>Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {archivedPlayers.map(p => (
                                        <tr key={p.id} style={{ borderBottom: '1px solid var(--border)' }}>
                                            <td style={{ padding: '1rem' }}>
                                                <div style={{ fontWeight: 'bold' }}>{p.name}</div>
                                                <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>#{p.number}</div>
                                            </td>
                                            <td style={{ padding: '1rem' }}>{p.position}</td>
                                            <td style={{ padding: '1rem' }}>{p.year}</td>
                                            <td style={{ padding: '1rem', textAlign: 'right', display: 'flex', gap: '0.5rem', justifyContent: 'flex-end' }}>
                                                <button className="btn btn-secondary" onClick={() => restorePlayer(p.id)} title="Restore to Roster">
                                                    <Icon name="Undo" size={16} /> Restore
                                                </button>
                                                <button className="btn btn-danger" onClick={() => deletePlayerForever(p.id)} title="Delete Permanently">
                                                    <Icon name="Trash" size={16} />
                                                </button>
                                            </td>
                                        </tr>
                                    ))}
                                    {archivedPlayers.length === 0 && (
                                        <tr>
                                            <td colSpan="4" style={{ textAlign: 'center', padding: '3rem', color: 'var(--text-secondary)' }}>
                                                No archived players found.
                                            </td>
                                        </tr>
                                    )}
                                </tbody>
                            </table>
                        )}

                        {tab === 'staff' && (
                            <table className="table" style={{ width: '100%', borderCollapse: 'collapse' }}>
                                <thead>
                                    <tr style={{ borderBottom: '2px solid var(--border)' }}>
                                        <th style={{ textAlign: 'left', padding: '1rem' }}>Name</th>
                                        <th style={{ textAlign: 'left', padding: '1rem' }}>Role</th>
                                        <th style={{ textAlign: 'left', padding: '1rem' }}>Email</th>
                                        <th style={{ textAlign: 'right', padding: '1rem' }}>Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {archivedStaff.map(s => (
                                        <tr key={s.id} style={{ borderBottom: '1px solid var(--border)' }}>
                                            <td style={{ padding: '1rem' }}>
                                                <div style={{ fontWeight: 'bold' }}>{s.name}</div>
                                            </td>
                                            <td style={{ padding: '1rem' }}>{s.role}</td>
                                            <td style={{ padding: '1rem' }}>{s.email}</td>
                                            <td style={{ padding: '1rem', textAlign: 'right', display: 'flex', gap: '0.5rem', justifyContent: 'flex-end' }}>
                                                <button className="btn btn-secondary" onClick={() => restoreStaff(s.id)} title="Restore to Staff">
                                                    <Icon name="Undo" size={16} /> Restore
                                                </button>
                                                <button className="btn btn-danger" onClick={() => deleteStaffForever(s.id)} title="Delete Permanently">
                                                    <Icon name="Trash" size={16} />
                                                </button>
                                            </td>
                                        </tr>
                                    ))}
                                    {archivedStaff.length === 0 && (
                                        <tr>
                                            <td colSpan="4" style={{ textAlign: 'center', padding: '3rem', color: 'var(--text-secondary)' }}>
                                                No archived staff found.
                                            </td>
                                        </tr>
                                    )}
                                </tbody>
                            </table>
                        )}
                    </div>
                </div>
            );
        };

        // -- Archive Manager --

        const StaffManager = ({ currentUser, staff, onUpdateStaff, teamLogo }) => {
            const [newMember, setNewMember] = useState({
                name: '', role: '', shirtSize: '', phone: '', email: '',
                positions: { offense: '', defense: '', specials: { ko: '', kr: '', punt: '', pr: '', fg: '', block: '' } }
            });

            const [isEditing, setIsEditing] = useState(null);
            const [selectedCoach, setSelectedCoach] = useState(null);

            // Drag and Drop Logic
            const handleDragStart = (e, id) => {
                e.dataTransfer.setData('staffId', id);
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            };

            const handleDrop = (e, targetId) => {
                e.preventDefault();
                const draggedId = e.dataTransfer.getData('staffId');

                if (draggedId === targetId) return;

                const draggedIndex = staff.findIndex(m => m.id === draggedId);
                const targetIndex = staff.findIndex(m => m.id === targetId);

                if (draggedIndex === -1 || targetIndex === -1) return;

                const newStaff = [...staff];
                const [draggedItem] = newStaff.splice(draggedIndex, 1);
                newStaff.splice(targetIndex, 0, draggedItem);

                onUpdateStaff(newStaff);
            };

            const addMember = () => {
                // Email Invitation Logic
                if (newMember.email) {
                    const schoolId = localStorage.getItem('hc_school_id') || 'UNKNOWN';
                    const schoolName = localStorage.getItem('hc_school_name') || 'the team';
                    const coachName = currentUser?.displayName || 'Head Coach';

                    const subjectRaw = `Join the coaching staff at ${schoolName}`;
                    const bodyRaw = `Coach ${coachName} has added you to the staff.\n\n` +
                        `Please join the team using the following School ID:\n` +
                        `${schoolId}\n\n` +
                        `1. Log in to Digital DoFO\n` +
                        `2. Select "Join Existing School"\n` +
                        `3. Enter School ID: ${schoolId}`;

                    if (window.db) {
                        // Automated Email via Firebase Extension
                        window.db.collection('mail').add({
                            to: newMember.email,
                            message: {
                                subject: subjectRaw,
                                text: bodyRaw,
                                html: `<div style="font-family: sans-serif; padding: 20px;">
                                    <h2>Join ${schoolName}</h2>
                                    <p>Coach ${coachName} has added you to the staff.</p>
                                    <div style="background: #f3f4f6; padding: 15px; border-radius: 8px; margin: 20px 0;">
                                        <strong>School ID:</strong> <span style="font-family: monospace; font-size: 1.2em;">${schoolId}</span>
                                    </div>
                                    <ol>
                                        <li>Log in to <a href="https://digitaldofo.com">Digital DoFO</a></li>
                                        <li>Select "Join Existing School"</li>
                                        <li>Enter the School ID above</li>
                                    </ol>
                                </div>`
                            }
                        }).then(() => {
                            alert(`Invitation queued for ${newMember.email}. It should arrive shortly.`);
                        }).catch(err => {
                            console.error("Auto-email failed:", err);
                            // Fallback to mailto
                            window.location.href = `mailto:${newMember.email}?subject=${encodeURIComponent(subjectRaw)}&body=${encodeURIComponent(bodyRaw)}`;
                        });

                        // Auto-add to Access Control List
                        window.db.collection('config').doc('access').update({
                            allowedEmails: firebase.firestore.FieldValue.arrayUnion(newMember.email)
                        }).catch(err => console.warn("Could not update access list:", err));

                        // Create Invite Ticket (For Auto-Join)
                        window.db.collection('invites').doc(newMember.email.toLowerCase()).set({
                            schoolId: schoolId,
                            schoolName: schoolName,
                            role: newMember.role,
                            invitedBy: coachName,
                            invitedAt: new Date().toISOString(),
                            status: 'pending'
                        }).catch(err => console.error("Could not create invite ticket:", err));

                    } else {
                        window.location.href = `mailto:${newMember.email}?subject=${encodeURIComponent(subjectRaw)}&body=${encodeURIComponent(bodyRaw)}`;
                    }
                }

                const id = 'coach_' + Date.now();
                onUpdateStaff([...staff, { ...newMember, id }]);
                setNewMember({
                    name: '', role: '', shirtSize: '', phone: '', email: '',
                    positions: { offense: '', defense: '', specials: { ko: '', kr: '', punt: '', pr: '', fg: '', block: '' } }
                });
            };

            const updateMember = (id, field, value) => {
                onUpdateStaff(staff.map(m => m.id === id ? { ...m, [field]: value } : m));
            };

            const updatePosition = (id, group, value) => {
                onUpdateStaff(staff.map(m => {
                    if (m.id !== id) return m;
                    return { ...m, positions: { ...m.positions, [group]: value } };
                }));
            };

            const updateSpecialsPosition = (id, unit, value) => {
                onUpdateStaff(staff.map(m => {
                    if (m.id !== id) return m;
                    return {
                        ...m,
                        positions: {
                            ...m.positions,
                            specials: { ...m.positions.specials, [unit]: value }
                        }
                    };
                }));
            };

            const deleteMember = (id) => {
                if (confirm('Are you sure you want to ARCHIVE this staff member? They can be restored from the Personnel > Archive menu.')) {
                    onUpdateStaff(staff.map(m => m.id === id ? { ...m, archived: true } : m));
                }
            };

            const formatSpecials = (specials) => {
                if (!specials) return '-';
                return Object.entries(specials)
                    .filter(([_, val]) => val)
                    .map(([key, val]) => `${key.toUpperCase()}: ${val}`)
                    .join(', ');
            };




            return (
                <div className="card" style={{ padding: '1.5rem', height: '100%', display: 'flex', flexDirection: 'column' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                        <h2 style={{ margin: 0 }}>Staff Manager</h2>
                    </div>

                    {selectedCoach ? (
                        <div style={{ flex: 1, overflowY: 'auto' }}>
                            <button className="btn btn-secondary" onClick={() => setSelectedCoach(null)} style={{ marginBottom: '1rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                <span>←</span> Back to Roster
                            </button>
                            <div className="card" style={{ marginBottom: '2rem', border: '1px solid var(--border)' }}>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '1rem', marginBottom: '1.5rem', borderBottom: '1px solid var(--border)', paddingBottom: '1rem' }}>
                                    <div style={{ width: '60px', height: '60px', borderRadius: '50%', background: 'var(--accent)', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '1.5rem', fontWeight: 'bold' }}>
                                        {selectedCoach.name.charAt(0)}
                                    </div>
                                    <div>
                                        <h2 style={{ margin: 0 }}>{selectedCoach.name}</h2>
                                        <div style={{ color: 'var(--text-secondary)' }}>
                                            {selectedCoach.role}
                                        </div>
                                    </div>
                                </div>

                                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '3rem' }}>
                                    <div>
                                        <h4 style={{ color: 'var(--accent)', marginBottom: '1rem', textTransform: 'uppercase', fontSize: '0.85rem', letterSpacing: '1px' }}>Coaching Responsibilities</h4>
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                                            <div style={{ background: 'var(--surface)', padding: '0.75rem', borderRadius: '6px' }}>
                                                <div style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', marginBottom: '0.25rem' }}>Offense</div>
                                                <div>{selectedCoach.positions?.offense || '-'}</div>
                                            </div>
                                            <div style={{ background: 'var(--surface)', padding: '0.75rem', borderRadius: '6px' }}>
                                                <div style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', marginBottom: '0.25rem' }}>Defense</div>
                                                <div>{selectedCoach.positions?.defense || '-'}</div>
                                            </div>
                                        </div>
                                    </div>

                                    <div>
                                        <h4 style={{ color: 'var(--accent)', marginBottom: '1rem', textTransform: 'uppercase', fontSize: '0.85rem', letterSpacing: '1px' }}>Special Teams</h4>
                                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '0.5rem' }}>
                                            {Object.entries(selectedCoach.positions?.specials || {}).map(([unit, role]) => (
                                                role && (
                                                    <div key={unit} style={{ background: 'var(--surface)', padding: '0.5rem', borderRadius: '4px', fontSize: '0.9rem' }}>
                                                        <strong style={{ textTransform: 'uppercase', marginRight: '0.5rem' }}>{unit}:</strong> {role}
                                                    </div>
                                                )
                                            ))}
                                            {(!selectedCoach.positions?.specials || Object.values(selectedCoach.positions.specials).every(v => !v)) && (
                                                <div style={{ gridColumn: '1 / -1', color: 'var(--text-secondary)', fontStyle: 'italic' }}>No special teams assigned</div>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    ) : (
                        <div style={{ flex: 1, overflowY: 'auto' }}>
                            {(() => {
                                const activeStaff = staff.filter(m => !m.archived);

                                const renderStaffTable = (list, title) => (
                                    <div style={{ marginBottom: '2rem' }}>
                                        <h3 style={{ borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem', marginBottom: '1rem', color: 'var(--accent)' }}>{title} ({list.length})</h3>
                                        <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                                            <thead>
                                                <tr style={{ textAlign: 'left', color: 'var(--text-secondary)', fontSize: '0.85rem', borderBottom: '1px solid var(--border)' }}>
                                                    <th style={{ padding: '0.5rem', width: '30px' }}></th>
                                                    <th style={{ padding: '0.5rem', width: '22%' }}>Name</th>
                                                    <th style={{ padding: '0.5rem', width: '13%' }}>Role</th>
                                                    <th style={{ padding: '0.5rem', width: '18%' }}>Contact</th>
                                                    <th style={{ padding: '0.5rem', width: '5%' }}>Size</th>
                                                    <th style={{ padding: '0.5rem', width: '22%' }}>Assignments</th>
                                                    <th style={{ padding: '0.5rem', width: '8%', textAlign: 'center' }} title="Admin can access Settings and View As menu">Admin</th>
                                                    <th style={{ padding: '0.5rem', width: '10%' }}></th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {list.map(member => (
                                                    <tr
                                                        key={member.id}
                                                        style={{ borderBottom: '1px solid var(--border)', cursor: 'move' }}
                                                        draggable
                                                        onDragStart={(e) => handleDragStart(e, member.id)}
                                                        onDragOver={handleDragOver}
                                                        onDrop={(e) => handleDrop(e, member.id)}
                                                    >
                                                        <td style={{ padding: '0.75rem 0.5rem', color: 'var(--text-secondary)' }}>
                                                            <div style={{ cursor: 'grab' }}>⋮⋮</div>
                                                        </td>
                                                        <td style={{ padding: '0.75rem 0.5rem' }}>
                                                            {isEditing === member.id ? (
                                                                <input
                                                                    className="form-input"
                                                                    value={member.name}
                                                                    onChange={e => updateMember(member.id, 'name', e.target.value)}
                                                                />
                                                            ) : (
                                                                <button
                                                                    onClick={() => setSelectedCoach(member)}
                                                                    style={{
                                                                        background: 'none', border: 'none',
                                                                        color: 'var(--text-primary)', fontWeight: 'bold',
                                                                        cursor: 'pointer', textAlign: 'left', padding: 0,
                                                                        fontSize: '1rem'
                                                                    }}
                                                                >
                                                                    {member.name}
                                                                </button>
                                                            )}
                                                        </td>
                                                        <td style={{ padding: '0.75rem 0.5rem' }}>
                                                            {isEditing === member.id ? (
                                                                <input
                                                                    className="form-input"
                                                                    value={member.role || (member.roles ? member.roles.join(', ') : '')}
                                                                    onChange={e => updateMember(member.id, 'role', e.target.value)}
                                                                    placeholder="Role"
                                                                />
                                                            ) : (
                                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.25rem' }}>
                                                                    <div style={{ fontWeight: 500 }}>{member.role || (member.roles ? member.roles.join(', ') : '')}</div>
                                                                </div>
                                                            )}
                                                        </td>
                                                        <td style={{ padding: '0.75rem 0.5rem' }}>
                                                            {isEditing === member.id ? (
                                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                                                    <input
                                                                        className="form-input"
                                                                        value={member.phone || ''}
                                                                        onChange={e => updateMember(member.id, 'phone', e.target.value)}
                                                                        placeholder="Phone"
                                                                    />
                                                                    <input
                                                                        className="form-input"
                                                                        value={member.email || ''}
                                                                        onChange={e => updateMember(member.id, 'email', e.target.value)}
                                                                        placeholder="Email"
                                                                    />
                                                                </div>
                                                            ) : (
                                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.25rem', fontSize: '0.9rem' }}>
                                                                    {member.phone && (
                                                                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                                            <Icon name="Phone" size={14} style={{ color: 'var(--text-secondary)' }} />
                                                                            <span>{member.phone}</span>
                                                                        </div>
                                                                    )}
                                                                    {member.email && (
                                                                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                                            <Icon name="Mail" size={14} style={{ color: 'var(--text-secondary)' }} />
                                                                            <span>{member.email}</span>
                                                                        </div>
                                                                    )}
                                                                    {!member.phone && !member.email && <span style={{ opacity: 0.5 }}>-</span>}
                                                                </div>
                                                            )}
                                                        </td>
                                                        <td style={{ padding: '0.75rem 0.5rem' }}>
                                                            {isEditing === member.id ? (
                                                                <select
                                                                    className="form-select"
                                                                    value={member.shirtSize || ''}
                                                                    onChange={e => updateMember(member.id, 'shirtSize', e.target.value)}
                                                                >
                                                                    <option value="">-</option>
                                                                    {['XS', 'S', 'M', 'L', 'XL', '2XL', '3XL', '4XL'].map(sz => (
                                                                        <option key={sz} value={sz}>{sz}</option>
                                                                    ))}
                                                                </select>
                                                            ) : (
                                                                <span style={{
                                                                    padding: '0.2rem 0.5rem',
                                                                    background: 'var(--bg-tertiary)',
                                                                    borderRadius: '4px',
                                                                    fontSize: '0.85rem'
                                                                }}>
                                                                    {member.shirtSize || '-'}
                                                                </span>
                                                            )}
                                                        </td>
                                                        <td style={{ padding: '0.75rem 0.5rem', fontSize: '0.9rem' }}>
                                                            {isEditing === member.id ? (
                                                                <div style={{ display: 'grid', gridTemplateColumns: '30px 35px 1fr', gap: '0.5rem', alignItems: 'center' }}>
                                                                    {/* Header row */}
                                                                    <span style={{ color: 'var(--text-secondary)', fontSize: '0.8rem' }}>Off</span>
                                                                    <span style={{ color: 'var(--text-secondary)', fontSize: '0.7rem', textAlign: 'center' }}>Coord</span>
                                                                    <span></span>
                                                                    {/* Offense row */}
                                                                    <span></span>
                                                                    <input type="checkbox" checked={member.positions?.offenseCoordinator || false} onChange={e => updatePosition(member.id, 'offenseCoordinator', e.target.checked)} title="Coordinator" style={{ cursor: 'pointer', justifySelf: 'center' }} />
                                                                    <input
                                                                        className="form-input"
                                                                        value={member.positions?.offense || ''}
                                                                        onChange={e => updatePosition(member.id, 'offense', e.target.value)}
                                                                        placeholder="Position"
                                                                    />
                                                                    {/* Defense header */}
                                                                    <span style={{ color: 'var(--text-secondary)', fontSize: '0.8rem' }}>Def</span>
                                                                    <span style={{ color: 'var(--text-secondary)', fontSize: '0.7rem', textAlign: 'center' }}>Coord</span>
                                                                    <span></span>
                                                                    {/* Defense row */}
                                                                    <span></span>
                                                                    <input type="checkbox" checked={member.positions?.defenseCoordinator || false} onChange={e => updatePosition(member.id, 'defenseCoordinator', e.target.checked)} title="Coordinator" style={{ cursor: 'pointer', justifySelf: 'center' }} />
                                                                    <input
                                                                        className="form-input"
                                                                        value={member.positions?.defense || ''}
                                                                        onChange={e => updatePosition(member.id, 'defense', e.target.value)}
                                                                        placeholder="Position"
                                                                    />
                                                                    {/* Specials header */}
                                                                    <span style={{ color: 'var(--text-secondary)', fontSize: '0.8rem' }}>Spc</span>
                                                                    <span style={{ color: 'var(--text-secondary)', fontSize: '0.7rem', textAlign: 'center' }}>Coord</span>
                                                                    <span></span>
                                                                    {/* Specials row */}
                                                                    <span></span>
                                                                    <input type="checkbox" checked={member.positions?.specialsCoordinator || false} onChange={e => updatePosition(member.id, 'specialsCoordinator', e.target.checked)} title="Coordinator" style={{ cursor: 'pointer', justifySelf: 'center' }} />
                                                                    <input
                                                                        className="form-input"
                                                                        value={typeof member.positions?.specials === 'object' ? 'See Details' : (member.positions?.specials || '')}
                                                                        disabled={typeof member.positions?.specials === 'object'}
                                                                        onChange={e => updatePosition(member.id, 'specials', e.target.value)}
                                                                        title={typeof member.positions?.specials === 'object' ? "Edit in Detail View" : ""}
                                                                        placeholder="Position"
                                                                    />
                                                                </div>
                                                            ) : (
                                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.25rem' }}>
                                                                    {member.positions?.offense && <div><span style={{ color: 'var(--text-secondary)' }}>Off{member.positions.offenseCoordinator ? ' (C)' : ''}:</span> {member.positions.offense}</div>}
                                                                    {member.positions?.defense && <div><span style={{ color: 'var(--text-secondary)' }}>Def{member.positions.defenseCoordinator ? ' (C)' : ''}:</span> {member.positions.defense}</div>}
                                                                    {(member.positions?.specials && member.positions.specials !== ' - ') && (
                                                                        <div><span style={{ color: 'var(--text-secondary)' }}>Spc{member.positions.specialsCoordinator ? ' (C)' : ''}:</span> {typeof member.positions.specials === 'object' ? formatSpecials(member.positions.specials) : member.positions.specials}</div>
                                                                    )}
                                                                </div>
                                                            )}
                                                        </td>
                                                        <td style={{ padding: '0.75rem 0.5rem', textAlign: 'center' }}>
                                                            <input
                                                                type="checkbox"
                                                                checked={member.isAdmin || false}
                                                                onChange={e => updateMember(member.id, 'isAdmin', e.target.checked)}
                                                                style={{ cursor: 'pointer', width: '18px', height: '18px' }}
                                                                title="Grant admin access to Settings and View As menu"
                                                            />
                                                        </td>
                                                        <td style={{ padding: '0.75rem 0.5rem' }}>
                                                            <div style={{ display: 'flex', gap: '0.5rem', justifyContent: 'flex-end' }}>
                                                                {isEditing === member.id ? (
                                                                    <button className="btn btn-primary btn-sm" onClick={() => setIsEditing(null)}>Save</button>
                                                                ) : (
                                                                    <>
                                                                        <button
                                                                            onClick={() => setIsEditing(member.id)}
                                                                            style={{
                                                                                background: 'none',
                                                                                border: 'none',
                                                                                padding: '6px 10px',
                                                                                cursor: 'pointer',
                                                                                borderRadius: '6px',
                                                                                transition: 'all 0.2s',
                                                                                display: 'inline-flex',
                                                                                alignItems: 'center',
                                                                                justifyContent: 'center',
                                                                                color: 'var(--text-secondary)'
                                                                            }}
                                                                            onMouseEnter={e => e.currentTarget.style.background = 'var(--bg-tertiary)'}
                                                                            onMouseLeave={e => e.currentTarget.style.background = 'none'}
                                                                            title="Edit"
                                                                        >
                                                                            <Icon name="Edit2" size={16} />
                                                                        </button>
                                                                        <button
                                                                            onClick={() => deleteMember(member.id)}
                                                                            style={{
                                                                                background: 'none',
                                                                                border: 'none',
                                                                                padding: '6px 10px',
                                                                                cursor: 'pointer',
                                                                                borderRadius: '6px',
                                                                                transition: 'all 0.2s',
                                                                                display: 'inline-flex',
                                                                                alignItems: 'center',
                                                                                justifyContent: 'center',
                                                                                color: 'var(--text-secondary)'
                                                                            }}
                                                                            onMouseEnter={e => {
                                                                                e.currentTarget.style.background = 'rgba(239, 68, 68, 0.1)';
                                                                                e.currentTarget.style.color = '#ef4444';
                                                                            }}
                                                                            onMouseLeave={e => {
                                                                                e.currentTarget.style.background = 'none';
                                                                                e.currentTarget.style.color = 'var(--text-secondary)';
                                                                            }}
                                                                            title="Delete"
                                                                        >
                                                                            <Icon name="Trash2" size={16} />
                                                                        </button>
                                                                    </>
                                                                )}
                                                            </div>
                                                        </td>

                                                    </tr>
                                                ))}
                                            </tbody>
                                        </table>
                                    </div>
                                );

                                return (
                                    <>
                                        {renderStaffTable(activeStaff, "Coaching Staff")}
                                    </>
                                );
                            })()}

                            <div className="card" style={{ marginTop: '2rem', padding: '1.5rem', border: '1px solid var(--border)' }}>
                                <h3 style={{ marginTop: 0, marginBottom: '1.5rem' }}>Add New Staff Member</h3>
                                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1.5rem' }}>
                                    <div>
                                        <label className="form-label">Name</label>
                                        <input
                                            className="form-input"
                                            value={newMember.name}
                                            onChange={e => setNewMember({ ...newMember, name: e.target.value })}
                                            placeholder="Coach Name"
                                        />
                                    </div>
                                    <div>
                                        <label className="form-label">Role</label>
                                        <select
                                            className="form-select"
                                            value={newMember.role}
                                            onChange={e => setNewMember({ ...newMember, role: e.target.value })}
                                        >
                                            <option value="">Select Role...</option>
                                            <option value="Head Coach">Head Coach</option>
                                            <option value="Assistant">Assistant</option>
                                            <option value="Student Manager">Student Manager</option>
                                            <option value="Trainer">Trainer</option>
                                            <option value="Stats">Stats</option>
                                        </select>
                                    </div>

                                    <div>
                                        <label className="form-label" style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer', marginTop: '30px' }}>
                                            <input
                                                type="checkbox"
                                                checked={newMember.isAdmin || false}
                                                onChange={e => setNewMember({ ...newMember, isAdmin: e.target.checked })}
                                                style={{ width: '18px', height: '18px' }}
                                            />
                                            <span>Grant Admin Privileges</span>
                                        </label>
                                    </div>

                                    <div>
                                        <label className="form-label">Shirt Size</label>
                                        <select
                                            className="form-select"
                                            value={newMember.shirtSize || ''}
                                            onChange={e => setNewMember({ ...newMember, shirtSize: e.target.value })}
                                        >
                                            <option value="">Select Size</option>
                                            {['XS', 'S', 'M', 'L', 'XL', '2XL', '3XL', '4XL'].map(sz => (
                                                <option key={sz} value={sz}>{sz}</option>
                                            ))}
                                        </select>
                                    </div>

                                    <div>
                                        <label className="form-label">Phone</label>
                                        <input
                                            className="form-input"
                                            value={newMember.phone || ''}
                                            onChange={e => setNewMember({ ...newMember, phone: e.target.value })}
                                            placeholder="(555) 555-5555"
                                        />
                                    </div>
                                    <div>
                                        <label className="form-label">Email</label>
                                        <input
                                            className="form-input"
                                            value={newMember.email || ''}
                                            onChange={e => setNewMember({ ...newMember, email: e.target.value })}
                                            placeholder="coach@example.com"
                                        />
                                    </div>

                                    <div>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem' }}>
                                            <label className="form-label" style={{ marginBottom: 0 }}>Offensive Assignment</label>
                                            <label style={{ display: 'flex', alignItems: 'center', gap: '5px', fontSize: '0.8rem', cursor: 'pointer' }}>
                                                <input
                                                    type="checkbox"
                                                    checked={newMember.positions.offenseCoordinator || false}
                                                    onChange={e => setNewMember({ ...newMember, positions: { ...newMember.positions, offenseCoordinator: e.target.checked } })}
                                                />
                                                Coordinator
                                            </label>
                                        </div>
                                        <input
                                            className="form-input"
                                            value={newMember.positions.offense}
                                            onChange={e => setNewMember({ ...newMember, positions: { ...newMember.positions, offense: e.target.value } })}
                                            placeholder="e.g. QBs"
                                        />
                                    </div>
                                    <div>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem' }}>
                                            <label className="form-label" style={{ marginBottom: 0 }}>Defensive Assignment</label>
                                            <label style={{ display: 'flex', alignItems: 'center', gap: '5px', fontSize: '0.8rem', cursor: 'pointer' }}>
                                                <input
                                                    type="checkbox"
                                                    checked={newMember.positions.defenseCoordinator || false}
                                                    onChange={e => setNewMember({ ...newMember, positions: { ...newMember.positions, defenseCoordinator: e.target.checked } })}
                                                />
                                                Coordinator
                                            </label>
                                        </div>
                                        <input
                                            className="form-input"
                                            value={newMember.positions.defense}
                                            onChange={e => setNewMember({ ...newMember, positions: { ...newMember.positions, defense: e.target.value } })}
                                            placeholder="e.g. LBs"
                                        />
                                    </div>
                                </div>
                                <div style={{ marginTop: '1.5rem', textAlign: 'right' }}>
                                    <button
                                        className="btn btn-primary"
                                        onClick={addMember}
                                        disabled={!newMember.name || !newMember.role}
                                    >
                                        Add Staff Member
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Special Teams Dashboard Component
        const SpecialTeamsDashboard = ({ roster, depthCharts, onUpdateDepthChart, savedLayouts, onUpdateLayout, onResetLayout, opponentData, onUpdateOpponentData, customPositions = {}, hiddenPositions = {}, positionNames = {} }) => {
            const [kickerDistance, setKickerDistance] = useState(opponentData?.kickerDistance || 50);
            const [punterDistance, setPunterDistance] = useState(opponentData?.punterDistance || 45);
            const [yardLine, setYardLine] = useState(35);
            const [searchQuery, setSearchQuery] = useState('');

            // Calculate returner placement
            const calculateReturnerPlacement = () => {
                // Simple calculation: where the ball will land minus a safety buffer
                const kickLandingZone = 100 - yardLine - kickerDistance;
                const puntLandingZone = 100 - yardLine - punterDistance;

                return {
                    kickReturn: Math.max(kickLandingZone - 5, 0), // 5 yard safety buffer
                    puntReturn: Math.max(puntLandingZone - 5, 0)
                };
            };

            const placement = calculateReturnerPlacement();

            // Update player status
            const updatePlayerStatus = (playerId, status) => {
                const currentAvailability = opponentData.playerAvailability || {};
                const updatedAvailability = {
                    ...currentAvailability,
                    [playerId]: {
                        status,
                        timestamp: new Date().toISOString()
                    }
                };
                onUpdateOpponentData({
                    ...opponentData,
                    playerAvailability: updatedAvailability
                });
            };

            // Update opponent data when values change
            useEffect(() => {
                if (onUpdateOpponentData) {
                    onUpdateOpponentData({ ...opponentData, kickerDistance, punterDistance });
                }
            }, [kickerDistance, punterDistance]);


            const stCharts = [
                { type: 'KICKOFF', title: 'Kickoff' },
                { type: 'KICK_RETURN', title: 'Kick Return' },
                { type: 'PUNT', title: 'Punt' },
                { type: 'PUNT_RETURN', title: 'Punt Return' },
                { type: 'FIELD_GOAL', title: 'Field Goal / PAT' },
                { type: 'HANDS_TEAM', title: 'Hands Team' },
                { type: 'ONSIDE_KICK', title: 'Onside Kick' },
                { type: 'PAT_BLOCK', title: 'PAT Block' }
            ];

            return (
                <div style={{ padding: '2rem' }}>
                    <h2 style={{ marginBottom: '2rem' }}>Special Teams Dashboard</h2>

                    {/* Player Availability Tracker */}
                    <div style={{
                        backgroundColor: 'var(--surface)',
                        border: '1px solid var(--border)',
                        borderRadius: '8px',
                        padding: '1.5rem',
                        marginBottom: '2rem'
                    }}>
                        <h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Player Availability</h3>

                        <div style={{ marginBottom: '1rem', display: 'flex', gap: '1rem', alignItems: 'center' }}>
                            <input
                                type="text"
                                className="form-input"
                                placeholder="Search players..."
                                value={searchQuery}
                                onChange={e => setSearchQuery(e.target.value)}
                                style={{ maxWidth: '300px' }}
                            />
                            <div style={{ display: 'flex', gap: '0.5rem', fontSize: '0.9rem' }}>
                                <span>Legend:</span>
                                <span style={{ color: '#10b981' }}>🟢 Available</span>
                                <span style={{ color: '#f59e0b' }}>🟡 Questionable</span>
                                <span style={{ color: '#ef4444' }}>🔴 OUT</span>
                            </div>
                        </div>

                        <div style={{ maxHeight: '400px', overflowY: 'auto', border: '1px solid var(--border)', borderRadius: '4px' }}>
                            <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                                <thead style={{ position: 'sticky', top: 0, backgroundColor: 'var(--bg)', zIndex: 1 }}>
                                    <tr style={{ borderBottom: '2px solid var(--border)' }}>
                                        <th style={{ padding: '0.75rem', textAlign: 'left' }}>#</th>
                                        <th style={{ padding: '0.75rem', textAlign: 'left' }}>Name</th>
                                        <th style={{ padding: '0.75rem', textAlign: 'left' }}>Pos</th>
                                        <th style={{ padding: '0.75rem', textAlign: 'center' }}>Status</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {roster
                                        .filter(player =>
                                            !searchQuery ||
                                            player.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
                                            player.number.toString().includes(searchQuery) ||
                                            player.position.toLowerCase().includes(searchQuery.toLowerCase())
                                        )
                                        .filter(Boolean).sort((a, b) => (a?.name || '').localeCompare(b?.name || ''))
                                        .map(player => {
                                            const status = (opponentData.playerAvailability || {})[player.id]?.status || 'available';
                                            return (
                                                <tr key={player.id} style={{ borderBottom: '1px solid var(--border)' }}>
                                                    <td style={{ padding: '0.75rem' }}>{player.number}</td>
                                                    <td style={{ padding: '0.75rem', fontWeight: '500' }}>{player.name}</td>
                                                    <td style={{ padding: '0.75rem' }}>{player.position}</td>
                                                    <td style={{ padding: '0.75rem' }}>
                                                        <div style={{ display: 'flex', gap: '0.25rem', justifyContent: 'center' }}>
                                                            <button
                                                                onClick={() => updatePlayerStatus(player.id, 'available')}
                                                                style={{
                                                                    padding: '0.25rem 0.5rem',
                                                                    border: status === 'available' ? '2px solid #10b981' : '1px solid var(--border)',
                                                                    backgroundColor: status === 'available' ? 'rgba(16, 185, 129, 0.2)' : 'transparent',
                                                                    borderRadius: '4px',
                                                                    cursor: 'pointer',
                                                                    fontSize: '0.85rem'
                                                                }}
                                                            >
                                                                🟢
                                                            </button>
                                                            <button
                                                                onClick={() => updatePlayerStatus(player.id, 'questionable')}
                                                                style={{
                                                                    padding: '0.25rem 0.5rem',
                                                                    border: status === 'questionable' ? '2px solid #f59e0b' : '1px solid var(--border)',
                                                                    backgroundColor: status === 'questionable' ? 'rgba(245, 158, 11, 0.2)' : 'transparent',
                                                                    borderRadius: '4px',
                                                                    cursor: 'pointer',
                                                                    fontSize: '0.85rem'
                                                                }}
                                                            >
                                                                🟡
                                                            </button>
                                                            <button
                                                                onClick={() => updatePlayerStatus(player.id, 'out')}
                                                                style={{
                                                                    padding: '0.25rem 0.5rem',
                                                                    border: status === 'out' ? '2px solid #ef4444' : '1px solid var(--border)',
                                                                    backgroundColor: status === 'out' ? 'rgba(239, 68, 68, 0.2)' : 'transparent',
                                                                    borderRadius: '4px',
                                                                    cursor: 'pointer',
                                                                    fontSize: '0.85rem'
                                                                }}
                                                            >
                                                                🔴
                                                            </button>
                                                        </div>
                                                    </td>
                                                </tr>
                                            );
                                        })}
                                </tbody>
                            </table>
                        </div>
                    </div>

                    {/* Returner Placement Calculator */}
                    <div style={{
                        backgroundColor: 'rgba(56, 189, 248, 0.1)',
                        border: '1px solid var(--accent)',
                        borderRadius: '8px',
                        padding: '1.5rem',
                        marginBottom: '2rem'
                    }}>
                        <h3 style={{ marginTop: 0, marginBottom: '1rem', color: 'var(--accent)' }}>Returner Placement Calculator</h3>

                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1rem', marginBottom: '1.5rem' }}>
                            <div>
                                <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: 'bold' }}>
                                    Opponent Kicker Max Distance (yds)
                                </label>
                                <input
                                    type="number"
                                    className="form-input"
                                    value={kickerDistance}
                                    onChange={e => setKickerDistance(parseInt(e.target.value) || 0)}
                                    style={{ width: '100%' }}
                                />
                            </div>

                            <div>
                                <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: 'bold' }}>
                                    Opponent Punter Max Distance (yds)
                                </label>
                                <input
                                    type="number"
                                    className="form-input"
                                    value={punterDistance}
                                    onChange={e => setPunterDistance(parseInt(e.target.value) || 0)}
                                    style={{ width: '100%' }}
                                />
                            </div>

                            <div>
                                <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: 'bold' }}>
                                    Line of Scrimmage (yard line)
                                </label>
                                <input
                                    type="number"
                                    className="form-input"
                                    value={yardLine}
                                    onChange={e => setYardLine(parseInt(e.target.value) || 0)}
                                    min="0"
                                    max="100"
                                    style={{ width: '100%' }}
                                />
                            </div>
                        </div>

                        <div style={{
                            display: 'grid',
                            gridTemplateColumns: '1fr 1fr',
                            gap: '1rem',
                            padding: '1rem',
                            backgroundColor: 'rgba(0, 0, 0, 0.2)',
                            borderRadius: '4px'
                        }}>
                            <div>
                                <div style={{ fontSize: '0.9rem', color: 'var(--text-secondary)', marginBottom: '0.25rem' }}>
                                    Kick Return - Suggested Returner Depth:
                                </div>
                                <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: 'var(--accent)' }}>
                                    {placement.kickReturn} yards
                                </div>
                            </div>
                            <div>
                                <div style={{ fontSize: '0.9rem', color: 'var(--text-secondary)', marginBottom: '0.25rem' }}>
                                    Punt Return - Suggested Returner Depth:
                                </div>
                                <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: 'var(--accent)' }}>
                                    {placement.puntReturn} yards
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Special Teams Depth Charts */}
                    <h3 style={{ marginBottom: '1.5rem' }}>Special Teams Depth Charts</h3>
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '2rem' }}>
                        {stCharts.map(chart => (
                            <div key={chart.type} style={{
                                border: '1px solid var(--border)',
                                borderRadius: '8px',
                                padding: '1rem',
                                backgroundColor: 'var(--surface)'
                            }}>
                                <DepthChart
                                    roster={roster}
                                    depthChart={depthCharts[chart.type] || {}}
                                    onUpdateDepthChart={(updated) => onUpdateDepthChart(chart.type, updated)}
                                    chartType={chart.type}
                                    savedLayout={savedLayouts[chart.type] || {}}
                                    onUpdateLayout={(layout) => onUpdateLayout(chart.type, layout)}
                                    onResetLayout={() => onResetLayout(chart.type)}
                                    customPositions={customPositions}
                                    hiddenPositions={hiddenPositions}
                                    positionNames={positionNames}
                                />
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        // Searchable Player Dropdown Component
        const SearchablePlayerDropdown = ({ roster, value, onChange, style, depthChart }) => {
            const [isOpen, setIsOpen] = useState(false);
            const [searchTerm, setSearchTerm] = useState('');
            const [highlightedIndex, setHighlightedIndex] = useState(0);
            const dropdownRef = useRef(null);
            const inputRef = useRef(null);

            // Filter roster based on search term
            const filteredRoster = useMemo(() => {
                if (!searchTerm.trim()) return roster;
                const term = searchTerm.toLowerCase();
                return roster.filter(p =>
                    p.name.toLowerCase().includes(term) ||
                    (p.number && p.number.toString().includes(term))
                );
            }, [roster, searchTerm]);

            // Get selected player
            const selectedPlayer = roster.find(p => p.id === value);

            // Close dropdown when clicking outside
            useEffect(() => {
                const handleClickOutside = (e) => {
                    if (dropdownRef.current && !dropdownRef.current.contains(e.target)) {
                        setIsOpen(false);
                        setSearchTerm('');
                    }
                };
                if (isOpen) {
                    document.addEventListener('mousedown', handleClickOutside);
                    return () => document.removeEventListener('mousedown', handleClickOutside);
                }
            }, [isOpen]);

            // Focus input when opened
            useEffect(() => {
                if (isOpen && inputRef.current) {
                    inputRef.current.focus();
                }
            }, [isOpen]);

            // Reset highlighted index when filtered list changes
            useEffect(() => {
                setHighlightedIndex(0);
            }, [filteredRoster]);

            const handleKeyDown = (e) => {
                if (!isOpen) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        setIsOpen(true);
                    }
                    return;
                }

                switch (e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        setHighlightedIndex(prev => Math.min(prev + 1, filteredRoster.length - 1));
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        setHighlightedIndex(prev => Math.max(prev - 1, 0));
                        break;
                    case 'Enter':
                        e.preventDefault();
                        if (filteredRoster[highlightedIndex]) {
                            onChange(filteredRoster[highlightedIndex].id);
                            setIsOpen(false);
                            setSearchTerm('');
                        }
                        break;
                    case 'Escape':
                        e.preventDefault();
                        setIsOpen(false);
                        setSearchTerm('');
                        break;
                }
            };

            const handleSelect = (playerId) => {
                onChange(playerId);
                setIsOpen(false);
                setSearchTerm('');
            };

            return (
                <div
                    ref={dropdownRef}
                    style={{ position: 'relative', width: '100%', ...style }}
                    onMouseDown={(e) => e.stopPropagation()} // Prevent drag handler
                >
                    {!isOpen ? (
                        <div
                            onClick={() => setIsOpen(true)}
                            onKeyDown={handleKeyDown}
                            tabIndex={0}
                            style={{
                                fontSize: '0.75rem',
                                padding: '2px 4px',
                                width: '100%',
                                background: 'var(--input-bg)',
                                border: '1px solid var(--border)',
                                borderRadius: '4px',
                                cursor: 'pointer',
                                color: 'var(--text)',
                                textAlign: 'left',
                                minHeight: '22px',
                                display: 'flex',
                                alignItems: 'center'
                            }}
                        >
                            {selectedPlayer ? (
                                <span>#{selectedPlayer.number} {selectedPlayer.name}</span>
                            ) : '--'}
                        </div>
                    ) : (
                        <div style={{ position: 'relative' }}>
                            <input
                                ref={inputRef}
                                type="text"
                                value={searchTerm}
                                onChange={(e) => setSearchTerm(e.target.value)}
                                onKeyDown={handleKeyDown}
                                placeholder="Type name or #..."
                                style={{
                                    fontSize: '0.75rem',
                                    padding: '2px 4px',
                                    width: '100%',
                                    background: 'var(--input-bg)',
                                    border: '1px solid var(--accent)',
                                    borderRadius: '4px',
                                    color: 'var(--text)',
                                    outline: 'none'
                                }}
                            />
                            <div
                                style={{
                                    position: 'absolute',
                                    top: '100%',
                                    left: 0,
                                    right: 0,
                                    maxHeight: '200px',
                                    overflowY: 'auto',
                                    background: 'var(--bg-panel)',
                                    border: '1px solid var(--border)',
                                    borderRadius: '4px',
                                    marginTop: '2px',
                                    zIndex: 1000,
                                    boxShadow: '0 4px 6px rgba(0,0,0,0.3)'
                                }}
                            >
                                <div
                                    onClick={() => handleSelect('')}
                                    onMouseEnter={() => setHighlightedIndex(-1)}
                                    style={{
                                        padding: '4px 8px',
                                        fontSize: '0.75rem',
                                        cursor: 'pointer',
                                        background: highlightedIndex === -1 ? 'var(--accent)' : 'transparent',
                                        color: highlightedIndex === -1 ? 'white' : 'var(--text-secondary)'
                                    }}
                                >
                                    -- Clear --
                                </div>
                                {filteredRoster.length === 0 ? (
                                    <div style={{ padding: '8px', fontSize: '0.75rem', color: 'var(--text-secondary)', fontStyle: 'italic' }}>
                                        No players found
                                    </div>
                                ) : (
                                    filteredRoster.map((player, index) => {
                                        const isHighlighted = highlightedIndex === index;
                                        return (
                                            <div
                                                key={player.id}
                                                onClick={() => handleSelect(player.id)}
                                                onMouseEnter={() => setHighlightedIndex(index)}
                                                style={{
                                                    padding: '4px 8px',
                                                    fontSize: '0.75rem',
                                                    cursor: 'pointer',
                                                    background: isHighlighted ? 'var(--accent)' : 'transparent',
                                                    color: isHighlighted ? 'white' : 'var(--text)'
                                                }}
                                            >
                                                #{player.number} {player.name}
                                            </div>
                                        );
                                    })
                                )}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const DepthChart = ({ roster, depthChart, onUpdateDepthChart, chartType = 'OFFENSE', savedLayout = {}, onUpdateLayout, onResetLayout, positionNames = {}, onUpdatePositionNames, depthStrings = {}, onUpdateDepthStrings, depthRowCounts = {}, onUpdateDepthRowCounts, customPositions = {}, hiddenPositions = {}, forcePrintView = false, teamLogo, currentWeek, personnelGroupings = {} }) => {
            // Use chart type directly (no squad prefixes)
            const formattedType = chartType || 'OFFENSE';
            const baseChartType = formattedType;

            // Map chart type to Setup Phase (OFFENSE, DEFENSE, SPECIAL_TEAMS)
            const getSetupPhase = (type) => {
                if (type === 'OFFENSE') return 'OFFENSE';
                if (type === 'DEFENSE') return 'DEFENSE';
                return 'SPECIAL_TEAMS'; // KICKOFF, PUNT, etc.
            };
            const setupPhase = getSetupPhase(baseChartType);

            // Standard coordinate mappings for different formations
            const FORMATIONS = {
                'OFFENSE': [
                    { id: 'OFF_LWR', key: 'X', defaultName: 'X', x: 100, y: 100 },
                    { id: 'OFF_LT', key: 'LT', defaultName: 'LT', x: 340, y: 100 },
                    { id: 'OFF_LG', key: 'LG', defaultName: 'LG', x: 520, y: 100 },
                    { id: 'OFF_C', key: 'C', defaultName: 'C', x: 700, y: 100 },
                    { id: 'OFF_RG', key: 'RG', defaultName: 'RG', x: 880, y: 100 },
                    { id: 'OFF_RT', key: 'RT', defaultName: 'RT', x: 1060, y: 100 },
                    { id: 'OFF_RWR', key: 'Z', defaultName: 'Z', x: 1240, y: 200 },
                    { id: 'OFF_QB', key: 'QB', defaultName: 'QB', x: 700, y: 300 },
                    { id: 'OFF_RB', key: 'RB', defaultName: 'RB', x: 700, y: 500 },
                    { id: 'OFF_SWR', key: 'A', defaultName: 'A', x: 170, y: 200 },
                    { id: 'OFF_TE', key: 'Y', defaultName: 'Y', x: 1420, y: 100 }
                ],
                'DEFENSE': [
                    { id: 'DEF_LDE', key: 'DE', defaultName: 'DE', x: 340, y: 100 },
                    { id: 'DEF_LDT', key: 'DT', defaultName: 'DT', x: 520, y: 100 },
                    { id: 'DEF_RDT', key: 'NT', defaultName: 'NT', x: 880, y: 100 },
                    { id: 'DEF_RDE', key: 'DE', defaultName: 'DE', x: 1060, y: 100 },
                    { id: 'DEF_WLB', key: 'Will', defaultName: 'Will', x: 520, y: 300 },
                    { id: 'DEF_MLB', key: 'Mike', defaultName: 'Mike', x: 880, y: 300 },
                    { id: 'DEF_LCB', key: 'CB', defaultName: 'CB', x: 100, y: 200 },
                    { id: 'DEF_RCB', key: 'CB', defaultName: 'CB', x: 1380, y: 200 },
                    { id: 'DEF_FS', key: 'FS', defaultName: 'FS', x: 520, y: 500 },
                    { id: 'DEF_SS', key: 'SS', defaultName: 'SS', x: 880, y: 500 },
                    { id: 'DEF_NICK', key: 'Nickel', defaultName: 'Nickel', x: 1100, y: 300 }
                ],
                'KICKOFF': [
                    { id: 'KO_K', key: 'K', defaultName: 'K', x: 700, y: 500 },
                    { id: 'KO_L1', key: 'L1', defaultName: 'L1', x: 600, y: 300 }, { id: 'KO_R1', key: 'R1', defaultName: 'R1', x: 800, y: 300 },
                    { id: 'KO_L2', key: 'L2', defaultName: 'L2', x: 500, y: 300 }, { id: 'KO_R2', key: 'R2', defaultName: 'R2', x: 900, y: 300 },
                    { id: 'KO_L3', key: 'L3', defaultName: 'L3', x: 400, y: 300 }, { id: 'KO_R3', key: 'R3', defaultName: 'R3', x: 1000, y: 300 },
                    { id: 'KO_L4', key: 'L4', defaultName: 'L4', x: 300, y: 300 }, { id: 'KO_R4', key: 'R4', defaultName: 'R4', x: 1100, y: 300 },
                    { id: 'KO_L5', key: 'L5', defaultName: 'L5', x: 200, y: 300 }, { id: 'KO_R5', key: 'R5', defaultName: 'R5', x: 1200, y: 300 }
                ],
                // ... other units if needed, adding key/defaultName to ensure consistency if renamed
                'KICK_RETURN': [
                    { id: 'KR_R1', defaultName: 'KR', x: 600, y: 600 }, { id: 'KR_R2', defaultName: 'KR', x: 800, y: 600 },
                    { id: 'KR_FL1', defaultName: 'Front', x: 200, y: 200 }, { id: 'KR_FL2', defaultName: 'Front', x: 1200, y: 200 },
                    { id: 'KR_M1', defaultName: 'Mid', x: 400, y: 300 }, { id: 'KR_M2', defaultName: 'Mid', x: 1000, y: 300 },
                    { id: 'KR_M3', defaultName: 'Mid', x: 600, y: 300 }, { id: 'KR_M4', defaultName: 'Mid', x: 800, y: 300 },
                    { id: 'KR_B1', defaultName: 'Back', x: 500, y: 450 }, { id: 'KR_B2', defaultName: 'Back', x: 900, y: 450 },
                    { id: 'KR_OFF', defaultName: 'Off', x: 700, y: 450 }
                ],
                'PUNT': [
                    { id: 'P_P', defaultName: 'P', x: 700, y: 600 },
                    { id: 'P_PP', defaultName: 'PP', x: 700, y: 400 },
                    { id: 'P_LS', defaultName: 'LS', x: 700, y: 100 },
                    { id: 'P_L1', defaultName: 'L1', x: 600, y: 100 }, { id: 'P_R1', defaultName: 'R1', x: 800, y: 100 },
                    { id: 'P_L2', defaultName: 'L2', x: 500, y: 100 }, { id: 'P_R2', defaultName: 'R2', x: 900, y: 100 },
                    { id: 'P_L3', defaultName: 'Wing', x: 400, y: 150 }, { id: 'P_R3', defaultName: 'Wing', x: 1000, y: 150 },
                    { id: 'P_G1', defaultName: 'Gunner', x: 100, y: 100 }, { id: 'P_G2', defaultName: 'Gunner', x: 1300, y: 100 }
                ],
                'PUNT_RETURN': [
                    { id: 'PR_R', defaultName: 'Ret', x: 700, y: 600 },
                    { id: 'PR_J1', defaultName: 'Jam', x: 100, y: 200 }, { id: 'PR_J2', defaultName: 'Jam', x: 1300, y: 200 },
                    { id: 'PR_L1', defaultName: 'Rush', x: 300, y: 150 }, { id: 'PR_R1', defaultName: 'Rush', x: 1100, y: 150 },
                    { id: 'PR_L2', defaultName: 'Rush', x: 400, y: 150 }, { id: 'PR_R2', defaultName: 'Rush', x: 1000, y: 150 },
                    { id: 'PR_L3', defaultName: 'Rush', x: 500, y: 150 }, { id: 'PR_R3', defaultName: 'Rush', x: 900, y: 150 },
                    { id: 'PR_L4', defaultName: 'Rush', x: 600, y: 150 }, { id: 'PR_R4', defaultName: 'Rush', x: 800, y: 150 }
                ],
                'HANDS_TEAM': [
                    { id: 'HT_FL1', defaultName: 'Front', x: 200, y: 100 }, { id: 'HT_FL2', defaultName: 'Front', x: 1200, y: 100 },
                    { id: 'HT_FL3', defaultName: 'Front', x: 400, y: 100 }, { id: 'HT_FL4', defaultName: 'Front', x: 1000, y: 100 },
                    { id: 'HT_FL5', defaultName: 'Front', x: 600, y: 100 }, { id: 'HT_FL6', defaultName: 'Front', x: 800, y: 100 },
                    { id: 'HT_M1', defaultName: 'Mid', x: 300, y: 300 }, { id: 'HT_M2', defaultName: 'Mid', x: 1100, y: 300 },
                    { id: 'HT_M3', defaultName: 'Mid', x: 700, y: 300 },
                    { id: 'HT_D1', defaultName: 'Deep', x: 500, y: 500 }, { id: 'HT_D2', defaultName: 'Deep', x: 900, y: 500 }
                ],
                'ONSIDE_KICK': [
                    { id: 'OS_K', defaultName: 'K', x: 700, y: 500 },
                    { id: 'OS_L1', defaultName: 'L1', x: 650, y: 300 }, { id: 'OS_R1', defaultName: 'R1', x: 750, y: 300 },
                    { id: 'OS_L2', defaultName: 'L2', x: 600, y: 300 }, { id: 'OS_R2', defaultName: 'R2', x: 800, y: 300 },
                    { id: 'OS_L3', defaultName: 'L3', x: 550, y: 300 }, { id: 'OS_R3', defaultName: 'R3', x: 850, y: 300 },
                    { id: 'OS_L4', defaultName: 'L4', x: 500, y: 300 }, { id: 'OS_R4', defaultName: 'R4', x: 900, y: 300 },
                    { id: 'OS_L5', defaultName: 'L5', x: 450, y: 300 }, { id: 'OS_R5', defaultName: 'R5', x: 950, y: 300 }
                ],
                'PAT_BLOCK': [
                    { id: 'PB_1', defaultName: 'Rush', x: 100, y: 100 }, { id: 'PB_11', defaultName: 'Rush', x: 1300, y: 100 },
                    { id: 'PB_2', defaultName: 'Rush', x: 220, y: 100 }, { id: 'PB_10', defaultName: 'Rush', x: 1180, y: 100 },
                    { id: 'PB_3', defaultName: 'Rush', x: 340, y: 100 }, { id: 'PB_9', defaultName: 'Rush', x: 1060, y: 100 },
                    { id: 'PB_4', defaultName: 'Rush', x: 460, y: 100 }, { id: 'PB_8', defaultName: 'Rush', x: 940, y: 100 },
                    { id: 'PB_5', defaultName: 'Rush', x: 580, y: 100 }, { id: 'PB_7', defaultName: 'Rush', x: 820, y: 100 },
                    { id: 'PB_6', defaultName: 'Safe', x: 700, y: 400 }
                ]
            };

            // Prepare Custom Positions for this phase
            const phaseCustomPositions = customPositions[setupPhase] || [];
            const formattedCustomPositions = phaseCustomPositions.map((cp, idx) => ({
                id: `CUSTOM_${baseChartType}_${cp.key}`, // Unique ID for depth chart assignment
                key: cp.key,
                defaultName: cp.key,
                x: 100 + (idx * 150) % 1200, // Staggered default placement
                y: 650 + Math.floor(idx / 8) * 150, // Below default positions
                isCustom: true
            }));

            // Get base defaults
            const baseDefaults = FORMATIONS[baseChartType] || FORMATIONS['OFFENSE'];

            // For OFFENSE charts, auto-include positions from personnel groupings
            const personnelPositions = [];
            if (baseChartType === 'OFFENSE' && Array.isArray(personnelGroupings)) {
                const allPersonnelPositions = new Set();
                personnelGroupings.forEach(grouping => {
                    (grouping.positions || []).forEach(pos => allPersonnelPositions.add(pos));
                });
                // Get positions that are in personnel groupings but not in base defaults or custom positions
                const existingKeys = new Set([
                    ...baseDefaults.map(p => p.key),
                    ...phaseCustomPositions.map(p => p.key)
                ]);
                let personnelIdx = 0;
                allPersonnelPositions.forEach(posKey => {
                    if (!existingKeys.has(posKey)) {
                        personnelPositions.push({
                            id: `PERSONNEL_${baseChartType}_${posKey}`,
                            key: posKey,
                            defaultName: posKey,
                            x: 1420, // Default x position (right side)
                            y: 300 + (personnelIdx * 200), // Staggered y positions
                            isPersonnel: true
                        });
                        personnelIdx++;
                    }
                });
            }

            // Filter out Hidden defaults
            const currentHidden = hiddenPositions[setupPhase] || [];
            const filteredDefaults = baseDefaults.filter(pos => !currentHidden.includes(pos.key));

            // Combine: base defaults + custom positions + personnel grouping positions
            const availablePositions = [...filteredDefaults, ...formattedCustomPositions, ...personnelPositions];

            // Merge with saved layout
            const positions = availablePositions.map(pos => {
                const saved = savedLayout[pos.id];
                // Determine name: user key override > default key override > default name
                const name = (pos.key ? positionNames[pos.key] : null) || pos.defaultName;
                return saved ? { ...pos, x: saved.x, y: saved.y, name } : { ...pos, name };
            });

            const getPlayer = (id) => roster.find(p => p.id === id);

            const handleSelectPlayer = (posId, depthIndex, playerId) => {
                const currentDepth = depthChart[posId] || [null, null, null];
                const newDepth = [...currentDepth];
                newDepth[depthIndex] = playerId;
                onUpdateDepthChart({ ...depthChart, [posId]: newDepth });
            };

            const chartTitles = {
                'OFFENSE': 'Offensive Depth Chart',
                'DEFENSE': 'Defensive Depth Chart',
                'KICKOFF': 'Kickoff Unit',
                'KICK_RETURN': 'Kick Return Unit',
                'PUNT': 'Punt Unit',
                'PUNT_RETURN': 'Punt Return / Block',
                'HANDS_TEAM': 'Hands Team',
                'ONSIDE_KICK': 'Onside Kick Unit',
                'PAT_BLOCK': 'PAT / FG Block'
            };

            // Draggable & Renaming Logic
            const [isLocked, setIsLocked] = useLocalStorage('depthChartLocked', false);
            const [draggingId, setDraggingId] = useState(null);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [tempPosition, setTempPosition] = useState(null); // { x, y } while dragging

            // Renaming State
            const [editingId, setEditingId] = useState(null);
            const [editName, setEditName] = useState("");

            // Zoom/Scale for editing
            const [editZoom, setEditZoom] = useLocalStorage('depthChartZoom', 1);

            // Print Logic
            const [isPrinting, setIsPrinting] = useState(false);

            const handlePrint = () => {
                setIsPrinting(true);
                setTimeout(() => {
                    window.print();
                    setIsPrinting(false);
                }, 500);
            };

            const PrintView = () => {
                const weekTitle = currentWeek?.name || `Week ${currentWeek?.weekNumber || ''}`;
                const opponentTitle = currentWeek?.opponent ? `vs. ${currentWeek.opponent}` : '';

                return (
                <div className="depth-chart-print-view" style={{ padding: '20px', fontFamily: 'Arial, sans-serif', background: '#fff', color: '#000' }}>
                    {/* Print Header with Logo, Week, Opponent */}
                    <div style={{
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'space-between',
                        marginBottom: '1rem',
                        paddingBottom: '0.5rem',
                        borderBottom: '2px solid black'
                    }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                            {teamLogo && (teamLogo.startsWith('http') || teamLogo.startsWith('data:')) ? (
                                <img src={teamLogo} alt="Logo" style={{ height: '50px', width: 'auto' }} />
                            ) : teamLogo ? (
                                <span style={{ fontSize: '2rem' }}>{teamLogo}</span>
                            ) : null}
                            <div>
                                <div style={{ fontSize: '1.25rem', fontWeight: 'bold', color: 'black' }}>
                                    {weekTitle} {opponentTitle && `- ${opponentTitle}`}
                                </div>
                            </div>
                        </div>
                        <div style={{ fontSize: '0.75rem', color: '#64748b', textAlign: 'right' }}>
                            {new Date().toLocaleDateString()}
                        </div>
                    </div>
                    <h1 style={{ textAlign: 'center', marginBottom: '20px', color: '#000' }}>{chartTitles[baseChartType] || chartTitles['OFFENSE']}</h1>
                    <div style={{ position: 'relative', height: '600px', border: '2px solid #000', background: '#fff' }}>
                        {/* Field Lines */}
                        <div style={{ position: 'absolute', top: '50px', left: 0, right: 0, height: '2px', background: '#000' }}></div>

                        {positions.map(pos => (
                            <div
                                key={pos.id}
                                style={{
                                    position: 'absolute',
                                    left: `${pos.x}px`,
                                    top: `${pos.y}px`,
                                    width: '140px',
                                    transform: 'translateX(-50%)',
                                    border: '2px solid #000',
                                    padding: '5px',
                                    background: '#fff',
                                    borderRadius: '5px',
                                    textAlign: 'center',
                                    color: '#000'
                                }}
                            >
                                <div style={{ fontWeight: 'bold', borderBottom: '2px solid #000', marginBottom: '5px', paddingBottom: '3px', color: '#000' }}>{pos.name}</div>
                                {Array.from({ length: (depthRowCounts[pos.id] || 3) }).map((_, depth) => {
                                    const playerId = depthChart[pos.id]?.[depth];
                                    const player = getPlayer(playerId);
                                    return (
                                        <div key={depth} style={{ fontSize: '12px', padding: '2px 0', borderBottom: '1px solid #000', color: '#000' }}>
                                            {player ? `#${player.number} ${player.name}` : '-'}
                                        </div>
                                    );
                                })}
                            </div>
                        ))}
                    </div>
                </div>
            );
            };

            const handleMouseDown = (e, pos) => {
                // Prevent drag if locked, clicking select, or editing
                if (isLocked) return;
                if (e.target.tagName === 'SELECT' || e.target.tagName === 'OPTION' || e.target.tagName === 'INPUT') return;
                if (editingId) return; // Don't drag while editing

                setDraggingId(pos.id);
                setDragOffset({
                    x: e.clientX - pos.x,
                    y: e.clientY - pos.y
                });
                setTempPosition({ x: pos.x, y: pos.y });
            };

            const handleDoubleClick = (pos) => {
                if (pos.key) {
                    setEditingId(pos.id);
                    setEditName(pos.name);
                }
            };

            const saveName = (pos) => {
                if (pos.key && onUpdatePositionNames) {
                    onUpdatePositionNames({ ...positionNames, [pos.key]: editName.toUpperCase().slice(0, 3) });
                }
                setEditingId(null);
            };

            const handleMouseMove = (e) => {
                if (!draggingId || !tempPosition) return;

                const SNAP_SIZE = 20;

                const rawX = e.clientX - dragOffset.x;
                const rawY = e.clientY - dragOffset.y;

                // Snap to grid
                const snappedX = Math.round(rawX / SNAP_SIZE) * SNAP_SIZE;
                const snappedY = Math.round(rawY / SNAP_SIZE) * SNAP_SIZE;

                setTempPosition({ x: snappedX, y: snappedY });
            };

            const handleMouseUp = () => {
                if (draggingId && tempPosition && onUpdateLayout) {
                    onUpdateLayout(draggingId, tempPosition.x, tempPosition.y);
                }
                setDraggingId(null);
                setTempPosition(null);
            };

            // Add listener to window for mouse up to catch drags that end outside container
            useEffect(() => {
                if (draggingId) {
                    window.addEventListener('mousemove', handleMouseMove);
                    window.addEventListener('mouseup', handleMouseUp);
                    return () => {
                        window.removeEventListener('mousemove', handleMouseMove);
                        window.removeEventListener('mouseup', handleMouseUp);
                    };
                }
            }, [draggingId, tempPosition]);

            // Direct Return for Forced Print View (Print All Mode)
            if (forcePrintView) {
                return (
                    <div style={{ height: 'auto', pageBreakInside: 'avoid' }}>
                        <PrintView />
                    </div>
                );
            }

            return (
                <>
                    <div className="depth-chart-container" style={{ height: 'calc(100vh - 100px)', display: 'flex', flexDirection: 'column' }}>
                        <div className="depth-chart-controls" style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '2rem' }}>
                            <h2>{chartTitles[baseChartType] || chartTitles['OFFENSE']}</h2>
                            <div style={{ display: 'flex', gap: '1rem' }}>
                                <button
                                    className={`btn ${isLocked ? 'btn-primary' : 'btn-secondary'}`}
                                    onClick={() => setIsLocked(!isLocked)}
                                    title={isLocked ? "Unlock positions to move them" : "Lock positions to prevent changes"}
                                >
                                    {isLocked ? '🔒 Layout Locked' : '🔓 Lock Layout'}
                                </button>
                                {!isLocked && (
                                    <button className="btn btn-secondary" onClick={onResetLayout} title="Reset positions to default">Reset Layout</button>
                                )}
                                <button className="btn btn-secondary" onClick={handlePrint}>🖨️ Print</button>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginLeft: '1rem', padding: '0 12px', background: 'var(--surface)', borderRadius: '6px', border: '1px solid var(--border)' }}>
                                    <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)' }}>Zoom</span>
                                    <button
                                        className="btn btn-secondary"
                                        onClick={() => setEditZoom(Math.max(0.4, editZoom - 0.1))}
                                        style={{ padding: '4px 8px', minWidth: '30px' }}
                                    >−</button>
                                    <span style={{ fontSize: '0.85rem', fontWeight: '600', minWidth: '45px', textAlign: 'center' }}>{Math.round(editZoom * 100)}%</span>
                                    <button
                                        className="btn btn-secondary"
                                        onClick={() => setEditZoom(Math.min(1.5, editZoom + 0.1))}
                                        style={{ padding: '4px 8px', minWidth: '30px' }}
                                    >+</button>
                                    <button
                                        className="btn btn-secondary"
                                        onClick={() => setEditZoom(1)}
                                        style={{ padding: '4px 8px', fontSize: '0.7rem' }}
                                        title="Reset to 100%"
                                    >Reset</button>
                                </div>
                            </div>
                        </div>

                        <div className="depth-chart-viewport" style={{
                            flex: 1,
                            overflowY: 'auto',
                            overflowX: 'auto',
                            position: 'relative',
                            minHeight: '600px',
                            border: '1px solid var(--border)',
                            borderRadius: '8px',
                            background: 'var(--surface)',
                            userSelect: 'none'
                        }}>
                            <div style={{
                                transform: `scale(${editZoom})`,
                                transformOrigin: 'top left',
                                minWidth: `${1650 / editZoom}px`,
                                minHeight: `${1300 / editZoom}px`
                            }}>
                            {/* Letter-sized Page Guide (scaled 1.5x for easier editing - prints at ~65% scale) */}
                            <div style={{
                                position: 'absolute',
                                top: '20px',
                                left: '20px',
                                width: '1584px',
                                height: '1224px',
                                border: '2px dashed rgba(100, 160, 255, 0.5)',
                                borderRadius: '4px',
                                background: 'var(--surface)',
                                pointerEvents: 'none',
                                zIndex: 0
                            }}>
                                <div style={{
                                    position: 'absolute',
                                    top: '-24px',
                                    left: '0',
                                    fontSize: '0.7rem',
                                    color: 'rgba(100, 160, 255, 0.7)',
                                    fontWeight: '600',
                                    textTransform: 'uppercase',
                                    letterSpacing: '0.05em'
                                }}>
                                    📄 Page Guide (print at ~65% scale to fit letter size)
                                </div>
                            </div>

                            {positions.map(pos => {
                                const isDragging = draggingId === pos.id;
                                const x = isDragging ? tempPosition.x : pos.x;
                                const y = isDragging ? tempPosition.y : pos.y;
                                const isEditing = editingId === pos.id;

                                return (
                                    <div
                                        key={pos.id}
                                        onMouseDown={(e) => handleMouseDown(e, pos)}
                                        onDoubleClick={() => handleDoubleClick(pos)}
                                        style={{
                                            position: 'absolute',
                                            left: `${x}px`,
                                            top: `${y}px`,
                                            width: '140px',
                                            transform: 'translateX(-50%)', // Center align relative to coords
                                            display: 'flex',
                                            flexDirection: 'column',
                                            gap: '4px',
                                            background: isDragging ? 'var(--highlight)' : 'rgba(0,0,0,0.5)',
                                            padding: '8px',
                                            borderRadius: '8px',
                                            cursor: isDragging ? 'grabbing' : (pos.key ? 'pointer' : 'default'),
                                            border: isDragging ? '1px solid var(--accent)' : '1px solid transparent',
                                            zIndex: isDragging ? 10 : 1
                                        }}
                                    >
                                        {isEditing ? (
                                            <input
                                                autoFocus
                                                value={editName}
                                                onChange={(e) => setEditName(e.target.value)}
                                                onBlur={() => saveName(pos)}
                                                onKeyDown={(e) => {
                                                    if (e.key === 'Enter') saveName(pos);
                                                    if (e.key === 'Escape') setEditingId(null);
                                                }}
                                                maxLength={3}
                                                style={{
                                                    textAlign: 'center',
                                                    fontWeight: 'bold',
                                                    color: 'var(--text-primary)',
                                                    marginBottom: '4px',
                                                    background: 'var(--surface)',
                                                    border: '1px solid var(--accent)',
                                                    borderRadius: '4px',
                                                    padding: '2px',
                                                    width: '100%'
                                                }}
                                                onClick={(e) => e.stopPropagation()} // Prevent drag start
                                            />
                                        ) : (
                                            <div style={{ textAlign: 'center', fontWeight: 'bold', color: 'var(--accent)', marginBottom: '4px' }}>
                                                {pos.name}
                                            </div>
                                        )}

                                        {Array.from({ length: (depthRowCounts[pos.id] || 3) }).map((_, depth) => {
                                            const playerId = depthChart[pos.id]?.[depth];
                                            const label = depthStrings[pos.id]?.[depth] || (depth + 1).toString();

                                            return (
                                                <div key={depth} style={{ display: 'flex', gap: '4px', alignItems: 'center' }}>
                                                    <input
                                                        value={label}
                                                        onChange={(e) => {
                                                            if (!onUpdateDepthStrings) return;
                                                            const newPosStrings = [...(depthStrings[pos.id] || [])];
                                                            // Ensure array is padded if assigning to index > length
                                                            while (newPosStrings.length <= depth) newPosStrings.push('');
                                                            newPosStrings[depth] = e.target.value;
                                                            onUpdateDepthStrings({ ...depthStrings, [pos.id]: newPosStrings });
                                                        }}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                        placeholder={(depth + 1).toString()}
                                                        style={{
                                                            width: '24px',
                                                            textAlign: 'center',
                                                            padding: '2px',
                                                            border: '1px solid var(--border)',
                                                            borderRadius: '4px',
                                                            fontSize: '0.75rem',
                                                            background: 'var(--surface)',
                                                            color: 'var(--text-secondary)'
                                                        }}
                                                    />
                                                    <div style={{ flex: 1 }}>
                                                        <SearchablePlayerDropdown
                                                            roster={roster}
                                                            value={playerId || ''}
                                                            onChange={(newPlayerId) => handleSelectPlayer(pos.id, depth, newPlayerId)}
                                                            depthChart={depthChart}
                                                        />
                                                    </div>
                                                </div>
                                            );
                                        })}
                                        <div style={{ display: 'flex', justifyContent: 'center', marginTop: '4px' }}>
                                            <button
                                                className="btn-text"
                                                style={{ fontSize: '0.7rem', padding: '2px 4px', color: 'var(--text-secondary)' }}
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    if (onUpdateDepthRowCounts) {
                                                        const currentCount = depthRowCounts[pos.id] || 3;
                                                        onUpdateDepthRowCounts({ ...depthRowCounts, [pos.id]: currentCount + 1 });
                                                    }
                                                }}
                                            >
                                                + Add Row
                                            </button>
                                        </div>
                                    </div>
                                );
                            })}
                            </div>{/* end zoom wrapper */}
                        </div>
                    </div>
                    {/* Print Portal - always rendered, hidden on screen, shown in print */}
                    {ReactDOM.createPortal(
                        <div className="print-only-portal depth-chart-single-print">
                            <PrintView />
                        </div>,
                        document.body
                    )}
                </>
            );
        };



        // --- Global Helper Functions for Metrics & Scoring ---
        const parseTime = (val) => {
            if (!val) return null;
            if (typeof val === 'number') return val;
            if (val.includes(':')) {
                const [m, s] = val.split(':').map(Number);
                return (m * 60) + s;
            }
            return parseFloat(val);
        };

        const calculateIronManScore = (id, value, weight) => {
            if (!value || !weight) return 0;
            const wt = parseFloat(weight);
            const val = parseTime(value);

            if (isNaN(wt) || isNaN(val)) return 0;

            // 40 Yard Dash (Linear Approximation)
            if (id === 'forty') {
                const standard1000 = 4.3 + (wt - 100) * 0.0056;
                const standard0 = standard1000 + 2.4;
                if (val <= standard1000) return 1000;
                if (val >= standard0) return 0;
                const range = standard0 - standard1000;
                const diff = standard0 - val;
                return Math.round((diff / range) * 1000);
            }

            // Bench Press & Squat
            if (id === 'bench' || id === 'squat') {
                const roundedWeight = Math.round(wt / 10) * 10;
                if (roundedWeight === 0) return 0;
                const rawScore = (val * 3 / roundedWeight) * 100;
                return Math.max(0, Math.min(1000, Math.round(rawScore)));
            }

            // Bag Jump (Board Jump)
            if (id === 'bagJump' || id === 'boardJump') {
                let threshold = 30;
                if (wt <= 150) threshold = 30;
                else if (wt < 160) threshold = 30;
                else if (wt < 170) threshold = 29;
                else if (wt < 180) threshold = 28;
                else if (wt < 190) threshold = 27;
                else if (wt < 200) threshold = 26;
                else if (wt < 210) threshold = 26;
                else if (wt < 220) threshold = 25;
                else if (wt < 230) threshold = 25;
                else if (wt < 240) threshold = 24;
                else if (wt < 250) threshold = 23;
                else if (wt < 260) threshold = 22;
                else if (wt < 270) threshold = 21;
                else if (wt < 280) threshold = 20;
                else if (wt < 290) threshold = 19;
                else if (wt < 300) threshold = 18;
                else if (wt < 310) threshold = 17;
                else if (wt < 320) threshold = 16;
                else threshold = 15;

                const rawScore = (val - threshold) * 20;
                return Math.max(0, Math.min(1000, Math.round(rawScore)));
            }

            // 800m Run
            if (id === 'run800') {
                const standard1000 = 125 + (wt - 100) * 0.15;
                const standard0 = standard1000 + 120;
                if (val <= standard1000) return 1000;
                if (val >= standard0) return 0;
                const range = standard0 - standard1000;
                const diff = standard0 - val;
                return Math.round((diff / range) * 1000);
            }

            // 30 Yard Shuttle
            if (id === 'shuttle30') {
                const rawScore = 4000 + (wt * 4) - (val * 80);
                return Math.max(0, Math.min(1000, Math.round(rawScore)));
            }

            return 0;
        };
        const FormationManager = ({ formations, onAddFormation, onUpdateFormation, onDeleteFormation, positionNames = {}, positionColors = {}, phase = 'OFFENSE', personnelGroupings = {} }) => {
            const [selectedFormationId, setSelectedFormationId] = useState(null);
            const [editingFormation, setEditingFormation] = useState(null);
            const [isCreatingNew, setIsCreatingNew] = useState(false);
            const fieldRef = useRef(null);
            const [draggingPlayer, setDraggingPlayer] = useState(null);
            const [selectedIndices, setSelectedIndices] = useState([]);
            const [selectionBox, setSelectionBox] = useState(null);
            const [lastMousePos, setLastMousePos] = useState(null);
            const [selectedFormationIds, setSelectedFormationIds] = useState(new Set());
            const [lastClickedId, setLastClickedId] = useState(null);
            const [showDiagramEditor, setShowDiagramEditor] = useState(false);

            const displayedFormations = formations.filter(f => (f.phase || 'OFFENSE') === phase);

            // Convert formation positions (percentage 0-100) to diagrammer elements (pixels 800x500)
            // Formation y=50 = LOS, higher y = deeper in backfield (behind LOS)
            // PlayDiagramEditor has LOS at y=250 (center), higher pixel y = behind LOS
            const positionsToElements = (positions) => {
                // Default colors as fallback - will be overridden by positionColors prop
                const defaultColors = {
                    'C': '#64748b', 'G': '#64748b', 'T': '#64748b',
                    'LT': '#64748b', 'LG': '#64748b', 'RG': '#64748b', 'RT': '#64748b',
                    'QB': '#1e3a5f', 'Q': '#1e3a5f',
                    'RB': '#3b82f6', 'B': '#3b82f6',
                    'X': '#a855f7', 'Z': '#22c55e', 'Y': '#eab308',
                    'A': '#ef4444', 'F': '#f97316', 'H': '#06b6d4'
                };
                const getColor = (label) => positionColors[label] || defaultColors[label] || '#3b82f6';
                // WIZ card viewBox is 754x445 with LOS at bottom (~y=380)
                // Background image has: 15 yard line at top, 10, 5, then LOS at bottom
                const LOS_PIXEL_Y = 380; // LOS position in 754x445 viewBox (near bottom)
                const CANVAS_WIDTH = 754;
                const SCALE = 4; // pixels per formation unit
                return positions.map((pos, idx) => {
                    const pixelY = LOS_PIXEL_Y + (pos.y - 50) * SCALE;
                    return {
                        id: Date.now() + idx,
                        type: 'player',
                        points: [{ x: (pos.x / 100) * CANVAS_WIDTH, y: pixelY }],
                        color: getColor(pos.label),
                        label: pos.label,
                        shape: 'circle',
                        variant: 'filled'
                    };
                });
            };

            // Convert diagrammer elements back to formation positions (percentages)
            // Reverse the y transformation: pixel y → formation y
            const elementsToPositions = (elements) => {
                const LOS_PIXEL_Y = 380; // Must match positionsToElements
                const CANVAS_WIDTH = 754; // Must match positionsToElements
                const SCALE = 4; // Must match positionsToElements
                return elements
                    .filter(el => el.type === 'player')
                    .map(el => ({
                        label: el.label || '?',
                        x: Math.round((el.points[0].x / CANVAS_WIDTH) * 100),
                        y: Math.round(50 + (el.points[0].y - LOS_PIXEL_Y) / SCALE)
                    }));
            };

            const handleDiagramSave = (elements) => {
                const newPositions = elementsToPositions(elements);
                setEditingFormation(prev => ({ ...prev, positions: newPositions }));
                setShowDiagramEditor(false);
            };

            const handleFormationClick = (formationId, e) => {
                if (e.shiftKey && lastClickedId) {
                    // Shift-click: select range
                    const ids = displayedFormations.map(f => f.id);
                    const startIdx = ids.indexOf(lastClickedId);
                    const endIdx = ids.indexOf(formationId);
                    const [from, to] = startIdx < endIdx ? [startIdx, endIdx] : [endIdx, startIdx];
                    const rangeIds = ids.slice(from, to + 1);
                    setSelectedFormationIds(new Set(rangeIds));
                } else if (e.metaKey || e.ctrlKey) {
                    // Cmd/Ctrl-click: toggle individual selection
                    setSelectedFormationIds(prev => {
                        const newSet = new Set(prev);
                        if (newSet.has(formationId)) {
                            newSet.delete(formationId);
                        } else {
                            newSet.add(formationId);
                        }
                        return newSet;
                    });
                    setLastClickedId(formationId);
                } else {
                    // Normal click: select single and edit
                    setSelectedFormationIds(new Set([formationId]));
                    setLastClickedId(formationId);
                    handleSelectFormation(formationId);
                    return;
                }
                setLastClickedId(formationId);
            };

            const handleBatchDelete = () => {
                if (selectedFormationIds.size === 0) return;
                if (!confirm(`Delete ${selectedFormationIds.size} formation(s)?`)) return;
                selectedFormationIds.forEach(id => onDeleteFormation(id));
                setSelectedFormationIds(new Set());
                if (selectedFormationIds.has(selectedFormationId)) {
                    setSelectedFormationId(null);
                    setEditingFormation(null);
                }
            };

            const handleStartNew = () => {
                setIsCreatingNew(true);
                setSelectedFormationId(null);

                let defaultPositions = [];
                if (phase === 'DEFENSE') {
                    defaultPositions = [
                        { label: 'DE', x: 30, y: 48 }, { label: 'NT', x: 50, y: 48 }, { label: 'DE', x: 70, y: 48 },
                        { label: 'LB', x: 20, y: 40 }, { label: 'LB', x: 40, y: 35 }, { label: 'LB', x: 60, y: 35 }, { label: 'LB', x: 80, y: 40 },
                        { label: 'CB', x: 10, y: 25 }, { label: 'CB', x: 90, y: 25 },
                        { label: 'S', x: 35, y: 15 }, { label: 'S', x: 65, y: 15 }
                    ];
                } else if (phase === 'SPECIAL_TEAMS') {
                    defaultPositions = [
                        { label: 'L1', x: 10, y: 40 }, { label: 'L2', x: 20, y: 40 }, { label: 'L3', x: 30, y: 40 }, { label: 'L4', x: 40, y: 40 }, { label: 'L5', x: 45, y: 40 },
                        { label: 'K', x: 50, y: 50 },
                        { label: 'R5', x: 55, y: 40 }, { label: 'R4', x: 60, y: 40 }, { label: 'R3', x: 70, y: 40 }, { label: 'R2', x: 80, y: 40 }, { label: 'R1', x: 90, y: 40 }
                    ];
                } else {
                    // Align all players at or near the LOS (y=50) for easier positioning
                    defaultPositions = [
                        // OL on the LOS
                        { label: 'LT', x: 35, y: 50 }, { label: 'LG', x: 42, y: 50 }, { label: 'C', x: 50, y: 50 },
                        { label: 'RG', x: 58, y: 50 }, { label: 'RT', x: 65, y: 50 },
                        // Receivers on the LOS
                        { label: 'X', x: 10, y: 50 }, { label: 'Z', x: 90, y: 50 },
                        { label: 'Y', x: 72, y: 50 }, { label: 'A', x: 28, y: 50 },
                        // Backfield behind LOS
                        { label: 'QB', x: 50, y: 56 }, { label: 'RB', x: 50, y: 64 }
                    ];
                }

                setEditingFormation({
                    id: Date.now().toString(),
                    name: '',
                    tag: '',
                    side: '',
                    personnel: '',
                    distribution: '',
                    tags: [],
                    notes: '',
                    phase: phase,
                    positions: defaultPositions
                });
            };

            const handleSelectFormation = (formationId) => {
                const formation = formations.find(f => f.id === formationId);
                if (formation) {
                    setSelectedFormationId(formationId);
                    setEditingFormation(JSON.parse(JSON.stringify(formation)));
                    setIsCreatingNew(false);
                    setSelectedIndices([]);
                }
            };

            const handleSave = () => {
                if (!editingFormation.name.trim()) {
                    alert('Please enter a formation number/name');
                    return;
                }
                if (isCreatingNew) onAddFormation(editingFormation);
                else onUpdateFormation(editingFormation.id, editingFormation);
                setIsCreatingNew(false);
                setSelectedFormationId(editingFormation.id);
            };

            const handleDelete = () => {
                if (!selectedFormationId) return;
                onDeleteFormation(selectedFormationId);
                setSelectedFormationId(null);
                setEditingFormation(null);
            };

            return (
                <div style={{ height: 'calc(100vh - 100px)', display: 'flex', gap: '2rem' }}>
                    <div className="card" style={{ width: '300px', display: 'flex', flexDirection: 'column', padding: '0' }}>
                        <div style={{ padding: '1rem', borderBottom: '1px solid var(--border)' }}>
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                <h3 style={{ margin: 0 }}>Formations</h3>
                                <button className="btn btn-primary" style={{ fontSize: '0.8rem', padding: '0.25rem 0.75rem' }} onClick={handleStartNew}>+ New</button>
                            </div>
                            {selectedFormationIds.size > 1 && (
                                <div style={{ marginTop: '0.75rem', display: 'flex', gap: '0.5rem', alignItems: 'center' }}>
                                    <span style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>{selectedFormationIds.size} selected</span>
                                    <button
                                        className="btn"
                                        style={{ fontSize: '0.75rem', padding: '0.25rem 0.5rem', background: '#ef4444', color: 'white', border: 'none' }}
                                        onClick={handleBatchDelete}
                                    >
                                        Delete Selected
                                    </button>
                                    <button
                                        className="btn btn-secondary"
                                        style={{ fontSize: '0.75rem', padding: '0.25rem 0.5rem' }}
                                        onClick={() => setSelectedFormationIds(new Set())}
                                    >
                                        Clear
                                    </button>
                                </div>
                            )}
                            <div style={{ fontSize: '0.7rem', color: 'var(--text-secondary)', marginTop: '0.5rem' }}>
                                Shift+click to select range, {navigator.platform.includes('Mac') ? '⌘' : 'Ctrl'}+click to toggle
                            </div>
                        </div>
                        <div style={{ flex: 1, overflowY: 'auto' }}>
                            {displayedFormations.map(formation => (
                                <div
                                    key={formation.id}
                                    onClick={(e) => handleFormationClick(formation.id, e)}
                                    style={{
                                        padding: '0.75rem 1rem',
                                        borderBottom: '1px solid var(--border)',
                                        cursor: 'pointer',
                                        background: selectedFormationIds.has(formation.id) ? 'rgba(59, 130, 246, 0.15)' :
                                                   selectedFormationId === formation.id ? 'var(--bg-body)' : 'transparent',
                                        borderLeft: selectedFormationIds.has(formation.id) ? '3px solid var(--primary)' : '3px solid transparent'
                                    }}
                                >
                                    <div style={{ fontWeight: 'bold', fontSize: '1.1rem' }}>{formation.name}</div>
                                    {formation.description && <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginTop: '0.25rem' }}>{formation.description}</div>}
                                </div>
                            ))}
                        </div>
                    </div>
                    <div className="card" style={{ flex: 1, display: 'flex', flexDirection: 'column' }}>
                        {editingFormation ? (
                            <>
                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem', paddingBottom: '1rem', borderBottom: '1px solid var(--border)' }}>
                                    <h2 style={{ margin: 0 }}>{isCreatingNew ? 'Create Formation' : 'Edit Formation'}</h2>
                                    <div style={{ display: 'flex', gap: '0.5rem' }}>
                                        <button className="btn btn-secondary" onClick={() => { setIsCreatingNew(false); setEditingFormation(null); setSelectedFormationId(null); }}>Cancel</button>
                                        {!isCreatingNew && <button className="btn" style={{ background: '#ef4444', color: 'white', border: 'none' }} onClick={handleDelete}>Delete</button>}
                                        <button className="btn btn-primary" onClick={handleSave}>Save</button>
                                    </div>
                                </div>
                                {/* Compact Form Layout */}
                                <div style={{ display: 'grid', gridTemplateColumns: '1fr auto', gap: '1rem', marginBottom: '1rem' }}>
                                    {/* Left Column: Name/Tag/Side row + Personnel/Distribution row */}
                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                                        {/* Row 1: Name + Tag + Side */}
                                        <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center' }}>
                                            <input
                                                type="text"
                                                className="form-input"
                                                value={editingFormation.name}
                                                onChange={e => setEditingFormation({ ...editingFormation, name: e.target.value })}
                                                placeholder="Formation Name"
                                                style={{ flex: 1, height: '36px' }}
                                            />
                                            <input
                                                type="text"
                                                className="form-input"
                                                value={editingFormation.tag || ''}
                                                onChange={e => setEditingFormation({ ...editingFormation, tag: e.target.value })}
                                                placeholder="Tag"
                                                maxLength={4}
                                                style={{ width: '60px', height: '36px', textAlign: 'center' }}
                                            />
                                            <div style={{ display: 'flex', height: '36px' }}>
                                                {['L', 'R'].map(side => (
                                                    <button
                                                        key={side}
                                                        type="button"
                                                        onClick={() => setEditingFormation({ ...editingFormation, side: editingFormation.side === side ? '' : side })}
                                                        style={{
                                                            width: '36px',
                                                            height: '36px',
                                                            fontSize: '0.9rem',
                                                            fontWeight: '700',
                                                            background: editingFormation.side === side ? (side === 'L' ? '#3b82f6' : '#ef4444') : 'var(--surface)',
                                                            color: editingFormation.side === side ? 'white' : 'var(--text-muted)',
                                                            border: `1px solid ${editingFormation.side === side ? (side === 'L' ? '#3b82f6' : '#ef4444') : 'var(--border)'}`,
                                                            borderRadius: side === 'L' ? '6px 0 0 6px' : '0 6px 6px 0',
                                                            cursor: 'pointer'
                                                        }}
                                                    >{side}</button>
                                                ))}
                                            </div>
                                        </div>

                                        {/* Row 2: Personnel + Distribution */}
                                        <div style={{ display: 'flex', gap: '0.75rem', alignItems: 'center', flexWrap: 'wrap' }}>
                                            <select
                                                className="form-input"
                                                value={editingFormation.personnel || ''}
                                                onChange={e => setEditingFormation({ ...editingFormation, personnel: e.target.value })}
                                                style={{ width: '100px', height: '32px', fontSize: '0.85rem' }}
                                            >
                                                <option value="">Personnel</option>
                                                {(personnelGroupings || []).map(g => (
                                                    <option key={g.id} value={g.code}>{g.code || g.name}</option>
                                                ))}
                                            </select>
                                            {(() => {
                                                const matchedGrouping = (personnelGroupings || []).find(g => g.code === editingFormation.personnel);
                                                if (!editingFormation.personnel || !matchedGrouping) return null;
                                                const defaultPosColors = {
                                                    'QB': '#1e3a5f', 'RB': '#3b82f6', 'F': '#f97316', 'H': '#06b6d4',
                                                    'X': '#a855f7', 'Z': '#22c55e', 'Y': '#eab308', 'A': '#ef4444', 'B': '#ec4899'
                                                };
                                                return (
                                                    <div style={{ display: 'flex', gap: '3px', alignItems: 'center' }}>
                                                        {(matchedGrouping.positions || []).map(pos => (
                                                            <span
                                                                key={pos}
                                                                style={{
                                                                    padding: '2px 6px',
                                                                    fontSize: '0.7rem',
                                                                    fontWeight: '600',
                                                                    background: positionColors[pos] || defaultPosColors[pos] || '#64748b',
                                                                    color: 'white',
                                                                    borderRadius: '4px'
                                                                }}
                                                            >
                                                                {positionNames[pos] || pos}
                                                            </span>
                                                        ))}
                                                    </div>
                                                );
                                            })()}
                                            <div style={{ display: 'flex', gap: '3px' }}>
                                                {['1x3', '2x2', '3x1', '1x4', '4x1', '3x2', '2x3', '0x4', '4x0'].map(dist => (
                                                    <button
                                                        key={dist}
                                                        type="button"
                                                        onClick={() => setEditingFormation({ ...editingFormation, distribution: editingFormation.distribution === dist ? '' : dist })}
                                                        style={{
                                                            padding: '0.4rem 0.5rem',
                                                            height: '32px',
                                                            fontSize: '0.75rem',
                                                            fontWeight: '600',
                                                            background: editingFormation.distribution === dist ? 'var(--primary)' : 'var(--surface)',
                                                            color: editingFormation.distribution === dist ? 'white' : 'var(--text-muted)',
                                                            border: `1px solid ${editingFormation.distribution === dist ? 'var(--primary)' : 'var(--border)'}`,
                                                            borderRadius: '4px',
                                                            cursor: 'pointer'
                                                        }}
                                                    >{dist}</button>
                                                ))}
                                            </div>
                                        </div>

                                        {/* Row 3: Tags */}
                                        <div style={{ display: 'flex', gap: '4px', flexWrap: 'wrap' }}>
                                            {[
                                                { key: 'shotgun', label: 'Gun' },
                                                { key: 'pistol', label: 'Pistol' },
                                                { key: 'under', label: 'Under' },
                                                { key: 'nubTE', label: 'Nub' },
                                                { key: 'open', label: 'Open' },
                                                { key: 'closed', label: 'Closed' },
                                                { key: 'strong', label: 'Strong' },
                                                { key: 'trade', label: 'Trade' },
                                                { key: 'backTo', label: 'Back To' },
                                                { key: 'backAway', label: 'Back Away' }
                                            ].map(tag => {
                                                const tags = editingFormation.tags || [];
                                                const isActive = tags.includes(tag.key);
                                                return (
                                                    <button
                                                        key={tag.key}
                                                        type="button"
                                                        onClick={() => {
                                                            const newTags = isActive
                                                                ? tags.filter(t => t !== tag.key)
                                                                : [...tags, tag.key];
                                                            setEditingFormation({ ...editingFormation, tags: newTags });
                                                        }}
                                                        style={{
                                                            padding: '0.3rem 0.6rem',
                                                            fontSize: '0.75rem',
                                                            fontWeight: '500',
                                                            background: isActive ? 'var(--accent)' : 'transparent',
                                                            color: isActive ? 'white' : 'var(--text-muted)',
                                                            border: `1px solid ${isActive ? 'var(--accent)' : 'var(--border)'}`,
                                                            borderRadius: '12px',
                                                            cursor: 'pointer'
                                                        }}
                                                    >{tag.label}</button>
                                                );
                                            })}
                                        </div>
                                    </div>

                                    {/* Right Column: Notes */}
                                    <div style={{ width: '200px' }}>
                                        <textarea
                                            className="form-input"
                                            value={editingFormation.notes || ''}
                                            onChange={e => setEditingFormation({ ...editingFormation, notes: e.target.value })}
                                            placeholder="Coach notes..."
                                            style={{ width: '100%', height: '100%', minHeight: '90px', resize: 'none', fontSize: '0.8rem' }}
                                        />
                                    </div>
                                </div>

                                <div style={{ flex: 1, minHeight: '400px' }}>
                                    <label className="form-label" style={{ marginBottom: '0.5rem', display: 'block' }}>Player Positions</label>

                                    {/* Preview SVG - 15.07:8.89 aspect ratio (WIZ diagram proportions) */}
                                    {(() => {
                                        // Same constants as positionsToElements for consistency
                                        const LOS_PIXEL_Y = 380;
                                        const CANVAS_WIDTH = 754;
                                        const SCALE = 4;

                                        // Fixed viewBox with 15.07:8.89 aspect ratio (width 754, height 445)
                                        const viewWidth = 754;
                                        const viewHeight = 445;

                                        // Calculate player positions using same formula as diagrammer
                                        const playerPositions = editingFormation.positions.map(pos => ({
                                            ...pos,
                                            pixelX: (pos.x / 100) * viewWidth,
                                            pixelY: LOS_PIXEL_Y + (pos.y - 50) * SCALE
                                        }));

                                        // Find topmost player to position LOS above them
                                        const topPlayerY = Math.min(...playerPositions.map(p => p.pixelY));
                                        // LOS should be 25px above the top of the topmost player
                                        const losDrawY = topPlayerY - 25;

                                        // Center the formation vertically in the viewBox
                                        const maxPlayerY = Math.max(...playerPositions.map(p => p.pixelY));
                                        const formationHeight = (maxPlayerY + 20) - (losDrawY - 20);
                                        const viewY = losDrawY - 20 - (viewHeight - formationHeight) / 2;

                                        return (
                                            <svg
                                                width="100%"
                                                viewBox={`0 ${viewY} ${viewWidth} ${viewHeight}`}
                                                preserveAspectRatio="xMidYMid meet"
                                                style={{ border: '2px solid #cbd5e1', borderRadius: '8px', background: '#f9f9f9', marginBottom: '1rem', aspectRatio: '15.07 / 8.89' }}
                                            >
                                                {/* LOS drawn above the players */}
                                                <line x1="20" y1={losDrawY} x2={viewWidth - 20} y2={losDrawY} stroke="#000" strokeWidth="3" />
                                                <text x="8" y={losDrawY + 4} fontSize="10" fill="#666">LOS</text>
                                                <text x={viewWidth - 8} y={losDrawY + 4} fontSize="10" fill="#666" textAnchor="end">LOS</text>
                                                {/* Hash marks on LOS */}
                                                <line x1={viewWidth * 0.33} y1={losDrawY - 5} x2={viewWidth * 0.33} y2={losDrawY + 5} stroke="#999" strokeWidth="1" />
                                                <line x1={viewWidth * 0.67} y1={losDrawY - 5} x2={viewWidth * 0.67} y2={losDrawY + 5} stroke="#999" strokeWidth="1" />
                                                {/* Yard line behind deepest player */}
                                                <line x1="20" y1={maxPlayerY + 25} x2={viewWidth - 20} y2={maxPlayerY + 25} stroke="#ddd" strokeWidth="1" strokeDasharray="8,4" />
                                                <line x1={viewWidth * 0.33} y1={maxPlayerY + 20} x2={viewWidth * 0.33} y2={maxPlayerY + 30} stroke="#ccc" strokeWidth="1" />
                                                <line x1={viewWidth * 0.67} y1={maxPlayerY + 20} x2={viewWidth * 0.67} y2={maxPlayerY + 30} stroke="#ccc" strokeWidth="1" />

                                                {/* Player Markers */}
                                                {playerPositions.map((pos, idx) => {
                                                    const defaultColorMap = {
                                                        'C': '#64748b', 'LG': '#64748b', 'RG': '#64748b', 'LT': '#64748b', 'RT': '#64748b',
                                                        'QB': '#1e3a5f', 'Q': '#1e3a5f',
                                                        'RB': '#3b82f6', 'B': '#3b82f6',
                                                        'X': '#a855f7', 'Z': '#22c55e', 'Y': '#eab308', 'A': '#ef4444',
                                                        'F': '#f97316', 'H': '#06b6d4'
                                                    };
                                                    const color = positionColors[pos.label] || defaultColorMap[pos.label] || '#3b82f6';
                                                    return (
                                                        <g key={idx}>
                                                            <circle cx={pos.pixelX} cy={pos.pixelY} r="14" fill={color} stroke="#fff" strokeWidth="2" />
                                                            <text x={pos.pixelX} y={pos.pixelY + 4} fill="#fff" fontSize="10" fontWeight="bold" textAnchor="middle">
                                                                {positionNames[pos.label] || pos.label}
                                                            </text>
                                                        </g>
                                                    );
                                                })}
                                            </svg>
                                        );
                                    })()}

                                    <button
                                        className="btn btn-secondary"
                                        onClick={() => setShowDiagramEditor(true)}
                                        style={{ width: '100%' }}
                                    >
                                        <Icon name="Edit3" size={16} /> Edit Positions
                                    </button>

                                    {/* PlayDiagramEditor Modal */}
                                    {showDiagramEditor && (
                                        <div style={{
                                            position: 'fixed',
                                            top: 0, left: 0, right: 0, bottom: 0,
                                            background: 'rgba(0,0,0,0.8)',
                                            zIndex: 9999,
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            padding: '2rem'
                                        }}>
                                            <div style={{ width: '100%', maxWidth: '1200px', maxHeight: '90vh', overflow: 'auto', background: 'var(--bg-card)', borderRadius: '12px' }}>
                                                <PlayDiagramEditor
                                                    initialData={{ elements: positionsToElements(editingFormation.positions) }}
                                                    onSave={(data) => handleDiagramSave(data.elements)}
                                                    onCancel={() => setShowDiagramEditor(false)}
                                                    mode="wiz-skill"
                                                    formations={formations}
                                                    positionNames={positionNames}
                                                    positionColors={positionColors}
                                                    formationOnly={true}
                                                />
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </>
                        ) : (
                            <div style={{ flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'var(--text-secondary)', flexDirection: 'column' }}>
                                <Icon name="Grid" size={48} />
                                <p style={{ marginTop: '1rem', fontSize: '1.1rem' }}>Select a formation or create a new one</p>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const UserGuide = () => {
            return (
                <div className="card" style={{ padding: '2rem', maxWidth: '800px', margin: '0 auto' }}>
                    <h1 style={{ marginBottom: '2rem' }}><Icon name="HelpCircle" size={32} /> User Guide</h1>

                    <section style={{ marginBottom: '3rem' }}>
                        <h2 style={{ color: 'var(--accent)', borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem' }}>Head Coach Usage</h2>
                        <ul style={{ lineHeight: '1.6', fontSize: '1.1rem', color: 'var(--text-secondary)' }}>
                            <li><strong>Staff Management:</strong> Use "Task Assigner" and "Staff & Roles" to delegate responsibilities to your assistants.</li>
                            <li><strong>Weekly Schedule:</strong> Monitor the "Active Week" timeline to ensure the team is on track for the upcoming opponent.</li>
                            <li><strong>Travel & Logistics:</strong> Use the "Travel Roster" to manage personnel for away games.</li>
                            <li><strong>Oversight:</strong> View all depth charts and practice plans to ensure alignment with team goals.</li>
                        </ul>
                    </section>

                    <section style={{ marginBottom: '3rem' }}>
                        <h2 style={{ color: 'var(--accent)', borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem' }}>Offensive Coordinator Usage</h2>
                        <ul style={{ lineHeight: '1.6', fontSize: '1.1rem', color: 'var(--text-secondary)' }}>
                            <li><strong>Playbook:</strong> Add and organize plays with tags (Formation, Concept, Situation). Use batch delete to clean up old plays.</li>
                            <li><strong>Game Planning:</strong> Build your "Situations and Scripts" by tagging plays with specific situations (e.g., "3rd & Long").</li>
                            <li><strong>Practice Scripts:</strong> Generate scripts based on your installed playbook and daily focus.</li>
                            <li><strong>In-Game:</strong> Use the "OC Call Sheet" on the tablet app for real-time play calling and tracking.</li>
                        </ul>
                    </section>

                    <section style={{ marginBottom: '3rem' }}>
                        <h2 style={{ color: 'var(--accent)', borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem' }}>Position Coach Usage</h2>
                        <ul style={{ lineHeight: '1.6', fontSize: '1.1rem', color: 'var(--text-secondary)' }}>
                            <li><strong>Depth Charts:</strong> Manage rotation and depth for your unit.</li>
                        </ul>
                    </section>
                </div>
            );
        };


        // REMOVED: TestingRecords (~1,047 lines) - check git history

        // Site Admin Panel - Only accessible to site admins
        const SiteAdminPanel = () => {
            const { currentUser } = useAuth();
            const [activeTab, setActiveTab] = useState('schools'); // 'schools' | 'requests' | 'templates'

            // Schools Overview State
            const [allSchools, setAllSchools] = useState([]);
            const [schoolsLoading, setSchoolsLoading] = useState(false);

            // Global Templates State
            const [globalTemplates, setGlobalTemplates] = useState([]);
            const [templatesLoading, setTemplatesLoading] = useState(false);
            const [showTemplateModal, setShowTemplateModal] = useState(false);
            const [editingTemplate, setEditingTemplate] = useState(null);
            const [templateForm, setTemplateForm] = useState({
                type: 'practice_plan',
                name: '',
                description: '',
                category: '',
                data: {}
            });

            // Fetch all schools
            useEffect(() => {
                if (!window.db || activeTab !== 'schools') return;
                setSchoolsLoading(true);
                const unsubscribe = window.db.collection('schools')
                    .onSnapshot(async (snapshot) => {
                        const schoolsData = [];
                        for (const doc of snapshot.docs) {
                            const school = { id: doc.id, ...doc.data() };
                            try {
                                const membersSnap = await window.db.collection('schools').doc(doc.id).collection('roster').get();
                                school.memberCount = membersSnap.size;
                            } catch (e) {
                                school.memberCount = 0;
                            }
                            schoolsData.push(school);
                        }
                        setAllSchools(schoolsData);
                        setSchoolsLoading(false);
                    }, (error) => {
                        console.error("Error fetching schools:", error);
                        setSchoolsLoading(false);
                    });
                return () => unsubscribe();
            }, [activeTab]);

            // Fetch global templates
            useEffect(() => {
                if (!window.db || activeTab !== 'templates') return;
                setTemplatesLoading(true);
                const unsubscribe = window.db.collection('global_templates')
                    .orderBy('createdAt', 'desc')
                    .onSnapshot((snapshot) => {
                        setGlobalTemplates(snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
                        setTemplatesLoading(false);
                    }, () => setTemplatesLoading(false));
                return () => unsubscribe();
            }, [activeTab]);

            const handleCreateTemplate = () => {
                setEditingTemplate(null);
                setTemplateForm({ type: 'practice_plan', name: '', description: '', category: '', data: {} });
                setShowTemplateModal(true);
            };

            const handleEditTemplate = (template) => {
                setEditingTemplate(template);
                setTemplateForm({
                    type: template.type,
                    name: template.name,
                    description: template.description || '',
                    category: template.category || '',
                    data: template.data || {}
                });
                setShowTemplateModal(true);
            };

            const handleSaveTemplate = async () => {
                if (!templateForm.name.trim()) {
                    alert('Please enter a template name');
                    return;
                }
                try {
                    const templateData = {
                        ...templateForm,
                        updatedAt: new Date().toISOString(),
                        updatedBy: currentUser?.email
                    };
                    if (editingTemplate) {
                        await window.db.collection('global_templates').doc(editingTemplate.id).update(templateData);
                    } else {
                        templateData.createdAt = new Date().toISOString();
                        templateData.createdBy = currentUser?.email;
                        await window.db.collection('global_templates').add(templateData);
                    }
                    setShowTemplateModal(false);
                } catch (err) {
                    console.error("Error saving template:", err);
                    alert("Error saving template: " + err.message);
                }
            };

            const handleDeleteTemplate = async (templateId) => {
                if (!window.confirm('Are you sure you want to delete this template?')) return;
                try {
                    await window.db.collection('global_templates').doc(templateId).delete();
                } catch (err) {
                    console.error("Error deleting template:", err);
                    alert("Error deleting template: " + err.message);
                }
            };

            return (
                <div style={{ height: 'calc(100vh - 100px)', display: 'flex', flexDirection: 'column', gap: '2rem' }}>
                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                        <h2>Site Admin</h2>
                        <div style={{ display: 'flex', gap: '0.5rem', background: 'var(--bg-panel)', padding: '0.25rem', borderRadius: '8px' }}>
                            <button className="btn" style={{ backgroundColor: activeTab === 'schools' ? 'var(--accent)' : 'transparent', color: activeTab === 'schools' ? 'white' : 'var(--text-secondary)' }} onClick={() => setActiveTab('schools')}>Schools & Users</button>
                            <button className="btn" style={{ backgroundColor: activeTab === 'requests' ? 'var(--accent)' : 'transparent', color: activeTab === 'requests' ? 'white' : 'var(--text-secondary)' }} onClick={() => setActiveTab('requests')}>Access Requests</button>
                            <button className="btn" style={{ backgroundColor: activeTab === 'templates' ? 'var(--accent)' : 'transparent', color: activeTab === 'templates' ? 'white' : 'var(--text-secondary)' }} onClick={() => setActiveTab('templates')}>Global Templates</button>
                        </div>
                    </div>

                    {/* SCHOOLS & USERS TAB */}
                    {activeTab === 'schools' && (
                        <div className="animation-fade-in card">
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                <div>
                                    <h3>Schools & Users</h3>
                                    <p style={{ color: 'var(--text-secondary)', fontSize: '0.9rem' }}>
                                        Overview of all schools and their status.
                                    </p>
                                </div>
                                <div style={{ display: 'flex', gap: '1rem', alignItems: 'center' }}>
                                    <span style={{ fontSize: '0.85rem', color: 'var(--text-secondary)' }}>
                                        {allSchools.length} school{allSchools.length !== 1 ? 's' : ''}
                                    </span>
                                </div>
                            </div>

                            {schoolsLoading ? (
                                <div style={{ padding: '2rem', textAlign: 'center', color: 'var(--text-secondary)' }}>
                                    Loading schools...
                                </div>
                            ) : allSchools.length === 0 ? (
                                <div style={{ padding: '2rem', textAlign: 'center', color: 'var(--text-secondary)', fontStyle: 'italic', background: 'var(--surface)', borderRadius: '8px' }}>
                                    No schools created yet.
                                </div>
                            ) : (
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                                    {allSchools.map(school => {
                                        const billing = school.billing || {};
                                        const plan = billing.plan || 'free';
                                        const trialEnds = billing.trialEndsAt ? new Date(billing.trialEndsAt) : null;
                                        const isTrialActive = trialEnds && trialEnds > new Date();
                                        const isTrialExpired = trialEnds && trialEnds <= new Date();

                                        let statusColor = '#64748b';
                                        let statusText = 'Free';
                                        if (plan === 'premium') {
                                            statusColor = '#22c55e';
                                            statusText = 'Premium';
                                        } else if (plan === 'trial' || isTrialActive) {
                                            statusColor = '#0ea5e9';
                                            statusText = `Trial (${trialEnds ? Math.ceil((trialEnds - new Date()) / (1000 * 60 * 60 * 24)) : '?'}d left)`;
                                        } else if (isTrialExpired) {
                                            statusColor = '#ef4444';
                                            statusText = 'Trial Expired';
                                        }

                                        return (
                                            <div key={school.id} style={{
                                                padding: '1rem',
                                                background: 'var(--surface)',
                                                borderRadius: '8px',
                                                borderLeft: `4px solid ${statusColor}`
                                            }}>
                                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                                                    <div>
                                                        <div style={{ fontWeight: 'bold', fontSize: '1.1rem', marginBottom: '0.25rem' }}>
                                                            {school.name || 'Unnamed School'}
                                                        </div>
                                                        <div style={{ fontSize: '0.85rem', color: 'var(--text-secondary)' }}>
                                                            {school.mascot && <span>{school.mascot} • </span>}
                                                            {school.zipCode && <span>ZIP: {school.zipCode}</span>}
                                                        </div>
                                                        <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginTop: '0.5rem' }}>
                                                            <span>ID: {school.id}</span>
                                                            {school.createdAt && <span> • Created: {new Date(school.createdAt).toLocaleDateString()}</span>}
                                                        </div>
                                                    </div>
                                                    <div style={{ textAlign: 'right' }}>
                                                        <span style={{
                                                            display: 'inline-block',
                                                            padding: '0.25rem 0.75rem',
                                                            background: `${statusColor}20`,
                                                            color: statusColor,
                                                            borderRadius: '12px',
                                                            fontSize: '0.8rem',
                                                            fontWeight: '600'
                                                        }}>
                                                            {statusText}
                                                        </span>
                                                        {school.memberCount !== undefined && (
                                                            <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginTop: '0.5rem' }}>
                                                                {school.memberCount} roster member{school.memberCount !== 1 ? 's' : ''}
                                                            </div>
                                                        )}
                                                        <button
                                                            onClick={async () => {
                                                                if (!window.confirm(`Are you sure you want to delete "${school.name || school.id}"?\n\nThis will permanently delete all data for this school including roster, plays, and practice plans.`)) {
                                                                    return;
                                                                }
                                                                try {
                                                                    // Archive access requests for all members of this school
                                                                    if (school.memberList && school.memberList.length > 0) {
                                                                        const archivePromises = school.memberList.map(async (member) => {
                                                                            if (member.email) {
                                                                                const requestDoc = await window.db.collection('access_requests').doc(member.email.toLowerCase()).get();
                                                                                if (requestDoc.exists) {
                                                                                    await window.db.collection('access_requests').doc(member.email.toLowerCase()).update({
                                                                                        status: 'archived',
                                                                                        archivedAt: new Date().toISOString(),
                                                                                        archivedReason: 'School deleted by admin',
                                                                                        previousSchoolName: school.name || school.id
                                                                                    });
                                                                                }
                                                                            }
                                                                        });
                                                                        await Promise.all(archivePromises);
                                                                    }
                                                                    await window.db.collection('schools').doc(school.id).delete();
                                                                    alert('School deleted successfully. Access requests archived.');
                                                                } catch (err) {
                                                                    console.error('Error deleting school:', err);
                                                                    alert('Error deleting school: ' + err.message);
                                                                }
                                                            }}
                                                            style={{
                                                                marginTop: '0.5rem',
                                                                padding: '0.25rem 0.5rem',
                                                                fontSize: '0.75rem',
                                                                background: 'transparent',
                                                                border: '1px solid #ef4444',
                                                                color: '#ef4444',
                                                                borderRadius: '4px',
                                                                cursor: 'pointer'
                                                            }}
                                                        >
                                                            Delete School
                                                        </button>
                                                    </div>
                                                </div>
                                                {school.memberList && school.memberList.length > 0 && (() => {
                                                    const uniqueMembers = [];
                                                    const seenEmails = new Set();
                                                    for (const member of school.memberList) {
                                                        if (member.email && !seenEmails.has(member.email.toLowerCase())) {
                                                            seenEmails.add(member.email.toLowerCase());
                                                            uniqueMembers.push(member);
                                                        }
                                                    }
                                                    if (uniqueMembers.length === 0) return null;
                                                    return (
                                                        <div style={{ marginTop: '0.75rem', paddingTop: '0.75rem', borderTop: '1px solid var(--border)' }}>
                                                            <div style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', marginBottom: '0.5rem' }}>COACHES:</div>
                                                            <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.5rem' }}>
                                                                {uniqueMembers.map((member, idx) => (
                                                                    <span key={idx} style={{
                                                                        fontSize: '0.8rem',
                                                                        padding: '0.25rem 0.5rem',
                                                                        background: 'var(--surface)',
                                                                        borderRadius: '4px',
                                                                        color: 'var(--text-primary)'
                                                                    }}>
                                                                        {member.email}
                                                                        <span style={{ color: 'var(--text-secondary)', marginLeft: '0.25rem' }}>
                                                                            ({member.role || 'member'})
                                                                        </span>
                                                                    </span>
                                                                ))}
                                                            </div>
                                                        </div>
                                                    );
                                                })()}
                                            </div>
                                        );
                                    })}
                                </div>
                            )}
                        </div>
                    )}

                    {/* ACCESS REQUESTS TAB */}
                    {activeTab === 'requests' && (
                        <div className="animation-fade-in card">
                            <AccessRequestsAdmin currentUser={currentUser} />
                        </div>
                    )}

                    {/* GLOBAL TEMPLATES TAB */}
                    {activeTab === 'templates' && (
                        <div className="animation-fade-in card">
                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                <div>
                                    <h3>Global Templates</h3>
                                    <p style={{ color: 'var(--text-secondary)', fontSize: '0.9rem' }}>
                                        Create and manage templates available to all schools.
                                    </p>
                                </div>
                                <button className="btn btn-primary" onClick={handleCreateTemplate}>
                                    + Create Template
                                </button>
                            </div>

                            {templatesLoading ? (
                                <p>Loading templates...</p>
                            ) : globalTemplates.length === 0 ? (
                                <div style={{ textAlign: 'center', padding: '2rem', color: 'var(--text-secondary)', fontStyle: 'italic' }}>
                                    No global templates yet. Create one to get started!
                                </div>
                            ) : (
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                    {globalTemplates.map(template => (
                                        <div key={template.id} style={{
                                            display: 'flex', justifyContent: 'space-between', alignItems: 'center',
                                            padding: '1rem', background: 'var(--surface)', borderRadius: '8px',
                                            borderLeft: `4px solid ${template.type === 'practice_plan' ? '#10b981' : template.type === 'calendar_event' ? '#3b82f6' : '#f59e0b'}`
                                        }}>
                                            <div style={{ flex: 1 }}>
                                                <div style={{ fontWeight: 'bold', marginBottom: '0.25rem' }}>{template.name}</div>
                                                <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>
                                                    {template.type === 'practice_plan' ? 'Practice Plan' : template.type === 'calendar_event' ? 'Calendar Event' : 'Task List'}
                                                    {template.category && ` - ${template.category}`}
                                                    {template.description && ` - ${template.description}`}
                                                </div>
                                            </div>
                                            <div style={{ display: 'flex', gap: '0.5rem' }}>
                                                <button className="btn" onClick={() => handleEditTemplate(template)}>Edit</button>
                                                <button className="btn" style={{ color: '#ef4444' }} onClick={() => handleDeleteTemplate(template.id)}>Delete</button>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>
                    )}

                    {/* TEMPLATE MODAL */}
                    {showTemplateModal && (
                        <div style={{
                            position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
                            background: 'rgba(0,0,0,0.7)', display: 'flex', alignItems: 'center',
                            justifyContent: 'center', zIndex: 9999
                        }} onClick={() => setShowTemplateModal(false)}>
                            <div style={{
                                background: 'var(--bg-panel)', padding: '2rem', borderRadius: '12px',
                                maxWidth: '600px', width: '90%', maxHeight: '80vh', overflow: 'auto'
                            }} onClick={(e) => e.stopPropagation()}>
                                <h2>{editingTemplate ? 'Edit Template' : 'Create Template'}</h2>
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem', marginTop: '1.5rem' }}>
                                    <div>
                                        <label className="form-label">Template Type</label>
                                        <select
                                            className="form-select"
                                            value={templateForm.type}
                                            onChange={(e) => setTemplateForm({ ...templateForm, type: e.target.value, data: {} })}
                                            disabled={!!editingTemplate}
                                        >
                                            <option value="practice_plan">Practice Plan</option>
                                            <option value="calendar_event">Calendar Event</option>
                                            <option value="task_list">Task List</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label className="form-label">Template Name *</label>
                                        <input
                                            type="text"
                                            className="form-input"
                                            value={templateForm.name}
                                            onChange={(e) => setTemplateForm({ ...templateForm, name: e.target.value })}
                                            placeholder="e.g. Monday - Base Install"
                                        />
                                    </div>
                                    <div>
                                        <label className="form-label">Description</label>
                                        <input
                                            type="text"
                                            className="form-input"
                                            value={templateForm.description}
                                            onChange={(e) => setTemplateForm({ ...templateForm, description: e.target.value })}
                                            placeholder="Optional description"
                                        />
                                    </div>
                                    <div>
                                        <label className="form-label">Category</label>
                                        <input
                                            type="text"
                                            className="form-input"
                                            value={templateForm.category}
                                            onChange={(e) => setTemplateForm({ ...templateForm, category: e.target.value })}
                                            placeholder="e.g. Weekly, Game Week, Offseason"
                                        />
                                    </div>
                                    <div style={{ padding: '1rem', background: 'var(--surface)', borderRadius: '8px' }}>
                                        <p style={{ color: 'var(--text-secondary)', fontSize: '0.9rem', marginBottom: '0.5rem' }}>
                                            <strong>Template Data:</strong> {templateForm.type === 'practice_plan' ? 'Define practice segments in JSON format' : templateForm.type === 'calendar_event' ? 'Define program events and tasks' : 'Define task list items'}
                                        </p>
                                        <textarea
                                            className="form-input"
                                            value={JSON.stringify(templateForm.data, null, 2)}
                                            onChange={(e) => {
                                                try {
                                                    const parsed = JSON.parse(e.target.value);
                                                    setTemplateForm({ ...templateForm, data: parsed });
                                                } catch (err) {
                                                    // Invalid JSON
                                                }
                                            }}
                                            rows={10}
                                            style={{ fontFamily: 'monospace', fontSize: '0.85rem' }}
                                            placeholder={templateForm.type === 'practice_plan'
                                                ? '{\n  "segments": [\n    {"type": "Team O", "duration": 15, "situation": "Base Downs", "hasScript": true}\n  ]\n}'
                                                : templateForm.type === 'calendar_event'
                                                    ? '{\n  "program": ["Event 1", "Event 2"],\n  "tasks": []\n}'
                                                    : '{\n  "tasks": [\n    {"task": "Task name", "assignTo": ["Role"]}\n  ]\n}'
                                            }
                                        />
                                    </div>
                                    <div style={{ display: 'flex', gap: '0.5rem', justifyContent: 'flex-end', marginTop: '1rem' }}>
                                        <button className="btn" onClick={() => setShowTemplateModal(false)}>Cancel</button>
                                        <button className="btn btn-primary" onClick={handleSaveTemplate}>
                                            {editingTemplate ? 'Update' : 'Create'} Template
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const Settings = ({ teamLogo, onUpdateLogo, accentColor, onUpdateAccentColor, theme, onUpdateTheme, positionNames, onUpdatePositionNames, activeYear, onUpdateActiveYear, visibleFeatures, onUpdateVisibleFeatures, renderSyncManager, isAdmin = false, currentSchoolId }) => {


            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        onUpdateLogo(reader.result);
                    };
                    reader.readAsDataURL(file);
                }
            };
            const { currentUser, logout } = useAuth();

            const [activeTab, setActiveTab] = useState('general'); // 'general' | 'members' | 'billing'
            const [expandedCategories, setExpandedCategories] = useState({});

            const toggleCategory = (key) => {
                setExpandedCategories(prev => ({ ...prev, [key]: !prev[key] }));
            };

            // Cloud Migration State
            const [migrationStatus, setMigrationStatus] = useState('idle');
            const [migrationError, setMigrationError] = useState(null);

            const handleMigrateToCloud = async () => {
                if (!currentUser) {
                    alert('You must be logged in to migrate data.');
                    return;
                }
                if (!window.confirm('Are you sure you want to migrate all local data to the cloud? This will overwrite any existing cloud data.')) {
                    return;
                }
                setMigrationStatus('loading');
                setMigrationError(null);
                try {
                    const getLocal = (key) => {
                        const saved = localStorage.getItem(key);
                        return saved ? JSON.parse(saved) : null;
                    };

                    // Core Data to Migrate
                    const itemsToSync = [
                        { id: 'roster', data: getLocal('oc-dashboard-roster') || [] },
                        { id: 'plays', data: getLocal('oc-dashboard-plays') || [] },
                        { id: 'staff', data: getLocal('oc-dashboard-staff') || [] },
                        { id: 'weeks', data: getLocal('oc-dashboard-weeks') || [] },
                        {
                            id: 'settings', data: {
                                teamLogo: localStorage.getItem('oc-dashboard-logo'),
                                accentColor: localStorage.getItem('oc-dashboard-accent'),
                                theme: localStorage.getItem('oc-dashboard-theme'),
                                activeYear: localStorage.getItem('hc-active-year'),
                                visibleFeatures: getLocal('hc-visible-features')
                            }
                        }
                    ];

                    await Promise.all(itemsToSync.map(item =>
                        syncToFirestore(currentUser.uid, item.id, item.data)
                    ));

                    setMigrationStatus('success');
                    setTimeout(() => setMigrationStatus('idle'), 3000);
                } catch (err) {
                    console.error('Migration Error:', err);
                    setMigrationError(err.message);
                    setMigrationStatus('error');
                }
            };

            // --- BILLING & LICENSING ---
            const [promoCode, setPromoCode] = useState('');
            const [redeeming, setRedeeming] = useState(false);
            const { billingInfo, updateBilling, planStatus: currentPlanStatus } = useSchoolPlan();

            const handleRedeemPromo = async () => {
                if (!promoCode) return;
                setRedeeming(true);
                try {
                    // 1. Validate Code
                    // NOTE: This assumes 'promo_codes' collection is readable by admins
                    const codeId = promoCode.trim();
                    const codeDoc = await window.db.collection('config').doc('billing').collection('promo_codes').doc(codeId).get();

                    if (!codeDoc.exists) throw new Error("Invalid Promo Code");
                    const codeData = codeDoc.data();

                    if (!codeData.active) throw new Error("Promo Code is inactive");
                    if (codeData.expiresAt && new Date(codeData.expiresAt) < new Date()) throw new Error("Promo Code expired");

                    // 2. Apply Code
                    const now = new Date();
                    let newSubEnd = now;

                    // If already premium/trial, extend from current expiry? 
                    // Let's simplify: Extend from NOW or Extend from Current Expiry if valid?
                    // Design: If 'extension', add days to max(now, currentExpiry).

                    let baseDate = now;
                    if (currentPlanStatus.includes('PREMIUM') && billingInfo.subscriptionEndsAt) {
                        const currentEnd = new Date(billingInfo.subscriptionEndsAt);
                        if (currentEnd > now) baseDate = currentEnd;
                    } else if (currentPlanStatus === 'PREMIUM_TRIAL' && billingInfo.trialEndsAt) {
                        const trialEnd = new Date(billingInfo.trialEndsAt);
                        if (trialEnd > now) baseDate = trialEnd;
                    }

                    if (codeData.durationDays) {
                        newSubEnd = new Date(baseDate.getTime() + (codeData.durationDays * 24 * 60 * 60 * 1000));
                    }

                    const newBilling = {
                        ...billingInfo,
                        plan: 'premium',
                        status: 'active',
                        subscriptionEndsAt: newSubEnd.toISOString(),
                        promoCode: codeId
                    };

                    // Update School
                    await window.db.collection('schools').doc(currentSchoolId).update({
                        billing: newBilling,
                        // Track redemption in school doc to prevent reuse? 
                        redeemedCodes: firebase.firestore.FieldValue.arrayUnion(codeId)
                    });

                    // Update Local State
                    updateBilling(newBilling);
                    setPromoCode('');
                    alert(`Success! Plan extended until ${newSubEnd.toLocaleDateString()}.\n\nReloading application...`);
                    window.location.reload();

                } catch (err) {
                    console.error("Redemption Error:", err);
                    alert("Redemption Failed: " + err.message);
                }
                setRedeeming(false);
            };

            // ... (existing code)

            // NEW: Members Logic
            const [loadingMembers, setLoadingMembers] = useState(false);
            const [members, setMembers] = useState([]);
            const [inviteEmail, setInviteEmail] = useState('');
            const [inviteRole, setInviteRole] = useState('coach');

            // Domain Management State
            const [claimedDomains, setClaimedDomains] = useState([]);
            const [newDomain, setNewDomain] = useState('');

            useEffect(() => {
                if (activeTab === 'members' && currentSchoolId) {
                    loadMembers();
                }
            }, [activeTab, currentSchoolId]);

            const loadMembers = async () => {
                setLoadingMembers(true);
                try {
                    const schoolDoc = await window.db.collection('schools').doc(currentSchoolId).get();
                    if (schoolDoc.exists) {
                        setMembers(schoolDoc.data().memberList || []);
                        setClaimedDomains(schoolDoc.data().domains || []);
                    }
                } catch (err) {
                    console.error("Error loading members:", err);
                }
                setLoadingMembers(false);
            };

            const handleAddDomain = async () => {
                if (!newDomain || !newDomain.includes('.')) return alert("Please enter a valid domain (e.g. myschool.edu)");
                const domain = newDomain.toLowerCase().trim().replace('@', ''); // specific cleanup

                try {
                    await window.db.collection('schools').doc(currentSchoolId).update({
                        domains: firebase.firestore.FieldValue.arrayUnion(domain)
                    });
                    setClaimedDomains(prev => [...prev, domain]);
                    setNewDomain('');
                } catch (err) {
                    console.error("Error adding domain:", err);
                    alert("Failed to add domain.");
                }
            };

            const handleRemoveDomain = async (domain) => {
                if (!window.confirm(`Stop auto-joining users from @${domain}?`)) return;
                try {
                    await window.db.collection('schools').doc(currentSchoolId).update({
                        domains: firebase.firestore.FieldValue.arrayRemove(domain)
                    });
                    setClaimedDomains(prev => prev.filter(d => d !== domain));
                } catch (err) {
                    console.error("Error removing domain:", err);
                    alert("Failed to remove domain.");
                }
            };

            const handleSendInvite = async () => {
                if (!inviteEmail || !inviteEmail.includes('@')) return;

                try {
                    // Create Invite Doc
                    const inviteToken = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
                    await window.db.collection('invites').add({
                        email: inviteEmail.toLowerCase(),
                        schoolId: currentSchoolId,
                        schoolName: localStorage.getItem('hc_school_name') || 'Football Program',
                        role: inviteRole,
                        token: inviteToken,
                        status: 'pending',
                        createdAt: new Date().toISOString(),
                        createdBy: window.auth.currentUser.uid
                    });

                    alert(`Invite Link Generated (Copy & Send):\n\n${window.location.origin}?invite=${inviteToken}`);
                    setInviteEmail('');
                } catch (err) {
                    console.error("Error sending invite:", err);
                }
            };

            const handleRemoveMember = async (member) => {
                const isSelf = member.uid === currentUser.uid;

                if (isSelf) {
                    if (member.role === 'admin') {
                        // Prompt for Admin Self-Removal choices
                        const choice = prompt("You are leaving as an Admin.\n\nType 'DELETE' to permanently delete this school (Wipe Data).\nType 'LEAVE' to just remove yourself.\nClick Cancel to stay.", "LEAVE");

                        if (choice === null) return; // Cancelled

                        const action = choice.toUpperCase().trim();

                        if (action === 'DELETE') {
                            if (!window.confirm("FINAL WARNING: This will wipe all school data. Are you sure?")) return;
                            setLoadingMembers(true);
                            try {
                                // 1. Delete School Doc
                                await window.db.collection('schools').doc(currentSchoolId).delete();

                                // 2. Delete Membership
                                await window.db.collection('users').doc(currentUser.uid).collection('memberships').doc(currentSchoolId).delete();

                                // 3. Update User Legacy Field & Local Storage
                                await window.db.collection('users').doc(currentUser.uid).update({ schoolId: firebase.firestore.FieldValue.delete() });
                                localStorage.removeItem('hc_school_id');

                                alert("School deleted. Reloading...");
                                window.location.reload();
                            } catch (err) {
                                console.error("Error deleting school:", err);
                                alert("Error: " + err.message);
                                setLoadingMembers(false);
                            }
                            return;
                        }

                        if (action !== 'LEAVE') return; // Invalid input or aborted
                        // Fallthrough to LEAVE logic
                    } else {
                        if (!window.confirm("Are you sure you want to leave this school?")) return;
                    }
                } else {
                    if (!window.confirm(`Are you sure you want to remove ${member.email}?`)) return;
                }

                // Standard Remove / Leave Logic
                try {
                    setLoadingMembers(true);

                    // 1. Remove from School's memberList
                    // 1. Remove from School's memberList AND staff list
                    await window.db.collection('schools').doc(currentSchoolId).update({
                        memberList: firebase.firestore.FieldValue.arrayRemove(member),
                        staff: firebase.firestore.FieldValue.arrayRemove(member) // Assuming member object is consistent/same ref.
                    });

                    // Note: arrayRemove only works if the object is IDENTICAL. 
                    // Members in 'staff' might have different fields than 'memberList'.
                    // So we might need to Read-Filter-Write for 'staff' array if the object structure differs.
                    // Given the 'member' passed here comes from the 'members' state which is `memberList`, 
                    // let's do a more robust Read-Modify-Write for the staff array to be safe.

                    const schoolDocRef = window.db.collection('schools').doc(currentSchoolId);
                    await window.db.runTransaction(async (transaction) => {
                        const sDoc = await transaction.get(schoolDocRef);
                        if (!sDoc.exists) return;

                        const sData = sDoc.data();
                        const currentStaff = sData.staff || [];
                        const currentMembers = sData.memberList || [];

                        const newStaff = currentStaff.filter(s => s.uid !== member.uid && s.id !== member.uid); // Check both UID and ID
                        const newMembers = currentMembers.filter(m => m.uid !== member.uid);

                        transaction.update(schoolDocRef, {
                            staff: newStaff,
                            memberList: newMembers
                        });
                    });

                    // 2. Delete Membership subdoc for the target user
                    // Note: This requires write permission to target user's subcollection. 
                    // If this fails (due to rules), the user is at least removed from the 'memberList'
                    // so they won't show in UI, but might retain access if rules check membership doc.
                    // Ideally Admin should have write access.
                    await window.db.collection('users').doc(member.uid).collection('memberships').doc(currentSchoolId).delete()
                        .catch(err => console.warn("Could not delete membership doc (perm issue?):", err));

                    // 3. [NEW] Clear Root User Legacy Fields
                    // This forces the user to be "orphaned" from this school in their personal view
                    await window.db.collection('users').doc(member.uid).update({
                        schoolId: firebase.firestore.FieldValue.delete(),
                        role: firebase.firestore.FieldValue.delete(),
                        activeYear: firebase.firestore.FieldValue.delete()
                    }).catch(err => console.warn("Could not clear root user fields (perm issue?):", err));

                    if (isSelf) {
                        // Also clear legacy field
                        await window.db.collection('users').doc(currentUser.uid).update({ schoolId: firebase.firestore.FieldValue.delete() });
                        localStorage.removeItem('hc_school_id');
                        window.location.reload();
                    } else {
                        // Refresh list
                        fetchMembers();
                    }

                } catch (err) {
                    console.error("Error removing member:", err);
                    alert("Failed to remove member. " + err.message);
                    setLoadingMembers(false);
                }
            };

            return (
                <div style={{ height: 'calc(100vh - 100px)', display: 'flex', flexDirection: 'column', gap: '2rem' }}>

                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                        <h2>Settings</h2>
                        <div style={{ display: 'flex', gap: '0.5rem', background: 'var(--bg-panel)', padding: '0.25rem', borderRadius: '8px' }}>
                            <button className="btn" style={{ backgroundColor: activeTab === 'general' ? 'var(--accent)' : 'transparent', color: activeTab === 'general' ? 'white' : 'var(--text-secondary)' }} onClick={() => setActiveTab('general')}>General</button>
                            {currentSchoolId && (
                                <button className="btn" style={{ backgroundColor: activeTab === 'members' ? 'var(--accent)' : 'transparent', color: activeTab === 'members' ? 'white' : 'var(--text-secondary)' }} onClick={() => setActiveTab('members')}>Members</button>
                            )}
                            {(isAdmin || members.find(m => m.uid === currentUser.uid)?.role === 'admin') && (
                                <button className="btn" style={{ backgroundColor: activeTab === 'billing' ? 'var(--accent)' : 'transparent', color: activeTab === 'billing' ? 'white' : 'var(--text-secondary)' }} onClick={() => setActiveTab('billing')}>Billing</button>
                            )}
                        </div>
                    </div>

                    {activeTab === 'members' && currentSchoolId && (
                        <div className="animation-fade-in card">
                            {/* Domain Management UI */}
                            {(isAdmin || members.find(m => m.uid === currentUser.uid)?.role === 'admin') && (
                                <div style={{ borderTop: 'none', paddingTop: 0, marginTop: 0 }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '1rem', alignItems: 'center' }}>
                                        <div>
                                            <h3 style={{ margin: 0 }}>Approved Domains</h3>
                                            <p style={{ color: 'var(--text-secondary)', fontSize: '0.9rem', margin: '0.25rem 0 0 0' }}>
                                                Auto-join users with these email domains.
                                            </p>
                                        </div>
                                        <div style={{ display: 'flex', gap: '0.5rem' }}>
                                            <input
                                                placeholder="e.g. myschool.edu"
                                                className="form-input"
                                                value={newDomain}
                                                onChange={e => setNewDomain(e.target.value)}
                                                style={{ minWidth: '200px' }}
                                            />
                                            <button className="btn btn-primary" onClick={handleAddDomain}>Add</button>
                                        </div>
                                    </div>

                                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.5rem' }}>
                                        {claimedDomains.map((d, idx) => (
                                            <div key={idx} style={{
                                                background: 'var(--bg-main)', border: '1px solid var(--border)',
                                                padding: '0.5rem 1rem', borderRadius: '20px', display: 'flex', alignItems: 'center', gap: '0.5rem'
                                            }}>
                                                <span style={{ fontWeight: 500 }}>@{d}</span>
                                                <button
                                                    onClick={() => handleRemoveDomain(d)}
                                                    style={{ background: 'none', border: 'none', color: '#ef4444', cursor: 'pointer', padding: 0, display: 'flex', alignItems: 'center' }}
                                                    title="Remove Domain"
                                                >
                                                    <div style={{ fontSize: '1.2rem', lineHeight: 1 }}>&times;</div>
                                                </button>
                                            </div>
                                        ))}
                                        {claimedDomains.length === 0 && <span style={{ opacity: 0.5, fontSize: '0.9rem' }}>No domains claimed yet. Users must be invited manually.</span>}
                                    </div>
                                </div>
                            )}
                        </div>
                    )}

                    {activeTab === 'general' && (
                        <div className="animation-fade-in" style={{ display: 'flex', flexDirection: 'column', gap: '2rem' }}>

                            <div className="card">
                                <h3>Team Branding</h3>
                                <p style={{ color: 'var(--text-secondary)', marginBottom: '1rem' }}>Upload your team logo to appear on printed documents.</p>

                                <div style={{ display: 'flex', alignItems: 'center', gap: '2rem' }}>
                                    <div style={{
                                        width: '100px',
                                        height: '100px',
                                        border: '2px dashed var(--border)',
                                        borderRadius: '8px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        overflow: 'hidden',
                                        background: 'var(--surface)'
                                    }}>
                                        {teamLogo ? (
                                            <img src={teamLogo} alt="Team Logo" style={{ maxWidth: '100%', maxHeight: '100%' }} />
                                        ) : (
                                            <span style={{ fontSize: '2rem' }}>🛡️</span>
                                        )}
                                    </div>
                                    <div>
                                        <input
                                            type="file"
                                            accept="image/*"
                                            onChange={handleImageUpload}
                                            style={{ marginBottom: '0.5rem' }}
                                        />
                                        {teamLogo && (
                                            <button
                                                className="btn"
                                                style={{ color: '#ef4444', display: 'block' }}
                                                onClick={() => onUpdateLogo(null)}
                                            >
                                                Remove Logo
                                            </button>
                                        )}
                                    </div>
                                </div>
                            </div>



                            <div className="card">
                                <h3>Interface Theme</h3>
                                <p style={{ color: 'var(--text-secondary)', marginBottom: '1rem' }}>Select the overall look and feel of the application.</p>
                                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))', gap: '1rem' }}>
                                    {[
                                        { id: 'navy', name: 'Navy Night', color: '#0f172a', textColor: '#f8fafc' },
                                        { id: 'light', name: 'Clean Light', color: '#f1f5f9', textColor: '#0f172a' },
                                        { id: 'contrast', name: 'High Contrast', color: '#000000', textColor: '#ffffff' }
                                    ].map(t => (
                                        <button
                                            key={t.id}
                                            className="btn"
                                            onClick={() => onUpdateTheme(t.id)}
                                            style={{
                                                display: 'flex',
                                                flexDirection: 'column',
                                                alignItems: 'center',
                                                justifyContent: 'center',
                                                padding: '1.5rem',
                                                background: t.color,
                                                border: (theme || 'navy') === t.id ? `2px solid var(--accent)` : '1px solid var(--border)',
                                                borderRadius: '8px',
                                                cursor: 'pointer',
                                                boxShadow: (theme || 'navy') === t.id ? '0 0 0 2px var(--accent)' : 'none'
                                            }}
                                        >
                                            <span style={{ color: t.textColor, fontWeight: 'bold' }}>{t.name}</span>
                                            {(theme || 'navy') === t.id && (
                                                <div style={{ marginTop: '0.5rem', fontSize: '0.8rem', color: 'var(--accent)' }}>Active</div>
                                            )}
                                        </button>
                                    ))}
                                </div>
                            </div>

                            <div className="card">
                                <h3>Team Colors</h3>
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem', marginTop: '1rem' }}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                                        <input
                                            type="color"
                                            value={accentColor || '#38bdf8'}
                                            onChange={(e) => onUpdateAccentColor(e.target.value)}
                                            style={{ width: '50px', height: '50px', padding: '0', border: 'none', borderRadius: '4px', cursor: 'pointer', background: 'none' }}
                                        />
                                        <div>
                                            <div style={{ fontWeight: 'bold' }}>Accent Color</div>
                                            <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>Primary color for buttons, active states, and highlights.</div>
                                        </div>
                                    </div>

                                    <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                                        {PRESET_COLORS.map(color => (
                                            <button
                                                key={color}
                                                onClick={() => onUpdateAccentColor(color)}
                                                style={{
                                                    width: '32px',
                                                    height: '32px',
                                                    borderRadius: '50%',
                                                    backgroundColor: color,
                                                    border: accentColor === color ? '2px solid white' : '2px solid transparent',
                                                    boxShadow: accentColor === color ? '0 0 0 2px var(--accent)' : 'none',
                                                    cursor: 'pointer'
                                                }}
                                                title={color}
                                            />
                                        ))}
                                    </div>
                                </div>
                            </div>

                            <div className="card">
                                <h3>Active Season</h3>
                                <p style={{ color: 'var(--text-secondary)', marginBottom: '1rem' }}>Select the current active year for your program.</p>
                                <div>
                                    <label className="form-label">Season Year</label>
                                    <select
                                        className="form-select"
                                        value={activeYear}
                                        onChange={(e) => onUpdateActiveYear(e.target.value)}
                                        style={{ width: '200px' }}
                                    >
                                        <option value="2024">2024</option>
                                        <option value="2025">2025</option>
                                        <option value="2026">2026</option>
                                        <option value="2027">2027</option>
                                        <option value="2028">2028</option>
                                    </select>
                                </div>
                            </div>

                            <div className="card">
                                <h3>Menu Visibility</h3>
                                <p style={{ color: 'var(--text-secondary)', marginBottom: '1rem' }}>Toggle menu categories and individual items to simplify your sidebar.</p>
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                                    {[
                                        {
                                            key: 'staffMeeting', label: 'Staff Meeting', items: [

                                                { key: 'weekOverview', label: 'Week Overview' },
                                                { key: 'practice', label: 'Practice Plans' },
                                                { key: 'pregame', label: 'Pre-game Timeline' },

                                            ]
                                        },
                                        {
                                            key: 'gameWeek', label: 'Offense, Defense & Special Teams', items: [
                                                { key: 'schemeSetup', label: 'Scheme Setup' },
                                                { key: 'depthCharts', label: 'Depth Charts' },
                                                { key: 'playbook', label: 'Playbook' },
                                                { key: 'gamePlan', label: 'Game Plan' },
                                                { key: 'addPlay', label: 'Add a New Play' },
                                                { key: 'wristband', label: 'Wristband Builder' },
                                                { key: 'practiceScripts', label: 'Practice Scripts' },
                                                { key: 'dumbCallsheet', label: 'Dumb Call Sheet' },

                                            ]
                                        }
                                    ].map(category => (
                                        <div key={category.key} style={{ borderLeft: '3px solid var(--primary)', paddingLeft: '1rem' }}>
                                            {/* Category Header - Clickable to expand/collapse */}
                                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '0.5rem' }}>
                                                {/* Category Checkbox */}
                                                <label style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', cursor: 'pointer', fontWeight: 'bold', flex: 1 }} onClick={(e) => e.stopPropagation()}>
                                                    <input
                                                        type="checkbox"
                                                        checked={visibleFeatures[category.key]?.enabled || false}
                                                        onChange={(e) => onUpdateVisibleFeatures({
                                                            ...visibleFeatures,
                                                            [category.key]: {
                                                                ...visibleFeatures[category.key],
                                                                enabled: e.target.checked
                                                            }
                                                        })}
                                                        style={{ cursor: 'pointer', width: '18px', height: '18px' }}
                                                    />
                                                    <span>{category.label}</span>
                                                </label>
                                                {/* Expand/Collapse Button */}
                                                <button
                                                    onClick={() => toggleCategory(category.key)}
                                                    style={{
                                                        background: 'none',
                                                        border: 'none',
                                                        cursor: 'pointer',
                                                        padding: '0.25rem',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        color: 'var(--text-secondary)',
                                                        transition: 'transform 0.2s'
                                                    }}
                                                >
                                                    <Icon name={expandedCategories[category.key] ? 'ChevronDown' : 'ChevronRight'} size={18} />
                                                </button>
                                            </div>
                                            {/* Item Checkboxes - Collapsible */}
                                            {expandedCategories[category.key] && (
                                                <div style={{ paddingLeft: '1.5rem', display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                                    {category.items.map(item => (
                                                        <label key={item.key} style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', cursor: 'pointer', opacity: visibleFeatures[category.key]?.enabled ? 1 : 0.5 }}>
                                                            <input
                                                                type="checkbox"
                                                                checked={visibleFeatures[category.key]?.items?.[item.key] || false}
                                                                disabled={!visibleFeatures[category.key]?.enabled}
                                                                onChange={(e) => onUpdateVisibleFeatures({
                                                                    ...visibleFeatures,
                                                                    [category.key]: {
                                                                        ...visibleFeatures[category.key],
                                                                        items: {
                                                                            ...visibleFeatures[category.key]?.items,
                                                                            [item.key]: e.target.checked
                                                                        }
                                                                    }
                                                                })}
                                                                style={{ cursor: visibleFeatures[category.key]?.enabled ? 'pointer' : 'not-allowed' }}
                                                            />
                                                            <span style={{ fontSize: '0.9rem' }}>{item.label}</span>
                                                        </label>
                                                    ))}
                                                </div>
                                            )}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    )}

                </div>
            );
        };
        // REMOVED: PlayerMetrics and ImpactRatings (~481 lines) - check git history

        const CollapsibleCategory = ({ title, icon, children, defaultOpen = false, nested = false, onTitleClick }) => {
            const [isOpen, setIsOpen] = useState(defaultOpen);

            const handleClick = () => {
                if (onTitleClick) {
                    onTitleClick();
                }
                setIsOpen(!isOpen);
            };

            return (
                <div style={{ marginBottom: '0.5rem' }}>
                    <div
                        onClick={handleClick}
                        style={{
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'space-between',
                            padding: nested ? '0.5rem 0.5rem 0.5rem 1.25rem' : '0.75rem 0.5rem',
                            cursor: 'pointer',
                            color: 'var(--text-secondary)',
                            fontWeight: nested ? '500' : 'bold',
                            fontSize: '0.9rem',
                            borderRadius: '6px',
                            transition: 'background 0.2s',
                            userSelect: 'none'
                        }}
                        className="nav-category-header"
                        onMouseEnter={e => e.currentTarget.style.background = 'var(--surface)'}
                        onMouseLeave={e => e.currentTarget.style.background = 'transparent'}
                    >
                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                            {icon && <Icon name={icon} size={nested ? 16 : 18} />}
                            <span style={{
                                textTransform: nested ? 'none' : 'uppercase',
                                letterSpacing: nested ? 'normal' : '0.05em',
                                fontSize: nested ? '0.9rem' : '0.8rem'
                            }}>{title}</span>
                        </div>
                        <span style={{ fontSize: '0.8rem' }}>
                            <Icon name={isOpen ? "ChevronDown" : "ChevronRight"} />
                        </span>
                    </div>
                    {isOpen && (
                        <div key={isOpen} style={{ paddingLeft: '0.5rem', display: 'flex', flexDirection: 'column', gap: '0.25rem' }}>
                            {children}
                        </div>
                    )}
                </div>
            );
        };

        const useLocalStorage = (key, initialValue) => {
            const [storedValue, setStoredValue] = useState(() => {
                try {
                    const item = window.localStorage.getItem(key);
                    return item ? JSON.parse(item) : initialValue;
                } catch (error) {
                    console.error(error);
                    return initialValue;
                }
            });

            const setValue = React.useCallback((value) => {
                try {
                    const valueToStore = value instanceof Function ? value(storedValue) : value;
                    setStoredValue(valueToStore);
                    window.localStorage.setItem(key, JSON.stringify(valueToStore));
                } catch (error) {
                    console.error(error);
                }
            }, [key, storedValue]);

            return [storedValue, setValue];
        };




        // 1. Install Manager Component
        const InstallManagerView = ({
            plays,
            week,
            weeks,
            currentWeekId,
            onUpdateWeek,
            gamePlan,
            practicePlans,
            wbSettings,
            onQuickAddPlay,
            playSyntax = [],
            onUpdatePlay,
            gamePlanLayouts,
            defaultWbSettings,
            defaultDepthChart,
            defaultZonePhilosophies,
            playCategories = [],
            playBuckets = []
        }) => {
            // Helper to group categories for the 3 columns
            const getCategoryGroup = (type) => {
                if (!type) return 'NONE';
                // Check if type matches a known category
                const cat = playCategories.find(c => c.id === type || c.label === type) || { id: type, label: type };
                const str = (cat.label || cat.id).toLowerCase();

                if (str.includes('run') || str.includes('rpo')) return 'RUN';
                if (str.includes('pass') || str.includes('quick') || str.includes('inter') || str.includes('shot') || str.includes('pap')) return 'PASS';
                return 'OTHER';
            };
            const { ReactSortable } = window; // Destructure Sortable
            const [searchTerm, setSearchTerm] = useState('');
            const [isQuickAddOpen, setIsQuickAddOpen] = useState(false); // Modal state for parser
            const [showImportModal, setShowImportModal] = useState(false);
            const [importSourceWeekId, setImportSourceWeekId] = useState('');

            // Quick Parser State
            const [assignmentModalState, setAssignmentModalState] = useState(null); // { playId, x, y }
            const [rawPlayCall, setRawPlayCall] = useState('');
            const [tokens, setTokens] = useState([]);
            const [parsedFields, setParsedFields] = useState({});

            const handleAssignSituation = (playId, box) => {
                const setId = box.setId;
                if (!onUpdateWeek || !week || !week.id) return;

                // Clone current gamePlan (offensiveGamePlan)
                const currentGamePlan = week.offensiveGamePlan || {};

                let updatedGamePlan;

                if (setId.startsWith('ms_')) {
                    // Handle Mini Script Update
                    const newMiniScripts = (currentGamePlan.miniScripts || []).map(s =>
                        s.id === setId ? { ...s, playIds: [...(s.playIds || []), playId] } : s
                    );
                    updatedGamePlan = { ...currentGamePlan, miniScripts: newMiniScripts };
                } else {
                    // Handle Standard Set Update
                    const existingSet = currentGamePlan.sets?.find(s => s.id === setId);
                    let newSets;
                    if (existingSet) {
                        newSets = (currentGamePlan.sets || []).map(s => s.id === setId ? { ...s, playIds: [...(s.playIds || []), playId] } : s);
                    } else {
                        // Implicit creation
                        newSets = [...(currentGamePlan.sets || []), { id: setId, name: setId, playIds: [playId] }];
                    }
                    updatedGamePlan = { ...currentGamePlan, sets: newSets };
                }

                // Update Week
                onUpdateWeek(week.id, 'offensiveGamePlan', updatedGamePlan);
            };

            // Fallback Buckets (ensure Run/Pass/Screen always exist)
            const DEFAULT_DEFAULTS = [
                { id: 'run', label: 'Run', color: '#10b981', textColor: '#ffffff' },
                { id: 'pass', label: 'Pass', color: '#3b82f6', textColor: '#ffffff' },
                { id: 'screen', label: 'Screen', color: '#8b5cf6', textColor: '#ffffff' }
            ];

            // Calculate Effective Buckets
            const effectiveBuckets = useMemo(() => {
                // If user has defined categories (buckets), use them strictly.
                // This prevents legacy defaults (like 'screen') from reappearing if user created 'SCREENS'.
                if (playCategories && playCategories.length > 0) {
                    return playCategories;
                }

                // Fallback Layout if nothing is defined
                return DEFAULT_DEFAULTS;
            }, [playCategories]);

            // Helper for Game Plan Updates
            const onUpdateGamePlan = (newPlan) => {
                if (onUpdateWeek && week) {
                    onUpdateWeek(week.id, 'offensiveGamePlan', newPlan);
                }
            };

            // Current Install List (Array of play IDs)
            const installList = week.installList || [];

            // Hydrated Install List
            const hydratedInstall = installList.map(id => plays.find(p => p.id === id)).filter(Boolean);

            // AUTO-MIGRATION: Ensure plays with 'type' but no 'bucketId' are assigned to matching bucket
            useEffect(() => {
                if (!onUpdatePlay || !hydratedInstall.length || !playBuckets.length) return;

                hydratedInstall.forEach(play => {
                    if (!play.bucketId && play.type) {
                        const typeStr = play.type.toLowerCase();
                        // Find a bucket that matches this type
                        const matchingBucket = effectiveBuckets.find(b =>
                            !b.categoryId && (
                                b.id === typeStr ||
                                b.label.toLowerCase() === typeStr ||
                                (typeStr.includes('run') && (b.id === 'run' || b.id === 'run-root')) ||
                                (typeStr.includes('pass') && (b.id === 'pass' || b.id === 'pass-root')) ||
                                (typeStr.includes('screen') && (b.id === 'screen' || b.id === 'screen-root'))
                            )
                        );
                        if (matchingBucket) {
                            onUpdatePlay(play.id, { bucketId: matchingBucket.id });
                        }
                    }
                });
            }, [hydratedInstall.length, effectiveBuckets]);

            const handleAssignPlayToSituation = (playId, box) => {
                if (!playId || !box || !box.setId) return;

                const safeGamePlan = gamePlan || {};
                const isScript = box.type === 'script';
                const collectionKey = isScript ? 'miniScripts' : 'sets';
                const targetId = box.setId;

                const updatedGamePlan = { ...safeGamePlan };

                // Ensure collection array exists
                if (!Array.isArray(updatedGamePlan[collectionKey])) {
                    updatedGamePlan[collectionKey] = [];
                }

                // Find existing set/script in the array
                const existingItem = updatedGamePlan[collectionKey].find(item => item.id === targetId);

                // Get current assigned IDs
                const currentData = existingItem || { playIds: [], assignedPlayIds: [] };
                let currentAssigned = currentData.assignedPlayIds || currentData.playIds || [];

                const isAssigned = currentAssigned.includes(playId);
                let newAssignedIds;

                if (isAssigned) {
                    // Remove play (toggle off)
                    newAssignedIds = currentAssigned.filter(id => id !== playId);
                } else {
                    // Add play - use Set to prevent duplicates from rapid clicks
                    newAssignedIds = [...new Set([...currentAssigned, playId])];
                }

                if (existingItem) {
                    // Update existing item
                    updatedGamePlan[collectionKey] = updatedGamePlan[collectionKey].map(item =>
                        item.id === targetId
                            ? { ...item, assignedPlayIds: newAssignedIds }
                            : item
                    );
                } else {
                    // Create new item
                    updatedGamePlan[collectionKey] = [
                        ...updatedGamePlan[collectionKey],
                        { id: targetId, name: targetId, assignedPlayIds: newAssignedIds, playIds: [] }
                    ];
                }

                onUpdateGamePlan(updatedGamePlan);
            };

            const getPlaySituations = (playId) => {
                const layouts = gamePlanLayouts;
                if (!playId || !layouts?.CALL_SHEET?.sections) return [];

                const assignedSituations = [];

                layouts.CALL_SHEET.sections.forEach(section => {
                    if (!section.boxes) return;
                    section.boxes.forEach(box => {
                        if (!box.setId) return;

                        const safeGamePlan = gamePlan || {};
                        const isScript = box.type === 'script';
                        // Fix: Handle as Arrays
                        const collection = isScript ? (safeGamePlan.miniScripts || []) : (safeGamePlan.sets || []);

                        const data = Array.isArray(collection) ? collection.find(item => item.id === box.setId)
                            : null;

                        // Check if play is assigned
                        if (data?.assignedPlayIds?.includes(playId)) {
                            assignedSituations.push({
                                id: box.setId,
                                header: box.header,
                                color: box.color,
                                type: box.type
                            });
                        }
                    });
                });

                return assignedSituations;
            };

            // Initialize/Reset parsed fields when syntax changes or modal opens
            useEffect(() => {
                if (isQuickAddOpen) {
                    const initialFields = {};
                    playSyntax.forEach(s => {
                        initialFields[s.id] = [];
                    });
                    setParsedFields(initialFields);
                }
            }, [isQuickAddOpen, playSyntax]);

            // Tokenizer
            const handleTokenize = () => {
                const parts = rawPlayCall.trim().split(/\s+/).filter(t => t.length > 0);
                setTokens(parts.map((t, i) => ({ id: `token-${i}`, text: t })));
                // Reset bucket distribution
                const initialFields = {};
                playSyntax.forEach(s => {
                    initialFields[s.id] = [];
                });
                setParsedFields(initialFields);
            };

            // Drag and Drop Logic for Parser
            const handleDragStartToken = (e, token, source) => {
                e.dataTransfer.setData('token', JSON.stringify(token));
                e.dataTransfer.setData('source', source);
            };

            const handleDropToken = (e, targetField) => {
                e.preventDefault();
                const tokenData = JSON.parse(e.dataTransfer.getData('token'));
                const source = e.dataTransfer.getData('source');

                // Remove from source
                if (source === 'unassigned') {
                    setTokens(prev => prev.filter(t => t.id !== tokenData.id));
                } else {
                    setParsedFields(prev => ({
                        ...prev,
                        [source]: prev[source].filter(t => t.id !== tokenData.id)
                    }));
                }

                // Add to target
                if (targetField === 'unassigned') {
                    setTokens(prev => [...prev, tokenData]);
                } else {
                    setParsedFields(prev => ({
                        ...prev,
                        [targetField]: [...prev[targetField], tokenData]
                    }));
                }
            };

            const handleQuickAddSubmit = () => {
                // Construct Play Name from fields in Order of Syntax

                const buildPart = (fieldId, arr) => {
                    if (!arr || arr.length === 0) return '';
                    const coreText = arr.map(t => t.text).join(' ');
                    const syntaxItem = playSyntax.find(s => s.id === fieldId);
                    if (syntaxItem) {
                        const pre = syntaxItem.prefix || '';
                        const suf = syntaxItem.suffix || '';
                        return `${pre}${coreText}${suf}`;
                    }
                    return coreText;
                };

                const parts = playSyntax.map(s => buildPart(s.id, parsedFields[s.id])).filter(p => p.length > 0);

                // If no syntax defined, fallback (or if user just typed)
                let finalName = parts.join(' ');
                if (!finalName && rawPlayCall) finalName = rawPlayCall.trim();

                if (!finalName) return;

                // Check if exists
                const existing = plays.find(p => p.name.toLowerCase() === finalName.toLowerCase());

                if (existing) {
                    handleAddToInstall(existing.id);
                    alert("Play already exists in Master Playbook. Added to this week's install.");
                } else {
                    // Create New
                    // We need to pass structured data if handleQuickAddPlay supports it.
                    // The current App implementation just takes a name. 
                    // We can enhance App's handler or just pass a name and let App create a shell.

                    // We'll call onQuickAddPlay which returns the new play object
                    const newPlay = onQuickAddPlay(finalName);

                    // If we want to save specific fields (like 'formation' property), we might need to update the play immediately after.
                    // But for now, let's just assume the name is the key.
                    // If onQuickAddPlay returns the object, we can add it to install list.

                    if (newPlay && newPlay.id) {
                        handleAddToInstall(newPlay.id);
                    }
                }

                // Reset
                setRawPlayCall('');
                setTokens([]);
                setParsedFields({ formation: [], motion: [], concept: [], protection: [], tags: [] });
                setIsQuickAddOpen(false);
            };


            // Removed redundant installList declaration (moved to top)

            const handleAddToInstall = (playId) => {
                if (!installList.includes(playId)) {
                    // Get the play
                    const play = plays.find(p => p.id === playId);

                    // Prepare updates: Reset priority (always start unstarred)
                    const updates = { priority: false };
                    onUpdatePlay(playId, updates);

                    // Create new installList or append to existing
                    const newList = [...installList, playId];
                    onUpdateWeek(week.id, 'installList', newList);
                }
            };

            const handleRemoveFromInstall = (playId) => {
                const newList = installList.filter(id => id !== playId);
                onUpdateWeek(week.id, 'installList', newList);
            };

            const handleTogglePriority = (playId) => {
                const play = plays.find(p => p.id === playId);
                if (play) {
                    onUpdatePlay(playId, { priority: !play.priority });
                }
            };

            // Import Handler
            const handleImportInstalls = () => {
                if (!importSourceWeekId) return;
                const sourceWeek = weeks.find(w => w.id === importSourceWeekId);
                if (!sourceWeek) return;

                const confirm = window.confirm(`Importing week data from ${sourceWeek.name} will OVERWRITE the current week's Installs, Wristbands, Depth Chart, and Zone Philosophies. This cannot be undone. Continue?`);
                if (!confirm) return;

                // 1. Installs
                if (sourceWeek.installList) onUpdateWeek(week.id, 'installList', [...sourceWeek.installList]);
                if (sourceWeek.newInstallIds) onUpdateWeek(week.id, 'newInstallIds', [...sourceWeek.newInstallIds]);

                // 2. Wristbands
                const newWristbands = sourceWeek.wristbands ? JSON.parse(JSON.stringify(sourceWeek.wristbands)) : JSON.parse(JSON.stringify(defaultWbSettings));
                onUpdateWeek(week.id, 'wristbands', newWristbands);

                // 3. Depth Chart
                const newDepthChart = sourceWeek.depthChart ? JSON.parse(JSON.stringify(sourceWeek.depthChart)) : JSON.parse(JSON.stringify(defaultDepthChart));
                onUpdateWeek(week.id, 'depthChart', newDepthChart);

                // 4. Zone Philosophies
                const newZonePhi = sourceWeek.zonePhilosophies ? JSON.parse(JSON.stringify(sourceWeek.zonePhilosophies)) : JSON.parse(JSON.stringify(defaultZonePhilosophies));
                onUpdateWeek(week.id, 'zonePhilosophies', newZonePhi);

                setShowImportModal(false);
            };

            const handleClearWeek = () => {
                const confirm = window.prompt(`Are you sure you want to CLEAR ALL DATA for this week (Installs, Wristbands, Depth Chart, Zone Phi)? This cannot be undone.\n\nType "delete" to confirm.`);
                if (confirm !== 'delete') return;

                onUpdateWeek(week.id, 'installList', []);
                onUpdateWeek(week.id, 'newInstallIds', []);
                onUpdateWeek(week.id, 'wristbands', JSON.parse(JSON.stringify(defaultWbSettings)));
                onUpdateWeek(week.id, 'depthChart', JSON.parse(JSON.stringify(defaultDepthChart)));
                onUpdateWeek(week.id, 'zonePhilosophies', JSON.parse(JSON.stringify(defaultZonePhilosophies)));
            };

            // Analytics Helpers
            const getGamePlanStatus = (playId) => {
                if (!gamePlan) return false;
                let found = false;

                Object.values(gamePlan).forEach(section => {
                    if (Array.isArray(section)) {
                        if (section.some(p => p.id === playId)) found = true;
                    } else if (typeof section === 'object' && section !== null) {
                        // Check for nested sets/plays if applicable to data structure
                        Object.values(section).forEach(sub => {
                            if (Array.isArray(sub)) {
                                if (sub.some(p => p.id === playId)) found = true;
                            }
                        })
                    }
                });
                return found;
            };

            const getScriptCount = (playId) => {
                let count = 0;
                if (!practicePlans) return 0;

                Object.values(practicePlans).forEach(plan => {
                    if (plan.segments) {
                        plan.segments.forEach(seg => {
                            // Check unassigned cards
                            if (seg.unassignedCards) {
                                count += seg.unassignedCards.filter(c => c.playId === playId).length;
                            }
                            // Check script rows if they exist
                            if (seg.scriptRows) {
                                count += seg.scriptRows.filter(r => r.playId === playId).length;
                            }
                        });
                    }
                });
                return count;
            };



            const handleListChange = (newItems, bucketId, familyName) => {
                // Update the install list order
                const fullListIds = week.installList || [];
                const newIdsSet = new Set(newItems.map(p => p.id));

                // Get all items NOT in the current bucket
                const otherIds = fullListIds.filter(id => !newIdsSet.has(id));

                // Combine: other items + new items from this bucket
                const finalIds = [...otherIds, ...newItems.map(p => p.id)];

                // Update the week's install list
                onUpdateWeek(week.id, 'installList', finalIds);

                // Assign bucketId and conceptFamily to plays that were dragged
                newItems.forEach(p => {
                    const updates = {};
                    if (p.bucketId !== bucketId) updates.bucketId = bucketId;

                    // Only update conceptFamily if familyName is provided (which it is for family-specific columns)
                    // If familyName is 'No Concept', we set it to null or empty string
                    const targetFamily = familyName === 'No Concept' ? '' : familyName;
                    if (familyName !== undefined && p.conceptFamily !== targetFamily) {
                        updates.conceptFamily = targetFamily;
                    }

                    if (Object.keys(updates).length > 0) {
                        onUpdatePlay(p.id, updates);
                    }
                });
            };

            const getWristbandSlot = (playId) => {
                const play = plays.find(p => p.id === playId);
                if (play && play.wristbandSlot) return play.wristbandSlot;
                return null;
            };

            // Calculate Available Wristband Slots
            const availableSlots = React.useMemo(() => {
                if (!wbSettings) return [];
                const slots = [];
                Object.keys(wbSettings).filter(k => k.startsWith('card')).forEach(cardKey => {
                    const card = wbSettings[cardKey];
                    if (card.type === 'wiz') {
                        const series = cardKey.replace('card', '');
                        for (let i = 1; i <= 16; i++) slots.push(`${series}${String(i).padStart(2, '0')}`);
                    } else {
                        const start = (parseInt(cardKey.replace('card', '')) * 100) + 1;
                        for (let i = 0; i < 48; i++) slots.push(String(start + i));
                    }
                });
                const assigned = new Set(plays.filter(p => p.wristbandSlot).map(p => String(p.wristbandSlot)));
                return slots.filter(s => !assigned.has(s)).sort((a, b) => parseInt(a) - parseInt(b));
            }, [wbSettings, plays]);


            // Filtered Master List (Exclude already installed)
            const masterList = plays.filter(p => {
                if (installList.includes(p.id)) return false;
                if (searchTerm && !p.name.toLowerCase().includes(searchTerm.toLowerCase())) return false;
                return true;
            });

            // Removed redundant hydratedInstall declaration (moved to top)

            const handleToggleNewPlay = (playId) => {
                const currentNewIds = week.newInstallIds || [];
                let newIds;
                if (currentNewIds.includes(playId)) {
                    newIds = currentNewIds.filter(id => id !== playId);
                } else {
                    newIds = [...currentNewIds, playId];
                }
                onUpdateWeek(week.id, 'newInstallIds', newIds);
            };


            const handleDuplicatePlay = (playId) => {
                const playToClone = plays.find(p => p.id === playId);
                if (!playToClone) return;

                const newPlay = {
                    ...playToClone,
                    id: Date.now().toString() + Math.random().toString().slice(2, 5),
                    name: `${playToClone.name} (Copy)`,
                    wristbandSlot: null,
                    isWiz: false,
                    isMiniScript: false
                };

                // Add to library
                if (onQuickAddPlay) {
                    onQuickAddPlay(newPlay);

                    // Add to install
                    const currentList = week.installList || [];
                    onUpdateWeek(week.id, 'installList', [...currentList, newPlay.id]);
                }
            };

            return (
                <>
                    <div style={{ height: 'calc(100vh - 100px)', display: 'flex', flexDirection: 'column' }}>
                        <div style={{ padding: '1.5rem', borderBottom: '1px solid var(--border)', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <div>
                                <h1 style={{ margin: 0 }}>Week {week.weekNum} Install/Ready List</h1>
                                <p style={{ margin: '0.5rem 0 0 0', opacity: 0.7 }}>Manage the active plays for Week {week.weekNum}: {week.opponent}</p>
                            </div>

                            <div style={{ display: 'flex', gap: '12px', alignItems: 'center' }}>
                                <button
                                    className="btn"
                                    onClick={handleClearWeek}
                                    title="Clear Week"
                                    style={{
                                        height: '38px',
                                        padding: '0 16px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '8px',
                                        background: 'white',
                                        border: '1px solid #cbd5e1',
                                        color: '#ef4444',
                                        borderRadius: '6px',
                                        fontSize: '0.9rem',
                                        fontWeight: '500'
                                    }}
                                >
                                    <Icon name="Trash" size={16} /> Clear Week
                                </button>
                                <button
                                    className="btn"
                                    onClick={() => setShowImportModal(true)}
                                    style={{
                                        height: '38px',
                                        padding: '0 16px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '8px',
                                        background: 'white',
                                        border: '1px solid #cbd5e1',
                                        color: '#64748b',
                                        borderRadius: '6px',
                                        fontSize: '0.9rem',
                                        fontWeight: '500'
                                    }}
                                >
                                    <Icon name="Download" size={16} /> Import
                                </button>
                                <button
                                    className="btn btn-primary"
                                    onClick={() => setIsQuickAddOpen(true)}
                                    style={{
                                        height: '38px',
                                        padding: '0 16px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        gap: '8px',
                                        borderRadius: '6px',
                                        fontSize: '0.9rem',
                                        fontWeight: '600'
                                    }}
                                >
                                    <Icon name="Plus" size={16} /> Quick Add / Parse Play
                                </button>
                            </div>
                        </div>

                        {showImportModal && (
                            <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 10000 }}>
                                <div className="card" style={{ width: '400px', padding: '1.5rem', background: 'white', color: 'black' }}>
                                    <h3>Import Installs</h3>
                                    <p>Select a week to copy installs from. <strong>This will overwrite current data.</strong></p>
                                    <select
                                        className="form-select"
                                        value={importSourceWeekId}
                                        onChange={e => setImportSourceWeekId(e.target.value)}
                                        style={{ marginBottom: '1rem', width: '100%' }}
                                    >
                                        <option value="">Select Week...</option>
                                        {weeks.filter(w => w.id !== week.id).map(w => (
                                            <option key={w.id} value={w.id}>{w.name}</option>
                                        ))}
                                    </select>
                                    <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '8px' }}>
                                        <button className="btn" onClick={() => setShowImportModal(false)}>Cancel</button>
                                        <button className="btn btn-primary" onClick={handleImportInstalls} disabled={!importSourceWeekId}>Import</button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {isQuickAddOpen && (
                            <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 10000 }}>
                                <div className="card" style={{ width: '90%', maxWidth: '600px', padding: '1.5rem', background: '#f8fafc', border: '1px solid #e2e8f0', boxShadow: '0 10px 25px rgba(0,0,0,0.2)' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                        <h3 style={{ margin: 0 }}>Play Call Parser</h3>
                                        <button onClick={() => setIsQuickAddOpen(false)} style={{ background: 'none', border: 'none', cursor: 'pointer' }}>
                                            <Icon name="X" size={20} />
                                        </button>
                                    </div>

                                    <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '1rem' }}>
                                        <input
                                            className="form-input"
                                            value={rawPlayCall}
                                            onChange={e => setRawPlayCall(e.target.value.toUpperCase())}
                                            placeholder="Type play call here..."
                                            onKeyDown={e => e.key === 'Enter' && handleTokenize()}
                                        />
                                        <button className="btn btn-primary" onClick={handleTokenize}>Parse</button>
                                    </div>

                                    {/* Unassigned Tokens */}
                                    <div
                                        style={{ minHeight: '40px', padding: '0.5rem', background: 'white', border: '1px solid #ddd', borderRadius: '4px', marginBottom: '1rem', display: 'flex', flexWrap: 'wrap', gap: '0.5rem' }}
                                        onDragOver={e => e.preventDefault()}
                                        onDrop={e => handleDropToken(e, 'unassigned')}
                                    >
                                        {tokens.length === 0 && <span style={{ color: '#aaa', fontSize: '0.8rem' }}>Tokens will appear here...</span>}
                                        {tokens.map(t => (
                                            <span
                                                key={t.id}
                                                draggable
                                                onDragStart={e => handleDragStartToken(e, t, 'unassigned')}
                                                style={{ background: '#e2e8f0', color: '#0f172a', padding: '2px 8px', borderRadius: '12px', fontSize: '0.85rem', cursor: 'grab' }}
                                            >
                                                {t.text}
                                            </span>
                                        ))}
                                    </div>

                                    {/* Drop Zones Grid */}
                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '0.5rem' }}>
                                        {playSyntax.length === 0 && (
                                            <div style={{ gridColumn: '1 / -1', padding: '1rem', background: '#fef3c7', color: '#b45309', borderRadius: '4px', textAlign: 'center' }}>
                                                No Play Syntax defined. Go to Offense Setup to configure your play structure.
                                            </div>
                                        )}
                                        {playSyntax.map(field => (
                                            <div
                                                key={field.id}
                                                style={{ background: 'white', border: '1px solid #ddd', borderRadius: '4px', padding: '0.5rem', minHeight: '60px' }}
                                                onDragOver={e => e.preventDefault()}
                                                onDrop={e => handleDropToken(e, field.id)}
                                            >
                                                <div style={{ fontSize: '0.7rem', textTransform: 'uppercase', color: '#888', marginBottom: '0.25rem' }}>{field.label}</div>
                                                <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.25rem' }}>
                                                    {parsedFields[field.id] && parsedFields[field.id].map(t => (
                                                        <span
                                                            key={t.id}
                                                            draggable
                                                            onDragStart={e => handleDragStartToken(e, t, field.id)}
                                                            style={{ background: '#dbeafe', color: '#1e3a8a', padding: '2px 6px', borderRadius: '4px', fontSize: '0.8rem', cursor: 'grab' }}
                                                        >
                                                            {t.text}
                                                        </span>
                                                    ))}
                                                </div>
                                            </div>
                                        ))}
                                    </div>

                                    <div style={{ marginTop: '1rem', display: 'flex', justifyContent: 'flex-end', gap: '0.5rem' }}>
                                        <button className="btn" onClick={() => setIsQuickAddOpen(false)}>Cancel</button>
                                        <button className="btn btn-primary" onClick={handleQuickAddSubmit}>Create & Add</button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* FLEX LAYOUT: Sidebar + Main Content */}
                        <div style={{ flex: 1, display: 'flex', overflow: 'hidden', minHeight: 0 }}>

                            {/* LEFT COLUMN: MASTER PLAYBOOK SEARCH + INSTALL LIST */}
                            <div style={{ width: '300px', flexShrink: 0, display: 'flex', flexDirection: 'column', borderRight: '1px solid var(--border)', background: 'white', minHeight: 0 }}>
                                {/* Master Playbook Search Section */}
                                <div style={{ borderBottom: '1px solid var(--border)', background: '#f8fafc' }}>
                                    <div style={{ padding: '0.75rem', background: '#f1f5f9', borderBottom: '1px solid var(--border)' }}>
                                        <h4 style={{ margin: 0, fontSize: '0.9rem', fontWeight: 'bold', color: 'var(--text-secondary)' }}>Master Playbook</h4>
                                    </div>
                                    <div style={{ padding: '0.75rem' }}>
                                        <input
                                            type="text"
                                            className="form-input"
                                            placeholder="Search plays..."
                                            value={searchTerm}
                                            onChange={e => setSearchTerm(e.target.value)}
                                            style={{ fontSize: '0.85rem' }}
                                        />
                                    </div>
                                    <div style={{ maxHeight: '200px', overflowY: 'auto', padding: '0 0.75rem 0.75rem 0.75rem' }}>
                                        {masterList.slice(0, 20).map(play => (
                                            <div
                                                key={play.id}
                                                className="card"
                                                onClick={() => handleAddToInstall(play.id)}
                                                style={{
                                                    padding: '0.5rem 0.6rem',
                                                    marginBottom: '0.25rem',
                                                    display: 'flex',
                                                    justifyContent: 'space-between',
                                                    alignItems: 'center',
                                                    cursor: 'pointer',
                                                    transition: 'all 0.2s',
                                                    border: '1px solid #e2e8f0'
                                                }}
                                                onMouseEnter={(e) => {
                                                    e.currentTarget.style.background = '#f0f9ff';
                                                    e.currentTarget.style.borderColor = '#3b82f6';
                                                }}
                                                onMouseLeave={(e) => {
                                                    e.currentTarget.style.background = 'white';
                                                    e.currentTarget.style.borderColor = '#e2e8f0';
                                                }}
                                                title="Click to add to install list"
                                            >
                                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', flex: 1, overflow: 'hidden' }}>
                                                    {/* Plus Icon */}
                                                    <div style={{
                                                        background: '#3b82f6',
                                                        color: 'white',
                                                        borderRadius: '50%',
                                                        width: '20px',
                                                        height: '20px',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        flexShrink: 0
                                                    }}>
                                                        <Icon name="Plus" size={14} />
                                                    </div>

                                                    {/* Play Info */}
                                                    <div style={{ flex: 1, overflow: 'hidden' }}>
                                                        <div style={{ fontWeight: 'bold', fontSize: '0.8rem', color: '#1e293b', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                            {getPlayDisplayName(play)}
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        ))}
                                        {masterList.length === 0 && searchTerm && (
                                            <div style={{ padding: '0.75rem' }}>
                                                <div style={{ textAlign: 'center', padding: '0.5rem 0', color: 'var(--text-secondary)', fontSize: '0.8rem', marginBottom: '0.5rem' }}>
                                                    No plays found matching "{searchTerm}"
                                                </div>
                                                <button
                                                    className="btn btn-primary"
                                                    onClick={() => {
                                                        // Create a new play with the search term as the name
                                                        const newPlay = onQuickAddPlay(searchTerm.trim());
                                                        if (newPlay && newPlay.id) {
                                                            handleAddToInstall(newPlay.id);
                                                        }
                                                        setSearchTerm(''); // Clear search after creating
                                                    }}
                                                    style={{ width: '100%', fontSize: '0.85rem', padding: '0.6rem' }}
                                                >
                                                    <Icon name="Plus" size={14} /> Create "{searchTerm}"
                                                </button>
                                            </div>
                                        )}
                                        {masterList.length === 0 && !searchTerm && (
                                            <div style={{ textAlign: 'center', padding: '1rem', color: 'var(--text-secondary)', fontSize: '0.8rem' }}>
                                                No plays found to add.
                                            </div>
                                        )}
                                        {masterList.length > 20 && (
                                            <div style={{ textAlign: 'center', padding: '0.5rem', color: 'var(--text-secondary)', fontSize: '0.75rem', fontStyle: 'italic' }}>
                                                Showing first 20 results. Refine search to see more.
                                            </div>
                                        )}
                                    </div>
                                </div>

                                {/* Uncategorized Plays - Prompt to tag them */}
                                <div style={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden', minHeight: 0 }}>
                                    <div style={{ padding: '0.75rem', background: '#fef2f2', borderBottom: '1px solid var(--border)' }}>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                            <h4 style={{ margin: 0, fontSize: '0.9rem', fontWeight: 'bold', color: '#991b1b' }}>Uncategorized Plays</h4>
                                            <span style={{ fontSize: '0.7rem', padding: '2px 8px', background: '#fee2e2', color: '#991b1b', borderRadius: '12px', fontWeight: 'bold' }}>
                                                {hydratedInstall.filter(p =>
                                                    (p.bucketId && !effectiveBuckets.some(b => b.id === p.bucketId)) ||
                                                    (!p.bucketId && (!p.type || !effectiveBuckets.some(b => b.id === p.type)))
                                                ).length}
                                            </span>
                                        </div>
                                        <p style={{ margin: '0.25rem 0 0 0', fontSize: '0.7rem', color: '#b91c1c' }}>
                                            Tag these to move to Run/Pass/Screen columns.
                                        </p>
                                    </div>
                                    <div style={{ flex: 1, overflowY: 'auto', padding: '0.75rem', display: 'flex', flexDirection: 'column' }}>
                                        {(() => {
                                            const uncategorized = hydratedInstall.filter(p => (p.bucketId && !effectiveBuckets.some(b => b.id === p.bucketId)) || (!p.bucketId && (!p.type || !effectiveBuckets.some(b => b.id === p.type))));

                                            if (uncategorized.length === 0) {
                                                return (
                                                    <ReactSortable
                                                        list={[]}
                                                        setList={() => { }}
                                                        group="installColumns"
                                                        style={{
                                                            minHeight: '100px', display: 'flex', alignItems: 'center', justifyContent: 'center'
                                                        }}
                                                    >
                                                        <div style={{ textAlign: 'center', padding: '2rem', color: 'var(--text-secondary)', fontSize: '0.8rem', width: '100%' }}>
                                                            No unassigned                                                                  <br />Drag plays here to unassign.
                                                        </div>
                                                    </ReactSortable>
                                                );
                                            }

                                            return (
                                                <ReactSortable
                                                    list={uncategorized}
                                                    setList={(items) => handleListChange(items, null)}
                                                    group="installColumns"
                                                    animation={150}
                                                    style={{ minHeight: '50px' }}
                                                >
                                                    {uncategorized.map(play => (
                                                        <div
                                                            key={play.id}
                                                            data-id={play.id}
                                                            className="card"
                                                            style={{
                                                                padding: '0.5rem 0.6rem',
                                                                marginBottom: '0.25rem',
                                                                display: 'flex',
                                                                justifyContent: 'space-between',
                                                                alignItems: 'center',
                                                                borderLeft: '3px solid #64748b', // Grey for unassigned
                                                                cursor: 'grab',
                                                                background: 'white'
                                                            }}
                                                            onClick={(e) => setAssignmentModalState({ playId: play.id, x: e.clientX, y: e.clientY })}
                                                        >
                                                            <div style={{ flex: 1, overflow: 'hidden' }}>
                                                                <div style={{ fontWeight: 'bold', color: '#1e293b', fontSize: '0.8rem' }}>{getPlayDisplayName(play)}</div>
                                                            </div>
                                                            <div style={{ color: '#64748b' }}>
                                                                <Icon name="Tag" size={14} />
                                                            </div>
                                                        </div>
                                                    ))}
                                                </ReactSortable>
                                            );
                                        })()}
                                    </div>
                                </div>
                            </div>


                            {/* BUCKET GRID: Dynamic columns based on playBuckets from Offense Setup */}
                            {/* Bucket Grid - Full Width with Nested Concept Families */}

                            {/* NEW LAYOUT: Grid + Inbox */}
                            <div style={{ flex: 1, display: 'flex', height: 'calc(100vh - 250px)', overflow: 'hidden', gap: '1rem', padding: '1rem' }}>
                                <div style={{
                                    flex: 3,
                                    display: 'grid',
                                    gridTemplateColumns: 'repeat(auto-fill, minmax(280px, 1fr))',
                                    gridAutoRows: 'min-content',
                                    gap: '1rem',
                                    overflowY: 'auto',
                                    overflowX: 'hidden', // Prevent horizontal bleed
                                    paddingRight: '0.5rem',
                                    minWidth: 0 // Allow flex item to shrink
                                }}>
                                    {effectiveBuckets.filter(b => !b.categoryId).map(bucket => {
                                        const bucketPlays = hydratedInstall.filter(p => p.bucketId === bucket.id);

                                        // Group plays by concept family
                                        const playsByFamily = bucketPlays.reduce((acc, play) => {
                                            const family = play.conceptFamily || 'No Concept';
                                            if (!acc[family]) acc[family] = [];
                                            acc[family].push(play);
                                            return acc;
                                        }, {});

                                        const families = Object.keys(playsByFamily).sort();

                                        return (
                                            <div key={bucket.id} className="card" style={{
                                                display: 'flex',
                                                flexDirection: 'column',
                                                background: 'var(--bg-panel)',
                                                border: '1px solid var(--border)',
                                                height: 'fit-content'
                                            }}>
                                                {/* Bucket Header */}
                                                <div style={{
                                                    padding: '0.75rem 1rem',
                                                    borderBottom: `3px solid ${bucket.color || 'var(--accent)'}`,
                                                    background: 'var(--bg-main)',
                                                    fontWeight: 'bold',
                                                    display: 'flex',
                                                    justifyContent: 'space-between',
                                                    alignItems: 'center',
                                                    fontSize: '1rem',
                                                    color: 'var(--text-main)'
                                                }}>
                                                    <span style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                        <div style={{ width: '10px', height: '10px', borderRadius: '50%', background: bucket.color || 'var(--accent)' }}></div>
                                                        {bucket.label || bucket.id}
                                                    </span>
                                                    <span style={{
                                                        fontSize: '0.75rem',
                                                        padding: '2px 8px',
                                                        background: 'var(--bg-panel)',
                                                        border: '1px solid var(--border)',
                                                        borderRadius: '12px',
                                                        fontWeight: 'bold',
                                                        color: 'var(--text-secondary)'
                                                    }}>
                                                        {bucketPlays.length}
                                                    </span>
                                                </div>

                                                {/* Content */}
                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem', padding: '0.5rem' }}>
                                                    {families.length === 0 ? (
                                                        <div style={{ padding: '1.5rem', textAlign: 'center', color: 'var(--text-secondary)', fontSize: '0.8rem', fontStyle: 'italic', opacity: 0.7 }}>
                                                            No plays assigned
                                                        </div>
                                                    ) : (
                                                        families.map(family => (
                                                            <div key={family} style={{
                                                                border: '1px solid var(--border)',
                                                                borderRadius: '6px',
                                                                overflow: 'hidden'
                                                            }}>
                                                                {family !== 'No Concept' && (
                                                                    <div style={{
                                                                        padding: '0.25rem 0.5rem',
                                                                        background: 'var(--bg-item)',
                                                                        borderBottom: '1px solid var(--border)',
                                                                        fontSize: '0.75rem',
                                                                        fontWeight: 'bold',
                                                                        color: 'var(--text-secondary)',
                                                                        display: 'flex', justifyContent: 'space-between'
                                                                    }}>
                                                                        <span>{family}</span>
                                                                        <span>{playsByFamily[family].length}</span>
                                                                    </div>
                                                                )}
                                                                <div style={{ padding: '0.25rem' }}>
                                                                    <InstallSortableColumn
                                                                        items={playsByFamily[family]}
                                                                        type={`${bucket.label}-${family}`}
                                                                        onListChange={(newItems) => {
                                                                            handleListChange(newItems, bucket.id, family);
                                                                        }}
                                                                        onUpdatePlay={onUpdatePlay}
                                                                        handleRemoveFromInstall={handleRemoveFromInstall}
                                                                        handleTogglePriority={handleTogglePriority}
                                                                        getGamePlanStatus={getGamePlanStatus}
                                                                        getScriptCount={getScriptCount}
                                                                        handleToggleNewPlay={handleToggleNewPlay}
                                                                        newInstallIds={week.newInstallIds || []}
                                                                        onOpenAssignmentModal={(id, x, y) => setAssignmentModalState({ playId: id, x, y })}
                                                                        onDuplicatePlay={handleDuplicatePlay}
                                                                        playBuckets={effectiveBuckets}
                                                                    />
                                                                </div>
                                                            </div>
                                                        ))
                                                    )}
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>

                            </div>
                        </div>




                    </div >
                    {assignmentModalState && (() => {
                        const { playId, x, y } = assignmentModalState;
                        const play = plays.find(p => p.id === playId);
                        if (!play) return null;

                        const assignedSits = getPlaySituations(playId);
                        const assignedIds = new Set(assignedSits.map(s => s.id));

                        return (
                            <PlayDetailsModal
                                playId={playId}
                                plays={plays}
                                weekDate={week.id}
                                newInstallIds={week.newInstallIds || []}
                                gamePlanLayouts={gamePlanLayouts}
                                assignedIds={assignedIds}
                                onClose={() => setAssignmentModalState(null)}
                                onUpdateWeek={onUpdateWeek}
                                onUpdatePlay={onUpdatePlay}
                                onAssignSituation={handleAssignSituation}
                                position={{ x, y }}
                                playBuckets={playBuckets}
                                playCategories={playCategories}
                                currentWeek={week}
                            />
                        );
                    })()}
                </>
            );
        };

        const PrintHubView = ({ roster, staff, gamePlans, depthChart, practicePlans, attendance, wbSettings, setWbSettings, plays, personnelGroupings = {} }) => {
            const [selectedCategory, setSelectedCategory] = useState('practice');
            const [selectedOption, setSelectedOption] = useState(null); // 'daily_plan', 'weekly_plan', 'wristbands', etc.
            const [selectedDay, setSelectedDay] = useState(null); // For daily plan selection
            const [selectedCardForPrint, setSelectedCardForPrint] = useState(null); // For wristband card selection
            const [scheduledEvents] = useLocalStorage('oc-dashboard-scheduled-events', []);

            const printLinks = [
                { id: 'daily_plan', label: 'Practice Print Batcher', desc: 'Daily plans, scripts, and scout cards', icon: 'Calendar' },
                { id: 'wristbands', label: 'Wristband Builder', desc: '3x5" Wristband Inserts', icon: 'Columns' },
                { id: 'depth_chart', label: 'Depth Chart', desc: 'Offense, Defense, and Special Teams', icon: 'Layers' },
            ];

            const handlePrint = (optionId) => {
                if (optionId === 'daily_plan') {
                    setSelectedOption('daily_plan');
                    setSelectedDay(null);
                } else if (optionId === 'wristbands') {
                    setSelectedOption('wristbands');
                    setSelectedCardForPrint(null);
                } else if (optionId === 'depth_chart') {
                    setSelectedOption('depth_chart');
                }
            };

            // Batch State
            const [batchSelection, setBatchSelection] = useState({
                Monday: { plan: false, script: false, cards: false },
                Tuesday: { plan: false, script: false, cards: false },
                Wednesday: { plan: false, script: false, cards: false },
                Thursday: { plan: false, script: false, cards: false },
                Friday: { plan: false, script: false, cards: false },
            });
            const [selectedPrintCoach, setSelectedPrintCoach] = useState('ALL');
            const [batchComponents, setBatchComponents] = useState(null);

            const handleToggleBatch = (day, type) => {
                setBatchSelection(prev => ({
                    ...prev,
                    [day]: { ...prev[day], [type]: !prev[day][type] }
                }));
            };

            const handleGenerateBatch = () => {
                const components = [];
                const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];

                days.forEach(day => {
                    const sel = batchSelection[day];
                    const plan = practicePlans[day];

                    // Order: Plan -> Script -> Cards (Ideal for Plan Front / Script Back if duplexing)
                    if (sel.plan) components.push(<PracticePlanPrintView key={`${day} -plan`} plan={plan} isBatchMode={true} coachFilter={selectedPrintCoach} roster={roster} staff={staff} />);
                    if (sel.script) components.push(<ScriptPrintView key={`${day} -script`} plan={plan} isBatchMode={true} />);
                    if (sel.cards) components.push(<ScoutCardPrintView key={`${day} -cards`} plan={plan} isBatchMode={true} />);
                });

                if (components.length === 0) {
                    alert('Please select at least one item to print.');
                    return;
                }
                setBatchComponents(components);
            };

            const handleBack = () => {
                setBatchComponents(null);
                setSelectedOption(null);
                setSelectedDay(null);
            };

            // Render Sub-Views
            if (batchComponents) {
                return <BatchPrintContainer components={batchComponents} onBack={() => setBatchComponents(null)} />;
            }

            if (selectedOption === 'daily_plan') {
                // Modified to show the Batch Matrix instead of just Day Buttons
                return (
                    <div style={{ padding: '2rem', maxWidth: '1000px', margin: '0 auto' }}>
                        <button onClick={handleBack} className="btn btn-secondary" style={{ marginBottom: '1rem' }}>
                            <Icon name="ArrowLeft" size={16} /> Back
                        </button>

                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                            <h2>Practice Print Batcher</h2>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                <label style={{ fontWeight: 'bold' }}>Filter by Coach:</label>
                                <select
                                    className="form-select"
                                    value={selectedPrintCoach}
                                    onChange={(e) => setSelectedPrintCoach(e.target.value)}
                                    style={{ width: '200px' }}
                                >
                                    <option value="ALL">All Coaches</option>
                                    {staff && staff.map(c => (
                                        <option key={c.id} value={c.id}>{c.name}</option>
                                    ))}
                                </select>
                            </div>
                        </div>

                        <div className="card" style={{ padding: '0', overflow: 'hidden' }}>
                            <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                                <thead style={{ background: 'var(--surface)' }}>
                                    <tr>
                                        <th style={{ padding: '1rem', textAlign: 'left' }}>Day</th>
                                        <th style={{ padding: '1rem', textAlign: 'center' }}>Daily Plan</th>
                                        <th style={{ padding: '1rem', textAlign: 'center' }}>Practice Script</th>
                                        <th style={{ padding: '1rem', textAlign: 'center' }}>Scout Cards</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {Object.keys(batchSelection).map(day => (
                                        <tr key={day} style={{ borderBottom: '1px solid var(--border)' }}>
                                            <td style={{ padding: '1rem', fontWeight: 'bold' }}>{day}</td>
                                            <td style={{ padding: '1rem', textAlign: 'center' }}>
                                                <input
                                                    type="checkbox"
                                                    checked={batchSelection[day].plan}
                                                    onChange={() => handleToggleBatch(day, 'plan')}
                                                    style={{ width: '20px', height: '20px', cursor: 'pointer' }}
                                                />
                                            </td>
                                            <td style={{ padding: '1rem', textAlign: 'center' }}>
                                                <input
                                                    type="checkbox"
                                                    checked={batchSelection[day].script}
                                                    onChange={() => handleToggleBatch(day, 'script')}
                                                    style={{ width: '20px', height: '20px', cursor: 'pointer' }}
                                                />
                                            </td>
                                            <td style={{ padding: '1rem', textAlign: 'center' }}>
                                                <input
                                                    type="checkbox"
                                                    checked={batchSelection[day].cards}
                                                    onChange={() => handleToggleBatch(day, 'cards')}
                                                    style={{ width: '20px', height: '20px', cursor: 'pointer' }}
                                                />
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                            <div style={{ padding: '1.5rem', background: 'var(--surface)', display: 'flex', justifyContent: 'flex-end', gap: '1rem' }}>
                                <button className="btn btn-secondary" onClick={() => setBatchSelection({
                                    Monday: { plan: false, script: false, cards: false },
                                    Tuesday: { plan: false, script: false, cards: false },
                                    Wednesday: { plan: false, script: false, cards: false },
                                    Thursday: { plan: false, script: false, cards: false },
                                    Friday: { plan: false, script: false, cards: false },
                                })}>Clear All</button>
                                <button className="btn btn-primary" onClick={handleGenerateBatch} style={{ padding: '0.75rem 2rem' }}>
                                    <Icon name="Printer" size={18} style={{ marginRight: '8px' }} />
                                    Generate Print Packet
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }
            // Wristband Print Preview
            if (selectedOption === 'wristbands') {
                if (!selectedCardForPrint) {
                    // Card Selector View - simple list of all configured cards
                    const allCards = wbSettings ? Object.keys(wbSettings).filter(key => key.startsWith('card')).sort() : [];

                    const getCardLabel = (cardId, card) => {
                        if (card?.type === 'wiz') return 'Staples';
                        const num = parseInt(cardId.replace('card', ''));
                        return `${num}00s`;
                    };

                    return (
                        <div style={{ padding: '2rem', maxWidth: '600px', margin: '0 auto' }}>
                            <button onClick={handleBack} className="btn btn-secondary" style={{ marginBottom: '1rem' }}>
                                <Icon name="ArrowLeft" size={16} /> Back to Print Center
                            </button>

                            <div style={{ marginBottom: '1.5rem' }}>
                                <h2 style={{ fontSize: '1.5rem', marginBottom: '0.25rem' }}>Wristband Cards</h2>
                                <p style={{ color: 'var(--text-secondary)', fontSize: '0.9rem' }}>4 copies per page (landscape)</p>
                            </div>

                            <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                {allCards.map(cardId => {
                                    const card = wbSettings[cardId];
                                    if (!card) return null;
                                    const label = getCardLabel(cardId, card);
                                    const opponent = card.opp || card.opponent || '';

                                    return (
                                        <div
                                            key={cardId}
                                            className="card"
                                            style={{
                                                padding: '1rem 1.25rem',
                                                display: 'flex',
                                                alignItems: 'center',
                                                gap: '1rem',
                                                cursor: 'pointer',
                                                transition: 'background 0.15s'
                                            }}
                                            onClick={() => setSelectedCardForPrint(cardId)}
                                            onMouseEnter={e => e.currentTarget.style.background = 'var(--bg-hover)'}
                                            onMouseLeave={e => e.currentTarget.style.background = ''}
                                        >
                                            <div style={{ flex: 1 }}>
                                                <div style={{ fontWeight: '600' }}>{label}</div>
                                                {opponent && <div style={{ color: 'var(--text-secondary)', fontSize: '0.85rem' }}>vs. {opponent}</div>}
                                            </div>
                                            <Icon name="ChevronRight" size={18} style={{ color: 'var(--text-secondary)' }} />
                                        </div>
                                    );
                                })}
                            </div>

                            {allCards.length === 0 && (
                                <div className="card" style={{ padding: '2rem', textAlign: 'center' }}>
                                    <p style={{ color: 'var(--text-secondary)' }}>
                                        No wristband cards available. Create cards in the Wristband Builder first.
                                    </p>
                                </div>
                            )}
                        </div>
                    );
                } else {
                    // Print Layout View - 4 copies in 2x2 grid
                    const card = wbSettings[selectedCardForPrint];
                    const cardNumber = selectedCardForPrint.replace('card', '');

                    // Get slots for this card
                    const getSlotsForCard = (cardId) => {
                        const cardData = wbSettings[cardId];
                        if (cardData.type === 'wiz') {
                            const series = cardId === 'card1' ? 1 : (cardId === 'card2' ? 2 : (cardId === 'card3' ? 3 : (cardId === 'card4' ? 4 : (cardId === 'card5' ? 5 : 6))));
                            const slots = [];
                            for (let i = 1; i <= 16; i++) {
                                slots.push(`${series}${String(i).padStart(2, '0')}`);
                            }
                            return slots;
                        }
                        const start = cardId === 'card1' ? 101 : (cardId === 'card2' ? 201 : (cardId === 'card3' ? 301 : (cardId === 'card4' ? 401 : (cardId === 'card5' ? 501 : 601))));
                        const slots = [];
                        for (let i = start; i <= start + 47; i++) slots.push(i);
                        return slots;
                    };

                    // Build slot map from plays
                    const slotMap = {};
                    if (plays) {
                        plays.forEach(play => {
                            if (play.wristbandSlot) slotMap[play.wristbandSlot] = play;
                        });
                    }

                    const slots = getSlotsForCard(selectedCardForPrint);
                    const opponent = card.opp || card.opponent || '';

                    // Helper: Render Play Thumbnail for Print (WIZ Grid style)
                    const renderPlayThumbnail = (play, type = 'standard') => {
                        if (!play) return null;

                        let data = null;
                        if (type === 'skill' && (play.wizSkillData || play.rooskiSkillData)) {
                            data = { elements: play.wizSkillData || play.rooskiSkillData };
                        } else if (type === 'oline' && (play.wizOlineData || play.rooskiOlineData)) {
                            data = { elements: play.wizOlineData || play.rooskiOlineData };
                        } else if (play.diagramData) {
                            data = play.diagramData;
                        }

                        if (!data || !data.elements || data.elements.length === 0) return null;

                        // Fixed viewBox matching WIZ grid cell proportions
                        const fieldWidth = 800;
                        const fieldHeight = 460;
                        const viewBoxX = 0;
                        const viewBoxY = 60;

                        const routeColors = ['#ef4444', '#3b82f6', '#22c55e', '#eab308', '#a855f7', '#f97316', '#06b6d4', '#ec4899'];

                        return (
                            <svg viewBox={`${viewBoxX} ${viewBoxY} ${fieldWidth} ${fieldHeight}`} width="100%" height="100%" style={{ display: 'block', background: 'white', flex: 1 }} preserveAspectRatio="xMidYMid meet">
                                {/* Arrow markers */}
                                <defs>
                                    {routeColors.map(color => (
                                        <marker key={color} id={`print-arrow-${color.replace('#', '')}`} markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                                            <path d="M0,0 L0,6 L9,3 z" fill={color} />
                                        </marker>
                                    ))}
                                    <marker id="print-arrow-000000" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                                        <path d="M0,0 L0,6 L9,3 z" fill="#000000" />
                                    </marker>
                                </defs>

                                {/* Field background */}
                                <rect x={viewBoxX} y={viewBoxY} width={fieldWidth} height={fieldHeight} fill="white" />

                                {/* Yard lines - LEFT side, 5/10/15 going UP from bottom */}
                                <g stroke="#c4a052" strokeWidth="2">
                                    <line x1="250" y1="40" x2="250" y2="65" />
                                    <line x1="550" y1="40" x2="550" y2="65" />
                                </g>
                                <g fill="#888" fontSize="12" fontWeight="bold">
                                    <text x="12" y="365">5</text>
                                    <text x="8" y="265">10</text>
                                    <text x="8" y="165">15</text>
                                </g>
                                <g stroke="#ddd" strokeWidth="1">
                                    <line x1="30" y1="350" x2={fieldWidth - 15} y2="350" />
                                    <line x1="30" y1="250" x2={fieldWidth - 15} y2="250" />
                                    <line x1="30" y1="150" x2={fieldWidth - 15} y2="150" />
                                </g>

                                {data.elements.map(el => {
                                    if (el.type === 'player') {
                                        const { x, y } = el.points[0];
                                        const size = el.shape === 'text-only' ? 0 : 28;
                                        const isRect = el.shape === 'square';
                                        const isTextOnly = el.shape === 'text-only';
                                        const fontSize = isTextOnly ? (el.fontSize ? Math.min(el.fontSize * 0.25, 40) : 24) : 14;

                                        return (
                                            <g key={el.id}>
                                                {!isTextOnly && (isRect ? (
                                                    <rect x={x - size / 2} y={y - size / 2} width={size} height={size} fill="white" stroke={el.color} strokeWidth="3" />
                                                ) : (
                                                    <circle cx={x} cy={y} r={size / 2} fill="white" stroke={el.color} strokeWidth="3" />
                                                ))}
                                                <text x={x} y={y} dy="0.35em" textAnchor="middle" fontSize={fontSize} fontWeight="bold" fill={el.color}>{el.label}</text>
                                            </g>
                                        );
                                    }

                                    let d = '';
                                    if (el.style === 'zigzag') {
                                        d = getZigZagPath(el.points);
                                    } else if (el.type === 'free' || el.points.length > 1) {
                                        d = `M ${el.points.map(p => `${p.x},${p.y}`).join(' L ')}`;
                                    }

                                    let markerEnd = undefined;
                                    let tBlock = null;
                                    const colorHex = (el.color || '#000000').replace('#', '');

                                    if (el.endType === 'arrow' || (!el.endType && el.type !== 'free')) {
                                        markerEnd = `url(#print-arrow-${colorHex})`;
                                    } else if (el.endType === 't') {
                                        const end = el.points[el.points.length - 1];
                                        const prev = el.points[el.points.length - 2] || el.points[0];
                                        const dx = end.x - prev.x;
                                        const dy = end.y - prev.y;
                                        const len = Math.hypot(dx, dy) || 1;
                                        const perpX = (-dy / len) * 12;
                                        const perpY = (dx / len) * 12;
                                        tBlock = <line x1={end.x - perpX} y1={end.y - perpY} x2={end.x + perpX} y2={end.y + perpY} stroke={el.color} strokeWidth="5" />;
                                    } else if (el.endType === 'dot') {
                                        const end = el.points[el.points.length - 1];
                                        tBlock = <circle cx={end.x} cy={end.y} r="5" fill={el.color} />;
                                    } else if (el.type === 'arrow') {
                                        markerEnd = `url(#print-arrow-${colorHex})`;
                                    }

                                    return (
                                        <g key={el.id}>
                                            <path d={d} stroke={el.color} strokeWidth="5" fill="none" strokeDasharray={el.style === 'dashed' ? "8,4" : "none"} markerEnd={markerEnd} />
                                            {tBlock}
                                        </g>
                                    );
                                })}
                            </svg>
                        );
                    };

                    // Render the appropriate card type
                    let cardContent = null;
                    if (card.type === 'wiz') {
                        // Wiz Rendering Logic adapted for Print
                        // 4x4 Grid for 3x5 card
                        const rows = [];
                        for (let i = 0; i < slots.length; i += 4) {
                            rows.push(slots.slice(i, i + 4));
                        }
                        const viewType = card.viewType || 'standard';

                        cardContent = (
                            <div className="wiz-grid-container" style={{ width: '5in', height: '3in', display: 'flex', flexDirection: 'column', border: '2px solid black', background: 'white' }}>
                                {/* Header */}
                                <div style={{
                                    background: 'black',
                                    color: 'white',
                                    fontWeight: 'bold',
                                    fontSize: '10pt',
                                    padding: '2px 4px',
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center'
                                }}>
                                    <span style={{ textTransform: 'uppercase' }}>{card.customHeader || 'WIZ'}</span>
                                    <span>{opponent}</span>
                                </div>
                                {/* Grid */}
                                <div style={{ flex: 1, display: 'flex', flexDirection: 'column' }}>
                                    {rows.map((rowSlots, rIndex) => (
                                        <div key={rIndex} style={{ flex: 1, display: 'flex', borderBottom: rIndex < rows.length - 1 ? '1px solid black' : 'none' }}>
                                            {rowSlots.map((slot, cIndex) => {
                                                const play = slotMap[slot];

                                                // Filter plays based on view type logic
                                                let shouldShowPlay = false;
                                                if (play) {
                                                    if (viewType === 'skill') {
                                                        // Relaxed filtering to allow Standard plays
                                                        shouldShowPlay = !play.isOlineOnly;
                                                    } else if (viewType === 'oline') {
                                                        // Relaxed filtering for oline view
                                                        shouldShowPlay = true;
                                                    } else {
                                                        shouldShowPlay = true; // standard/diagram view
                                                    }
                                                }

                                                const displayPlay = shouldShowPlay ? play : null;

                                                return (
                                                    <div key={slot} style={{
                                                        width: '25%', // Fixed width for print
                                                        flexShrink: 0,
                                                        borderRight: cIndex < 3 ? '1px solid black' : 'none',
                                                        display: 'flex',
                                                        flexDirection: 'column',
                                                        overflow: 'hidden'
                                                    }}>
                                                        {/* Diagram Area - fill the cell */}
                                                        <div style={{ flex: 1, display: 'flex', alignItems: 'stretch', justifyContent: 'stretch', overflow: 'hidden', background: 'white' }}>
                                                            {displayPlay && renderPlayThumbnail(displayPlay, viewType)}
                                                        </div>
                                                        {/* Info Row - compact like the reference */}
                                                        <div style={{ display: 'flex', borderTop: '1px solid black', height: '12px', minHeight: '12px', maxHeight: '12px', fontSize: '7px', background: 'white' }}>
                                                            <div style={{ width: '22px', display: 'flex', alignItems: 'center', justifyContent: 'center', borderRight: '1px solid black', fontWeight: 'bold', color: '#000' }}>{slot}</div>
                                                            <div style={{ flex: 1, minWidth: 0, display: 'flex', alignItems: 'center', paddingLeft: '2px', overflow: 'hidden', whiteSpace: 'nowrap', fontWeight: 'bold', color: '#000' }}>
                                                                {displayPlay ? (displayPlay.wizName || displayPlay.name) : ''}
                                                            </div>
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        );
                    } else {
                        // Traditional and script cards - proper rendering matching WristbandBuilder
                        const isMiniScripts = card.type === 'mini-scripts';
                        const cardType = isMiniScripts ? 'SCRIPT' : 'TRADITIONAL';
                        const rowHeight = 11;
                        const fontSize = 0.55; // rem

                        // Prepare Data Rows
                        let displayRows = [];
                        if (isMiniScripts) {
                            displayRows = (card.rows || []).map((row, idx) => {
                                const slotNum = slots[0] + idx; // Calculate slot based on start
                                if (row.type === 'play') {
                                    const play = plays.find(p => p.id === row.playId);
                                    const playName = row.playName || play?.name || 'Unknown';
                                    const wsSlot = play?.wristbandSlot || '';
                                    const displayText = wsSlot ? `[${wsSlot}] ${playName}` : playName;
                                    return { slot: slotNum, text: displayText, type: row.type, color: row.color };
                                } else {
                                    return { slot: slotNum, text: row.label, type: row.type, color: row.color };
                                }
                            });
                        } else if (card.type === 'modular') {
                            const colorBase = card.color || 'white';
                            const colorMap = {
                                'green-light': '#d1fae5', 'green-medium': '#a7f3d0',
                                'orange-light': '#fed7aa', 'orange-medium': '#fdba74',
                                'red-light': '#fecaca', 'red-medium': '#fca5a5',
                                'blue-light': '#bfdbfe', 'blue-medium': '#93c5fd',
                                'yellow-light': '#fef08a', 'yellow-medium': '#fde047',
                                'purple-light': '#e9d5ff', 'purple-medium': '#d8b4fe',
                                'teal-light': '#99f6e4', 'teal-medium': '#5eead4',
                                'pink-light': '#fbcfe8', 'pink-medium': '#f9a8d4'
                            };

                            const startSlot = slots[0];
                            let logicalSlot = startSlot;
                            let displaySlotCounter = startSlot;

                            displayRows = [];
                            (card.rows || []).forEach((row, idx) => {
                                const isHeader = row.type === 'header' || row.type === 'tempo';

                                if (isHeader && logicalSlot % 2 === 0) {
                                    displayRows.push({
                                        slot: logicalSlot,
                                        type: 'spacer',
                                        text: ''
                                    });
                                    logicalSlot++;
                                }

                                const currentLogical = logicalSlot;

                                let rowColor = 'transparent';
                                if (colorBase && colorBase !== 'white' && colorBase !== 'gray') {
                                    const shade = Math.floor(idx / 2) % 2 === 0 ? 'light' : 'medium';
                                    rowColor = colorMap[`${colorBase}-${shade}`] || 'transparent';
                                }

                                if (isHeader) {
                                    let text = (row.type === 'header') ? (row.label || 'SECTION') : (row.label || row.tempoType || 'TEMPO');
                                    displayRows.push({
                                        slot: currentLogical,
                                        displaySlot: '',
                                        type: row.type,
                                        text: text,
                                        isHeader: isHeader,
                                        color: rowColor
                                    });
                                    displayRows.push({
                                        slot: currentLogical + 1,
                                        type: 'spacer',
                                        text: '',
                                        color: rowColor
                                    });
                                    logicalSlot += 2;
                                } else {
                                    let slotDisplay = displaySlotCounter;
                                    displaySlotCounter++;

                                    let text = '';
                                    const play = plays.find(p => p.id === row.playId);
                                    text = play ? (row.playName || play.name) : 'Unknown';
                                    if (play && play.formation && !play.name.toLowerCase().includes(play.formation.toLowerCase())) text += ' - ' + play.formation;

                                    displayRows.push({
                                        slot: currentLogical,
                                        displaySlot: slotDisplay,
                                        type: row.type,
                                        text: text,
                                        isHeader: false,
                                        color: rowColor
                                    });
                                    logicalSlot++;
                                }
                            });
                        } else {
                            // Traditional Card Color Logic
                            const colorBase = card.color || 'white';
                            // Define color map directly here since we can't easily access the one in WristbandBuilder
                            const colorMap = {
                                'green-light': '#d1fae5', 'green-medium': '#a7f3d0',
                                'orange-light': '#fed7aa', 'orange-medium': '#fdba74',
                                'red-light': '#fecaca', 'red-medium': '#fca5a5',
                                'blue-light': '#bfdbfe', 'blue-medium': '#93c5fd',
                                'yellow-light': '#fef08a', 'yellow-medium': '#fde047',
                                'purple-light': '#e9d5ff', 'purple-medium': '#d8b4fe',
                                'teal-light': '#99f6e4', 'teal-medium': '#5eead4',
                                'pink-light': '#fbcfe8', 'pink-medium': '#f9a8d4'
                            };

                            displayRows = slots.map((slot, idx) => {
                                const play = slotMap[slot];

                                // Calculate alternating row color
                                let rowColor = 'transparent';
                                if (colorBase && colorBase !== 'white' && colorBase !== 'gray') {
                                    // Alternating shades logic: light, medium
                                    // Use Math.floor(idx / 2) to ensure both columns in the same row get the same shade
                                    const shade = Math.floor(idx / 2) % 2 === 0 ? 'light' : 'medium';
                                    rowColor = colorMap[`${colorBase}-${shade}`] || 'transparent';
                                }

                                return {
                                    slot: slot,
                                    text: play ? `${play.name}${play.formation && !checkRedundantFormation(play.name, play.formation) ? ' - ' + play.formation : ''}` : '',
                                    type: 'play',
                                    color: rowColor
                                };
                            });
                        }

                        // Split into Odd/Even Columns
                        const col1 = [];
                        const col2 = [];
                        displayRows.forEach(row => {
                            if (parseInt(row.slot) % 2 === 1) col1.push(row);
                            else col2.push(row);
                        });

                        // Ensure equal length for table rendering
                        const rowCount = Math.max(col1.length, col2.length, 24);
                        const tableRows = [];
                        for (let i = 0; i < rowCount; i++) {
                            tableRows.push([col1[i] || null, col2[i] || null]);
                        }

                        cardContent = (
                            <div style={{ width: '5in', height: '3in', border: '2px solid black', background: 'white', display: 'flex', flexDirection: 'column' }}>
                                {/* Header */}
                                <div style={{
                                    background: 'black',
                                    color: 'white',
                                    fontWeight: 'bold',
                                    fontSize: '10pt',
                                    padding: '0 2px',
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center'
                                }}>
                                    <span style={{ textTransform: 'uppercase' }}>{card.customHeader || cardType}</span>
                                    <span>{opponent}</span>
                                </div>
                                {/* Table Grid */}
                                <table className="wristband-spreadsheet-table" style={{ borderCollapse: 'collapse', width: '100%', flex: 1 }}>
                                    <tbody>
                                        {tableRows.map((rowGroup, rowIndex) => (
                                            <tr key={rowIndex}>
                                                {rowGroup.map((cellData, colIndex) => {
                                                    const isTempo = cellData?.type === 'tempo';
                                                    const isLastRow = rowIndex === tableRows.length - 1;
                                                    const boBottom = isLastRow ? 'none' : '1px solid #333';

                                                    if (!cellData) return (
                                                        <React.Fragment key={colIndex}>
                                                            <td style={{
                                                                border: '1px solid #333',
                                                                borderLeft: colIndex === 0 ? 'none' : '1px solid #333',
                                                                borderRight: colIndex === 1 ? 'none' : '1px solid #333',
                                                                borderBottom: boBottom,
                                                                width: '30px'
                                                            }} />
                                                            <td style={{
                                                                border: '1px solid #333',
                                                                borderLeft: '1px solid #333',
                                                                borderRight: colIndex === 1 ? 'none' : '1px solid #333',
                                                                borderBottom: boBottom,
                                                            }} />
                                                        </React.Fragment>
                                                    );

                                                    // Header/Tempo Row Render
                                                    if (cellData.isHeader) {
                                                        const isTempo = cellData.type === 'tempo';
                                                        return (
                                                            <React.Fragment key={`${colIndex}-${cellData.slot}`}>
                                                                <td
                                                                    colSpan={4}
                                                                    style={{
                                                                        fontWeight: 'bold',
                                                                        background: isTempo ? '#ffedd5' : '#333',
                                                                        color: isTempo ? 'black' : 'white',
                                                                        textAlign: 'center',
                                                                        border: '1px solid #333',
                                                                        height: `${fontSize + 0.5}rem`, // Adjust height slightly for preview
                                                                        fontSize: `${fontSize}rem`,
                                                                        verticalAlign: 'middle',
                                                                        overflow: 'hidden',
                                                                        whiteSpace: 'nowrap',
                                                                        borderBottom: boBottom
                                                                    }}
                                                                >
                                                                    {cellData.text}
                                                                </td>
                                                            </React.Fragment>
                                                        );
                                                    }

                                                    if (cellData.type === 'spacer') {
                                                        return null;
                                                    }

                                                    return (
                                                        <React.Fragment key={`${colIndex}-${cellData.slot}`}>
                                                            {/* Slot Number */}
                                                            <td style={{
                                                                fontWeight: 'bold',
                                                                width: '30px',
                                                                padding: '0 2px',
                                                                border: '1px solid #333',
                                                                borderLeft: colIndex === 0 ? 'none' : '1px solid #333',
                                                                borderBottom: boBottom,
                                                                fontSize: `${fontSize}rem`,
                                                                textAlign: 'center',
                                                                verticalAlign: 'middle',
                                                                color: 'black'
                                                            }}>
                                                                {cellData.displaySlot !== undefined ? cellData.displaySlot : cellData.slot}
                                                            </td>
                                                            {/* Play Name / Text */}
                                                            <td style={{
                                                                padding: '0 2px',
                                                                border: '1px solid #333',
                                                                borderRight: colIndex === 1 ? 'none' : '1px solid #333',
                                                                borderBottom: boBottom,
                                                                fontSize: `${fontSize}rem`,
                                                                verticalAlign: 'middle',
                                                                fontWeight: isTempo ? 'bold' : 'normal',
                                                                background: cellData.color || (isTempo ? '#ffedd5' : 'transparent'),
                                                                WebkitPrintColorAdjust: 'exact',
                                                                printColorAdjust: 'exact',
                                                                color: 'black',
                                                                overflow: 'hidden',
                                                                whiteSpace: 'nowrap',
                                                                maxWidth: '0' // Force overflow
                                                            }}>
                                                                <div style={{ overflow: 'hidden', textOverflow: 'ellipsis' }}>
                                                                    {cellData.text}
                                                                </div>
                                                            </td>
                                                        </React.Fragment>
                                                    );
                                                })}
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        );
                    }

                    const printContent = (
                        <div className="wristband-print-container" style={{
                            display: 'grid',
                            gridTemplateColumns: '1fr 1fr',
                            gridTemplateRows: '1fr 1fr',
                            width: '10.5in',
                            height: '7.5in',
                            gap: '0.25in',
                            margin: '0.25in auto',
                            background: 'white',
                            boxSizing: 'border-box'
                        }}>
                            {[1, 2, 3, 4].map(i => (
                                <div key={i} style={{
                                    width: '100%',
                                    height: '100%',
                                    display: 'flex',
                                    justifyContent: 'center',
                                    alignItems: 'center',
                                    border: 'none'
                                }}>
                                    <div style={{ transform: 'scale(1)', transformOrigin: 'center' }}>
                                        {cardContent}
                                    </div>
                                </div>
                            ))}
                        </div>
                    );

                    return (
                        <div>
                            <div className="no-print" style={{ padding: '1rem', background: '#333', color: 'white', marginBottom: '1rem', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                <div>
                                    <div style={{ marginBottom: '0.5rem' }}>
                                        <strong>Wristband Print Preview</strong> - Card {cardNumber} (4 copies per page)
                                    </div>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                        <label style={{ fontSize: '0.9rem', opacity: 0.8 }}>Header Title:</label>
                                        <input
                                            type="text"
                                            value={card.customHeader !== undefined ? card.customHeader : ((card.type === 'wiz') ? 'WIZ' : (card.type === 'mini-scripts' ? 'SCRIPT' : 'TRADITIONAL'))}
                                            onChange={(e) => {
                                                const newHeader = e.target.value;
                                                setWbSettings(prev => ({
                                                    ...prev,
                                                    [selectedCardForPrint]: { ...prev[selectedCardForPrint], customHeader: newHeader }
                                                }));
                                            }}
                                            style={{
                                                background: 'var(--surface)',
                                                border: '1px solid rgba(255,255,255,0.2)',
                                                color: 'white',
                                                padding: '2px 8px',
                                                borderRadius: '4px',
                                                width: '200px',
                                                fontSize: '0.9rem'
                                            }}
                                        />
                                    </div>
                                </div>
                                <div style={{ display: 'flex', gap: '1rem' }}>
                                    <button onClick={() => setSelectedCardForPrint(null)} className="btn btn-secondary">
                                        <Icon name="ChevronLeft" /> Change Card
                                    </button>
                                    <button onClick={() => window.print()} className="btn btn-primary">
                                        <Icon name="Printer" /> Print
                                    </button>
                                </div>
                            </div>

                            {/* On-Screen Preview */}
                            <div style={{ transform: 'scale(0.8)', transformOrigin: 'top center', marginBottom: '2rem' }}>
                                {printContent}
                            </div>

                            {/* Print Portal - Hidden on Screen, Visible on Print */}
                            {ReactDOM.createPortal(
                                <div className="print-only-portal">
                                    {printContent}
                                </div>,
                                document.body
                            )}
                        </div>
                    );
                }
            }

            // Depth Chart Print View
            if (selectedOption === 'depth_chart') {
                return (
                    <div style={{ padding: '2rem', maxWidth: '1200px', margin: '0 auto' }}>
                        <button onClick={handleBack} className="btn btn-secondary" style={{ marginBottom: '1rem' }}>
                            <Icon name="ArrowLeft" size={16} /> Back to Print Center
                        </button>
                        <div style={{ marginBottom: '1rem', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <h2>Depth Chart Print Preview</h2>
                            <button onClick={() => window.print()} className="btn btn-primary">
                                <Icon name="Printer" size={16} /> Print
                            </button>
                        </div>
                        <DepthChart
                            roster={roster}
                            depthChart={depthChart}
                            onUpdateDepthChart={() => {}}
                            forcePrintView={true}
                            personnelGroupings={personnelGroupings}
                        />
                    </div>
                );
            }

            return (
                <div style={{ padding: '2rem', maxWidth: '800px', margin: '0 auto' }}>
                    <div style={{ marginBottom: '2rem' }}>
                        <h1 style={{ fontSize: '2rem', marginBottom: '0.5rem' }}>Print Center</h1>
                        <p style={{ color: 'var(--text-secondary)' }}>Central hub for printing coaching documents.</p>
                    </div>

                    <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                        {printLinks.map(link => (
                            <div
                                key={link.id}
                                className="card"
                                style={{
                                    padding: '1rem 1.25rem',
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '1rem',
                                    cursor: 'pointer',
                                    transition: 'background 0.15s'
                                }}
                                onClick={() => handlePrint(link.id)}
                                onMouseEnter={e => e.currentTarget.style.background = 'var(--bg-hover)'}
                                onMouseLeave={e => e.currentTarget.style.background = ''}
                            >
                                <div style={{ color: 'var(--accent)' }}>
                                    <Icon name={link.icon} size={20} />
                                </div>
                                <div style={{ flex: 1 }}>
                                    <div style={{ fontWeight: '600' }}>{link.label}</div>
                                    <div style={{ color: 'var(--text-secondary)', fontSize: '0.85rem' }}>{link.desc}</div>
                                </div>
                                <Icon name="ChevronRight" size={18} style={{ color: 'var(--text-secondary)' }} />
                            </div>
                        ))}
                    </div>
                </div>
            );
        };


        const PlaybookSidebar = ({ plays, weekInstallIds = [] }) => {
            const [searchTerm, setSearchTerm] = useState('');
            // Store toggle state separately from search visibility
            const [userExpanded, setUserExpanded] = useState({
                'runs': true, 'passes': false, 'screens': false,
                'runs-week': true // Default open
            });

            // Toggle function handling user interactions
            const toggle = (id) => setUserExpanded(prev => ({ ...prev, [id]: !prev[id] }));

            // Memoize filtered plays to avoid recalculating on every render/keystroke
            const getFilteredPlays = (type, subFilter) => {
                let filtered = plays.filter(p => !p.archived);
                // 1. Basic Type Filter
                if (type === 'Run') filtered = filtered.filter(p => p.type === 'Run' || p.type === 'RPO');
                if (type === 'Pass') filtered = filtered.filter(p => p.type === 'Pass' || p.type === 'Play Action');
                if (type === 'Screen') filtered = filtered.filter(p => p.type === 'Screen');

                // 2. Search Filter (Global within type)
                if (searchTerm) {
                    const term = searchTerm.toLowerCase();
                    filtered = filtered.filter(p => p.name.toLowerCase().includes(term));
                }

                // 3. Sub-Filters
                if (subFilter === 'Inside') return filtered.filter(p => p.concept?.includes('Inside') || p.tags?.includes('Inside'));
                if (subFilter === 'Perimeter') return filtered.filter(p => p.concept?.includes('Outside') || p.concept?.includes('Perimeter') || p.tags?.includes('Outside'));
                if (subFilter === 'RPO') return filtered.filter(p => p.type === 'RPO' || p.name.includes('RPO'));
                if (subFilter === 'Week-Run') return filtered.filter(p => weekInstallIds.includes(p.id) && (p.type === 'Run' || p.type === 'RPO'));

                if (subFilter === 'Quick') return filtered.filter(p => p.concept?.includes('Quick') || p.tags?.includes('Quick'));
                if (subFilter === 'Intermediate') return filtered.filter(p => p.concept?.includes('Intermediate'));
                if (subFilter === 'Shot') return filtered.filter(p => p.concept?.includes('Shot') || p.tags?.includes('Shot'));
                if (subFilter === 'PA') return filtered.filter(p => p.type === 'Play Action' || p.name.includes('PA') || p.name.includes('Play Action'));
                if (subFilter === 'Week-Pass') return filtered.filter(p => weekInstallIds.includes(p.id) && (p.type === 'Pass' || p.type === 'Play Action'));

                if (subFilter === 'Week-Screen') return filtered.filter(p => weekInstallIds.includes(p.id) && p.type === 'Screen');

                return filtered;
            };

            const renderDraggablePlay = (play) => (
                <div
                    key={play.id}
                    draggable
                    onDragStart={(e) => {
                        e.dataTransfer.setData('application/react-dnd', JSON.stringify({ playId: play.id }));
                        e.dataTransfer.effectAllowed = 'copy';
                    }}
                    style={{
                        padding: '4px 8px', fontSize: '0.85rem', cursor: 'grab',
                        borderBottom: '1px solid #f1f5f9', background: 'white',
                        whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis',
                        color: 'black' // Explicit black for high contrast
                    }}
                    title={play.name}
                >
                    {play.priority && <span style={{ color: '#ca8a04', marginRight: '4px', fontWeight: 'bold' }}>★</span>}
                    {getPlayDisplayName(play)}
                </div>
            );

            const renderCategory = (id, label, items, level = 0) => {
                // If searching, always expand if there are items. If not searching, use user state.
                const isSearching = searchTerm.length > 0;
                const isOpen = isSearching ? items.length > 0 : userExpanded[id];

                // If searching and no items, hide the category entirely to reduce noise
                if (isSearching && items.length === 0) return null;

                return (
                    <div style={{ marginLeft: level * 8 }}>
                        <div
                            onClick={() => toggle(id)}
                            style={{
                                padding: '6px 8px', fontWeight: 'bold', fontSize: '0.9rem',
                                cursor: 'pointer', background: '#f1f5f9', borderBottom: '1px solid #cbd5e1',
                                display: 'flex', alignItems: 'center', justifyContent: 'space-between',
                                color: 'black' // High contrast
                            }}
                        >
                            <span>{label} <span style={{ fontWeight: 'normal', fontSize: '0.8em', color: '#64748b' }}>({items.length})</span></span>
                            <span style={{ color: '#64748b' }}>{isOpen ? '▼' : '▶'}</span>
                        </div>
                        {isOpen && (
                            <div style={{ borderLeft: '2px solid #e2e8f0' }}>
                                {items.length > 0 ? items.map(renderDraggablePlay) : <div style={{ padding: '4px 8px', color: '#64748b', fontSize: '0.8rem', fontStyle: 'italic' }}>No plays</div>}
                            </div>
                        )}
                    </div>
                );
            };

            const renderParentCategory = (id, label, children, hasResults) => {
                const isSearching = searchTerm.length > 0;
                // If searching, expand if any children have results (passed via prop or implied?)
                // For parents, we'll just check if they are toggled or if we are searching (expand all parents on search for simplicity)
                const isOpen = isSearching ? true : userExpanded[id];

                return (
                    <div>
                        <div
                            onClick={() => toggle(id)}
                            style={{
                                padding: '10px 8px', fontWeight: '900', fontSize: '1rem',
                                cursor: 'pointer', background: '#e2e8f0', borderBottom: '1px solid #94a3b8',
                                display: 'flex', alignItems: 'center', justifyContent: 'space-between',
                                color: 'black'
                            }}
                        >
                            {label}
                            <span style={{ color: '#475569' }}>{isOpen ? '▼' : '▶'}</span>
                        </div>
                        {isOpen && (
                            <div>{children}</div>
                        )}
                    </div>
                );
            };


            return (
                <div style={{ width: '280px', borderRight: '2px solid black', display: 'flex', flexDirection: 'column', background: '#fff' }}>
                    <div style={{ padding: '12px', borderBottom: '2px solid black', background: '#f8fafc' }}>
                        <input
                            placeholder={`Search ${plays.length} plays...`}
                            value={searchTerm}
                            onChange={(e) => setSearchTerm(e.target.value)}
                            style={{
                                width: '100%', padding: '8px', fontSize: '0.9rem',
                                border: '1px solid #64748b', borderRadius: '4px',
                                color: 'black'
                            }}
                        />
                    </div>
                    <div style={{ flex: 1, overflowY: 'auto' }}>
                        {/* RUNS / RPOS */}
                        {renderParentCategory('runs', 'RUNS / RPOs', (
                            <>
                                {renderCategory('runs-inside', 'Inside Runs', getFilteredPlays('Run', 'Inside'), 1)}
                                {renderCategory('runs-rpo', 'RPOs', getFilteredPlays('Run', 'RPO'), 1)}
                                {renderCategory('runs-perimeter', 'Perimeter', getFilteredPlays('Run', 'Perimeter'), 1)}
                                {renderCategory('runs-week', "This Week", getFilteredPlays('Run', 'Week-Run'), 1)}
                            </>
                        ))}

                        {/* PASSES */}
                        {renderParentCategory('passes', 'PASSES', (
                            <>
                                {renderCategory('passes-quick', 'Quick Game', getFilteredPlays('Pass', 'Quick'), 1)}
                                {renderCategory('passes-inter', 'Intermediate', getFilteredPlays('Pass', 'Intermediate'), 1)}
                                {renderCategory('passes-shot', 'Shots', getFilteredPlays('Pass', 'Shot'), 1)}
                                {renderCategory('passes-pa', 'Play Action', getFilteredPlays('Pass', 'PA'), 1)}
                                {renderCategory('passes-week', "This Week", getFilteredPlays('Pass', 'Week-Pass'), 1)}
                            </>
                        ))}

                        {/* SCREENS */}
                        {renderParentCategory('screens', 'SCREENS', (
                            <>
                                {renderCategory('screens-all', 'All Screens', getFilteredPlays('Screen'), 1)}
                                {renderCategory('screens-week', 'This Week', getFilteredPlays('Screen', 'Week-Screen'), 1)}
                            </>
                        ))}

                        {/* GLOBAL SEARCH RESULTS (Uncategorized / All) */}
                        {searchTerm.length > 1 && (
                            <div style={{ marginTop: '0', borderTop: '2px solid black' }}>
                                <div style={{
                                    padding: '10px 8px', fontWeight: '900', fontSize: '1rem',
                                    background: '#fef3c7', /* Amber-100 for visibility */
                                    borderBottom: '1px solid #d97706', color: '#78350f',
                                    display: 'flex', justifyContent: 'space-between', alignItems: 'center'
                                }}>
                                    <span>SEARCH RESULTS</span>
                                    <span style={{ fontSize: '0.8rem', color: '#92400e' }}>
                                        ({plays.filter(p => !p.archived && p.name.toLowerCase().includes(searchTerm.toLowerCase())).length})
                                    </span>
                                </div>
                                <div>
                                    {plays
                                        .filter(p => !p.archived && p.name.toLowerCase().includes(searchTerm.toLowerCase()))
                                        .map(renderDraggablePlay)}
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        function GamePlannerSideMenu({ plays, practicePlans, onQuickAddPlay, isOpen, onToggle, weekStats, gamePlan, gamePlanLayouts, playBuckets, playCategories, onAddSection, onUpdatePlay, onUpdateGamePlan, currentWeek, onNavigate, onAddToNextSlot, suggestions = {}, onUpdateSuggestions }) {
            const [searchTerm, setSearchTerm] = useState('');
            const [quickAddValue, setQuickAddValue] = useState('');
            const [activeTab, setActiveTab] = useState('usage'); // usage, gameplan, install
            const [expandedSections, setExpandedSections] = useState({});
            const [situationModalPlayId, setSituationModalPlayId] = useState(null);
            const [quickAddInputs, setQuickAddInputs] = useState({}); // { bucketId: 'input value' }

            // Quick Add: Create play if not exists, then assign to bucket
            const handleQuickAddToBucket = (inputValue, bucketId) => {
                if (!inputValue.trim()) return;

                const playName = inputValue.trim().toUpperCase();
                let existingPlay = plays.find(p => p.name.toLowerCase() === playName.toLowerCase());

                if (!existingPlay && onQuickAddPlay) {
                    // Create new play
                    const newPlay = {
                        id: `play_${Date.now()}`,
                        name: playName,
                        bucketId: bucketId,
                        formation: '',
                        tags: []
                    };
                    onQuickAddPlay(newPlay);
                    existingPlay = newPlay;
                } else if (existingPlay && onUpdatePlay) {
                    // Update existing play to have this bucket
                    onUpdatePlay(existingPlay.id, { bucketId: bucketId });
                }

                // Add to install list if we have currentWeek
                if (currentWeek && existingPlay) {
                    const installList = [...(currentWeek.installList || [])];
                    if (!installList.includes(existingPlay.id)) {
                        installList.push(existingPlay.id);
                        onUpdateGamePlan && onUpdateGamePlan({ ...gamePlan, installList });
                    }
                }

                // Clear the input
                setQuickAddInputs(prev => ({ ...prev, [bucketId]: '' }));
            };

            const toggleSection = (id) => {
                setExpandedSections(prev => ({
                    ...prev,
                    [id]: !prev[id]
                }));
            };

            // Calculate Usage
            const playUsage = useMemo(() => {
                const map = {};
                (plays || []).forEach(p => {
                    map[p.id] = { total: 0, days: { M: 0, T: 0, W: 0, TH: 0, F: 0 } };
                });

                if (practicePlans) {
                    const dayMapping = {
                        'MONDAY': 'M',
                        'TUESDAY': 'T',
                        'WEDNESDAY': 'W',
                        'THURSDAY': 'TH',
                        'FRIDAY': 'F'
                    };

                    Object.entries(practicePlans).forEach(([day, plan]) => {
                        const keyUpper = day.toUpperCase();
                        const dayKey = dayMapping[keyUpper] || keyUpper;

                        if (!['M', 'T', 'W', 'TH', 'F'].includes(dayKey)) return;

                        (plan.segments || []).forEach(seg => {
                            (seg.script || []).forEach(item => {
                                const pid = (typeof item === 'object') ? (item.playId || item.id) : item; // Handle object with playId/id or string
                                if (pid && map[pid]) {
                                    map[pid].total++;
                                    if (map[pid].days[dayKey] !== undefined) {
                                        map[pid].days[dayKey]++;
                                    }
                                }
                            });
                        });
                    });
                }
                return map;
            }, [plays, practicePlans]);

            // Grouping for "Usage" Tab (Buckets Style)
            const usageData = useMemo(() => {
                let filteredPlays = (plays || []).filter(p => !p.archived);
                const query = searchTerm.toLowerCase();

                // Map of filtered plays for quick lookup
                const filteredMap = {};
                filteredPlays.forEach(p => {
                    if (!searchTerm ||
                        p.name.toLowerCase().includes(query) ||
                        p.formation?.toLowerCase().includes(query) ||
                        p.concept?.toLowerCase().includes(query)) {
                        filteredMap[p.id] = p;
                    }
                });

                const categories = (playCategories || []).map(cat => {
                    const families = (playBuckets || []).filter(b => b.categoryId === cat.id).map(bucket => {
                        // Find plays assigned to this category and family label
                        const bucketPlays = Object.values(filteredMap).filter(p =>
                            p.bucketId === cat.id && p.conceptFamily === bucket.label
                        ).sort((a, b) => a.name.localeCompare(b.name));

                        return { ...bucket, plays: bucketPlays };
                    }).filter(f => searchTerm ? f.plays.length > 0 : true);

                    const totalPlays = families.reduce((sum, f) => sum + f.plays.length, 0);
                    return { ...cat, families, totalPlays };
                }).filter(c => searchTerm ? c.totalPlays > 0 : true);

                // Find unassigned plays (those not matching a category/family combination)
                const unassignedPlays = Object.values(filteredMap).filter(p => {
                    if (!p.bucketId || !p.conceptFamily) return true;
                    // Also unassigned if its bucketId or conceptFamily doesn't exist in setup
                    const catExists = (playCategories || []).some(cat => cat.id === p.bucketId);
                    const bucketExists = (playBuckets || []).some(b => b.categoryId === p.bucketId && b.label === p.conceptFamily);
                    return !catExists || !bucketExists;
                }).sort((a, b) => a.name.localeCompare(b.name));

                if (unassignedPlays.length > 0 || !searchTerm) {
                    categories.push({
                        id: 'unassigned',
                        label: 'Unassigned',
                        color: '#64748b',
                        families: [{ id: 'unassigned-family', label: 'Other Plays', plays: unassignedPlays }],
                        totalPlays: unassignedPlays.length
                    });
                }

                return categories;
            }, [plays, playCategories, playBuckets, searchTerm]);

            const installData = useMemo(() => {
                const installList = currentWeek?.installList || [];
                const installedPlays = (plays || []).filter(p => !p.archived && installList.includes(p.id));
                const query = searchTerm.toLowerCase();

                // Map of filtered plays for quick lookup
                const filteredMap = {};
                installedPlays.forEach(p => {
                    if (!searchTerm ||
                        p.name.toLowerCase().includes(query) ||
                        p.formation?.toLowerCase().includes(query) ||
                        p.concept?.toLowerCase().includes(query)) {
                        filteredMap[p.id] = p;
                    }
                });

                const categories = (playCategories || []).map(cat => {
                    const families = (playBuckets || []).filter(b => b.categoryId === cat.id).map(bucket => {
                        const bucketPlays = Object.values(filteredMap).filter(p =>
                            p.bucketId === cat.id && p.conceptFamily === bucket.label
                        ).sort((a, b) => a.name.localeCompare(b.name));

                        return { ...bucket, plays: bucketPlays };
                    }).filter(f => searchTerm ? f.plays.length > 0 : true);

                    const totalPlays = families.reduce((sum, f) => sum + f.plays.length, 0);
                    return { ...cat, families, totalPlays };
                }).filter(c => searchTerm ? c.totalPlays > 0 : true);

                // Find unassigned plays that are installed
                const unassignedPlays = Object.values(filteredMap).filter(p => {
                    if (!p.bucketId || !p.conceptFamily) return true;
                    const catExists = (playCategories || []).some(cat => cat.id === p.bucketId);
                    const bucketExists = (playBuckets || []).some(b => b.categoryId === p.bucketId && b.label === p.conceptFamily);
                    return !catExists || !bucketExists;
                }).sort((a, b) => a.name.localeCompare(b.name));

                if (unassignedPlays.length > 0 || !searchTerm) {
                    categories.push({
                        id: 'unassigned-install',
                        label: 'Uncategorized',
                        color: '#64748b',
                        families: [{ id: 'unassigned-install-family', label: 'Other Installed Plays', plays: unassignedPlays }],
                        totalPlays: unassignedPlays.length
                    });
                }

                return categories;
            }, [plays, playCategories, playBuckets, currentWeek, searchTerm]);

            const handleDragStart = (e, play) => {
                e.dataTransfer.setData('application/react-dnd', JSON.stringify({ playId: play.id, name: play.name })); // Pass name too just in case
                e.dataTransfer.effectAllowed = 'copy';
            };

            const handleAssignSituation = (playId, situationId, type) => {
                if (!onUpdateGamePlan) return;

                const updatedGamePlan = { ...gamePlan };

                // Helper to find and update target in sets or miniScripts
                const findAndAdd = (list) => {
                    if (!list) return false;
                    let found = false;
                    if (Array.isArray(list)) {
                        const target = list.find(s => s.id === situationId);
                        if (target) {
                            if (!target.assignedPlayIds) target.assignedPlayIds = [];
                            if (!target.assignedPlayIds.includes(playId)) {
                                target.assignedPlayIds.push(playId);
                                found = true;
                            }
                        }
                    } else if (typeof list === 'object') {
                        const target = list[situationId];
                        if (target) {
                            if (!target.assignedPlayIds) target.assignedPlayIds = [];
                            if (!target.assignedPlayIds.includes(playId)) {
                                target.assignedPlayIds.push(playId);
                                found = true;
                            }
                        }
                    }
                    return found;
                };

                const updatedSets = findAndAdd(updatedGamePlan.sets);
                const updatedMinis = findAndAdd(updatedGamePlan.miniScripts);

                if (updatedSets || updatedMinis) {
                    onUpdateGamePlan(updatedGamePlan);
                }
            };

            const renderRow = (play) => {
                const u = playUsage[play.id] || { days: { M: 0, T: 0, W: 0, TH: 0, F: 0 } };
                return (
                    <div
                        key={play.id}
                        style={{ display: 'flex', alignItems: 'center', padding: '6px 0', borderBottom: '1px solid #f1f5f9', fontSize: '0.8rem', cursor: 'default' }}
                        onDoubleClick={() => setSituationModalPlayId(play.id)}
                    >
                        {/* Add to next slot button */}
                        {onAddToNextSlot && (
                            <button
                                onClick={(e) => {
                                    e.stopPropagation();
                                    onAddToNextSlot(play.id, play);
                                }}
                                title="Add to next blank slot"
                                style={{
                                    width: '20px',
                                    height: '20px',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    background: 'transparent',
                                    border: '1px solid #cbd5e1',
                                    borderRadius: '4px',
                                    cursor: 'pointer',
                                    marginRight: '6px',
                                    color: '#64748b',
                                    fontSize: '1rem',
                                    fontWeight: 'bold',
                                    padding: 0,
                                    flexShrink: 0
                                }}
                                onMouseEnter={(e) => {
                                    e.target.style.background = '#3b82f6';
                                    e.target.style.color = 'white';
                                    e.target.style.borderColor = '#3b82f6';
                                }}
                                onMouseLeave={(e) => {
                                    e.target.style.background = 'transparent';
                                    e.target.style.color = '#64748b';
                                    e.target.style.borderColor = '#cbd5e1';
                                }}
                            >
                                +
                            </button>
                        )}
                        <div
                            draggable
                            onDragStart={(e) => handleDragStart(e, play)}
                            style={{ flex: 1, minWidth: 0, cursor: 'grab' }}
                        >
                            <div style={{ fontWeight: '500', color: '#1e293b', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                                {play.name}
                            </div>
                            {play.priority && <div style={{ fontSize: '0.7rem', color: '#ca8a04' }}>★</div>}
                        </div>
                        <div style={{ display: 'flex', gap: '2px', marginLeft: '8px', flexShrink: 0 }}>
                            {['M', 'T', 'W', 'TH', 'F'].map(day => (
                                <div key={day} style={{
                                    width: '18px', height: '18px', display: 'flex', alignItems: 'center', justifyContent: 'center',
                                    background: u.days[day] > 0 ? '#1e293b' : '#f1f5f9',
                                    color: u.days[day] > 0 ? 'white' : '#94a3b8',
                                    fontWeight: '900', fontSize: '0.6rem', borderRadius: '2px'
                                }}>
                                    {u.days[day] > 0 ? u.days[day] : ''}
                                </div>
                            ))}
                        </div>
                    </div>
                );
            };

            const renderGamePlanContent = () => {
                if (!gamePlanLayouts) return <div style={{ padding: '1rem', color: '#64748b' }}>No Game Plan Layouts found.</div>;

                // Helper to get plays for a section
                const getPlaysForSection = (type, sectionId, extraData = {}) => {
                    let playList = [];
                    if (type === 'matrix_formation') {
                        // Matrix logic
                        const matrixFormation = extraData.formation;
                        const playIds = new Set();
                        const layout = gamePlanLayouts?.MATRIX;
                        if (layout) {
                            layout.playTypes.forEach(pt => {
                                layout.cols.forEach(col => {
                                    const setId = `matrix_${matrixFormation.id}_${pt.id}_${col.id}`;
                                    let cellData = null;
                                    if (Array.isArray(gamePlan?.sets)) {
                                        cellData = gamePlan.sets.find(s => s.id === setId);
                                    } else if (gamePlan?.sets && typeof gamePlan.sets === 'object') {
                                        cellData = Object.values(gamePlan.sets).find(s => s.id === setId) || gamePlan.sets[setId];
                                    }
                                    if (cellData && cellData.assignedPlayIds) cellData.assignedPlayIds.forEach(id => playIds.add(id));
                                    else if (cellData && cellData.playIds) cellData.playIds.forEach(id => playIds.add(id));
                                });
                            });
                        }
                        playList = Array.from(playIds).map(id => plays.find(p => p.id === id)).filter(Boolean);
                    } else {

                        // Standard set logic
                        let rawIds = [];

                        // 1. Try Game Plan Data (Primary)
                        const setInSets = gamePlan?.sets?.[sectionId] || (Array.isArray(gamePlan?.sets) ? gamePlan.sets.find(s => s.id === sectionId) : null);
                        const setInMini = gamePlan?.miniScripts?.[sectionId] || (Array.isArray(gamePlan?.miniScripts) ? gamePlan.miniScripts.find(s => s.id === sectionId) : null);
                        const setData = setInSets || setInMini;

                        if (setData && (setData.assignedPlayIds || setData.playIds)) {
                            rawIds = setData.assignedPlayIds || setData.playIds || [];
                        }

                        // 2. Fallback to Layouts (Parallel Process - Fail-safe)
                        if ((!rawIds || rawIds.length === 0) && gamePlanLayouts?.CALL_SHEET?.sections) {
                            for (const sec of gamePlanLayouts.CALL_SHEET.sections) {
                                if (!sec.boxes) continue;
                                const box = sec.boxes.find(b => b.setId === sectionId);
                                if (box) {
                                    // For Grids
                                    if (box.assignedPlayIds && box.assignedPlayIds.length > 0) {
                                        rawIds = box.assignedPlayIds;
                                    }
                                    // For Scripts
                                    else if (box.rows) {
                                        const scriptIds = [];
                                        box.rows.forEach(r => {
                                            if (r.content) scriptIds.push(r.content);
                                            if (r.contentRight) scriptIds.push(r.contentRight);
                                        });
                                        rawIds = [...new Set(scriptIds)];
                                    }
                                    break;
                                }
                            }
                        }

                        playList = rawIds.map(id => {
                            const pid = typeof id === 'object' ? id.id : id;
                            if (pid === 'GAP') return null;
                            return plays.find(p => p.id === pid);
                        }).filter(Boolean);
                    }
                    return playList;
                };

                return (
                    <div style={{ padding: '0 0.75rem 0.75rem', overflowY: 'auto', flex: 1 }}>
                        {/* Header Row */}
                        <div style={{ display: 'flex', alignItems: 'center', paddingBottom: '4px', marginRight: '10px', marginTop: '8px' }}>
                            <div style={{ flex: 1 }}></div>
                            <div style={{ display: 'flex', gap: '2px', marginLeft: '8px' }}>
                                {['M', 'T', 'W', 'TH', 'F'].map(day => (
                                    <div key={day} style={{ width: '18px', textAlign: 'center', fontSize: '0.6rem', fontWeight: 'bold', color: '#64748b' }}>
                                        {day}
                                    </div>
                                ))}
                            </div>
                        </div>
                        {/* Call Sheet Sections */}
                        {(gamePlanLayouts?.CALL_SHEET?.sections || []).map(section => (
                            <div key={section.id}>
                                <div style={{ padding: '8px 0', fontSize: '0.75rem', fontWeight: 'bold', color: '#64748b', textTransform: 'uppercase' }}>{section.title}</div>
                                {section.boxes.map(box => {
                                    const items = getPlaysForSection('box', box.setId);
                                    // if (items.length === 0) return null; // Always show
                                    const isExpanded = expandedSections[box.setId];

                                    return (
                                        <div key={box.setId} style={{ marginBottom: '4px', border: '1px solid #e2e8f0', borderRadius: '4px', overflow: 'hidden' }}>
                                            <div
                                                onClick={() => toggleSection(box.setId)}
                                                style={{ padding: '8px', background: '#f8fafc', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}
                                            >
                                                <span style={{ fontSize: '0.85rem', fontWeight: '600', color: '#1e293b' }}>{box.header}</span>
                                                <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                                    <span style={{ fontSize: '0.7rem', color: '#64748b' }}>{items.length}</span>
                                                    <Icon name={isExpanded ? "ChevronDown" : "ChevronRight"} size={14} color="#64748b" />
                                                </div>
                                            </div>
                                            {isExpanded && (
                                                <div style={{ padding: '8px', borderTop: '1px solid #e2e8f0', background: 'white' }}>
                                                    {/* Quick Add Input */}
                                                    <input
                                                        type="text"
                                                        placeholder="+ Quick add play..."
                                                        value={quickAddInputs[box.setId] || ''}
                                                        onChange={(e) => setQuickAddInputs(prev => ({ ...prev, [box.setId]: e.target.value }))}
                                                        onKeyDown={(e) => {
                                                            if (e.key === 'Enter' && e.target.value.trim()) {
                                                                const playName = e.target.value.trim().toUpperCase();
                                                                let existingPlay = plays.find(p => p.name.toLowerCase() === playName.toLowerCase());
                                                                if (!existingPlay && onQuickAddPlay) {
                                                                    existingPlay = { id: `play_${Date.now()}`, name: playName, formation: '', tags: [] };
                                                                    onQuickAddPlay(existingPlay);
                                                                }
                                                                if (existingPlay) {
                                                                    // Add to this box's set
                                                                    const sets = { ...(gamePlan?.sets || {}) };
                                                                    if (!sets[box.setId]) sets[box.setId] = { id: box.setId, playIds: [] };
                                                                    if (!sets[box.setId].playIds.includes(existingPlay.id)) {
                                                                        sets[box.setId].playIds = [...sets[box.setId].playIds, existingPlay.id];
                                                                        onUpdateGamePlan && onUpdateGamePlan({ ...gamePlan, sets });
                                                                    }
                                                                }
                                                                setQuickAddInputs(prev => ({ ...prev, [box.setId]: '' }));
                                                            }
                                                        }}
                                                        style={{
                                                            width: '100%',
                                                            padding: '6px 8px',
                                                            marginBottom: '8px',
                                                            fontSize: '0.7rem',
                                                            border: '1px dashed #cbd5e1',
                                                            borderRadius: '4px',
                                                            background: '#f8fafc',
                                                            outline: 'none'
                                                        }}
                                                        onFocus={(e) => e.target.style.borderColor = '#3b82f6'}
                                                        onBlur={(e) => e.target.style.borderColor = '#cbd5e1'}
                                                    />
                                                    {items.length > 0 ? (
                                                        <>
                                                            <button
                                                                onClick={(e) => { e.stopPropagation(); onAddSection(box.setId); }}
                                                                style={{
                                                                    width: '100%',
                                                                    marginBottom: '8px',
                                                                    fontSize: '0.75rem',
                                                                    padding: '6px',
                                                                    background: '#f1f5f9',
                                                                    color: '#000000',
                                                                    border: '1px solid #cbd5e1',
                                                                    borderRadius: '4px',
                                                                    fontWeight: '700',
                                                                    cursor: 'pointer'
                                                                }}
                                                            >
                                                                + Add All
                                                            </button>
                                                            {items.map(renderRow)}
                                                        </>
                                                    ) : (
                                                        <div style={{ fontSize: '0.75rem', color: '#94a3b8', fontStyle: 'italic', padding: '4px' }}>No plays yet. Type above to add.</div>
                                                    )}
                                                </div>
                                            )}
                                        </div>
                                    );
                                })}
                            </div>
                        ))}

                        {/* Matrix Formations */}
                        <div style={{ padding: '8px 0', fontSize: '0.75rem', fontWeight: 'bold', color: '#64748b', textTransform: 'uppercase', marginTop: '1rem' }}>Formations (Matrix)</div>
                        {(gamePlanLayouts?.MATRIX?.formations || []).map(formation => {
                            const items = getPlaysForSection('matrix_formation', formation.id, { formation });
                            // if (items.length === 0) return null; // Always show
                            const isExpanded = expandedSections[formation.id];

                            return (
                                <div key={formation.id} style={{ marginBottom: '4px', border: '1px solid #e2e8f0', borderRadius: '4px', overflow: 'hidden' }}>
                                    <div
                                        onClick={() => toggleSection(formation.id)}
                                        style={{ padding: '8px', background: '#f8fafc', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}
                                    >
                                        <span style={{ fontSize: '0.85rem', fontWeight: '600', color: '#1e293b' }}>{formation.label}</span>
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                            <span style={{ fontSize: '0.7rem', color: '#64748b' }}>{items.length}</span>
                                            <Icon name={isExpanded ? "ChevronDown" : "ChevronRight"} size={14} color="#64748b" />
                                        </div>
                                    </div>
                                    {isExpanded && (
                                        <div style={{ padding: '8px', borderTop: '1px solid #e2e8f0', background: 'white' }}>
                                            {items.length > 0 ? (
                                                <>
                                                    <button
                                                        onClick={(e) => { e.stopPropagation(); onAddSection(formation.id); }}
                                                        style={{
                                                            width: '100%',
                                                            marginBottom: '8px',
                                                            fontSize: '0.75rem',
                                                            padding: '6px',
                                                            background: '#f1f5f9',
                                                            color: '#000000',
                                                            border: '1px solid #cbd5e1',
                                                            borderRadius: '4px',
                                                            fontWeight: '700',
                                                            cursor: 'pointer'
                                                        }}
                                                    >
                                                        + Add All
                                                    </button>
                                                    {items.map(renderRow)}
                                                </>
                                            ) : (
                                                <div style={{ fontSize: '0.75rem', color: '#94a3b8', fontStyle: 'italic', padding: '4px' }}>No plays found.</div>
                                            )}
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                );
            };

            const renderInstallContent = () => {
                if (!playCategories || !playBuckets) return <div style={{ padding: '1rem', color: '#64748b' }}>No Categories or Play Families found.</div>;

                if (installData.length === 0) {
                    return (
                        <div style={{ padding: '1rem', color: '#64748b', fontStyle: 'italic' }}>
                            {searchTerm ? "No installed plays matching search." : "No plays installed this week."}
                        </div>
                    );
                }

                return (
                    <div style={{ padding: '0 0.75rem 0.75rem', overflowY: 'auto', flex: 1 }}>
                        {/* Header Row */}
                        <div style={{ display: 'flex', alignItems: 'center', paddingBottom: '4px', marginRight: '10px', marginTop: '8px' }}>
                            <div style={{ flex: 1 }}></div>
                            <div style={{ display: 'flex', gap: '2px', marginLeft: '8px' }}>
                                {['M', 'T', 'W', 'TH', 'F'].map(day => (
                                    <div key={day} style={{ width: '18px', textAlign: 'center', fontSize: '0.6rem', fontWeight: 'bold', color: '#64748b' }}>
                                        {day}
                                    </div>
                                ))}
                            </div>
                        </div>

                        {installData.map(category => {
                            const isCatExpanded = expandedSections[`cat-install-${category.id}`];
                            return (
                                <div key={category.id} style={{ marginBottom: '8px' }}>
                                    <div
                                        onClick={() => toggleSection(`cat-install-${category.id}`)}
                                        style={{
                                            padding: '8px 10px',
                                            background: category.color || '#3b82f6',
                                            cursor: 'pointer',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'space-between',
                                            borderRadius: '4px',
                                            marginBottom: '2px'
                                        }}
                                    >
                                        <span style={{ fontSize: '0.8rem', fontWeight: '700', color: 'white', textTransform: 'uppercase' }}>
                                            {category.label}
                                        </span>
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                            <span style={{ fontSize: '0.65rem', color: 'white', opacity: 0.9 }}>{category.totalPlays}</span>
                                            <Icon name={isCatExpanded ? "ChevronDown" : "ChevronRight"} size={14} color="white" />
                                        </div>
                                    </div>

                                    {isCatExpanded && (
                                        <div style={{ marginLeft: '8px', borderLeft: `2px solid ${category.color || '#3b82f6'}`, paddingLeft: '6px', paddingTop: '4px' }}>
                                            {category.totalPlays > 0 && (
                                                    <button
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            const allPlayIds = category.families.flatMap(f => f.plays.map(p => p.id));
                                                            onAddSection(allPlayIds);
                                                        }}
                                                        style={{
                                                            width: '100%',
                                                            marginBottom: '8px',
                                                            fontSize: '0.7rem',
                                                            padding: '6px',
                                                            background: 'white',
                                                            color: '#1e293b',
                                                            border: `1px solid ${category.color || '#3b82f6'}`,
                                                            borderRadius: '4px',
                                                            fontWeight: '700',
                                                            cursor: 'pointer',
                                                            display: 'flex',
                                                            alignItems: 'center',
                                                            justifyContent: 'center',
                                                            gap: '4px'
                                                        }}
                                                    >
                                                        <Icon name="PlusCircle" size={14} /> Add all to script ({category.totalPlays})
                                                    </button>
                                                )}
                                                {category.families.map(family => {
                                                const isFamExpanded = expandedSections[`fam-install-${family.id}`];
                                                return (
                                                    <div key={family.id} style={{ marginBottom: '4px', border: '1px solid #e2e8f0', borderRadius: '4px', overflow: 'hidden' }}>
                                                        <div
                                                            onClick={() => toggleSection(`fam-install-${family.id}`)}
                                                            style={{ padding: '6px 8px', background: '#f8fafc', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}
                                                        >
                                                            <span style={{ fontSize: '0.75rem', fontWeight: '600', color: '#1e293b' }}>{family.label || family.name}</span>
                                                            <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                                                                <span style={{ fontSize: '0.65rem', color: '#64748b' }}>{family.plays.length}</span>
                                                                <Icon name={isFamExpanded ? "ChevronDown" : "ChevronRight"} size={12} color="#64748b" />
                                                            </div>
                                                        </div>
                                                        {isFamExpanded && (
                                                            <div style={{ padding: '4px 8px', borderTop: '1px solid #e2e8f0', background: 'white' }}>
                                                                {/* Quick Add Input */}
                                                                <div style={{ marginBottom: '6px' }}>
                                                                    <input
                                                                        type="text"
                                                                        placeholder="+ Quick add play..."
                                                                        value={quickAddInputs[family.id] || ''}
                                                                        onChange={(e) => setQuickAddInputs(prev => ({ ...prev, [family.id]: e.target.value }))}
                                                                        onKeyDown={(e) => {
                                                                            if (e.key === 'Enter') {
                                                                                handleQuickAddToBucket(e.target.value, family.id);
                                                                            }
                                                                        }}
                                                                        style={{
                                                                            width: '100%',
                                                                            padding: '6px 8px',
                                                                            fontSize: '0.7rem',
                                                                            border: '1px dashed #cbd5e1',
                                                                            borderRadius: '4px',
                                                                            background: '#f8fafc',
                                                                            color: '#1e293b',
                                                                            outline: 'none'
                                                                        }}
                                                                        onFocus={(e) => e.target.style.borderColor = '#3b82f6'}
                                                                        onBlur={(e) => e.target.style.borderColor = '#cbd5e1'}
                                                                    />
                                                                </div>
                                                                {family.plays.length > 0 && (
                                                                        <button
                                                                            onClick={(e) => {
                                                                                e.stopPropagation();
                                                                                const familyPlayIds = family.plays.map(p => p.id);
                                                                                onAddSection(familyPlayIds);
                                                                            }}
                                                                            style={{
                                                                                width: '100%',
                                                                                marginBottom: '6px',
                                                                                fontSize: '0.65rem',
                                                                                padding: '4px',
                                                                                background: '#f1f5f9',
                                                                                color: '#1e293b',
                                                                                border: '1px solid #cbd5e1',
                                                                                borderRadius: '4px',
                                                                                fontWeight: '700',
                                                                                cursor: 'pointer',
                                                                                display: 'flex',
                                                                                alignItems: 'center',
                                                                                justifyContent: 'center',
                                                                                gap: '4px'
                                                                            }}
                                                                        >
                                                                            <Icon name="Plus" size={12} /> Add all to script ({family.plays.length})
                                                                        </button>
                                                                    )}
                                                                    {family.plays.map(renderRow)}
                                                            </div>
                                                        )}
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                );
            };



            return (
                <div style={{
                    width: isOpen ? '360px' : '40px',
                    transition: 'width 0.3s ease-in-out',
                    borderLeft: '1px solid var(--border)',
                    background: isOpen ? 'white' : '#1e293b',
                    display: 'flex',
                    flexDirection: 'column',
                    height: '100%',
                    flexShrink: 0,
                    position: 'relative',
                    overflow: 'hidden'
                }}>
                    {/* Collapsed state: toggle + vertical label */}
                    {!isOpen && (
                        <div
                            onClick={() => onToggle(true)}
                            title="Expand Play Bank"
                            style={{
                                width: '40px',
                                height: '100%',
                                background: '#1e293b',
                                border: 'none',
                                cursor: 'pointer',
                                display: 'flex',
                                flexDirection: 'column',
                                alignItems: 'center',
                                paddingTop: '8px',
                                gap: '12px'
                            }}
                        >
                            <Icon name="ChevronLeft" size={20} color="#94a3b8" />
                            <span style={{
                                writingMode: 'vertical-rl',
                                textOrientation: 'mixed',
                                transform: 'rotate(180deg)',
                                fontSize: '0.7rem',
                                fontWeight: '600',
                                color: '#64748b',
                                letterSpacing: '0.1em',
                                textTransform: 'uppercase'
                            }}>
                                Play Bank
                            </span>
                        </div>
                    )}

                    <div style={{ width: '360px', display: isOpen ? 'flex' : 'none', flexDirection: 'column', height: '100%', overflow: 'hidden' }}>
                        {/* Quick Navigation Links */}
                        {onNavigate && (
                            <div style={{
                                padding: '8px 12px',
                                borderBottom: '1px solid #1e293b',
                                display: 'flex',
                                gap: '8px',
                                background: '#0f172a'
                            }}>
                                <button
                                    onClick={() => onNavigate('setup')}
                                    style={{
                                        flex: 1,
                                        padding: '6px 10px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        gap: '6px',
                                        background: 'rgba(59, 130, 246, 0.2)',
                                        border: '1px solid rgba(59, 130, 246, 0.3)',
                                        borderRadius: '6px',
                                        color: '#93c5fd',
                                        fontSize: '0.75rem',
                                        fontWeight: '600',
                                        cursor: 'pointer',
                                        transition: 'all 0.2s'
                                    }}
                                    onMouseOver={(e) => e.target.style.background = 'rgba(59, 130, 246, 0.3)'}
                                    onMouseOut={(e) => e.target.style.background = 'rgba(59, 130, 246, 0.2)'}
                                >
                                    <Icon name="Settings" size={14} /> Setup
                                </button>
                                <button
                                    onClick={() => onNavigate('playbook')}
                                    style={{
                                        flex: 1,
                                        padding: '6px 10px',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        gap: '6px',
                                        background: 'rgba(34, 197, 94, 0.2)',
                                        border: '1px solid rgba(34, 197, 94, 0.3)',
                                        borderRadius: '6px',
                                        color: '#86efac',
                                        fontSize: '0.75rem',
                                        fontWeight: '600',
                                        cursor: 'pointer',
                                        transition: 'all 0.2s'
                                    }}
                                    onMouseOver={(e) => e.target.style.background = 'rgba(34, 197, 94, 0.3)'}
                                    onMouseOut={(e) => e.target.style.background = 'rgba(34, 197, 94, 0.2)'}
                                >
                                    <Icon name="BookOpen" size={14} /> Master Playbook
                                </button>
                            </div>
                        )}

                        {/* Header with Toggle Arrow */}
                        <div style={{
                            padding: '0.75rem 1rem',
                            borderBottom: '1px solid #334155',
                            display: 'flex',
                            justifyContent: 'space-between',
                            alignItems: 'center',
                            background: '#1e293b',
                            color: 'white'
                        }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                <Icon name="Landmark" size={20} color="#cbd5e1" />
                                <h3 style={{ margin: 0, fontSize: '1.25rem', fontWeight: '800', letterSpacing: '0.025em' }}>Play Bank</h3>
                            </div>
                            <button
                                onClick={() => onToggle(false)}
                                title="Collapse Play Bank"
                                style={{
                                    width: '32px',
                                    height: '32px',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    background: 'var(--surface)',
                                    border: 'none',
                                    borderRadius: '6px',
                                    color: '#94a3b8',
                                    cursor: 'pointer',
                                    transition: 'all 0.2s'
                                }}
                                onMouseOver={(e) => e.target.style.background = 'rgba(255,255,255,0.2)'}
                                onMouseOut={(e) => e.target.style.background = 'var(--surface)'}
                            >
                                <Icon name="ChevronRight" size={20} />
                            </button>
                        </div>

                        {/* Week Indicator & Stats */}
                        {weekStats && (
                            <div style={{
                                padding: '0.75rem',
                                borderBottom: '1px solid var(--border)',
                                display: 'flex',
                                flexDirection: 'column',
                                alignItems: 'center',
                                background: '#f8fafc',
                                gap: '6px'
                            }}>
                                <div style={{ fontSize: '0.65rem', fontWeight: 'bold', color: '#1e293b', marginBottom: '0', textTransform: 'uppercase', letterSpacing: '0.05em' }}>
                                    {currentWeek ? (currentWeek.opponent ? `vs. ${currentWeek.opponent}` : (currentWeek.name || `Week ${currentWeek.weekNumber || ''}`)) : 'No Week Selected'}
                                </div>
                                <div style={{
                                    display: 'flex',
                                    alignItems: 'center',
                                    background: '#e0e7ff',
                                    borderRadius: '20px',
                                    padding: '0.2rem 0.6rem',
                                    border: '1px solid #c7d2fe',
                                    height: '36px'
                                }}>
                                    <div style={{ display: 'flex', alignItems: 'center', marginRight: '0.5rem', paddingRight: '0.5rem', borderRight: '1px solid #a5b4fc' }}>
                                        <span style={{ fontSize: '1.1rem', fontWeight: 'bold', color: 'white', marginRight: '0.2rem', textShadow: '0px 1px 2px rgba(0,0,0,0.1)' }}>{weekStats.uniquePlaysCount}</span>
                                        <span style={{ fontSize: '0.65rem', color: '#6366f1', fontWeight: 'bold' }}>Unique</span>
                                    </div>
                                    <div style={{ display: 'flex', alignItems: 'center', marginRight: '0.5rem', paddingRight: '0.5rem', borderRight: '1px solid #a5b4fc' }}>
                                        <span style={{ fontSize: '1.1rem', fontWeight: 'bold', color: '#059669', marginRight: '0.2rem' }}>{weekStats.newPlaysCount}</span>
                                        <span style={{ fontSize: '0.65rem', color: '#6366f1', fontWeight: 'bold' }}>New</span>
                                    </div>
                                    <div style={{ display: 'flex', alignItems: 'center' }}>
                                        <span style={{ fontSize: '1.1rem', fontWeight: 'bold', color: '#6366f1', marginRight: '0.2rem' }}>{weekStats.totalScriptSlots}</span>
                                        <span style={{ fontSize: '0.65rem', color: '#6366f1', fontWeight: 'bold' }}>Scripts</span>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Tabs */}
                        <div style={{ display: 'flex', borderBottom: '1px solid #e2e8f0' }}>
                            {['Full Playbook', 'Game Plan', 'Install', 'Suggestions'].map(tab => {
                                const key = tab === 'Full Playbook' ? 'usage' : tab === 'Game Plan' ? 'gameplan' : tab === 'Install' ? 'install' : 'suggestions';
                                const isActive = activeTab === key;
                                // Count total suggestions
                                const suggestionCount = key === 'suggestions' ? Object.values(suggestions || {}).reduce((sum, arr) => sum + (arr?.length || 0), 0) : 0;
                                return (
                                    <div
                                        key={key}
                                        onClick={() => setActiveTab(key)}
                                        style={{
                                            flex: 1,
                                            textAlign: 'center',
                                            padding: '8px 4px',
                                            fontSize: '0.75rem',
                                            fontWeight: '600',
                                            color: isActive ? '#0f172a' : '#64748b',
                                            borderBottom: isActive ? '2px solid #0f172a' : '2px solid transparent',
                                            cursor: 'pointer',
                                            background: isActive ? 'white' : '#f8fafc',
                                            position: 'relative'
                                        }}
                                    >
                                        {tab}
                                        {key === 'suggestions' && suggestionCount > 0 && (
                                            <span style={{
                                                position: 'absolute',
                                                top: '2px',
                                                right: '4px',
                                                background: '#ef4444',
                                                color: 'white',
                                                fontSize: '0.6rem',
                                                fontWeight: '700',
                                                padding: '1px 4px',
                                                borderRadius: '8px',
                                                minWidth: '14px'
                                            }}>{suggestionCount}</span>
                                        )}
                                    </div>
                                );
                            })}
                        </div>

                        {/* Content */}
                        {activeTab === 'usage' && (
                            <>
                                <div style={{ padding: '0.5rem' }}>
                                    <input
                                        placeholder="Add / Search..."
                                        value={quickAddValue}
                                        onChange={e => {
                                            setQuickAddValue(e.target.value.toUpperCase());
                                            setSearchTerm(e.target.value.toUpperCase());
                                        }}
                                        onKeyDown={e => {
                                            if (e.key === 'Enter' && quickAddValue) {
                                                onQuickAddPlay(quickAddValue);
                                                setQuickAddValue('');
                                                setSearchTerm('');
                                            }
                                        }}
                                        style={{ width: '100%', padding: '6px', borderRadius: '4px', border: '1px solid #cbd5e1', fontSize: '0.85rem' }}
                                    />
                                </div>

                                <div style={{ flex: 1, overflowY: 'auto', padding: '0 0.75rem 0.75rem' }}>
                                    {/* Header Row */}
                                    <div style={{ display: 'flex', alignItems: 'center', paddingBottom: '4px', marginRight: '10px' }}>
                                        <div style={{ flex: 1 }}></div>
                                        <div style={{ display: 'flex', gap: '2px', marginLeft: '8px' }}>
                                            {['M', 'T', 'W', 'TH', 'F'].map(day => (
                                                <div key={day} style={{ width: '18px', textAlign: 'center', fontSize: '0.6rem', fontWeight: 'bold', color: '#64748b' }}>
                                                    {day}
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                    {usageData.length > 0 ? (
                                        usageData.map(category => {
                                            const isCatExpanded = expandedSections[`cat-usage-${category.id}`];
                                            return (
                                                <div key={category.id} style={{ marginBottom: '8px' }}>
                                                    <div
                                                        onClick={() => toggleSection(`cat-usage-${category.id}`)}
                                                        style={{
                                                            padding: '8px 10px',
                                                            background: category.color || '#3b82f6',
                                                            cursor: 'pointer',
                                                            display: 'flex',
                                                            alignItems: 'center',
                                                            justifyContent: 'space-between',
                                                            borderRadius: '4px',
                                                            marginBottom: '2px'
                                                        }}
                                                    >
                                                        <span style={{ fontSize: '0.8rem', fontWeight: '700', color: 'white', textTransform: 'uppercase' }}>
                                                            {category.label}
                                                        </span>
                                                        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                                            <span style={{ fontSize: '0.65rem', color: 'white', opacity: 0.9 }}>{category.totalPlays}</span>
                                                            <Icon name={isCatExpanded ? "ChevronDown" : "ChevronRight"} size={14} color="white" />
                                                        </div>
                                                    </div>

                                                    {isCatExpanded && (
                                                        <div style={{ marginLeft: '8px', borderLeft: `2px solid ${category.color || '#3b82f6'}`, paddingLeft: '6px', paddingTop: '4px' }}>
                                                            {category.totalPlays > 0 && category.id !== 'unassigned' && (
                                                    <button
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            const allPlayIds = category.families.flatMap(f => f.plays.map(p => p.id));
                                                            onAddSection(allPlayIds);
                                                        }}
                                                        style={{
                                                            width: '100%',
                                                            marginBottom: '8px',
                                                            fontSize: '0.7rem',
                                                            padding: '6px',
                                                            background: 'white',
                                                            color: '#1e293b',
                                                            border: `1px solid ${category.color || '#3b82f6'}`,
                                                            borderRadius: '4px',
                                                            fontWeight: '700',
                                                            cursor: 'pointer',
                                                            display: 'flex',
                                                            alignItems: 'center',
                                                            justifyContent: 'center',
                                                            gap: '4px'
                                                        }}
                                                    >
                                                        <Icon name="PlusCircle" size={14} /> Add all to script ({category.totalPlays})
                                                    </button>
                                                )}
                                                {category.families.map(family => {
                                                                const isFamExpanded = expandedSections[`fam-usage-${family.id}`];
                                                                return (
                                                                    <div key={family.id} style={{ marginBottom: '4px', border: '1px solid #e2e8f0', borderRadius: '4px', overflow: 'hidden' }}>
                                                                        <div
                                                                            onClick={() => toggleSection(`fam-usage-${family.id}`)}
                                                                            style={{ padding: '6px 8px', background: '#f8fafc', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}
                                                                        >
                                                                            <span style={{ fontSize: '0.75rem', fontWeight: '600', color: '#1e293b' }}>{family.label || family.name}</span>
                                                                            <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                                                                                <span style={{ fontSize: '0.65rem', color: '#64748b' }}>{family.plays.length}</span>
                                                                                <Icon name={isFamExpanded ? "ChevronDown" : "ChevronRight"} size={12} color="#64748b" />
                                                                            </div>
                                                                        </div>
                                                                        {isFamExpanded && (
                                                                            <div style={{ padding: '4px 8px', borderTop: '1px solid #e2e8f0', background: 'white' }}>
                                                                                {family.plays.length > 0 && category.id !== 'unassigned' && (
                                                                        <button
                                                                            onClick={(e) => {
                                                                                e.stopPropagation();
                                                                                const familyPlayIds = family.plays.map(p => p.id);
                                                                                onAddSection(familyPlayIds);
                                                                            }}
                                                                            style={{
                                                                                width: '100%',
                                                                                marginBottom: '6px',
                                                                                fontSize: '0.65rem',
                                                                                padding: '4px',
                                                                                background: '#f1f5f9',
                                                                                color: '#1e293b',
                                                                                border: '1px solid #cbd5e1',
                                                                                borderRadius: '4px',
                                                                                fontWeight: '700',
                                                                                cursor: 'pointer',
                                                                                display: 'flex',
                                                                                alignItems: 'center',
                                                                                justifyContent: 'center',
                                                                                gap: '4px'
                                                                            }}
                                                                        >
                                                                            <Icon name="Plus" size={12} /> Add all to script ({family.plays.length})
                                                                        </button>
                                                                    )}
                                                                    {/* Quick Add to this family (hide for unassigned) */}
                                                                    {category.id !== 'unassigned' && (
                                                                    <div style={{ marginBottom: '6px' }}>
                                                                        <input
                                                                            placeholder="+ Add play to family..."
                                                                            value={quickAddInputs[`usage-${family.id}`] || ''}
                                                                            onChange={e => setQuickAddInputs(prev => ({ ...prev, [`usage-${family.id}`]: e.target.value.toUpperCase() }))}
                                                                            onKeyDown={e => {
                                                                                if (e.key === 'Enter' && quickAddInputs[`usage-${family.id}`]) {
                                                                                    handleQuickAddToBucket(quickAddInputs[`usage-${family.id}`], family.id);
                                                                                    setQuickAddInputs(prev => ({ ...prev, [`usage-${family.id}`]: '' }));
                                                                                }
                                                                            }}
                                                                            onClick={e => e.stopPropagation()}
                                                                            style={{
                                                                                width: '100%',
                                                                                padding: '4px 8px',
                                                                                fontSize: '0.7rem',
                                                                                border: '1px dashed #cbd5e1',
                                                                                borderRadius: '4px',
                                                                                background: '#fafafa'
                                                                            }}
                                                                        />
                                                                    </div>
                                                                    )}
                                                                    {family.plays.map(renderRow)}
                                                                            </div>
                                                                        )}
                                                                    </div>
                                                                );
                                                            })}
                                                        </div>
                                                    )}
                                                </div>
                                            );
                                        })
                                    ) : (
                                        <div style={{ padding: '2rem', textAlign: 'center', color: '#94a3b8', fontSize: '0.85rem' }}>
                                            No plays found matching "{searchTerm}"
                                        </div>
                                    )}
                                </div>
                            </>
                        )}

                        {activeTab === 'gameplan' && renderGamePlanContent()}


                        {activeTab === 'install' && renderInstallContent()}

                        {/* Suggestions Tab Content */}
                        {activeTab === 'suggestions' && (
                            <div style={{ flex: 1, overflowY: 'auto', padding: '0.75rem' }}>
                                {Object.keys(suggestions || {}).length === 0 ? (
                                    <div style={{ textAlign: 'center', padding: '2rem 1rem', color: '#64748b' }}>
                                        <Icon name="MessageSquare" size={32} style={{ marginBottom: '0.5rem', opacity: 0.5 }} />
                                        <p style={{ fontSize: '0.85rem', margin: 0 }}>No suggestions yet</p>
                                        <p style={{ fontSize: '0.75rem', margin: '0.25rem 0 0' }}>Assistant coaches can suggest plays from the play details modal</p>
                                    </div>
                                ) : (
                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                                        {(gamePlanLayouts?.CALL_SHEET?.sections || []).map((section, sIdx) => {
                                            const sectionSuggestions = (section.boxes || []).filter(box =>
                                                box.setId && suggestions[box.setId]?.length > 0
                                            );
                                            if (sectionSuggestions.length === 0) return null;

                                            return (
                                                <div key={sIdx}>
                                                    <div style={{ fontSize: '0.7rem', fontWeight: '700', color: '#94a3b8', marginBottom: '0.5rem', textTransform: 'uppercase' }}>
                                                        {section.title || `Section ${sIdx + 1}`}
                                                    </div>
                                                    {sectionSuggestions.map((box, bIdx) => (
                                                        <div key={bIdx} style={{ marginBottom: '0.5rem' }}>
                                                            <div style={{
                                                                fontSize: '0.75rem',
                                                                fontWeight: '600',
                                                                color: box.color || '#3b82f6',
                                                                marginBottom: '0.25rem',
                                                                display: 'flex',
                                                                alignItems: 'center',
                                                                gap: '0.25rem'
                                                            }}>
                                                                {box.header}
                                                                <span style={{
                                                                    background: '#fef2f2',
                                                                    color: '#ef4444',
                                                                    fontSize: '0.65rem',
                                                                    padding: '1px 4px',
                                                                    borderRadius: '4px'
                                                                }}>
                                                                    {suggestions[box.setId].length}
                                                                </span>
                                                            </div>
                                                            {suggestions[box.setId].map((playId, pIdx) => {
                                                                const play = plays.find(p => p.id === playId);
                                                                if (!play) return null;
                                                                return (
                                                                    <div
                                                                        key={pIdx}
                                                                        style={{
                                                                            fontSize: '0.8rem',
                                                                            padding: '4px 8px',
                                                                            background: '#fef2f2',
                                                                            borderRadius: '4px',
                                                                            marginBottom: '2px',
                                                                            display: 'flex',
                                                                            justifyContent: 'space-between',
                                                                            alignItems: 'center'
                                                                        }}
                                                                    >
                                                                        <span
                                                                            style={{ cursor: 'pointer' }}
                                                                            onClick={() => setSituationModalPlayId(playId)}
                                                                        >
                                                                            {play.name}
                                                                        </span>
                                                                        <div style={{ display: 'flex', gap: '4px' }}>
                                                                            <button
                                                                                onClick={() => {
                                                                                    // Accept: add to quick list and remove from suggestions
                                                                                    handleAssignSituation(playId, box);
                                                                                    if (onUpdateSuggestions) {
                                                                                        const newSuggestions = { ...suggestions };
                                                                                        newSuggestions[box.setId] = newSuggestions[box.setId].filter(id => id !== playId);
                                                                                        if (newSuggestions[box.setId].length === 0) delete newSuggestions[box.setId];
                                                                                        onUpdateSuggestions(newSuggestions);
                                                                                    }
                                                                                }}
                                                                                style={{
                                                                                    background: '#22c55e',
                                                                                    color: 'white',
                                                                                    border: 'none',
                                                                                    borderRadius: '4px',
                                                                                    padding: '2px 6px',
                                                                                    fontSize: '0.65rem',
                                                                                    cursor: 'pointer'
                                                                                }}
                                                                                title="Accept suggestion"
                                                                            >
                                                                                ✓
                                                                            </button>
                                                                            <button
                                                                                onClick={() => {
                                                                                    // Dismiss: just remove from suggestions
                                                                                    if (onUpdateSuggestions) {
                                                                                        const newSuggestions = { ...suggestions };
                                                                                        newSuggestions[box.setId] = newSuggestions[box.setId].filter(id => id !== playId);
                                                                                        if (newSuggestions[box.setId].length === 0) delete newSuggestions[box.setId];
                                                                                        onUpdateSuggestions(newSuggestions);
                                                                                    }
                                                                                }}
                                                                                style={{
                                                                                    background: '#ef4444',
                                                                                    color: 'white',
                                                                                    border: 'none',
                                                                                    borderRadius: '4px',
                                                                                    padding: '2px 6px',
                                                                                    fontSize: '0.65rem',
                                                                                    cursor: 'pointer'
                                                                                }}
                                                                                title="Dismiss suggestion"
                                                                            >
                                                                                ✕
                                                                            </button>
                                                                        </div>
                                                                    </div>
                                                                );
                                                            })}
                                                        </div>
                                                    ))}
                                                </div>
                                            );
                                        })}
                                    </div>
                                )}
                            </div>
                        )}
                    </div>

                    {situationModalPlayId && (
                        <PlayDetailsModal
                            playId={situationModalPlayId}
                            onClose={() => setSituationModalPlayId(null)}
                            plays={plays}
                            gamePlanLayouts={gamePlanLayouts}
                            onUpdatePlay={onUpdatePlay}
                            onAssignSituation={(playId, situationId, type) => {
                                handleAssignSituation(playId, situationId, type);
                            }}
                            onSuggest={onUpdateSuggestions ? (playId, setId) => {
                                const newSuggestions = { ...suggestions };
                                if (!newSuggestions[setId]) newSuggestions[setId] = [];
                                if (newSuggestions[setId].includes(playId)) {
                                    // Toggle off
                                    newSuggestions[setId] = newSuggestions[setId].filter(id => id !== playId);
                                    if (newSuggestions[setId].length === 0) delete newSuggestions[setId];
                                } else {
                                    // Add suggestion
                                    newSuggestions[setId].push(playId);
                                }
                                onUpdateSuggestions(newSuggestions);
                            } : null}
                            suggestions={suggestions}
                            playBuckets={playBuckets}
                            playCategories={playCategories}
                            currentWeek={currentWeek}
                        />
                    )}
                </div>
            );
        };



        const OffensiveGamePlan = ({ plays, weekDate, gamePlan, practicePlans = {}, onUpdateGamePlan, onQuickAddPlay, onUpdatePlay, gamePlanLayouts = GAME_PLAN_LAYOUTS, onUpdateLayouts, isLocked, layoutVersions = {}, onSaveLayoutVersion, onDeleteLayoutVersion, onLoadLayoutVersion, wbSettings, newInstallIds = [], onUpdateWeek, weeks = [], currentWeek = {}, playCategories = [], playBuckets = [], setAppSidebarCollapsed, appSidebarCollapsed, addToNextSlotRef, teamLogo, positionNames = {}, customPositions = {}, hiddenPositions = {}, suggestions = {}, onUpdateSuggestions }) => {
            const { openPlayDetails } = usePlayDetailsModal();
            const [layoutSaveState, setLayoutSaveState] = useState({ isSaving: false, name: '' });
            const [layoutConfirmAction, setLayoutConfirmAction] = useState(null); // { type: 'load'|'delete', name: 'versionName' }
            const [showLayoutVersions, setShowLayoutVersions] = useState(false);
            const [assignmentModalState, setAssignmentModalState] = useState(null); // { playId, x, y }
            const [showImportModal, setShowImportModal] = useState(false);
            const [importSourceWeekId, setImportSourceWeekId] = useState('');

            const [viewMode, setViewMode] = useState('sheet'); // 'sheet', 'matrix', 'list'
            const [selectedSetId, setSelectedSetId] = useState(null);
            const [showPlaySelector, setShowPlaySelector] = useState(false);
            const [playSelectorFilters, setPlaySelectorFilters] = useState({ formation: '', concept: '', tag: '', situation: '' });

            // Side Menu State
            const [showSideMenu, setShowSideMenu] = useState(false);

            // Box Editor Modal State (moved here for useEffect access)
            const [editingBox, setEditingBox] = useState(null); // { sectionIdx, boxIdx, box }

            // Function to toggle side menu and collapse global sidebar
            const handleToggleSideMenu = (newState) => {
                setShowSideMenu(newState);
                if (newState && setAppSidebarCollapsed) {
                    setAppSidebarCollapsed(true);
                }
            };

            // Effect to close right side menu when left sidebar is expanded
            useEffect(() => {
                if (!appSidebarCollapsed && showSideMenu) {
                    setShowSideMenu(false);
                }
            }, [appSidebarCollapsed, showSideMenu]);

            // Register "add to next slot" handler for sidebar
            // Supports both single playId or array of playIds for batch additions
            useEffect(() => {
                if (addToNextSlotRef) {
                    addToNextSlotRef.current = (playIdOrIds, play) => {
                        // Support both single playId and array of playIds
                        const playIds = Array.isArray(playIdOrIds) ? playIdOrIds : [playIdOrIds];

                        // If a box is being edited in the modal, add to its script slots
                        if (editingBox && gamePlanLayouts?.CALL_SHEET?.sections) {
                            const { sectionIdx, boxIdx } = editingBox;
                            const section = gamePlanLayouts.CALL_SHEET.sections[sectionIdx];
                            if (section && section.boxes && section.boxes[boxIdx]) {
                                const box = section.boxes[boxIdx];

                                // Update layouts in a single update for all plays
                                const newLayouts = JSON.parse(JSON.stringify(gamePlanLayouts));
                                const targetBox = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];

                                if (box.type === 'grid') {
                                    // Grid box: add to assignedPlayIds
                                    const cols = targetBox.gridColumns || 4;
                                    const rowsCount = targetBox.gridRows || 5;
                                    const totalSlots = cols * rowsCount;

                                    if (!targetBox.assignedPlayIds) targetBox.assignedPlayIds = [];
                                    while (targetBox.assignedPlayIds.length < totalSlots) {
                                        targetBox.assignedPlayIds.push('GAP');
                                    }

                                    for (const pId of playIds) {
                                        let added = false;
                                        for (let i = 0; i < totalSlots; i++) {
                                            if (!targetBox.assignedPlayIds[i] || targetBox.assignedPlayIds[i] === 'GAP') {
                                                targetBox.assignedPlayIds[i] = pId;
                                                added = true;
                                                break;
                                            }
                                        }
                                        if (!added) break;
                                    }
                                } else {
                                    // Script box: add to rows (left hash first, then right hash)
                                    if (!targetBox.rows || targetBox.rows.length === 0) {
                                        targetBox.rows = [{ id: Date.now(), label: '1', content: '', contentRight: '' }];
                                    }

                                    for (const pId of playIds) {
                                        let added = false;

                                        // Find first empty slot
                                        for (let i = 0; i < targetBox.rows.length; i++) {
                                            if (!targetBox.rows[i].content) {
                                                targetBox.rows[i].content = pId;
                                                added = true;
                                                break;
                                            }
                                            if (!targetBox.rows[i].contentRight) {
                                                targetBox.rows[i].contentRight = pId;
                                                added = true;
                                                break;
                                            }
                                        }

                                        // If no empty slot, add new row
                                        if (!added) {
                                            targetBox.rows.push({
                                                id: Date.now() + targetBox.rows.length,
                                                label: (targetBox.rows.length + 1).toString(),
                                                content: pId,
                                                contentRight: ''
                                            });
                                        }
                                    }
                                }

                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);

                                // Also sync to game plan data model
                                if (box.setId && onUpdateGamePlan && gamePlan) {
                                    const allIds = [];
                                    if (targetBox.assignedPlayIds) {
                                        targetBox.assignedPlayIds.forEach(id => {
                                            if (id && id !== 'GAP') allIds.push(id);
                                        });
                                    } else if (targetBox.rows) {
                                        targetBox.rows.forEach(r => {
                                            if (r.content) allIds.push(r.content);
                                            if (r.contentRight) allIds.push(r.contentRight);
                                        });
                                    }

                                    const collectionKey = box.type === 'script' ? 'miniScripts' : 'sets';
                                    let collection = Array.isArray(gamePlan[collectionKey]) ? [...gamePlan[collectionKey]] : [];

                                    const existingIndex = collection.findIndex(item => item.id === box.setId);
                                    if (existingIndex >= 0) {
                                        collection[existingIndex] = { ...collection[existingIndex], playIds: allIds };
                                    } else {
                                        collection.push({ id: box.setId, playIds: allIds, assignedPlayIds: [] });
                                    }

                                    onUpdateGamePlan({ ...gamePlan, [collectionKey]: collection });
                                }
                                return;
                            }
                        }

                        // Fallback: Add plays to the selected set's quicklist, or first available set
                        const targetSetId = selectedSetId || (gamePlanLayouts?.CALL_SHEET?.sections?.[0]?.boxes?.[0]?.setId);
                        if (!targetSetId) return;

                        const sets = { ...(gamePlan?.sets || {}) };
                        if (!sets[targetSetId]) {
                            sets[targetSetId] = { id: targetSetId, playIds: [] };
                        }
                        if (!sets[targetSetId].playIds) {
                            sets[targetSetId].playIds = [];
                        }

                        let changed = false;
                        for (const pId of playIds) {
                            if (!sets[targetSetId].playIds.includes(pId)) {
                                sets[targetSetId].playIds = [...sets[targetSetId].playIds, pId];
                                changed = true;
                            }
                        }
                        if (changed) {
                            onUpdateGamePlan({ ...gamePlan, sets });
                        }
                    };
                }
                return () => {
                    if (addToNextSlotRef) addToNextSlotRef.current = null;
                };
            }, [addToNextSlotRef, selectedSetId, gamePlan, gamePlanLayouts, onUpdateGamePlan, editingBox, onUpdateLayouts]);

            // For Wristband Autocomplete
            const [showWristband, setShowWristband] = useState(true);
            const [wristbandFocus, setWristbandFocus] = useState(null);
            const [wbAutocomplete, setWbAutocomplete] = useState({ playId: null, query: '' });
            const [showPrintPreview, setShowPrintPreview] = useState(false); // Print Preview Toggle
            const [printPreviewTab, setPrintPreviewTab] = useState('staples'); // Selected tab for print preview
            const [printScale, setPrintScale] = useState(0.85); // Default to 85% for better fit
            const [printOrientation, setPrintOrientation] = useState('portrait'); // portrait or landscape

            const effectiveBuckets = useMemo(() => {
                if (playCategories && playCategories.length > 0) return playCategories;
                return [
                    { id: 'run', label: 'Run', color: '#10b981', textColor: '#ffffff' },
                    { id: 'pass', label: 'Pass', color: '#3b82f6', textColor: '#ffffff' },
                    { id: 'screen', label: 'Screen', color: '#8b5cf6', textColor: '#ffffff' }
                ];
            }, [playCategories]);

            const validWristbandSlots = useMemo(() => {
                if (!wbSettings) return [];
                const slots = [];
                const cardKeys = ['card1', 'card2', 'card3', 'card4', 'card5', 'card6'];
                for (const key of cardKeys) {
                    const card = wbSettings[key];
                    if (!card) continue;
                    const cardNum = parseInt(key.replace('card', ''));

                    if (card.type && (card.type === 'wiz')) {
                        // Wiz: Series X, 01-16
                        for (let i = 1; i <= 16; i++) {
                            slots.push(`${cardNum}${String(i).padStart(2, '0')}`);
                        }
                    } else {
                        // Standard/Modular: 48 slots per card (X01-X48)
                        const start = cardNum * 100 + 1;
                        const end = start + 47;
                        for (let i = start; i <= end; i++) slots.push(String(i));
                    }
                }
                return slots;
            }, [wbSettings]);

            const assignedSlots = useMemo(() => {
                const set = new Set();
                if (plays) {
                    plays.forEach(p => {
                        if (p.wristbandSlot) set.add(p.wristbandSlot);
                    });
                }
                return set;
            }, [plays]);

            // Calculate week stats for sidebar
            const weekStats = useMemo(() => {
                // Calculate unique plays in game plan
                const allGamePlanPlayIds = new Set();
                Object.values(gamePlan?.sets || {}).forEach(set => {
                    (set.playIds || []).forEach(item => {
                        const id = typeof item === 'object' ? item.id : item;
                        if (id) allGamePlanPlayIds.add(id);
                    });
                });
                Object.values(gamePlan?.miniScripts || {}).forEach(script => {
                    (script.playIds || []).forEach(item => {
                        const id = typeof item === 'object' ? item.id : item;
                        if (id) allGamePlanPlayIds.add(id);
                    });
                });
                const uniquePlaysCount = allGamePlanPlayIds.size;

                // Calculate new plays (plays added this week that weren't in previous weeks)
                const previousWeekPlayIds = new Set();
                weeks.forEach(w => {
                    if (w.weekNumber < currentWeek.weekNumber) {
                        const prevGamePlan = w.gamePlan || {};
                        Object.values(prevGamePlan.sets || {}).forEach(set => {
                            (set.playIds || []).forEach(item => {
                                const id = typeof item === 'object' ? item.id : item;
                                if (id) previousWeekPlayIds.add(id);
                            });
                        });
                        Object.values(prevGamePlan.miniScripts || {}).forEach(script => {
                            (script.playIds || []).forEach(item => {
                                const id = typeof item === 'object' ? item.id : item;
                                if (id) previousWeekPlayIds.add(id);
                            });
                        });
                    }
                });
                const newPlaysCount = Array.from(allGamePlanPlayIds).filter(id => !previousWeekPlayIds.has(id)).length;

                // Calculate total practice script slots for the week
                let totalScriptSlots = 0;
                const plansList = Array.isArray(practicePlans) ? practicePlans : Object.values(practicePlans || {});
                plansList.forEach(plan => {
                    plan.segments.forEach(seg => {
                        if (seg.hasScript && seg.script && seg.script.length > 0) {
                            totalScriptSlots += seg.script.length;
                        }
                    });
                });

                return { uniquePlaysCount, newPlaysCount, totalScriptSlots };
            }, [gamePlan, weeks, currentWeek, practicePlans]);

            // Auto-Assign Priority Plays to Categories based on Type
            useEffect(() => {
                if (isLocked || !gamePlan) return;

                const priorityCategories = gamePlan.priorityCategories || {};
                const categorizedIds = new Set(Object.values(priorityCategories).flat());

                // Filter for unassigned priority plays with types
                const unassigned = plays.filter(p => p.priority && p.type && !categorizedIds.has(p.id));

                if (unassigned.length === 0) return;

                // Dynamic Mapping from Play Type to Category ID
                // We assume Play Type matches Category ID (normalized) or Label
                const typeToCat = {};
                (playCategories.length > 0 ? playCategories : DEFAULT_PLAY_CATEGORIES).forEach(cat => {
                    typeToCat[cat.label] = cat.id;
                    typeToCat[cat.id] = cat.id;
                    typeToCat[cat.label.toUpperCase()] = cat.id; // Handle uppercase types
                    typeToCat[cat.id.toUpperCase()] = cat.id;
                });

                // Fallback for known hardcoded types if they differ from category IDs
                typeToCat['RPO'] = 'rpo';
                typeToCat['QUICK'] = 'quick';
                typeToCat['INTER'] = 'intermediate';
                typeToCat['SHOT'] = 'deep';
                typeToCat['Screen'] = 'screen';
                typeToCat['GADGET'] = 'gadget';


                let updates = null;

                unassigned.forEach(p => {
                    const catId = typeToCat[p.type] || typeToCat[p.type.toUpperCase()];
                    // Verify the target category actually exists in our list (to avoid junk data)
                    const targetExists = (playCategories.length > 0 ? playCategories : DEFAULT_PLAY_CATEGORIES).some(c => c.id === catId);

                    if (catId && targetExists) {
                        if (!updates) updates = { ...priorityCategories };
                        updates[catId] = [...(updates[catId] || []), p.id];
                    }
                });

                if (updates) {
                    onUpdateGamePlan({ ...gamePlan, priorityCategories: updates });
                }

            }, [plays, gamePlan, isLocked, onUpdateGamePlan, playCategories]);

            // Import Handler
            const handleImportGamePlan = () => {
                if (!importSourceWeekId) return;
                const sourceWeek = weeks.find(w => w.id === importSourceWeekId);
                if (sourceWeek) {
                    if (confirm(`Import Game Plan from ${sourceWeek.name}? This will REPLACE current Game Plan and Call Sheet data.`)) {
                        // Deep copy ensures we don't link by reference
                        const newGamePlan = sourceWeek.offensiveGamePlan ? JSON.parse(JSON.stringify(sourceWeek.offensiveGamePlan)) : { sets: [] };
                        const newDumbData = sourceWeek.dumbCallSheetData ? JSON.parse(JSON.stringify(sourceWeek.dumbCallSheetData)) : {};
                        const newLayouts = sourceWeek.gamePlanLayouts ? JSON.parse(JSON.stringify(sourceWeek.gamePlanLayouts)) : null;

                        if (onUpdateWeek) {
                            onUpdateWeek(currentWeek.id, 'offensiveGamePlan', newGamePlan);
                            onUpdateWeek(currentWeek.id, 'dumbCallSheetData', newDumbData);
                            if (newLayouts) onUpdateWeek(currentWeek.id, 'gamePlanLayouts', newLayouts);
                        }
                        setShowImportModal(false);
                    }
                }
            };

            const handleClearGamePlan = () => {
                const confirm = window.prompt(`Are you sure you want to CLEAR the entire Game Plan and Call Sheet for this week? This cannot be undone.\n\nType "delete" to confirm.`);
                if (confirm && confirm.trim().toLowerCase() !== 'delete') return;

                // 1. Clear Week Data (Sets, Dumb Data)
                if (onUpdateWeek) {
                    onUpdateWeek(currentWeek.id, 'offensiveGamePlan', { sets: [], miniScripts: [] });
                    onUpdateWeek(currentWeek.id, 'dumbCallSheetData', {});
                }

                // 2. Clear Layout Content (Scripts & Grids stored in Layouts)
                if (onUpdateLayouts && gamePlanLayouts) {
                    const newLayouts = JSON.parse(JSON.stringify(gamePlanLayouts));
                    if (newLayouts.CALL_SHEET && newLayouts.CALL_SHEET.sections) {
                        newLayouts.CALL_SHEET.sections.forEach(section => {
                            if (section.boxes) {
                                section.boxes.forEach(box => {
                                    // Clear Script Rows
                                    if (box.rows) {
                                        box.rows.forEach(row => {
                                            row.content = '';
                                            if (row.contentRight) row.contentRight = '';
                                        });
                                    }
                                    // Clear Grid Assignments
                                    if (box.assignedPlayIds) {
                                        box.assignedPlayIds = [];
                                    }
                                });
                            }
                        });
                    }
                    onUpdateLayouts(newLayouts);
                }
            };

            // For Matrix/Grid Cell Editing
            const [activeCellSetId, setActiveCellSetId] = useState(null); // The setId currently being edited via modal
            const [editingFormationId, setEditingFormationId] = useState(null); // ID of formation currently being renamed

            const [isCreatingScript, setIsCreatingScript] = useState(false); // For inline script creation
            const [confirmDeleteScriptId, setConfirmDeleteScriptId] = useState(null); // For inline delete confirmation
            const [configuringSection, setConfiguringSection] = useState(null); // { idx: number }

            // For Strike 'Em Out matrix collapsible groups
            const [collapsedGroups, setCollapsedGroups] = useState(new Set());
            const [collapsedRows, setCollapsedRows] = useState(new Set());

            // For Strike 'Em Out matrix collapsible hash columns (LEFT/RIGHT)
            const [collapsedHashColumns, setCollapsedHashColumns] = useState(() => {
                const saved = localStorage.getItem('collapsedHashColumns_strikeEmOut');
                return saved ? new Set(JSON.parse(saved)) : new Set();
            });

            const toggleRow = (rowId) => {
                setCollapsedRows(prev => {
                    const newCollapsed = new Set(prev);
                    if (newCollapsed.has(rowId)) {
                        newCollapsed.delete(rowId);
                    } else {
                        newCollapsed.add(rowId);
                    }
                    return newCollapsed;
                });
            };

            const toggleHashColumn = (groupId, hashSide) => {
                const key = `${groupId}_${hashSide}`;
                setCollapsedHashColumns(prev => {
                    const newSet = new Set(prev);
                    if (newSet.has(key)) {
                        newSet.delete(key);
                    } else {
                        newSet.add(key);
                    }
                    localStorage.setItem('collapsedHashColumns_strikeEmOut', JSON.stringify([...newSet]));
                    return newSet;
                });
            };

            // For FZDnD collapsible rows
            const [collapsedFZDnDRows, setCollapsedFZDnDRows] = useState(new Set());

            const toggleFZDnDRow = (zoneId, rowIdx) => {
                const key = `${zoneId}_${rowIdx}`;
                setCollapsedFZDnDRows(prev => {
                    const newCollapsed = new Set(prev);
                    if (newCollapsed.has(key)) {
                        newCollapsed.delete(key);
                    } else {
                        newCollapsed.add(key);
                    }
                    return newCollapsed;
                });
            };

            // For FZDnD autocomplete input
            const [fzdndAutocomplete, setFzdndAutocomplete] = useState({
                zoneId: null,
                rowIdx: null,
                colIdx: null,
                query: ''
            });

            // For FZDnD wristband autocomplete
            const [fzdndWbAutocomplete, setFzdndWbAutocomplete] = useState({
                playId: null,
                query: ''
            });

            // Helper to get wristband type indicator (T/W/M) for a slot
            const getWristbandTypeIndicator = (slot) => {
                if (!wbSettings || !slot) return '';

                // Determine which card this slot belongs to
                const cardKeys = ['card1', 'card2', 'card3', 'card4', 'card5', 'card6'];
                for (const key of cardKeys) {
                    const card = wbSettings[key];
                    if (!card) continue;
                    const cardNum = parseInt(key.replace('card', ''));

                    // Check if this slot belongs to this card
                    if (card.type && (card.type === 'wiz')) {
                        // Wiz cards: X01-X16 format
                        const slotPattern = new RegExp(`^${cardNum}(0[1-9]|1[0-6])$`);
                        if (slotPattern.test(slot)) {
                            return 'W'; // Wrist Coach (Wiz)
                        }
                    } else {
                        // Standard/Modular cards: X01-X48 format
                        const start = cardNum * 100 + 1;
                        const end = start + 47;
                        const slotNum = parseInt(slot);
                        if (slotNum >= start && slotNum <= end) {
                            // Determine if it's mini-scripts (modular) or traditional
                            if (card.type === 'mini-scripts') {
                                return 'M'; // Modular
                            } else {
                                return 'T'; // Traditional
                            }
                        }
                    }
                }
                return '';
            };

            // Helper to create new play from FZDnD autocomplete
            const createFZDnDPlay = (playName, zoneId, rowIdx, colIdx) => {
                if (!onQuickAddPlay) return;

                // Create the play using the quick add function
                const newPlay = onQuickAddPlay(playName.trim());

                // Assign to cell
                assignPlayToFZDnDCell(zoneId, rowIdx, colIdx, newPlay.id);

                // Reset autocomplete
                setFzdndAutocomplete({ zoneId: null, rowIdx: null, colIdx: null, query: '' });
            };

            // Helper to assign play to FZDnD cell
            const assignPlayToFZDnDCell = (zoneId, rowIdx, colIdx, playId) => {
                const setId = `fzdnd_${zoneId}_${colIdx}`;
                let sets = [...(gamePlan?.sets || [])];
                let set = sets.find(s => s.id === setId);

                if (!set) {
                    set = { id: setId, playIds: [] };
                    sets.push(set);
                }

                // Ensure playIds array has at least rowIdx + 1 elements
                while (set.playIds.length <= rowIdx) {
                    set.playIds.push(null);
                }

                // Set the play at this row index
                set.playIds[rowIdx] = playId;

                onUpdateGamePlan({ ...gamePlan, sets });

                // Reset autocomplete
                setFzdndAutocomplete({ zoneId: null, rowIdx: null, colIdx: null, query: '' });
            };

            // Helper to get play objects for a set ID
            const getPlaysForSet = (setId) => {
                let set = null;
                // Handle sets as array or object
                if (Array.isArray(gamePlan?.sets)) {
                    set = gamePlan.sets.find(s => s.id === setId);
                } else if (gamePlan?.sets && typeof gamePlan.sets === 'object') {
                    set = Object.values(gamePlan.sets).find(s => s.id === setId) || gamePlan.sets[setId];
                }
                if (!set && setId.startsWith('ms_')) {
                    if (Array.isArray(gamePlan?.miniScripts)) {
                        set = gamePlan.miniScripts.find(s => s.id === setId);
                    } else if (gamePlan?.miniScripts && typeof gamePlan.miniScripts === 'object') {
                        set = Object.values(gamePlan.miniScripts).find(s => s.id === setId) || gamePlan.miniScripts[setId];
                    }
                }
                if (!set) return [];
                return set.playIds.map((item, idx) => {
                    if (item === 'GAP') return null;

                    // Handle String ID (Legacy)
                    if (typeof item === 'string') {
                        if (item.startsWith('NOTE:')) {
                            return { id: item, name: item.replace('NOTE:', ''), type: 'note', _index: idx, _raw: item };
                        }
                        const play = plays.find(p => p.id === item);
                        return play ? { ...play, type: 'play', _index: idx, _raw: item } : null;
                    }

                    // Handle Object ID (New: { id, tempo, ... })
                    else if (typeof item === 'object' && item.id) {
                        if (item.id.startsWith('NOTE:')) {
                            return { ...item, name: item.id.replace('NOTE:', ''), type: 'note', _index: idx, _raw: item };
                        }
                        const play = plays.find(p => p.id === item.id);
                        return play ? { ...play, ...item, type: 'play', _index: idx, _raw: item } : null;
                    }
                    return null;
                }).filter(Boolean);
            };

            // Play Selector specific helper to get grid array (20 items)
            const getGridPlays = (setId, limit = 20, assignedIds = null) => {
                let rawIds = [];
                if (assignedIds && Array.isArray(assignedIds) && assignedIds.length > 0) {
                    rawIds = [...assignedIds];
                } else {
                    let set = null;
                    // Handle sets as array or object
                    if (Array.isArray(gamePlan?.sets)) {
                        set = gamePlan.sets.find(s => s.id === setId);
                    } else if (gamePlan?.sets && typeof gamePlan.sets === 'object') {
                        set = Object.values(gamePlan.sets).find(s => s.id === setId) || gamePlan.sets[setId];
                    }
                    if (!set && setId && setId.startsWith('ms_')) {
                        if (Array.isArray(gamePlan?.miniScripts)) {
                            set = gamePlan.miniScripts.find(s => s.id === setId);
                        } else if (gamePlan?.miniScripts && typeof gamePlan.miniScripts === 'object') {
                            set = Object.values(gamePlan.miniScripts).find(s => s.id === setId) || gamePlan.miniScripts[setId];
                        }
                    }
                    rawIds = set ? [...(set.playIds || [])] : [];
                }
                // Pad to 20
                while (rawIds.length < limit) {
                    rawIds.push('GAP');
                }
                // If more than 20, keep them? User asked for 10 rows. Let's just show 20 for now.
                // We map rawIds to objects or 'GAP'
                return rawIds.slice(0, limit).map((item, idx) => {
                    if (item === 'GAP') return { type: 'GAP', _index: idx, _raw: item };

                    if (typeof item === 'string') {
                        if (item.startsWith('NOTE:')) {
                            return { id: item, name: item.replace('NOTE:', ''), type: 'note', _index: idx, _raw: item };
                        }
                        const play = plays.find(p => p.id === item);
                        return play ? { ...play, type: 'play', _index: idx, _raw: item } : { type: 'GAP', _index: idx, _raw: item };
                    }
                    else if (typeof item === 'object' && item.id) {
                        if (item.id.startsWith('NOTE:')) {
                            return { ...item, name: item.id.replace('NOTE:', ''), type: 'note', _index: idx, _raw: item };
                        }
                        const play = plays.find(p => p.id === item.id);
                        return play ? { ...play, ...item, type: 'play', _index: idx, _raw: item } : { type: 'GAP', _index: idx, _raw: item };
                    }
                    return { type: 'GAP', _index: idx, _raw: item };
                });
            };

            const handleGridCellUpdate = (setId, index, playId) => {
                // Safety check: ensure setId is defined
                if (!setId) {
                    console.warn('handleGridCellUpdate called with undefined setId');
                    return;
                }

                let set = null;
                // Handle sets as array or object
                if (Array.isArray(gamePlan?.sets)) {
                    set = gamePlan.sets.find(s => s.id === setId);
                } else if (gamePlan?.sets && typeof gamePlan.sets === 'object') {
                    set = Object.values(gamePlan.sets).find(s => s.id === setId) || gamePlan.sets[setId];
                }
                if (!set && setId.startsWith('ms_')) {
                    if (Array.isArray(gamePlan?.miniScripts)) {
                        set = gamePlan.miniScripts.find(s => s.id === setId);
                    } else if (gamePlan?.miniScripts && typeof gamePlan.miniScripts === 'object') {
                        set = Object.values(gamePlan.miniScripts).find(s => s.id === setId) || gamePlan.miniScripts[setId];
                    }
                }
                const rawIds = set ? [...(set.playIds || [])] : [];
                // Pad if needed
                while (rawIds.length <= index) {
                    rawIds.push('GAP');
                }

                rawIds[index] = playId || 'GAP';

                if (setId.startsWith('ms_')) {
                    const newMiniScripts = (gamePlan?.miniScripts || []).map(s =>
                        s.id === setId ? { ...s, playIds: rawIds } : s
                    );
                    onUpdateGamePlan({ ...gamePlan, miniScripts: newMiniScripts });
                } else {
                    let existingSet = null;
                    if (Array.isArray(gamePlan?.sets)) {
                        existingSet = gamePlan.sets.find(s => s.id === setId);
                    } else if (gamePlan?.sets && typeof gamePlan.sets === 'object') {
                        existingSet = Object.values(gamePlan.sets).find(s => s.id === setId) || gamePlan.sets[setId];
                    }
                    let newSets;
                    if (existingSet) {
                        newSets = (gamePlan?.sets || []).map(s => s.id === setId ? { ...s, playIds: rawIds } : s);
                    } else {
                        // Implicit create
                        newSets = [...(gamePlan?.sets || []), { id: setId, name: setId, playIds: rawIds }];
                    }
                    onUpdateGamePlan({ ...gamePlan, sets: newSets });
                }
            };

            const handleGridMove = (fromIndex, toIndex) => {
                // Safety check: ensure activeCellSetId is defined
                if (!activeCellSetId) {
                    console.warn('handleGridMove called with undefined activeCellSetId');
                    return;
                }

                const currentGrid = getGridPlays(activeCellSetId);
                // We need the raw IDs not objects to save
                let set = null;
                // Handle sets as array or object
                if (Array.isArray(gamePlan?.sets)) {
                    set = gamePlan.sets.find(s => s.id === activeCellSetId);
                } else if (gamePlan?.sets && typeof gamePlan.sets === 'object') {
                    set = Object.values(gamePlan.sets).find(s => s.id === activeCellSetId) || gamePlan.sets[activeCellSetId];
                }
                if (!set && activeCellSetId.startsWith('ms_')) {
                    if (Array.isArray(gamePlan?.miniScripts)) {
                        set = gamePlan.miniScripts.find(s => s.id === activeCellSetId);
                    } else if (gamePlan?.miniScripts && typeof gamePlan.miniScripts === 'object') {
                        set = Object.values(gamePlan.miniScripts).find(s => s.id === activeCellSetId) || gamePlan.miniScripts[activeCellSetId];
                    }
                }
                const rawIds = set ? [...(set.playIds || [])] : [];
                // Pad local rawIds to ensure indices exist
                while (rawIds.length <= Math.max(fromIndex, toIndex)) {
                    rawIds.push('GAP');
                }

                // Swap
                const temp = rawIds[fromIndex];
                rawIds[fromIndex] = rawIds[toIndex];
                rawIds[toIndex] = temp;

                // Save
                // Strip trailing GAPs? Maybe not, to preserve layout if user wanted gaps.
                // But for now let's just save.
                if (activeCellSetId.startsWith('ms_')) {
                    const newMiniScripts = (gamePlan?.miniScripts || []).map(s =>
                        s.id === activeCellSetId ? { ...s, playIds: rawIds } : s
                    );
                    onUpdateGamePlan({ ...gamePlan, miniScripts: newMiniScripts });
                } else {
                    let existingSet = null;
                    if (Array.isArray(gamePlan?.sets)) {
                        existingSet = gamePlan.sets.find(s => s.id === activeCellSetId);
                    } else if (gamePlan?.sets && typeof gamePlan.sets === 'object') {
                        existingSet = Object.values(gamePlan.sets).find(s => s.id === activeCellSetId) || gamePlan.sets[activeCellSetId];
                    }
                    let newSets;
                    if (existingSet) {
                        newSets = (gamePlan?.sets || []).map(s => s.id === activeCellSetId ? { ...s, playIds: rawIds } : s);
                    } else {
                        // Should not happen in selector usually, but implicit create
                        newSets = [...(gamePlan?.sets || []), { id: activeCellSetId, name: activeCellSetId, playIds: rawIds }];
                    }
                    onUpdateGamePlan({ ...gamePlan, sets: newSets });
                }
            };

            const handleGridAdd = (playId) => {
                // Safety check: ensure activeCellSetId is defined
                if (!activeCellSetId) {
                    console.warn('handleGridAdd called with undefined activeCellSetId');
                    return;
                }

                let set = null;
                // Handle sets as array or object
                if (Array.isArray(gamePlan?.sets)) {
                    set = gamePlan.sets.find(s => s.id === activeCellSetId);
                } else if (gamePlan?.sets && typeof gamePlan.sets === 'object') {
                    set = Object.values(gamePlan.sets).find(s => s.id === activeCellSetId) || gamePlan.sets[activeCellSetId];
                }
                if (!set && activeCellSetId.startsWith('ms_')) {
                    if (Array.isArray(gamePlan?.miniScripts)) {
                        set = gamePlan.miniScripts.find(s => s.id === activeCellSetId);
                    } else if (gamePlan?.miniScripts && typeof gamePlan.miniScripts === 'object') {
                        set = Object.values(gamePlan.miniScripts).find(s => s.id === activeCellSetId) || gamePlan.miniScripts[activeCellSetId];
                    }
                }
                const rawIds = set ? [...(set.playIds || [])] : [];

                // Find first GAP or push
                let insertIdx = rawIds.indexOf('GAP');
                if (insertIdx === -1) {
                    insertIdx = rawIds.length;
                    if (insertIdx >= 20) {
                        alert("Grid is full (20 plays max for this view)");
                        return;
                    }
                }

                rawIds[insertIdx] = playId;

                // Save (Same logic as move basically)
                if (activeCellSetId.startsWith('ms_')) {
                    const newMiniScripts = (gamePlan?.miniScripts || []).map(s =>
                        s.id === activeCellSetId ? { ...s, playIds: rawIds } : s
                    );
                    onUpdateGamePlan({ ...gamePlan, miniScripts: newMiniScripts });
                } else {
                    let existingSet = null;
                    if (Array.isArray(gamePlan?.sets)) {
                        existingSet = gamePlan.sets.find(s => s.id === activeCellSetId);
                    } else if (gamePlan?.sets && typeof gamePlan.sets === 'object') {
                        existingSet = Object.values(gamePlan.sets).find(s => s.id === activeCellSetId) || gamePlan.sets[activeCellSetId];
                    }
                    let newSets;
                    if (existingSet) {
                        newSets = (gamePlan?.sets || []).map(s => s.id === activeCellSetId ? { ...s, playIds: rawIds } : s);
                    } else {
                        newSets = [...(gamePlan?.sets || []), { id: activeCellSetId, name: activeCellSetId, playIds: rawIds }];
                    }
                    onUpdateGamePlan({ ...gamePlan, sets: newSets });
                }
            }

            const handleGridRemove = (index) => {
                let set = null;
                // Handle sets as array or object
                if (Array.isArray(gamePlan?.sets)) {
                    set = gamePlan.sets.find(s => s.id === activeCellSetId);
                } else if (gamePlan?.sets && typeof gamePlan.sets === 'object') {
                    set = Object.values(gamePlan.sets).find(s => s.id === activeCellSetId) || gamePlan.sets[activeCellSetId];
                }
                if (!set && activeCellSetId && activeCellSetId.startsWith('ms_')) {
                    if (Array.isArray(gamePlan?.miniScripts)) {
                        set = gamePlan.miniScripts.find(s => s.id === activeCellSetId);
                    } else if (gamePlan?.miniScripts && typeof gamePlan.miniScripts === 'object') {
                        set = Object.values(gamePlan.miniScripts).find(s => s.id === activeCellSetId) || gamePlan.miniScripts[activeCellSetId];
                    }
                }
                const rawIds = set ? [...(set.playIds || [])] : [];
                if (rawIds[index]) {
                    rawIds[index] = 'GAP';
                    // Save
                    if (activeCellSetId.startsWith('ms_')) {
                        const newMiniScripts = (gamePlan?.miniScripts || []).map(s =>
                            s.id === activeCellSetId ? { ...s, playIds: rawIds } : s
                        );
                        onUpdateGamePlan({ ...gamePlan, miniScripts: newMiniScripts });
                    } else {
                        let existingSet = null;
                        if (Array.isArray(gamePlan?.sets)) {
                            existingSet = gamePlan.sets.find(s => s.id === activeCellSetId);
                        } else if (gamePlan?.sets && typeof gamePlan.sets === 'object') {
                            existingSet = Object.values(gamePlan.sets).find(s => s.id === activeCellSetId) || gamePlan.sets[activeCellSetId];
                        }
                        let newSets;
                        if (existingSet) {
                            newSets = (gamePlan?.sets || []).map(s => s.id === activeCellSetId ? { ...s, playIds: rawIds } : s);
                        }
                        // If implicitly creating on remove? weird. Ignore.
                        if (newSets) onUpdateGamePlan({ ...gamePlan, sets: newSets });
                    }
                }
            };

            const [draggedGridIndex, setDraggedGridIndex] = useState(null);

            // Helper to get the set object (or create if implicit)
            const getSet = (setId) => {
                if (setId && setId.startsWith('ms_')) {
                    if (Array.isArray(gamePlan?.miniScripts)) {
                        return gamePlan.miniScripts.find(s => s.id === setId);
                    } else if (gamePlan?.miniScripts && typeof gamePlan.miniScripts === 'object') {
                        return Object.values(gamePlan.miniScripts).find(s => s.id === setId) || gamePlan.miniScripts[setId];
                    }
                    return null;
                }
                if (Array.isArray(gamePlan?.sets)) {
                    return gamePlan.sets.find(s => s.id === setId);
                } else if (gamePlan?.sets && typeof gamePlan.sets === 'object') {
                    return Object.values(gamePlan.sets).find(s => s.id === setId) || gamePlan.sets[setId];
                }
                return null;
            };

            const handleAddPlayToSet = (setId, playId) => {
                if (setId.startsWith('ms_')) {
                    // Handle Mini Script Update
                    const newMiniScripts = (gamePlan?.miniScripts || []).map(s =>
                        s.id === setId ? { ...s, playIds: [...(s.playIds || []), playId] } : s
                    );
                    onUpdateGamePlan({ ...gamePlan, miniScripts: newMiniScripts });
                } else {
                    // Handle Standard Set Update
                    let existingSet = null;
                    if (Array.isArray(gamePlan?.sets)) {
                        existingSet = gamePlan.sets.find(s => s.id === setId);
                    } else if (gamePlan?.sets && typeof gamePlan.sets === 'object') {
                        existingSet = Object.values(gamePlan.sets).find(s => s.id === setId) || gamePlan.sets[setId];
                    }
                    let newSets;
                    if (existingSet) {
                        newSets = (Array.isArray(gamePlan?.sets) ? gamePlan.sets : Object.values(gamePlan?.sets || {})).map(s => s.id === setId ? { ...s, playIds: [...(s.playIds || []), playId] } : s);
                    } else {
                        // Implicit creation for grid cells
                        const currentSets = Array.isArray(gamePlan?.sets) ? gamePlan.sets : Object.values(gamePlan?.sets || {});
                        newSets = [...currentSets, { id: setId, name: setId, playIds: [playId] }];
                    }
                    onUpdateGamePlan({ ...gamePlan, sets: newSets });
                }
            };

            // Add play to Quick List (assignedPlayIds) - used when dragging from Play Bank
            const handleAddToQuickList = (setId, playId) => {
                if (setId.startsWith('ms_')) {
                    // Handle Mini Script Update - add to assignedPlayIds (Quick List)
                    let newMiniScripts = Array.isArray(gamePlan?.miniScripts) ? [...gamePlan.miniScripts] : [];
                    const existingIdx = newMiniScripts.findIndex(s => s.id === setId);
                    if (existingIdx >= 0) {
                        const existing = newMiniScripts[existingIdx];
                        // Don't add duplicates
                        if (!(existing.assignedPlayIds || []).includes(playId)) {
                            newMiniScripts[existingIdx] = { ...existing, assignedPlayIds: [...(existing.assignedPlayIds || []), playId] };
                        }
                    } else {
                        newMiniScripts.push({ id: setId, name: setId, playIds: [], assignedPlayIds: [playId] });
                    }
                    onUpdateGamePlan({ ...gamePlan, miniScripts: newMiniScripts });
                } else {
                    // Handle Standard Set Update - add to assignedPlayIds (Quick List)
                    let newSets = Array.isArray(gamePlan?.sets) ? [...gamePlan.sets] : Object.values(gamePlan?.sets || {});
                    const existingIdx = newSets.findIndex(s => s.id === setId);
                    if (existingIdx >= 0) {
                        const existing = newSets[existingIdx];
                        // Don't add duplicates
                        if (!(existing.assignedPlayIds || []).includes(playId)) {
                            newSets[existingIdx] = { ...existing, assignedPlayIds: [...(existing.assignedPlayIds || []), playId] };
                        }
                    } else {
                        newSets = [...newSets, { id: setId, name: setId, playIds: [], assignedPlayIds: [playId] }];
                    }
                    onUpdateGamePlan({ ...gamePlan, sets: newSets });
                }
            };

            const handleRemovePlayFromSet = (setId, playId) => {
                if (setId.startsWith('ms_')) {
                    let existingScript = null;
                    if (Array.isArray(gamePlan?.miniScripts)) {
                        existingScript = gamePlan.miniScripts.find(s => s.id === setId);
                    } else if (gamePlan?.miniScripts && typeof gamePlan.miniScripts === 'object') {
                        existingScript = Object.values(gamePlan.miniScripts).find(s => s.id === setId) || gamePlan.miniScripts[setId];
                    }
                    if (!existingScript) return;
                    const newPlayIds = (existingScript.playIds || []).filter(id => id !== playId);
                    const newMiniScripts = (Array.isArray(gamePlan?.miniScripts) ? gamePlan.miniScripts : Object.values(gamePlan?.miniScripts || {})).map(s => s.id === setId ? { ...s, playIds: newPlayIds } : s);
                    onUpdateGamePlan({ ...gamePlan, miniScripts: newMiniScripts });
                } else {
                    let existingSet = null;
                    if (Array.isArray(gamePlan?.sets)) {
                        existingSet = gamePlan.sets.find(s => s.id === setId);
                    } else if (gamePlan?.sets && typeof gamePlan.sets === 'object') {
                        existingSet = Object.values(gamePlan.sets).find(s => s.id === setId) || gamePlan.sets[setId];
                    }
                    if (!existingSet) return;
                    const newPlayIds = (existingSet.playIds || []).filter(id => id !== playId);
                    const newSets = (Array.isArray(gamePlan?.sets) ? gamePlan.sets : Object.values(gamePlan?.sets || {})).map(s => s.id === setId ? { ...s, playIds: newPlayIds } : s);
                    onUpdateGamePlan({ ...gamePlan, sets: newSets });
                }
            };

            // Quick add play to a set
            const handleQuickAddToSet = (setId, playName) => {
                const trimmed = playName.trim();
                if (!trimmed || !onQuickAddPlay) return;

                // Check for Note Syntax
                if (trimmed.toUpperCase().startsWith('NOTE:') || trimmed.toLowerCase().startsWith('n: ')) {
                    const noteText = trimmed.includes(':') ? trimmed.split(':').slice(1).join(':').trim() : trimmed;
                    const noteId = `NOTE:${noteText}`;
                    handleAddPlayToSet(setId, noteId);
                    return;
                }

                // Create the incomplete play
                const newPlay = onQuickAddPlay(trimmed);

                // Add to the set
                handleAddPlayToSet(setId, newPlay.id);
            };


            // Selector Logic (Shared)
            const filteredSelectorPlays = plays.filter(play => {
                const matchFormation = !playSelectorFilters.formation || play.formation === playSelectorFilters.formation;
                const matchConcept = !playSelectorFilters.concept || play.concept === playSelectorFilters.concept;
                const matchTag = !playSelectorFilters.tag || [play.tag1, play.tag2, ...(play.tags || [])].includes(playSelectorFilters.tag);
                const matchSituation = !playSelectorFilters.situation ||
                    (TAG_CATEGORIES["Field Position"] && TAG_CATEGORIES["Field Position"].includes(playSelectorFilters.situation) && play.tags.includes(playSelectorFilters.situation)) ||
                    (TAG_CATEGORIES["Down & Distance"] && TAG_CATEGORIES["Down & Distance"].includes(playSelectorFilters.situation) && play.tags.includes(playSelectorFilters.situation));
                const matchSearch = !playSelectorFilters.search ||
                    play.name.toLowerCase().includes(playSelectorFilters.search.toLowerCase());
                return matchFormation && matchConcept && matchTag && matchSituation && matchSearch;
            });
            const uniqueFormations = [...new Set(plays.map(p => p.formation).filter(Boolean))].sort();
            const uniqueConcepts = [...new Set(plays.map(p => p.concept).filter(Boolean))].sort();
            const allTags = [...new Set(plays.flatMap(p => [p.tag1, p.tag2, ...(p.tags || [])]))].filter(Boolean).sort();
            const situationTags = [...(TAG_CATEGORIES["Field Position"] || []), ...(TAG_CATEGORIES["Down & Distance"] || [])];

            const openPlaySelector = (setId) => {
                setActiveCellSetId(setId);
                setShowPlaySelector(true);
            };

            // Helper to get all assigned wristband coordinates
            const getAssignedWristbandCoordinates = (excludePlayId = null) => {
                const assigned = new Set();
                plays.forEach(play => {
                    if (play.wristbandSlot && play.id !== excludePlayId) {
                        assigned.add(play.wristbandSlot.trim());
                    }
                });
                return assigned;
            };

            // --- RENDERERS ---

            const renderPlayListSimple = (setId, isEditing) => {
                const playsInSet = getPlaysForSet(setId);

                const handleToggleTempo = (playIndex, currentTempo) => {
                    const nextIdx = (PLAY_PROTOCOLS.findIndex(p => p.id === (currentTempo || 'REGULAR')) + 1) % PLAY_PROTOCOLS.length;
                    const nextTempo = PLAY_PROTOCOLS[nextIdx].id;

                    const set = getSet(setId);
                    if (!set) return;

                    const newPlayIds = [...set.playIds];
                    const item = newPlayIds[playIndex];

                    if (typeof item === 'string') {
                        newPlayIds[playIndex] = { id: item, tempo: nextTempo };
                    } else if (typeof item === 'object') {
                        newPlayIds[playIndex] = { ...item, tempo: nextTempo };
                    }

                    if (setId.startsWith('ms_')) {
                        const newMiniScripts = (gamePlan?.miniScripts || []).map(s => s.id === setId ? { ...s, playIds: newPlayIds } : s);
                        onUpdateGamePlan({ ...gamePlan, miniScripts: newMiniScripts });
                    } else {
                        const newSets = (gamePlan?.sets || []).map(s => s.id === setId ? { ...s, playIds: newPlayIds } : s);
                        onUpdateGamePlan({ ...gamePlan, sets: newSets });
                    }
                };

                const renderTempoBadge = (tempo) => {
                    const protocol = PLAY_PROTOCOLS.find(p => p.id === (tempo || 'REGULAR'));
                    if (!protocol || protocol.id === 'REGULAR') return <span style={{ width: '20px', display: 'inline-block', textAlign: 'center', color: '#cbd5e1', cursor: 'pointer', fontSize: '0.65rem' }}>-</span>;

                    return (
                        <span style={{
                            background: protocol.color, color: 'white', fontSize: '0.6rem', padding: '1px 3px', borderRadius: '3px',
                            cursor: 'pointer', minWidth: '18px', display: 'inline-block', textAlign: 'center', fontWeight: 'bold'
                        }} title={protocol.label}>
                            {protocol.code}
                        </span>
                    );
                };

                return (
                    <div style={{ padding: '0' }}>
                        {playsInSet.map((p, pIdx) => (
                            <div key={`${p.id}_${pIdx}`} style={{
                                display: 'flex', alignItems: 'center', gap: '4px', padding: '2px 0', position: 'relative',
                                cursor: 'pointer', userSelect: 'none'
                            }}
                                onDoubleClick={(e) => {
                                    if (p.type === 'note') return;
                                    e.stopPropagation();
                                    setAssignmentModalState({ playId: p.id, x: e.clientX, y: e.clientY });
                                }}
                            >
                                {p.type === 'note' ? (
                                    <div style={{
                                        fontSize: '0.75rem', marginTop: '4px', marginBottom: '4px', padding: '2px 4px',
                                        background: '#fef3c7', color: '#92400e', textAlign: 'center', fontWeight: 'bold',
                                        borderRadius: '4px', border: '1px dashed #d97706', flex: 1
                                    }}>
                                        {p.name}
                                    </div>
                                ) : (
                                    <>
                                        <div onClick={(e) => { e.stopPropagation(); handleToggleTempo(pIdx, p.tempo); }}>
                                            {renderTempoBadge(p.tempo)}
                                        </div>
                                        <span style={{ fontSize: '0.75rem', flex: 1, whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', color: '#1e293b' }}>{p.name}</span>
                                        <input
                                            type="text"
                                            value={wbAutocomplete.playId === p.id ? wbAutocomplete.query : (p.wristbandSlot || '')}
                                            placeholder="#"
                                            style={{
                                                width: '32px',
                                                padding: '0 2px',
                                                fontSize: '0.65rem',
                                                border: '1px solid #e2e8f0',
                                                borderRadius: '2px',
                                                marginLeft: '4px',
                                                textAlign: 'center',
                                                background: '#f8fafc',
                                                color: '#475569',
                                                height: '16px',
                                                lineHeight: '14px'
                                            }}
                                            onClick={(e) => e.stopPropagation()}
                                            onFocus={(e) => {
                                                setWbAutocomplete({ playId: p.id, query: e.target.value });
                                            }}
                                            onChange={(e) => {
                                                setWbAutocomplete({ playId: p.id, query: e.target.value });
                                            }}
                                            onKeyDown={(e) => {
                                                if (e.key === 'Enter') {
                                                    const val = e.currentTarget.value.trim();
                                                    // Process selection or validation
                                                    if (val && val !== (p.wristbandSlot || '')) {
                                                        // Validation logic (same as before)
                                                        let isValid = false;
                                                        const cardKeys = ['card1', 'card2', 'card3', 'card4', 'card5', 'card6'];
                                                        for (const key of cardKeys) {
                                                            const card = wbSettings[key];
                                                            if (!card) continue;
                                                            if (wbSettings.enabledSections && wbSettings.enabledSections[key] === false) continue;

                                                            const cardNum = parseInt(key.replace('card', ''));
                                                            if (card.type && (card.type === 'wiz')) {
                                                                for (let i = 1; i <= 16; i++) if (val === `${cardNum}${String(i).padStart(2, '0')}`) isValid = true;
                                                            } else {
                                                                const start = cardNum * 100 + 1;
                                                                const end = start + 47;
                                                                const num = parseInt(val);
                                                                if (!isNaN(num) && num >= start && num <= end) isValid = true;
                                                            }
                                                        }

                                                        // Check Staples (10-89)
                                                        const num = parseInt(val);
                                                        if (!isNaN(num) && num >= 10 && num <= 89) {
                                                            if (!wbSettings.enabledSections || wbSettings.enabledSections.staples !== false) {
                                                                isValid = true;
                                                            }
                                                        }

                                                        if (!isValid) {
                                                            alert(`Invalid wristband slot "${val}".\n\nMust be a valid coordinate from your configured wristbands.`);
                                                            e.currentTarget.value = p.wristbandSlot || '';
                                                            return;
                                                        }
                                                        // Check for duplicates
                                                        if (assignedSlots.has(val)) {
                                                            alert(`Wristband slot "${val}" is already assigned to another play.`);
                                                            e.currentTarget.value = p.wristbandSlot || '';
                                                            return;
                                                        }

                                                        onUpdatePlay({ ...p, wristbandSlot: val });
                                                    }
                                                    e.currentTarget.blur();
                                                    setWbAutocomplete({ playId: null, query: '' });
                                                }
                                            }}
                                            onBlur={(e) => {
                                                // Delayed blur to allow click on suggestion
                                                setTimeout(() => {
                                                    // Determine if we need to validate/save
                                                    const val = e.target.value.trim();
                                                    if (val !== (p.wristbandSlot || '')) {
                                                        // Validation here is redundant if Enter caught it, but good for blur
                                                        // We might skip complex validation on blur if it's annoying, 
                                                        // but for consistency we keep it or rely on the previous validation logic.
                                                        // Let's rely on the user having selected or typed correctly.
                                                        // Real validation happens on update or explicit check.
                                                        // Simple check:
                                                        let isValid = !val;
                                                        if (val) {
                                                            const cardKeys = ['card1', 'card2', 'card3', 'card4', 'card5', 'card6'];
                                                            for (const key of cardKeys) {
                                                                const card = wbSettings[key];
                                                                if (!card) continue;
                                                                const cardNum = parseInt(key.replace('card', ''));
                                                                if (card.type && card.type.includes('wiz')) {
                                                                    for (let i = 1; i <= 16; i++) if (val === `${cardNum}${String(i).padStart(2, '0')}`) isValid = true;
                                                                } else {
                                                                    const start = cardNum * 100 + 1;
                                                                    const end = start + 47;
                                                                    const num = parseInt(val);
                                                                    if (!isNaN(num) && num >= start && num <= end) isValid = true;
                                                                }
                                                            }
                                                        }

                                                        if (isValid && val && assignedSlots.has(val)) {
                                                            alert(`Wristband slot "${val}" is already assigned to another play.`);
                                                            isValid = false;
                                                        }

                                                        if (isValid) {
                                                            onUpdatePlay({ ...p, wristbandSlot: val });
                                                        } else {
                                                            if (val && !assignedSlots.has(val)) alert(`Invalid wristband slot "${val}".`); // Only alert valid range if not duplicate alert done
                                                            // if duplicates, alert already shown. 
                                                            // Wait, logic above shows alert. 
                                                            e.target.value = p.wristbandSlot || '';
                                                        }
                                                    }
                                                    setWbAutocomplete({ playId: null, query: '' });
                                                }, 200);
                                            }}
                                        />
                                        {/* Autocomplete Dropdown */}
                                        {wbAutocomplete.playId === p.id && (
                                            <div style={{
                                                position: 'absolute',
                                                top: '100%',
                                                right: 0,
                                                zIndex: 100,
                                                background: 'white',
                                                border: '1px solid #e2e8f0',
                                                borderRadius: '4px',
                                                boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)',
                                                maxHeight: '150px',
                                                overflowY: 'auto',
                                                width: '60px',
                                                display: 'flex',
                                                flexDirection: 'column'
                                            }}>
                                                {validWristbandSlots
                                                    .filter(slot => {
                                                        if (!slot.startsWith(wbAutocomplete.query)) return false;
                                                        // Filter out assigned slots, unless it's THIS play's slot
                                                        if (assignedSlots.has(slot) && slot !== (p.wristbandSlot || '')) return false;
                                                        return true;
                                                    })
                                                    .slice(0, 50) // Limit results
                                                    .map(slot => (
                                                        <div
                                                            key={slot}
                                                            style={{
                                                                padding: '4px 8px',
                                                                fontSize: '0.7rem',
                                                                cursor: 'pointer',
                                                                borderBottom: '1px solid #f1f5f9',
                                                                background: 'white',
                                                                color: '#334155'
                                                            }}
                                                            onMouseDown={(e) => {
                                                                e.preventDefault(); // Prevent blur
                                                                onUpdatePlay({ ...p, wristbandSlot: slot });
                                                                // Update input visually if not controlled (it is uncontrolled with defaultValue)
                                                                // We need to re-render renderPlayListSimple or force update. 
                                                                // Since onUpdatePlay will trigger re-render of component, we are good.
                                                                setWbAutocomplete({ playId: null, query: '' });
                                                            }}
                                                            onMouseEnter={(e) => e.currentTarget.style.background = '#f8fafc'}
                                                            onMouseLeave={(e) => e.currentTarget.style.background = 'white'}
                                                        >
                                                            {slot}
                                                        </div>
                                                    ))}
                                            </div>
                                        )}
                                        {isEditing && (
                                            <div style={{ cursor: 'pointer', opacity: 0.5, marginLeft: '4px' }}
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    handleRemovePlayFromSet(setId, p.id);
                                                }}
                                            >×</div>
                                        )}
                                    </>
                                )}
                            </div>
                        ))}

                    </div>
                );
            };

            const handleSaveNewScript = (name) => {
                if (!name.trim()) {
                    setIsCreatingScript(false);
                    return;
                }

                const newScriptId = `ms_${Date.now()}`;
                const newScript = {
                    id: newScriptId,
                    name: name.trim(),
                    playIds: [],
                    color: '#8b5cf6' // Default purple
                };

                // Add to game plan data
                const newGamePlan = {
                    ...gamePlan,
                    miniScripts: [...(gamePlan?.miniScripts || []), newScript]
                };
                onUpdateGamePlan(newGamePlan);

                // Add to layout (if supported)
                if (onUpdateLayouts && gamePlanLayouts) {
                    const newLayouts = { ...gamePlanLayouts };
                    const sheet = { ...newLayouts.CALL_SHEET };
                    sheet.sections = [...sheet.sections];

                    // Find 'MINI SCRIPTS' section or last section
                    let targetIdx = sheet.sections.findIndex(s => s.title === 'MINI SCRIPTS');
                    if (targetIdx === -1) targetIdx = sheet.sections.length - 1;

                    const targetSection = { ...sheet.sections[targetIdx] };
                    targetSection.rows = [...targetSection.rows, {
                        header: newScript.name,
                        setId: newScript.id,
                        colSpan: 1,
                        color: newScript.color
                    }];
                    sheet.sections[targetIdx] = targetSection;
                    newLayouts.CALL_SHEET = sheet;
                    onUpdateLayouts(newLayouts);
                }

                setIsCreatingScript(false);
            };

            const handleDeleteMiniScript = (scriptId, e) => {
                if (e) e.stopPropagation();

                // Update Game Plan Data
                const newGamePlan = {
                    ...gamePlan,
                    miniScripts: (gamePlan?.miniScripts || []).filter(s => s.id !== scriptId)
                };
                onUpdateGamePlan(newGamePlan);
                setConfirmDeleteScriptId(null);

                // Update Layout
                if (onUpdateLayouts && gamePlanLayouts) {
                    const newLayouts = { ...gamePlanLayouts };
                    const sheet = { ...newLayouts.CALL_SHEET };
                    sheet.sections = sheet.sections.map(section => ({
                        ...section,
                        rows: section.rows.filter(row => row.setId !== scriptId)
                    }));
                    newLayouts.CALL_SHEET = sheet;
                    onUpdateLayouts(newLayouts);
                }
            };

            const handleUpdateFormationName = (formationId, newName) => {
                const newOverrides = { ...(gamePlan.formationOverrides || {}), [formationId]: newName };
                onUpdateGamePlan({ ...gamePlan, formationOverrides: newOverrides });
                setEditingFormationId(null);
            };

            // Layout Drag State
            const [confirmResetLayout, setConfirmResetLayout] = useState(false);
            const [draggedCell, setDraggedCell] = useState(null); // { sectionIdx, rowIdx }
            const [draggedSection, setDraggedSection] = useState(null); // { sectionIdx }
            const [editingHeader, setEditingHeader] = useState(null); // { sectionIdx, rowIdx }

            const handleDragStart = (e, sectionIdx, rowIdx) => {
                if (isLocked || draggedSection) return; // Don't allow cell drag if section is being dragged
                setDraggedCell({ sectionIdx, rowIdx });
                e.dataTransfer.effectAllowed = 'move';
                e.stopPropagation(); // Prevent section drag from firing
            };

            const handleDragOver = (e) => {
                if (isLocked) return;
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            };

            const handleDrop = (e, targetSectionIdx, targetRowIdx) => {
                if (isLocked || !draggedCell) return;
                e.preventDefault();

                // Clone layouts
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                sheet.sections = [...sheet.sections];

                // Get source and target arrays
                // FIX: Use .boxes instead of .rows
                const sourceBoxes = [...(sheet.sections[draggedCell.sectionIdx].boxes || [])]; const targetBoxes = draggedCell.sectionIdx === targetSectionIdx ? sourceBoxes : [...(sheet.sections[targetSectionIdx].boxes || [])];

                const itemToMove = sourceBoxes[draggedCell.rowIdx];
                if (!itemToMove) return; // Safety check

                // Verify index to prevent duplication if state is stale
                const realSourceIdx = sourceBoxes.findIndex(r => r.setId === itemToMove.setId);
                if (realSourceIdx === -1) return; // Item not found? Abort.

                // Remove from source
                sourceBoxes.splice(realSourceIdx, 1);

                // Insert into target
                if (draggedCell.sectionIdx === targetSectionIdx) {
                    // SAME LIST
                    // If we removed from BEFORE the target, the target index shifted down by 1.
                    // But wait, standard behavior:
                    // [A, B, C]. Drag A (0) to C (2).
                    // Remove A. [B, C].
                    // Visual Drop Target was Index 2 (C). C is now at Index 1.
                    // We want to insert AFTER C. So Index 2.

                    // Simple logic:
                    let insertionIdx = targetRowIdx;

                    // Checkbounds
                    if (insertionIdx > sourceBoxes.length) insertionIdx = sourceBoxes.length;

                    sourceBoxes.splice(insertionIdx, 0, itemToMove);

                    // Assign back
                    sheet.sections[draggedCell.sectionIdx].boxes = sourceBoxes;

                } else {
                    // DIFFERENT LIST
                    // Insert into target list at specific index
                    let insertionIdx = targetRowIdx;
                    if (insertionIdx > targetBoxes.length) insertionIdx = targetBoxes.length; // Safety

                    targetBoxes.splice(insertionIdx, 0, itemToMove);

                    // Update both sections
                    sheet.sections[draggedCell.sectionIdx].boxes = sourceBoxes;
                    sheet.sections[targetSectionIdx].boxes = targetBoxes;
                }

                // Update State
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                setDraggedCell(null);
            };

            // Section drag handlers
            const handleSectionDragStart = (e, sectionIdx) => {
                if (isLocked) return;
                setDraggedSection({ sectionIdx });
                e.dataTransfer.effectAllowed = 'move';
            };

            const handleSectionDragOver = (e) => {
                if (isLocked || (!draggedSection && !draggedCell)) return;
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'move';
            };

            const handleSectionDrop = (e, targetSectionIdx) => {
                if (isLocked) return;

                // Case 1: Dropping a Section (Reordering Sections)
                if (draggedSection) {
                    e.preventDefault();
                    e.stopPropagation();

                    const sourceSectionIdx = draggedSection.sectionIdx;
                    if (sourceSectionIdx === targetSectionIdx) {
                        setDraggedSection(null);
                        return;
                    }

                    // Reorder sections array
                    const newLayouts = { ...gamePlanLayouts };
                    const sheet = { ...newLayouts.CALL_SHEET };
                    const sections = [...sheet.sections];

                    // Remove source section
                    const [movedSection] = sections.splice(sourceSectionIdx, 1);

                    // Insert at target position
                    sections.splice(targetSectionIdx, 0, movedSection);

                    sheet.sections = sections;
                    newLayouts.CALL_SHEET = sheet;
                    if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                    setDraggedSection(null);
                    return;
                }

                // Case 2: Dropping a Box (Moving Box to Section)
                if (draggedCell) {
                    e.preventDefault();
                    e.stopPropagation();

                    // If dropped on the same section, do nothing (draggedCell logic in handleDrop handles intra-section sorts usually, 
                    // but dropping on the *container* usually implies appending or no-op if same. 
                    // Let's allow appending if same section? Or just return if same to avoid jumping.)
                    if (draggedCell.sectionIdx === targetSectionIdx) return;

                    // Move dragged item to this section
                    const newLayouts = { ...gamePlanLayouts };
                    const sheet = { ...newLayouts.CALL_SHEET };
                    sheet.sections = [...sheet.sections];

                    // Source
                    const sourceBoxes = [...(sheet.sections[draggedCell.sectionIdx].boxes || [])];
                    const itemToMove = sourceBoxes[draggedCell.rowIdx];

                    // Safety
                    if (!itemToMove) return;

                    // Remove from source
                    sourceBoxes.splice(draggedCell.rowIdx, 1);
                    sheet.sections[draggedCell.sectionIdx] = { ...sheet.sections[draggedCell.sectionIdx], boxes: sourceBoxes };

                    // Target (Append to this section)
                    // Ensure boxes array exists
                    const targetBoxes = [...(sheet.sections[targetSectionIdx].boxes || []), itemToMove];
                    sheet.sections[targetSectionIdx] = { ...sheet.sections[targetSectionIdx], boxes: targetBoxes };

                    newLayouts.CALL_SHEET = sheet;
                    if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                    setDraggedCell(null);
                }
            };


            const saveHeader = (sectionIdx, rowIdx, newName) => {
                if (!onUpdateLayouts) return;
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                sheet.sections = [...sheet.sections];
                const boxes = [...sheet.sections[sectionIdx].boxes];
                boxes[rowIdx] = { ...boxes[rowIdx], header: newName };
                sheet.sections[sectionIdx] = { ...sheet.sections[sectionIdx], boxes };
                newLayouts.CALL_SHEET = sheet;
                onUpdateLayouts(newLayouts);
                setEditingHeader(null);
            };

            const toggleSectionExpansion = (sectionIdx) => {
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                const section = { ...sheet.sections[sectionIdx] };

                // Toggle expansion state
                section.expandToFill = !section.expandToFill;

                sheet.sections[sectionIdx] = section;
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
            };

            const toggleVisibility = (sectionIdx, rowIdx) => {
                if (!onUpdateLayouts) return;
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                sheet.sections = [...sheet.sections];
                const boxes = [...sheet.sections[sectionIdx].boxes];
                boxes[rowIdx] = { ...boxes[rowIdx], hidden: !boxes[rowIdx].hidden };
                sheet.sections[sectionIdx].boxes = boxes;
                newLayouts.CALL_SHEET = sheet;
                onUpdateLayouts(newLayouts);
            };

            // Extracted logic for Active Plays
            const getAllActivePlays = () => {
                const allActivePlayIds = new Set();
                Object.values(gamePlan?.sets || {}).forEach(set => set.playIds.forEach(id => allActivePlayIds.add(id)));
                Object.values(gamePlan?.miniScripts || {}).forEach(script => script.playIds.forEach(id => allActivePlayIds.add(id)));
                return Array.from(allActivePlayIds).map(id => plays.find(p => p.id === id)).filter(Boolean);
            };

            const [touchesPersonnelFilter, setTouchesPersonnelFilter] = useState('');

            const renderPlayerTouches = () => {
                const allActivePlays = getAllActivePlays();

                // Skill positions only (no OL - they don't get touches)
                const defaultSkillPositions = [
                    { key: 'QB' }, { key: 'RB' }, { key: 'FB' }, { key: 'F' },
                    { key: 'X' }, { key: 'Z' }, { key: 'Y' }, { key: 'A' }, { key: 'B' }, { key: 'H' }
                ];

                // Filter out hidden positions and positions that don't exist in user's setup
                const visibleDefaults = defaultSkillPositions.filter(
                    p => !(hiddenPositions['OFFENSE'] || []).includes(p.key)
                );

                // Append custom positions (non-OL positions user added)
                const customSkillPositions = (customPositions['OFFENSE'] || []).filter(
                    p => !['LT', 'LG', 'C', 'RG', 'RT'].includes(p.key)
                );
                let allPositions = [...visibleDefaults, ...customSkillPositions];

                // Filter by personnel grouping if selected
                if (touchesPersonnelFilter) {
                    const matchedGrouping = (personnelGroupings || []).find(g => g.id === touchesPersonnelFilter);
                    if (matchedGrouping) {
                        const personnelPositions = matchedGrouping.positions || [];
                        allPositions = allPositions.filter(p => personnelPositions.includes(p.key));
                    }
                }

                return (
                    <div className="animate-fade-in" style={{ height: '100%', overflowY: 'auto', paddingRight: '1rem', background: 'white', padding: '1rem', borderRadius: '8px' }}>
                        <div style={{ marginBottom: '1.5rem', border: '1px solid #ddd', borderRadius: '8px', overflow: 'hidden' }}>
                            <div style={{ background: '#f8fafc', padding: '0.5rem 1rem', borderBottom: '1px solid #ddd', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                <span style={{ fontWeight: 'bold', color: '#64748b', fontSize: '0.8rem', textTransform: 'uppercase' }}>
                                    Player Touches Summary
                                </span>
                                <select
                                    value={touchesPersonnelFilter}
                                    onChange={(e) => setTouchesPersonnelFilter(e.target.value)}
                                    style={{
                                        padding: '4px 8px',
                                        fontSize: '0.8rem',
                                        border: '1px solid #ddd',
                                        borderRadius: '4px',
                                        background: 'white'
                                    }}
                                >
                                    <option value="">All Personnel</option>
                                    {(personnelGroupings || []).map(grouping => (
                                        <option key={grouping.id} value={grouping.id}>
                                            {grouping.code || grouping.name} - {grouping.name || grouping.description}
                                        </option>
                                    ))}
                                </select>
                            </div>
                            <div style={{ display: 'grid', gridTemplateColumns: `repeat(${allPositions.length}, 1fr)`, divideX: '1px solid #eee' }}>
                                {allPositions.map((pos, idx) => {
                                    const posKey = pos.key;
                                    const targetPlays = allActivePlays.filter(p =>
                                        (p.tags || []).includes(posKey) ||
                                        p.primaryTarget === posKey ||
                                        p.tag1 === posKey ||
                                        p.tag2 === posKey
                                    );
                                    const displayLabel = positionNames[posKey] || posKey;

                                    return (
                                        <div key={posKey} style={{ borderRight: idx < allPositions.length - 1 ? '1px solid #eee' : 'none' }}>
                                            <div style={{ background: '#f1f5f9', padding: '0.25rem', textAlign: 'center', fontWeight: 'bold', fontSize: '0.9rem', borderBottom: '1px solid #eee' }}>
                                                {displayLabel} <span style={{ fontSize: '0.7rem', color: '#94a3b8', marginLeft: '4px' }}>({targetPlays.length})</span>
                                            </div>
                                            <div style={{ padding: '0.5rem', maxHeight: '600px', overflowY: 'auto' }}>
                                                {targetPlays.length > 0 ? (
                                                    targetPlays.map(p => (
                                                        <div key={p.id} style={{ fontSize: '0.7rem', marginBottom: '4px', padding: '2px 4px', background: 'white', border: '1px solid #eee', borderRadius: '3px' }}>
                                                            {p.name}
                                                        </div>
                                                    ))
                                                ) : (
                                                    <div style={{ fontSize: '0.7rem', color: '#cbd5e1', textAlign: 'center', fontStyle: 'italic', padding: '0.5rem 0' }}>-</div>
                                                )}
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    </div>
                );
            };

            const handleClearPlays = (setId) => {
                if (!onUpdateGamePlan) return;
                const newGamePlan = { ...gamePlan };
                let found = false;
                if (newGamePlan.sets) {
                    const set = newGamePlan.sets.find(s => s.id === setId);
                    if (set) {
                        set.playIds = [];
                        found = true;
                    }
                }
                if (!found && newGamePlan.miniScripts) {
                    const script = newGamePlan.miniScripts.find(s => s.id === setId);
                    if (script) {
                        script.playIds = [];
                        found = true;
                    }
                }
                if (found) onUpdateGamePlan(newGamePlan);
            };

            // --- Box Renderers & Helpers ---

            const handleAddRowToSection = (sectionIdx) => {
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                const section = { ...sheet.sections[sectionIdx] };

                const newId = `cell_${Date.now()}`;
                section.rows.push({ id: newId, content: '' });

                sheet.sections[sectionIdx] = section;
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
            };

            const handleAddBoxToSection = (sectionIdx, type = 'grid') => {
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                const section = { ...sheet.sections[sectionIdx] };

                // Ensure boxes array exists
                if (!section.boxes) section.boxes = [];

                // Create new Box
                const newBox = {
                    header: type === 'script' ? 'New Script' : 'New Grid Box',
                    color: '#3b82f6',
                    setId: `box_${Date.now()}`,
                    type: type,
                    colSpan: 1,
                    hidden: false
                };

                if (type === 'grid') {
                    newBox.gridHeadings = ['LEFT HASH', 'MIDDLE', 'RIGHT HASH', 'NOTES'];
                    newBox.gridRowLabels = ['Group 1', 'Group 2', 'Group 3', 'Group 4'];
                    newBox.cornerLabel = 'Group/Type';
                } else if (type === 'script') {
                    newBox.rows = [{ content: null, contentRight: null, id: `slot_${Date.now()}` }];
                }

                section.boxes.push(newBox);

                sheet.sections[sectionIdx] = section;
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
            };

            const setTempo = (sectionIdx, rowIdx, value) => {
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                const section = { ...sheet.sections[sectionIdx] };
                if (!section.tempos) section.tempos = {};

                section.tempos[rowIdx] = value;
                sheet.sections[sectionIdx] = section;
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
            };




            const GridPlayInput = ({ setId, onSelectPlay, onQuickAdd }) => {
                const [searchTerm, setSearchTerm] = useState('');
                const [showDropdown, setShowDropdown] = useState(false);
                const [selectedIndex, setSelectedIndex] = useState(0);
                const inputRef = useRef(null);
                const dropdownRef = useRef(null);

                const filteredResults = useMemo(() => {
                    if (!searchTerm) return [];
                    const lower = searchTerm.toLowerCase();
                    return plays.filter(p => {
                        return (p.name || '').toLowerCase().includes(lower) ||
                            (p.formation || '').toLowerCase().includes(lower) ||
                            (p.concept || '').toLowerCase().includes(lower) ||
                            (p.wristbandSlot || '').toLowerCase().includes(lower);
                    }).slice(0, 8);
                }, [searchTerm, plays]);

                useEffect(() => {
                    if (showDropdown && filteredResults.length > 0) setSelectedIndex(0);
                }, [showDropdown, filteredResults.length]);

                useEffect(() => {
                    const handleClickOutside = (event) => {
                        if (dropdownRef.current && !dropdownRef.current.contains(event.target) && !inputRef.current.contains(event.target)) {
                            setShowDropdown(false);
                        }
                    };
                    document.addEventListener("mousedown", handleClickOutside);
                    return () => document.removeEventListener("mousedown", handleClickOutside);
                }, []);

                const handleKeyDown = (e) => {
                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        setSelectedIndex(prev => Math.min(prev + 1, filteredResults.length - 1));
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        setSelectedIndex(prev => Math.max(prev - 1, 0));
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        if (showDropdown && filteredResults.length > 0) {
                            onSelectPlay(filteredResults[selectedIndex].id);
                            setSearchTerm('');
                            setShowDropdown(false);
                        } else if (searchTerm.trim()) {
                            onQuickAdd(searchTerm);
                            setSearchTerm('');
                            setShowDropdown(false);
                        }
                    } else if (e.key === 'Escape') {
                        setShowDropdown(false);
                    }
                };

                return (
                    <div style={{ position: 'relative', width: '100%', marginTop: '0' }}>
                        <input
                            ref={inputRef}
                            type="text"
                            placeholder="+"
                            value={searchTerm}
                            onChange={(e) => {
                                setSearchTerm(e.target.value.toUpperCase());
                                setShowDropdown(true);
                            }}
                            onFocus={() => setShowDropdown(true)}
                            onKeyDown={handleKeyDown}
                            onClick={(e) => e.stopPropagation()}
                            style={{
                                width: '100%',
                                padding: '2px 4px',
                                fontSize: '0.75rem',
                                border: '1px dashed var(--border)',
                                borderRadius: '3px',
                                background: 'var(--surface)'
                            }}
                        />
                        {showDropdown && searchTerm && (
                            <div
                                ref={dropdownRef}
                                style={{
                                    position: 'absolute',
                                    top: '100%',
                                    left: 0,
                                    width: '200px',
                                    maxHeight: '150px',
                                    overflowY: 'auto',
                                    background: 'white',
                                    border: '1px solid #cbd5e1',
                                    borderRadius: '4px',
                                    boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)',
                                    zIndex: 1000,
                                    marginTop: '2px'
                                }}
                            >
                                {filteredResults.map((p, idx) => (
                                    <div
                                        key={p.id}
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            onSelectPlay(p.id);
                                            setSearchTerm('');
                                            setShowDropdown(false);
                                        }}
                                        style={{
                                            padding: '4px 8px',
                                            fontSize: '0.75rem',
                                            cursor: 'pointer',
                                            background: idx === selectedIndex ? '#f1f5f9' : 'white',
                                            borderBottom: '1px solid #f1f5f9',
                                            color: '#0f172a' // Force dark text
                                        }}
                                        onMouseEnter={() => setSelectedIndex(idx)}
                                    >
                                        <div style={{ fontWeight: 'bold', color: '#0f172a' }}>{p.name}</div>
                                    </div>
                                ))}
                                {filteredResults.length === 0 && (
                                    <div style={{ padding: '4px 8px', fontSize: '0.7rem', color: '#94a3b8', fontStyle: 'italic' }}>
                                        Enter to create "{searchTerm}"
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                );
            };

            const handleAssignPlayToSituation = (playId, box) => {
                if (!playId || !box || !box.setId) return;

                const isScript = box.type === 'script';
                const collectionKey = isScript ? 'miniScripts' : 'sets';
                const targetId = box.setId;

                const updatedGamePlan = { ...gamePlan };

                // Ensure collection array exists
                if (!Array.isArray(updatedGamePlan[collectionKey])) {
                    updatedGamePlan[collectionKey] = [];
                }

                // Find existing set/script in the array
                const existingItem = updatedGamePlan[collectionKey].find(item => item.id === targetId);

                // Get current assigned IDs
                const currentData = existingItem || { playIds: [], assignedPlayIds: [] };
                let currentAssigned = currentData.assignedPlayIds || currentData.playIds || [];

                const isAssigned = currentAssigned.includes(playId);
                let newAssignedIds;

                if (isAssigned) {
                    // Remove play (toggle off)
                    newAssignedIds = currentAssigned.filter(id => id !== playId);
                } else {
                    // Add play - use Set to prevent duplicates from rapid clicks
                    newAssignedIds = [...new Set([...currentAssigned, playId])];
                }

                if (existingItem) {
                    // Update existing item
                    updatedGamePlan[collectionKey] = updatedGamePlan[collectionKey].map(item =>
                        item.id === targetId
                            ? { ...item, assignedPlayIds: newAssignedIds }
                            : item
                    );
                } else {
                    // Create new item
                    updatedGamePlan[collectionKey] = [
                        ...updatedGamePlan[collectionKey],
                        { id: targetId, name: targetId, assignedPlayIds: newAssignedIds, playIds: [] }
                    ];
                }

                onUpdateGamePlan(updatedGamePlan);
            };

            const getPlaySituations = (playId) => {
                if (!playId || !gamePlanLayouts?.CALL_SHEET?.sections) return [];

                const assignedSituations = [];

                gamePlanLayouts.CALL_SHEET.sections.forEach(section => {
                    if (!section.boxes) return;
                    section.boxes.forEach(box => {
                        if (!box.setId) return;

                        const isScript = box.type === 'script';
                        const collection = isScript ? (gamePlan?.miniScripts || []) : (gamePlan?.sets || []);

                        // Handle both array and object formats
                        let data;
                        if (Array.isArray(collection)) {
                            data = collection.find(item => item.id === box.setId);
                        } else {
                            data = collection[box.setId];
                        }

                        // Check if play is assigned
                        if (data?.assignedPlayIds?.includes(playId)) {
                            assignedSituations.push({
                                id: box.setId,
                                header: box.header,
                                color: box.color,
                                type: box.type
                            });
                        }
                    });
                });

                return assignedSituations;
            };

            const PlaySlot = ({ playId, onUpdate, isLocked, placeholder = "+", dropUp = false, renderWristbandInput }) => {
                const play = plays.find(p => p.id === playId);
                const [isHovered, setIsHovered] = useState(false);
                const [searchTerm, setSearchTerm] = useState('');
                const [showDropdown, setShowDropdown] = useState(false);
                const [selectedIndex, setSelectedIndex] = useState(0);
                const dropdownRef = useRef(null);
                const inputRef = useRef(null);

                // Derived state for filtered results
                const filteredResults = useMemo(() => {
                    if (!searchTerm || isLocked) return [];
                    const lower = searchTerm.toLowerCase();

                    // Search Criteria: Name, Formulation, Concept, Wristband Slot
                    return plays.filter(p => {
                        const matchName = p.name.toLowerCase().includes(lower);
                        const matchFormation = (p.formation || '').toLowerCase().includes(lower);
                        const matchConcept = (p.concept || '').toLowerCase().includes(lower);
                        const matchWB = (p.wristbandSlot || '').toLowerCase().includes(lower);

                        return matchName || matchFormation || matchConcept || matchWB;
                    }).slice(0, 10); // Limit results
                }, [searchTerm, plays, isLocked]);

                // Close dropdown when clicking outside
                useEffect(() => {
                    const handleClickOutside = (event) => {
                        if (dropdownRef.current && !dropdownRef.current.contains(event.target) && !inputRef.current.contains(event.target)) {
                            setShowDropdown(false);
                        }
                    };
                    document.addEventListener("mousedown", handleClickOutside);
                    return () => document.removeEventListener("mousedown", handleClickOutside);
                }, []);

                useEffect(() => {
                    if (showDropdown && filteredResults.length > 0) {
                        setSelectedIndex(0);
                    }
                }, [showDropdown, filteredResults.length]);

                const handleKeyDown = (e) => {
                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        setSelectedIndex(prev => Math.min(prev + 1, filteredResults.length - 1));
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        setSelectedIndex(prev => Math.max(prev - 1, 0));
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        if (showDropdown && filteredResults.length > 0) {
                            // Select from dropdown
                            onUpdate(filteredResults[selectedIndex].id);
                            setShowDropdown(false);
                            setSearchTerm('');
                        } else {
                            // Quick Add New
                            if (onQuickAddPlay) {
                                const newPlay = onQuickAddPlay(searchTerm);
                                onUpdate(newPlay.id);
                                setShowDropdown(false);
                                setSearchTerm('');
                            }
                        }
                    } else if (e.key === 'Escape') {
                        setShowDropdown(false);
                    }
                };

                return (
                    <div
                        style={{
                            width: '100%',
                            height: '100%',
                            position: 'relative',
                            display: 'flex',
                            alignItems: 'center',
                            padding: '0 4px',
                            background: isHovered ? '#e0f2fe' : 'transparent',
                            cursor: play ? 'pointer' : 'text'  // Use 'text' cursor when showing input
                        }}
                        onDragOver={(e) => { e.preventDefault(); setIsHovered(true); }}
                        onDragLeave={() => setIsHovered(false)}
                        onDrop={(e) => {
                            e.preventDefault(); setIsHovered(false); if (isLocked) return;
                            try { const data = JSON.parse(e.dataTransfer.getData('application/react-dnd')); if (data && data.playId) onUpdate(data.playId); } catch (e) { }
                        }}
                        onDoubleClick={(e) => {
                            if (isLocked || !play) return;
                            e.stopPropagation();
                            setAssignmentModalState({ playId: play.id, x: e.clientX, y: e.clientY });
                        }}
                    >
                        {play ? (
                            <div style={{ width: '100%', overflow: 'hidden', display: 'flex', alignItems: 'center', gap: '4px', padding: '1px 0' }}>
                                <span style={{ fontWeight: 'bold', color: '#0f172a', fontSize: '0.7rem', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap', flex: 1, minWidth: 0 }}>{getPlayDisplayName(play)}</span>
                                {play.staplesSlot && <span style={{ fontSize: '0.6rem', background: '#fef3c7', color: '#b45309', padding: '1px 3px', borderRadius: '2px', fontWeight: 'bold', flexShrink: 0 }}>S:{play.staplesSlot}</span>}
                                {renderWristbandInput && renderWristbandInput(play.id)}
                                {!renderWristbandInput && play.wristbandSlot && (
                                    <span style={{ fontSize: '0.6rem', background: '#e0f2fe', color: '#0369a1', padding: '1px 3px', borderRadius: '2px', fontWeight: 'bold', flexShrink: 0 }}>
                                        {typeof getWristbandLabel === 'function' ? getWristbandLabel(play) : play.wristbandSlot + (play.isMiniScript || play.isWiz ? '' : 'T')}
                                    </span>
                                )}
                                {!isLocked && <button style={{ background: 'none', border: 'none', color: '#ef4444', cursor: 'pointer', padding: '0 2px', fontSize: '0.9em', lineHeight: '1', flexShrink: 0 }} onClick={() => onUpdate(null)}>×</button>}
                            </div>
                        ) : (
                            !isLocked && (
                                <div
                                    style={{ position: 'relative', width: '100%' }}
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        if (inputRef.current) {
                                            inputRef.current.focus();
                                        }
                                    }}
                                >
                                    <input
                                        ref={inputRef}
                                        placeholder={placeholder}
                                        value={searchTerm}
                                        onChange={(e) => {
                                            setSearchTerm(e.target.value.toUpperCase());
                                            setShowDropdown(true);
                                        }}
                                        onFocus={() => setShowDropdown(true)}
                                        onKeyDown={handleKeyDown}
                                        style={{ width: '100%', border: 'none', fontSize: '0.9rem', background: 'transparent', outline: 'none' }}
                                    />
                                    {showDropdown && searchTerm && (
                                        <div
                                            ref={dropdownRef}
                                            style={{
                                                position: 'absolute',
                                                top: dropUp ? 'auto' : '100%',
                                                bottom: dropUp ? '100%' : 'auto',
                                                left: 0,
                                                width: '300px', // Wider than input
                                                maxHeight: '200px',
                                                overflowY: 'auto',
                                                background: 'white',
                                                border: '1px solid #cbd5e1',
                                                borderRadius: '4px',
                                                boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)',
                                                zIndex: 1000,
                                                marginTop: dropUp ? '0' : '4px',
                                                marginBottom: dropUp ? '4px' : '0'
                                            }}
                                        >
                                            {filteredResults.map((p, idx) => (
                                                <div
                                                    key={p.id}
                                                    onClick={() => {
                                                        onUpdate(p.id);
                                                        setShowDropdown(false);
                                                        setSearchTerm('');
                                                    }}
                                                    style={{
                                                        padding: '6px 12px',
                                                        fontSize: '0.85rem',
                                                        cursor: 'pointer',
                                                        background: idx === selectedIndex ? '#f1f5f9' : 'white',
                                                        borderBottom: '1px solid #f1f5f9',
                                                        display: 'flex', alignItems: 'center', justifyContent: 'space-between',
                                                        color: '#0f172a' // Force dark text color
                                                    }}
                                                    onMouseEnter={() => setSelectedIndex(idx)}
                                                >
                                                    <div style={{ display: 'flex', flexDirection: 'column' }}>
                                                        <span style={{ fontWeight: 'bold', color: '#0f172a' }}>{p.name}</span>
                                                    </div>
                                                    {p.wristbandSlot && (
                                                        <div style={{ fontSize: '0.7em', background: '#dbeafe', color: '#1e40af', padding: '2px 6px', borderRadius: '12px', fontWeight: 'bold' }}>
                                                            {p.wristbandSlot}
                                                        </div>
                                                    )}
                                                </div>
                                            ))}
                                            {filteredResults.length === 0 && (
                                                <div style={{ padding: '8px', fontSize: '0.8rem', color: '#64748b', fontStyle: 'italic' }}>
                                                    Press Enter to create "{searchTerm}"
                                                </div>
                                            )}
                                        </div>
                                    )}
                                </div>
                            )
                        )}

                        {/* Situation Assignment UI - DOTS ONLY */}
                        {
                            (playId && !isLocked) && (
                                <div style={{ display: 'flex', alignItems: 'center', marginLeft: 'auto', paddingLeft: '4px' }}>
                                    {/* Render Assigned Situations */}
                                    {getPlaySituations(playId).map(sit => (
                                        <div
                                            key={sit.id}
                                            title={`Assigned to ${sit.header}`}
                                            style={{
                                                width: '8px', height: '8px', borderRadius: '50%',
                                                backgroundColor: sit.color || '#cbd5e1',
                                                marginRight: '2px',
                                                cursor: 'help'
                                            }}
                                        />
                                    ))}
                                </div>
                            )
                        }

                    </div >
                );
            };

            const renderInteriorConfig = (box, sectionIdx, boxIdx) => (
                <div style={{ background: '#f8fafc', border: '1px solid #e2e8f0', borderRadius: '6px', padding: '8px', marginBottom: '8px', display: 'flex', flexDirection: 'column', gap: '8px' }}>
                    <div style={{ width: '100%' }}>
                        <div style={{ fontSize: '0.65rem', fontWeight: 'bold', color: '#64748b', textTransform: 'uppercase', marginBottom: '2px' }}>Box Name</div>
                        <input
                            type="text"
                            value={box.header || ''}
                            onChange={(e) => {
                                const newLayouts = { ...gamePlanLayouts };
                                newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx].header = e.target.value;
                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                            }}
                            placeholder="Enter box name (e.g. 3rd & Long)"
                            style={{ width: '100%', padding: '6px', border: '1px solid #cbd5e1', borderRadius: '4px', fontSize: '0.8rem', fontFamily: 'inherit', marginBottom: '8px' }}
                        />
                        <div style={{ fontSize: '0.65rem', fontWeight: 'bold', color: '#64748b', textTransform: 'uppercase', marginBottom: '2px' }}>Box Notes / Situation Detail</div>
                        <textarea
                            value={box.notes || ''}
                            onChange={(e) => {
                                const newLayouts = { ...gamePlanLayouts };
                                newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx].notes = e.target.value;
                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                            }}
                            placeholder="Add situation details, notes, or instructions here..."
                            style={{ width: '100%', padding: '6px', border: '1px solid #cbd5e1', borderRadius: '4px', fontSize: '0.8rem', minHeight: '60px', resize: 'vertical', fontFamily: 'inherit' }}
                        />
                    </div>
                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: '8px' }}>
                        <div style={{ flex: 1 }}>
                            <div style={{ fontSize: '0.65rem', fontWeight: 'bold', color: '#64748b', textTransform: 'uppercase', marginBottom: '2px' }}>Box Type</div>
                            <select
                                value={box.type || 'grid'}
                                onChange={(e) => {
                                    const newLayouts = { ...gamePlanLayouts };
                                    newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx].type = e.target.value;
                                    if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                }}
                                style={{ width: '100%', padding: '4px', border: '1px solid #cbd5e1', borderRadius: '4px', fontSize: '0.8rem' }}
                            >
                                <option value="grid">Grid (4x4)</option>
                                <option value="script">Script (Rows)</option>
                            </select>
                        </div>
                        <button
                            className="btn-sm"
                            onClick={() => {
                                if (confirm('Delete this box?')) {
                                    const newLayouts = { ...gamePlanLayouts };
                                    newLayouts.CALL_SHEET.sections[sectionIdx].boxes.splice(boxIdx, 1);
                                    if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                    setEditingHeader(null);
                                    setEditingBox(null);
                                }
                            }}
                            style={{ background: '#fee2e2', color: '#dc2626', fontSize: '0.7rem', padding: '6px', borderRadius: '4px', border: '1px solid #fca5a5' }}
                        ><Icon name="Trash2" size={14} /></button>
                    </div>
                </div>
            );

            const renderAssignedPlaysPanel = (box) => {
                // Get the setId from the box to look up assigned plays
                const setId = box.setId;
                if (!setId) return null;

                // Get the set/script data object
                const sets = Array.isArray(gamePlan?.sets) ? gamePlan.sets : [];
                const scripts = Array.isArray(gamePlan?.miniScripts) ? gamePlan.miniScripts : [];
                const setData = sets.find(s => s.id === setId) || scripts.find(s => s.id === setId) || {};

                // Get assigned play IDs (safely defaulting to empty array)
                // Note: handling both 'playIds' and 'assignedPlayIds' for backward compatibility/migration
                let assignedPlayIds = setData.assignedPlayIds || setData.playIds || [];

                // PATCH: For Opening Script, aggregate from Left/Right hash sets AND Install List situations
                if (setId === 'opening_script') {
                    const leftSet = sets.find(s => s.id === 'opening_script_left') || {};
                    const rightSet = sets.find(s => s.id === 'opening_script_right') || {};
                    const leftIds = leftSet.assignedPlayIds || leftSet.playIds || [];
                    const rightIds = rightSet.assignedPlayIds || rightSet.playIds || [];

                    // Also find plays tagged with "Opening Script" in the Install List / Play Data
                    const taggedPlays = plays.filter(p => {
                        // Check if play is in install list (optional, but good practice)
                        // And check if its situation matches "Opening Script"
                        // This depends on how situation is stored. Assuming p.situation or p.tags
                        return p.situation === 'Opening Script' || (p.tags && p.tags.includes('Opening Script'));
                    }).map(p => p.id);

                    // Merge and Deduplicate
                    const allIds = new Set([...assignedPlayIds, ...leftIds, ...rightIds, ...taggedPlays]);
                    assignedPlayIds = Array.from(allIds);
                }

                // Map play IDs to full play objects
                const assignedPlays = assignedPlayIds
                    .map(playId => plays.find(p => p.id === playId))
                    .filter(Boolean);

                // Handle adding a play
                // Determine if this is a script or set
                const isScript = box.type === 'script';
                const collectionKey = isScript ? 'miniScripts' : 'sets';

                // Handle adding a play
                const handleAddPlay = (playId) => {
                    if (!assignedPlayIds.includes(playId)) {
                        const updatedGamePlan = { ...gamePlan };

                        // Ensure collection array exists
                        if (!updatedGamePlan[collectionKey]) {
                            updatedGamePlan[collectionKey] = [];
                        }

                        // Find existing set/script in the array
                        const existingItem = updatedGamePlan[collectionKey].find(item => item.id === setId);
                        const newAssignedIds = [...assignedPlayIds, playId];

                        if (existingItem) {
                            // Update existing item - only update assignedPlayIds, NOT playIds (grid uses playIds)
                            updatedGamePlan[collectionKey] = updatedGamePlan[collectionKey].map(item =>
                                item.id === setId
                                    ? { ...item, assignedPlayIds: newAssignedIds }
                                    : item
                            );
                        } else {
                            // Create new item - initialize playIds as empty array (used by Grid), assignedPlayIds for Quick List
                            updatedGamePlan[collectionKey] = [
                                ...updatedGamePlan[collectionKey],
                                { id: setId, name: setId, assignedPlayIds: newAssignedIds, playIds: [] }
                            ];
                        }

                        onUpdateGamePlan(updatedGamePlan);
                    }
                };

                // Handle removing a play
                const handleRemovePlay = (playId) => {
                    const updatedGamePlan = { ...gamePlan };

                    if (!updatedGamePlan[collectionKey]) return;

                    const newAssignedIds = assignedPlayIds.filter(id => id !== playId);

                    // Update the item in the array - only update assignedPlayIds, NOT playIds
                    updatedGamePlan[collectionKey] = updatedGamePlan[collectionKey].map(item =>
                        item.id === setId
                            ? { ...item, assignedPlayIds: newAssignedIds }
                            : item
                    );

                    onUpdateGamePlan(updatedGamePlan);
                };

                // Handle reordering plays
                const handleMovePlay = (playId, direction) => {
                    const currentIndex = assignedPlayIds.indexOf(playId);
                    if (currentIndex === -1) return;

                    const newIndex = direction === 'up' ? currentIndex - 1 : currentIndex + 1;
                    if (newIndex < 0 || newIndex >= assignedPlayIds.length) return;

                    const updatedGamePlan = { ...gamePlan };
                    if (!updatedGamePlan[collectionKey]) return;

                    const newPlayIds = [...assignedPlayIds];
                    [newPlayIds[currentIndex], newPlayIds[newIndex]] = [newPlayIds[newIndex], newPlayIds[currentIndex]];

                    // Update the item in the array - only update assignedPlayIds, NOT playIds
                    updatedGamePlan[collectionKey] = updatedGamePlan[collectionKey].map(item =>
                        item.id === setId
                            ? { ...item, assignedPlayIds: newPlayIds }
                            : item
                    );

                    onUpdateGamePlan(updatedGamePlan);
                };

                return (
                    <div style={{
                        display: 'flex',
                        flexDirection: 'column',
                        height: '100%',
                        background: '#f8fafc',
                        borderRadius: '8px',
                        overflow: 'visible'  // Changed from 'hidden' to allow dropdown to show
                    }}>
                        {/* Header */}
                        <div style={{
                            padding: '1rem',
                            borderBottom: '2px solid #e2e8f0',
                            background: 'white'
                        }}>
                            <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                                <h4 style={{ margin: 0, fontSize: '0.9rem', fontWeight: 'bold', color: '#1e293b' }}>
                                    QUICK LIST
                                </h4>
                                <span style={{
                                    background: box.color || '#64748b',
                                    color: 'white',
                                    padding: '2px 8px',
                                    borderRadius: '12px',
                                    fontSize: '0.75rem',
                                    fontWeight: 'bold'
                                }}>
                                    {assignedPlays.length}
                                </span>
                            </div>
                        </div>

                        {/* Play List */}
                        <div style={{ flex: 1, overflowY: 'auto', padding: '0.5rem' }}>
                            {assignedPlays.length > 0 ? (
                                assignedPlays.map((play, idx) => (
                                    <div
                                        key={play.id}
                                        draggable={true}
                                        style={{
                                            background: 'white',
                                            border: '1px solid #e2e8f0',
                                            borderRadius: '6px',
                                            padding: '0.4rem',
                                            marginBottom: '0.25rem',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '0.5rem',
                                            cursor: 'grab'
                                        }}
                                        onDragStart={(e) => {
                                            e.dataTransfer.setData('application/react-dnd', JSON.stringify({ playId: play.id }));
                                            e.currentTarget.style.cursor = 'grabbing';
                                            e.currentTarget.style.opacity = '0.5';
                                        }}
                                        onDragEnd={(e) => {
                                            e.currentTarget.style.cursor = 'grab';
                                            e.currentTarget.style.opacity = '1';
                                        }}
                                        onDoubleClick={(e) => {
                                            e.stopPropagation();
                                            setAssignmentModalState({ playId: play.id, x: e.clientX, y: e.clientY });
                                        }}
                                    >
                                        {/* Reorder Buttons */}
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '2px' }}>
                                            <button
                                                onClick={() => handleMovePlay(play.id, 'up')}
                                                disabled={idx === 0}
                                                style={{
                                                    padding: '2px 4px',
                                                    fontSize: '0.7rem',
                                                    background: idx === 0 ? '#f1f5f9' : '#e2e8f0',
                                                    border: 'none',
                                                    borderRadius: '3px',
                                                    cursor: idx === 0 ? 'not-allowed' : 'pointer',
                                                    color: idx === 0 ? '#cbd5e1' : '#475569'
                                                }}
                                            >
                                                ▲
                                            </button>
                                            <button
                                                onClick={() => handleMovePlay(play.id, 'down')}
                                                disabled={idx === assignedPlays.length - 1}
                                                style={{
                                                    padding: '2px 4px',
                                                    fontSize: '0.7rem',
                                                    background: idx === assignedPlays.length - 1 ? '#f1f5f9' : '#e2e8f0',
                                                    border: 'none',
                                                    borderRadius: '3px',
                                                    cursor: idx === assignedPlays.length - 1 ? 'not-allowed' : 'pointer',
                                                    color: idx === assignedPlays.length - 1 ? '#cbd5e1' : '#475569'
                                                }}
                                            >
                                                ▼
                                            </button>
                                        </div>

                                        {/* Play Info */}
                                        <div style={{ flex: 1, minWidth: 0 }}>
                                            <div style={{ fontWeight: 'bold', fontSize: '0.85rem', color: '#1e293b', marginBottom: '2px', display: 'flex', alignItems: 'center', gap: '4px' }}>
                                                {play.priority && <Icon name="Star" size={12} fill="gold" color="gold" />}
                                                {getPlayDisplayName(play)}
                                                {play.wristbandSlot && (
                                                    <span style={{
                                                        marginLeft: '6px',
                                                        fontSize: '0.7rem',
                                                        background: '#dbeafe',
                                                        color: '#1e40af',
                                                        padding: '1px 6px',
                                                        borderRadius: '10px',
                                                        fontWeight: 'normal'
                                                    }}>
                                                        {play.wristbandSlot}
                                                    </span>
                                                )}
                                            </div>

                                        </div>

                                        {/* Remove Button */}
                                        <button
                                            onClick={() => handleRemovePlay(play.id)}
                                            style={{
                                                padding: '4px 8px',
                                                fontSize: '0.9rem',
                                                background: '#fee2e2',
                                                color: '#dc2626',
                                                border: 'none',
                                                borderRadius: '4px',
                                                cursor: 'pointer',
                                                fontWeight: 'bold'
                                            }}
                                            onMouseEnter={(e) => e.currentTarget.style.background = '#fecaca'}
                                            onMouseLeave={(e) => e.currentTarget.style.background = '#fee2e2'}
                                        >
                                            ×
                                        </button>
                                    </div>
                                ))
                            ) : (
                                <div style={{
                                    textAlign: 'center',
                                    padding: '2rem 1rem',
                                    color: '#94a3b8',
                                    fontSize: '0.85rem',
                                    fontStyle: 'italic'
                                }}>
                                    No plays assigned yet.
                                    <br />
                                    Click "Add Play" below to get started.
                                </div>
                            )}

                            {/* Suggestions Section */}
                            {suggestions[box.setId]?.length > 0 && (
                                <div style={{ marginTop: '0.5rem', padding: '0.5rem', background: '#fef2f2', borderRadius: '6px', border: '1px solid #fecaca' }}>
                                    <div style={{ fontSize: '0.75rem', fontWeight: 'bold', color: '#ef4444', marginBottom: '0.5rem', display: 'flex', alignItems: 'center', gap: '4px' }}>
                                        <Icon name="MessageSquare" size={14} />
                                        SUGGESTIONS ({suggestions[box.setId].length})
                                    </div>
                                    {suggestions[box.setId].map((playId, idx) => {
                                        const play = plays.find(p => p.id === playId);
                                        if (!play) return null;
                                        return (
                                            <div key={idx} style={{
                                                display: 'flex',
                                                alignItems: 'center',
                                                justifyContent: 'space-between',
                                                padding: '4px 8px',
                                                background: 'white',
                                                borderRadius: '4px',
                                                marginBottom: '4px',
                                                fontSize: '0.8rem'
                                            }}>
                                                <span style={{ fontWeight: '500' }}>{play.name}</span>
                                                <div style={{ display: 'flex', gap: '4px' }}>
                                                    <button
                                                        onClick={() => {
                                                            // Accept: add to quick list
                                                            handleAddPlay(playId);
                                                            // Remove from suggestions
                                                            if (onUpdateSuggestions) {
                                                                const newSuggestions = { ...suggestions };
                                                                newSuggestions[box.setId] = newSuggestions[box.setId].filter(id => id !== playId);
                                                                if (newSuggestions[box.setId].length === 0) delete newSuggestions[box.setId];
                                                                onUpdateSuggestions(newSuggestions);
                                                            }
                                                        }}
                                                        style={{
                                                            background: '#22c55e',
                                                            color: 'white',
                                                            border: 'none',
                                                            borderRadius: '4px',
                                                            padding: '2px 8px',
                                                            fontSize: '0.7rem',
                                                            fontWeight: 'bold',
                                                            cursor: 'pointer'
                                                        }}
                                                        title="Accept"
                                                    >
                                                        ✓ Accept
                                                    </button>
                                                    <button
                                                        onClick={() => {
                                                            // Dismiss: just remove from suggestions
                                                            if (onUpdateSuggestions) {
                                                                const newSuggestions = { ...suggestions };
                                                                newSuggestions[box.setId] = newSuggestions[box.setId].filter(id => id !== playId);
                                                                if (newSuggestions[box.setId].length === 0) delete newSuggestions[box.setId];
                                                                onUpdateSuggestions(newSuggestions);
                                                            }
                                                        }}
                                                        style={{
                                                            background: '#f1f5f9',
                                                            color: '#64748b',
                                                            border: '1px solid #e2e8f0',
                                                            borderRadius: '4px',
                                                            padding: '2px 8px',
                                                            fontSize: '0.7rem',
                                                            cursor: 'pointer'
                                                        }}
                                                        title="Dismiss"
                                                    >
                                                        ✕
                                                    </button>
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                            )}
                        </div>

                        {/* Add Play Button */}
                        <div style={{ padding: '0.75rem', borderTop: '2px solid #e2e8f0', background: 'white' }}>
                            <PlaySlot
                                playId={null}
                                isLocked={false}
                                onUpdate={handleAddPlay}
                                placeholder="+ Add Play to Situation"
                                dropUp={true}
                            />
                        </div>
                    </div>
                );
            };

            const renderBoxEditorModal = () => {
                if (!editingBox) return null;
                const { sectionIdx, boxIdx } = editingBox;
                const section = gamePlanLayouts.CALL_SHEET.sections[sectionIdx];
                if (!section) return null;
                const box = section.boxes[boxIdx];
                if (!box) return null;

                const renderWristbandInput = (playId) => {
                    const play = plays.find(p => p.id === playId);
                    if (!play) return null;

                    const isFocused = wbAutocomplete.playId === playId;

                    // Filter available slots
                    const usedSlots = new Set(plays.filter(p => p.id !== playId && p.wristbandSlot).map(p => p.wristbandSlot));
                    const availableSlots = (validWristbandSlots || []).filter(slot => !usedSlots.has(slot));

                    const query = isFocused ? wbAutocomplete.query : (play.wristbandSlot || '');
                    const filteredSlots = isFocused && query
                        ? availableSlots.filter(s => s.toString().includes(query))
                        : []; // Only show when typing? Or show all available? Let's show filtered.

                    // Limit results
                    const candidates = filteredSlots.slice(0, 10);

                    return (
                        <div style={{ position: 'relative', marginLeft: '6px' }}>
                            <input
                                placeholder="#"
                                value={isFocused ? wbAutocomplete.query : (getWristbandLabel(play) || '')}
                                onFocus={() => setWbAutocomplete({ playId, query: play.wristbandSlot || '' })}
                                onChange={(e) => {
                                    setWbAutocomplete({ playId, query: e.target.value });
                                }}
                                onBlur={() => {
                                    // Delay to allow click
                                    setTimeout(() => {
                                        if (wbAutocomplete.playId === playId) {
                                            const slot = wbAutocomplete.query;

                                            // Validation Logic
                                            let isBlocked = false;
                                            const currentWbSettings = currentWeek?.wristbands || {};
                                            const enabledSections = currentWbSettings.enabledSections || {};

                                            const cardKeys = ['card1', 'card2', 'card3', 'card4', 'card5', 'card6'];
                                            for (const key of cardKeys) {
                                                if (enabledSections[key] !== false) continue;
                                                const card = currentWbSettings[key];
                                                if (!card) continue;
                                                const cardNum = parseInt(key.replace('card', ''));

                                                if (card.type && (card.type === 'wiz')) {
                                                    for (let i = 1; i <= 16; i++) {
                                                        if (slot === `${cardNum}${String(i).padStart(2, '0')}`) isBlocked = true;
                                                    }
                                                } else {
                                                    const start = cardNum * 100 + 1;
                                                    const end = start + 47;
                                                    const num = parseInt(slot);
                                                    if (!isNaN(num) && num >= start && num <= end && String(num) === slot) isBlocked = true;
                                                }
                                            }

                                            // Check Staples
                                            if (enabledSections.staples === false) {
                                                const num = parseInt(slot);
                                                if (!isNaN(num) && num >= 10 && num <= 89 && String(num) === slot) isBlocked = true;
                                            }

                                            if (isBlocked) {
                                                alert("This wristband section is disabled.");
                                                setWbAutocomplete({ playId: null, query: '' }); // Reset
                                                return;
                                            }

                                            if (onUpdatePlay) onUpdatePlay({ ...play, wristbandSlot: wbAutocomplete.query });
                                            setWbAutocomplete({ playId: null, query: '' });
                                        }
                                    }, 200);
                                }}
                                style={{
                                    width: '36px', fontSize: '0.75rem', padding: '2px 4px',
                                    border: '1px solid #cbd5e1', borderRadius: '4px', textAlign: 'center',
                                    background: play.wristbandSlot ? '#dbeafe' : 'white',
                                    color: play.wristbandSlot ? '#1e40af' : '#64748b',
                                    fontWeight: 'bold'
                                }}
                            />
                            {isFocused && candidates.length > 0 && (
                                <div style={{
                                    position: 'absolute', top: '100%', right: 0,
                                    background: 'white', border: '1px solid #cbd5e1', borderRadius: '4px',
                                    boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)', zIndex: 50,
                                    maxHeight: '150px', overflowY: 'auto', minWidth: '60px'
                                }}>
                                    {candidates.map(slot => (
                                        <div
                                            key={slot}
                                            onMouseDown={(e) => {
                                                e.preventDefault(); // Prevent blur

                                                // Validation Logic Same as onBlur but checking 'slot'
                                                let isBlocked = false;
                                                const currentWbSettings = currentWeek?.wristbands || {};
                                                const enabledSections = currentWbSettings.enabledSections || {};

                                                const cardKeys = ['card1', 'card2', 'card3', 'card4', 'card5', 'card6'];
                                                for (const key of cardKeys) {
                                                    if (enabledSections[key] !== false) continue;
                                                    const card = currentWbSettings[key];
                                                    if (!card) continue;
                                                    const cardNum = parseInt(key.replace('card', ''));

                                                    if (card.type && (card.type === 'wiz')) {
                                                        for (let i = 1; i <= 16; i++) {
                                                            if (String(slot) === `${cardNum}${String(i).padStart(2, '0')}`) isBlocked = true;
                                                        }
                                                    } else {
                                                        const start = cardNum * 100 + 1;
                                                        const end = start + 47;
                                                        const num = parseInt(slot);
                                                        if (!isNaN(num) && num >= start && num <= end && String(num) === String(slot)) isBlocked = true;
                                                    }
                                                }

                                                if (enabledSections.staples === false) {
                                                    const num = parseInt(slot);
                                                    if (!isNaN(num) && num >= 10 && num <= 89 && String(num) === String(slot)) isBlocked = true;
                                                }

                                                if (isBlocked) {
                                                    alert("This wristband section is disabled.");
                                                    setWbAutocomplete({ playId: null, query: '' }); // Reset
                                                    return;
                                                }

                                                if (onUpdatePlay) onUpdatePlay({ ...play, wristbandSlot: slot });
                                                setWbAutocomplete({ playId: null, query: '' });
                                            }}
                                            style={{
                                                padding: '4px 8px', fontSize: '0.75rem', cursor: 'pointer',
                                                borderBottom: '1px solid #f1f5f9', hover: { background: '#f8fafc' } // Inline hover not supported, relying on standard behavior
                                            }}
                                        >
                                            {slot}
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>
                    );
                };


                return (
                    <div style={{
                        position: 'fixed', top: 0, left: 0, right: '400px', bottom: 0,
                        backgroundColor: 'rgba(0,0,0,0.8)', zIndex: 1100,
                        display: 'flex', alignItems: 'center', justifyContent: 'center'
                    }} onClick={() => setEditingBox(null)}>
                        <div style={{
                            width: '95%', maxWidth: '1100px', maxHeight: '90vh',
                            background: 'white', borderRadius: '8px',
                            display: 'flex', flexDirection: 'column',
                            overflow: 'hidden'
                        }} onClick={e => e.stopPropagation()}>
                            <div style={{ padding: '1rem', borderBottom: '1px solid #ddd', display: 'flex', justifyContent: 'space-between', alignItems: 'center', background: box.color || '#f8fafc', color: 'white' }}>
                                <h3 style={{ margin: 0, textTransform: 'uppercase' }}>Edit {box.header}</h3>
                                <button className="btn" onClick={() => setEditingBox(null)} style={{ background: 'rgba(255,255,255,0.2)', border: 'none', color: 'white' }}>Close</button>
                            </div>
                            <div style={{ display: 'flex', flex: 1, overflow: 'hidden' }}>
                                {/* Left Panel: QUICK LIST */}
                                <div style={{ width: '350px', borderRight: '1px solid #e2e8f0', overflow: 'hidden' }}>
                                    {renderAssignedPlaysPanel(box)}
                                </div>

                                {/* Right Panel: Editor */}
                                <div style={{ flex: 1, padding: '1rem', overflowY: 'auto' }}>
                                    {box.type === 'script' ? renderScriptBox(box, sectionIdx, boxIdx, true, renderWristbandInput) : renderGridBox(box, sectionIdx, boxIdx, true, renderWristbandInput)}
                                </div>
                            </div>
                        </div>
                    </div>
                );
            };

            const renderScriptBox = (box, sectionIdx, boxIdx, isEditing, renderWristbandInput) => {
                const rows = (box.rows && box.rows.length > 0) ? box.rows : [{ id: 'default', label: '1', content: '' }];
                const tempos = box.tempos || {};
                const protocolList = box.customTempos || PLAY_PROTOCOLS;



                return (
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '4px', background: 'white', borderRadius: '4px', height: '100%' }}>
                        {isEditing && renderInteriorConfig(box, sectionIdx, boxIdx)}

                        <div style={{ flex: 1 }}>
                            {/* Header Row */}
                            <div style={{ display: 'grid', gridTemplateColumns: '60px 1fr 1fr', gap: '4px', marginBottom: '4px' }}>
                                <div></div>
                                <div style={{ fontSize: '0.7rem', fontWeight: 'bold', color: '#64748b', textAlign: 'center', textTransform: 'uppercase' }}>LEFT HASH</div>
                                <div style={{ fontSize: '0.7rem', fontWeight: 'bold', color: '#64748b', textAlign: 'center', textTransform: 'uppercase' }}>RIGHT HASH</div>
                            </div>

                            {rows.map((row, rowIdx) => (
                                <React.Fragment key={row.id || rowIdx}>
                                    <div style={{ display: 'grid', gridTemplateColumns: '60px 1fr 1fr', gap: '4px', alignItems: 'stretch' }}>

                                        {/* Editable Label Column */}
                                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                                            <input
                                                value={row.label || (rowIdx + 1).toString()}
                                                onChange={(e) => {
                                                    const newLayouts = { ...gamePlanLayouts };
                                                    const targetSection = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                                                    if (!targetSection.rows) targetSection.rows = [];
                                                    if (!targetSection.rows[rowIdx]) targetSection.rows[rowIdx] = { id: Date.now(), label: (rowIdx + 1).toString(), content: '' };
                                                    if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                }}
                                                style={{
                                                    width: '100%', textAlign: 'center', fontWeight: 'bold',
                                                    border: '1px solid #e2e8f0', color: '#64748b', fontSize: '0.9rem',
                                                    padding: '8px 4px', borderRadius: '4px', background: !isLocked ? 'white' : 'transparent',
                                                    height: '100%'
                                                }}
                                                disabled={isLocked}
                                            />
                                        </div>

                                        {/* Left Play Slot */}
                                        <div style={{ border: '1px solid #e2e8f0', borderRadius: '4px', background: 'white', minHeight: '40px', display: 'flex', alignItems: 'center', paddingRight: '4px' }}>
                                            <div style={{ flex: 1 }}>
                                                <PlaySlot
                                                    playId={row.content}
                                                    isLocked={isLocked}
                                                    renderWristbandInput={renderWristbandInput}
                                                    onQuickAddPlay={onQuickAddPlay}
                                                    onUpdate={(pid) => {
                                                        const newLayouts = { ...gamePlanLayouts };
                                                        const targetSection = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                                                        if (!targetSection.rows) targetSection.rows = [];
                                                        if (!targetSection.rows[rowIdx]) targetSection.rows[rowIdx] = { id: Date.now(), label: (rowIdx + 1).toString(), content: '' };
                                                        targetSection.rows[rowIdx].content = pid;
                                                        if (onUpdateLayouts) onUpdateLayouts(newLayouts);

                                                        // Sync to Data Model (miniScripts/sets)
                                                        if (box.setId && onUpdateGamePlan && gamePlan) {
                                                            const updatedRows = targetSection.rows;
                                                            const allIds = [];
                                                            updatedRows.forEach(r => {
                                                                if (r.content) allIds.push(r.content);
                                                                if (r.contentRight) allIds.push(r.contentRight);
                                                            });

                                                            const collectionKey = box.type === 'script' ? 'miniScripts' : 'sets';
                                                            let collection = Array.isArray(gamePlan[collectionKey]) ? [...gamePlan[collectionKey]] : [];

                                                            const uniqueIds = Array.from(new Set(allIds));

                                                            const existingIndex = collection.findIndex(item => item.id === box.setId);
                                                            if (existingIndex >= 0) {
                                                                // Only update playIds (script rows), keep assignedPlayIds (Quick List) separate
                                                                collection[existingIndex] = { ...collection[existingIndex], playIds: allIds };
                                                            } else {
                                                                // Create new item - only set playIds, assignedPlayIds (Quick List) starts empty
                                                                collection.push({ id: box.setId, playIds: allIds, assignedPlayIds: [] });
                                                            }

                                                            const updatedGamePlan = { ...gamePlan, [collectionKey]: collection };
                                                            onUpdateGamePlan(updatedGamePlan);
                                                        }
                                                    }}
                                                />
                                            </div>
                                        </div>

                                        {/* Right Play Slot */}
                                        <div style={{ border: '1px solid #e2e8f0', borderRadius: '4px', background: 'white', minHeight: '40px', display: 'flex', alignItems: 'center', paddingRight: '4px' }}>
                                            <div style={{ flex: 1 }}>
                                                <PlaySlot
                                                    playId={row.contentRight}
                                                    isLocked={isLocked}
                                                    renderWristbandInput={renderWristbandInput}
                                                    onQuickAddPlay={onQuickAddPlay}
                                                    onUpdate={(pid) => {
                                                        const newLayouts = { ...gamePlanLayouts };
                                                        const targetSection = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                                                        targetSection.rows[rowIdx].contentRight = pid;
                                                        if (onUpdateLayouts) onUpdateLayouts(newLayouts);

                                                        // Sync to Data Model (miniScripts/sets)
                                                        if (box.setId && onUpdateGamePlan && gamePlan) {
                                                            const updatedRows = targetSection.rows;
                                                            const allIds = [];
                                                            updatedRows.forEach(r => {
                                                                if (r.content) allIds.push(r.content);
                                                                if (r.contentRight) allIds.push(r.contentRight);
                                                            });

                                                            const collectionKey = box.type === 'script' ? 'miniScripts' : 'sets';
                                                            let collection = Array.isArray(gamePlan[collectionKey]) ? [...gamePlan[collectionKey]] : [];

                                                            const uniqueIds = Array.from(new Set(allIds));

                                                            const existingIndex = collection.findIndex(item => item.id === box.setId);
                                                            if (existingIndex >= 0) {
                                                                // Only update playIds (script rows), keep assignedPlayIds (Quick List) separate
                                                                collection[existingIndex] = { ...collection[existingIndex], playIds: allIds };
                                                            } else {
                                                                // Create new item - only set playIds, assignedPlayIds (Quick List) starts empty
                                                                collection.push({ id: box.setId, playIds: allIds, assignedPlayIds: [] });
                                                            }

                                                            const updatedGamePlan = { ...gamePlan, [collectionKey]: collection };
                                                            onUpdateGamePlan(updatedGamePlan);
                                                        }
                                                    }}
                                                />
                                            </div>
                                        </div>
                                    </div>

                                    {rowIdx < rows.length - 1 && (
                                        <div style={{ margin: '4px auto', width: 'fit-content' }}>
                                            <select
                                                disabled={isLocked}
                                                value={tempos[rowIdx] || 'REGULAR'}
                                                onChange={(e) => {
                                                    const newLayouts = { ...gamePlanLayouts };
                                                    const b = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                                                    if (!b.tempos) b.tempos = {};
                                                    b.tempos[rowIdx] = e.target.value;
                                                    if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                }}
                                                style={{
                                                    fontSize: '0.65rem', fontWeight: 'bold', padding: '2px 4px', borderRadius: '12px',
                                                    border: '1px solid #e2e8f0', background: '#f1f5f9', cursor: !isLocked ? 'pointer' : 'default',
                                                    color: protocolList.find(p => p.id === (tempos[rowIdx] || 'REGULAR'))?.color || '#64748b',
                                                    appearance: 'none', textAlign: 'center', minWidth: '100px'
                                                }}
                                            >
                                                {protocolList.map(proto => (
                                                    <option key={proto.id} value={proto.id}>{proto.label}</option>
                                                ))}
                                            </select>
                                        </div>
                                    )}
                                </React.Fragment>
                            ))}
                            {!isLocked && (
                                <button
                                    className="btn-sm"
                                    style={{ marginTop: '4px', width: '100%', border: '1px dashed #cbd5e1', color: '#64748b', padding: '4px' }}
                                    onClick={() => {
                                        const newLayouts = { ...gamePlanLayouts };
                                        const b = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                                        if (!b.rows) b.rows = [];
                                        b.rows.push({ content: null, contentRight: null, id: `slot_${Date.now()}` });
                                        if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                    }}
                                >
                                    + Add Play Slot
                                </button>
                            )}
                        </div>
                        {box.notes && (
                            <div style={{ marginTop: '8px', padding: '6px', background: '#fffbeb', border: '1px solid #fde68a', borderRadius: '4px', fontSize: '0.8rem', color: '#92400e', fontStyle: 'italic' }}>
                                <span style={{ fontWeight: 'bold', textTransform: 'uppercase', fontSize: '0.7rem', display: 'block', marginBottom: '2px' }}>Notes:</span>
                                {box.notes}
                            </div>
                        )}
                        {isEditing && (
                            <div style={{ borderTop: '2px solid #e2e8f0', paddingTop: '12px', marginTop: '12px' }}>
                                <div style={{ fontSize: '0.75rem', fontWeight: 'bold', color: '#64748b', textTransform: 'uppercase', marginBottom: '8px' }}>Manage Script Tempos</div>
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '6px', marginBottom: '12px' }}>
                                    {(box.customTempos || PLAY_PROTOCOLS).map((proto, pIdx) => (
                                        <div key={proto.id || pIdx} style={{ display: 'flex', alignItems: 'center', gap: '8px', background: '#f8fafc', padding: '4px 8px', borderRadius: '6px', border: '1px solid #e2e8f0' }}>
                                            <input type="color" value={proto.color} onChange={(e) => {
                                                const newLayouts = { ...gamePlanLayouts };
                                                const b = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                                                if (!b.customTempos) b.customTempos = [...PLAY_PROTOCOLS];
                                                b.customTempos[pIdx] = { ...b.customTempos[pIdx], color: e.target.value };
                                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                            }} style={{ width: '24px', height: '24px', border: 'none', padding: 0, background: 'none', cursor: 'pointer' }} />
                                            <input value={proto.label} onChange={(e) => {
                                                const newLayouts = { ...gamePlanLayouts };
                                                const b = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                                                if (!b.customTempos) b.customTempos = [...PLAY_PROTOCOLS];
                                                b.customTempos[pIdx] = { ...b.customTempos[pIdx], label: e.target.value };
                                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                            }} style={{ flex: 1, border: 'none', background: 'transparent', fontWeight: 'bold', color: '#334155' }} />
                                            <button onClick={() => {
                                                const newLayouts = { ...gamePlanLayouts };
                                                const b = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                                                if (!b.customTempos) b.customTempos = [...PLAY_PROTOCOLS];
                                                b.customTempos = b.customTempos.filter((_, i) => i !== pIdx);
                                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                            }} style={{ color: '#ef4444', background: 'none', border: 'none', cursor: 'pointer' }}>🗑</button>
                                        </div>
                                    ))}
                                    <input placeholder="Add tempo label..." onKeyDown={(e) => {
                                        if (e.key === 'Enter' && e.target.value) {
                                            const newLayouts = { ...gamePlanLayouts };
                                            const b = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                                            if (!b.customTempos) b.customTempos = [...PLAY_PROTOCOLS];
                                            b.customTempos.push({ id: `custom_${Date.now()}`, label: e.target.value, color: '#3b82f6' });
                                            if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                            e.target.value = '';
                                        }
                                    }} style={{ padding: '6px', border: '1px solid #e2e8f0', borderRadius: '4px', fontSize: '0.8rem' }} />
                                </div>
                            </div>
                        )}
                    </div>
                );
            };

            const renderGridBox = (box, sectionIdx, boxIdx, isEditing, renderWristbandInput) => {
                const cols = box.gridColumns || 4;
                const rowsCount = box.gridRows || 5;
                const totalSlots = cols * rowsCount;
                const gridTempos = box.gridTempos || {};
                const protocolList = box.customTempos || PLAY_PROTOCOLS;

                // Ensure headings match columns
                let headings = box.gridHeadings || [];
                if (headings.length < cols) {
                    const diff = cols - headings.length;
                    for (let i = 0; i < diff; i++) headings.push(`COL ${headings.length + 1}`);
                }
                if (headings.length > cols) {
                    headings = headings.slice(0, cols);
                }

                const allPlays = getGridPlays(box.setId, totalSlots, box.assignedPlayIds);
                const assignedPlays = (allPlays || []).filter(p => p.type !== 'GAP');

                const updateLayout = (updates) => {
                    const newLayouts = { ...gamePlanLayouts };
                    const targetBox = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                    Object.assign(targetBox, updates);
                    if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                };

                return (
                    <div style={{ padding: '8px', display: 'flex', flexDirection: 'column', height: '100%' }}>
                        {isEditing && (
                            <div style={{ marginBottom: '8px', padding: '6px', background: '#e2e8f0', borderRadius: '4px', display: 'flex', gap: '8px', alignItems: 'center', fontSize: '0.75rem', color: '#0f172a' }}>
                                <span style={{ fontWeight: 'bold' }}>Columns:</span>
                                <button className="btn btn-xs" style={{ background: 'white', color: 'black', border: '1px solid #cbd5e1' }} onClick={() => updateLayout({ gridColumns: Math.max(1, cols - 1) })}>-</button>
                                <span style={{ fontWeight: 'bold', minWidth: '16px', textAlign: 'center' }}>{cols}</span>
                                <button className="btn btn-xs" style={{ background: 'white', color: 'black', border: '1px solid #cbd5e1' }} onClick={() => updateLayout({ gridColumns: cols + 1 })}>+</button>

                                <span style={{ width: '12px', borderRight: '1px solid #cbd5e1', height: '16px' }}></span>
                                <span style={{ width: '4px' }}></span>

                                <span style={{ fontWeight: 'bold' }}>Rows:</span>
                                <button className="btn btn-xs" style={{ background: 'white', color: 'black', border: '1px solid #cbd5e1' }} onClick={() => updateLayout({ gridRows: Math.max(1, rowsCount - 1) })}>-</button>
                                <span style={{ fontWeight: 'bold', minWidth: '16px', textAlign: 'center' }}>{rowsCount}</span>
                                <button className="btn btn-xs" style={{ background: 'white', color: 'black', border: '1px solid #cbd5e1' }} onClick={() => updateLayout({ gridRows: rowsCount + 1 })}>+</button>
                            </div>
                        )}
                        {isEditing && renderInteriorConfig(box, sectionIdx, boxIdx)}

                        <div style={{ display: 'grid', gridTemplateColumns: `32px repeat(${cols}, 1fr)`, gap: '0', marginBottom: '8px', border: '1px solid #e2e8f0' }}>
                            <div style={{ fontSize: '0.55rem', color: '#94a3b8', fontStyle: 'italic', display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '2px', borderRight: '1px solid #e2e8f0', borderBottom: '1px solid #e2e8f0' }}>
                                {isEditing ? (
                                    <input
                                        value={box.cornerLabel || ''}
                                        onChange={(e) => updateLayout({ cornerLabel: e.target.value })}
                                        style={{ width: '100%', fontSize: '0.6rem', border: 'none', background: 'transparent', textAlign: 'center', color: '#94a3b8' }}
                                        placeholder="#"
                                    />
                                ) : (
                                    box.cornerLabel || '#'
                                )}
                            </div>
                            {headings.map((h, hIdx) => (
                                <div key={hIdx} style={{ textAlign: 'center', borderRight: hIdx < cols - 1 ? '1px solid #e2e8f0' : 'none', borderBottom: '1px solid #e2e8f0', background: '#f8fafc', padding: '2px 4px' }}>
                                    {isEditing ? (
                                        <input
                                            value={h}
                                            onChange={(e) => {
                                                const newHeadings = [...headings];
                                                newHeadings[hIdx] = e.target.value;
                                                updateLayout({ gridHeadings: newHeadings });
                                            }}
                                            style={{ width: '100%', fontSize: '0.55rem', border: 'none', background: 'transparent', textAlign: 'center', fontWeight: 'bold', color: '#64748b' }}
                                        />
                                    ) : (
                                        <span style={{ fontSize: '0.55rem', fontWeight: 'bold', color: '#64748b' }}>{h}</span>
                                    )}
                                </div>
                            ))}

                            {/* Row Headers and Slots */}
                            {Array.from({ length: rowsCount }).map((_, rIdx) => (
                                <React.Fragment key={rIdx}>
                                    {/* Row Header */}
                                    <div style={{
                                        fontSize: '0.55rem', color: '#94a3b8', fontWeight: 'bold',
                                        display: 'flex', alignItems: 'center', justifyContent: 'center',
                                        borderRight: '1px solid #e2e8f0', borderBottom: '1px dotted #e2e8f0', padding: '1px'
                                    }}>
                                        {isEditing ? (
                                            <input
                                                value={(box.gridRowLabels && box.gridRowLabels[rIdx]) || (rIdx + 1).toString()}
                                                onChange={(e) => {
                                                    const newLabels = [...(box.gridRowLabels || [])];
                                                    // Ensure array is padded up to this index if it was empty/short
                                                    for (let i = 0; i <= rIdx; i++) {
                                                        if (newLabels[i] === undefined) newLabels[i] = (i + 1).toString();
                                                    }
                                                    newLabels[rIdx] = e.target.value;
                                                    updateLayout({ gridRowLabels: newLabels });
                                                }}
                                                style={{
                                                    width: '100%', fontSize: '0.6rem', border: 'none', background: 'transparent',
                                                    textAlign: 'center', fontWeight: 'bold', color: '#94a3b8'
                                                }}
                                            />
                                        ) : (
                                            (box.gridRowLabels && box.gridRowLabels[rIdx]) || (rIdx + 1)
                                        )}
                                    </div>
                                    {/* Slot Cells */}
                                    {Array.from({ length: cols }).map((_, cIdx) => {
                                        const linearIdx = (rIdx * cols) + cIdx;
                                        const play = allPlays[linearIdx];

                                        const handleGridCellUpdate = (newPlayId) => {
                                            // 1. Get current plays (including GAPs)
                                            const currentPlays = [...allPlays];

                                            // 2. Update the specific slot
                                            // If newPlayId is null, it becomes a GAP. 
                                            // If it's a valid ID, we verify it exists.

                                            if (newPlayId) {
                                                const targetPlay = plays.find(p => p.id === newPlayId);
                                                if (targetPlay) {
                                                    currentPlays[linearIdx] = targetPlay;
                                                }
                                            } else {
                                                currentPlays[linearIdx] = { type: 'GAP' };
                                            }

                                            // 3. Convert back to ID list for storage
                                            // 'GAP' objects should be stored as 'GAP' strings or nulls depending on how getGridPlays expects them.
                                            // Looking at getGridPlays, it pads with 'GAP'. So we should likely store the IDs or 'GAP'.

                                            // Actually, let's look at how data is stored.
                                            // It seems we store an array of IDs in `assignedPlayIds`.
                                            // getGridPlays pads this array.

                                            // So we just need to reconstruct the `assignedPlayIds` array from our `currentPlays`
                                            // But we only want to persist up to the last non-gap? Or minimal set?
                                            // The simplest valid storage is the full array of IDs/'GAP's up to the grid size.

                                            const newAssignedIds = currentPlays.map(p => (p && p.id) ? p.id : 'GAP');

                                            // Clean up trailing GAPs if desired, or keep them to preserve structure?
                                            // To be safe and preserve "empty" slots in middle, we keep them.

                                            updateLayout({ assignedPlayIds: newAssignedIds });
                                        };

                                        return (
                                            <div key={`${rIdx}-${cIdx}`} style={{
                                                minHeight: '44px',
                                                borderRight: cIdx < cols - 1 ? '1px solid #e2e8f0' : 'none',
                                                borderBottom: '1px dotted #e2e8f0',
                                                display: 'flex', alignItems: 'center', justifyContent: 'flex-start',
                                                padding: '2px 4px',
                                                background: play && play.type !== 'GAP' ? 'white' : 'transparent',
                                                position: 'relative'
                                            }}>
                                                <PlaySlot
                                                    playId={play && play.type !== 'GAP' ? play.id : null}
                                                    onUpdate={handleGridCellUpdate}
                                                    isLocked={!isEditing}
                                                    placeholder="+"
                                                    showWristband={true} // Enable wristband display if available in PlaySlot
                                                    renderWristbandInput={renderWristbandInput} // Pass the hoisted renderer
                                                />
                                            </div>
                                        );
                                    })}
                                    {/* Tempo selector between rows (not after last row) */}
                                    {rIdx < rowsCount - 1 && (() => {
                                        const currentTempoId = gridTempos[rIdx] || 'REGULAR';
                                        const currentTempo = protocolList.find(p => p.id === currentTempoId) || protocolList[0];
                                        return (
                                            <div style={{ gridColumn: `1 / span ${cols + 1}`, display: 'flex', justifyContent: 'center', padding: '2px 0' }}>
                                                {isEditing ? (
                                                    <select
                                                        value={currentTempoId}
                                                        onChange={(e) => {
                                                            const newTempos = { ...gridTempos };
                                                            newTempos[rIdx] = e.target.value;
                                                            updateLayout({ gridTempos: newTempos });
                                                        }}
                                                        style={{
                                                            fontSize: '0.6rem', fontWeight: 'bold', padding: '2px 8px', borderRadius: '10px',
                                                            border: '1px solid #e2e8f0', background: '#f8fafc', cursor: 'pointer',
                                                            color: currentTempo?.color || '#64748b',
                                                            appearance: 'none', textAlign: 'center', minWidth: '80px'
                                                        }}
                                                    >
                                                        {protocolList.map(proto => (
                                                            <option key={proto.id} value={proto.id}>{proto.label}</option>
                                                        ))}
                                                    </select>
                                                ) : (
                                                    <div style={{
                                                        fontSize: '0.55rem', fontWeight: 'bold', padding: '1px 12px', borderRadius: '8px',
                                                        background: currentTempo?.color || '#64748b', color: 'white',
                                                        textTransform: 'uppercase', letterSpacing: '0.5px'
                                                    }}>
                                                        {currentTempo?.label || 'Regular'}
                                                    </div>
                                                )}
                                            </div>
                                        );
                                    })()}
                                </React.Fragment>
                            ))}
                        </div>

                        {/* Manage Grid Tempos */}
                        {isEditing && (
                            <div style={{ borderTop: '2px solid #e2e8f0', paddingTop: '12px', marginTop: '12px' }}>
                                <div style={{ fontSize: '0.75rem', fontWeight: 'bold', color: '#64748b', textTransform: 'uppercase', marginBottom: '8px' }}>Manage Grid Tempos</div>
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '6px', marginBottom: '12px' }}>
                                    {(box.customTempos || PLAY_PROTOCOLS).map((proto, pIdx) => (
                                        <div key={proto.id || pIdx} style={{ display: 'flex', alignItems: 'center', gap: '8px', background: '#f8fafc', padding: '4px 8px', borderRadius: '6px', border: '1px solid #e2e8f0' }}>
                                            <input type="color" value={proto.color} onChange={(e) => {
                                                const newLayouts = { ...gamePlanLayouts };
                                                const b = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                                                if (!b.customTempos) b.customTempos = [...PLAY_PROTOCOLS];
                                                b.customTempos[pIdx] = { ...b.customTempos[pIdx], color: e.target.value };
                                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                            }} style={{ width: '24px', height: '24px', border: 'none', padding: 0, background: 'none', cursor: 'pointer' }} />
                                            <input value={proto.label} onChange={(e) => {
                                                const newLayouts = { ...gamePlanLayouts };
                                                const b = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                                                if (!b.customTempos) b.customTempos = [...PLAY_PROTOCOLS];
                                                b.customTempos[pIdx] = { ...b.customTempos[pIdx], label: e.target.value };
                                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                            }} style={{ flex: 1, border: 'none', background: 'transparent', fontWeight: 'bold', color: '#334155' }} />
                                            <button onClick={() => {
                                                const newLayouts = { ...gamePlanLayouts };
                                                const b = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                                                if (!b.customTempos) b.customTempos = [...PLAY_PROTOCOLS];
                                                b.customTempos = b.customTempos.filter((_, i) => i !== pIdx);
                                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                            }} style={{ color: '#ef4444', background: 'none', border: 'none', cursor: 'pointer', fontSize: '0.8rem' }}>X</button>
                                        </div>
                                    ))}
                                    <input placeholder="Add tempo label..." onKeyDown={(e) => {
                                        if (e.key === 'Enter' && e.target.value) {
                                            const newLayouts = { ...gamePlanLayouts };
                                            const b = newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx];
                                            if (!b.customTempos) b.customTempos = [...PLAY_PROTOCOLS];
                                            b.customTempos.push({ id: `custom_${Date.now()}`, label: e.target.value, color: '#3b82f6' });
                                            if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                            e.target.value = '';
                                        }
                                    }} style={{ padding: '6px', border: '1px solid #e2e8f0', borderRadius: '4px', fontSize: '0.8rem' }} />
                                </div>
                            </div>
                        )}
                    </div>
                );
            };

            const renderGridSection = (section, sectionIdx) => {
                const headings = section.gridHeadings || ['LEFT HASH', 'MIDDLE', 'RIGHT HASH', 'NOTES'];
                const allPlays = getGridPlays(section.id);
                // For a full section grid (20 slots = 5 rows x 4 cols) -> logic uses slice 0-19 implicitly if length 5
                const assignedPlays = allPlays;

                return (
                    <div style={{ padding: '8px', display: 'flex', flexDirection: 'column', height: '100%', background: 'white', borderRadius: '8px', border: '1px solid #cbd5e1' }}>
                        <div style={{ display: 'grid', gridTemplateColumns: '50px repeat(4, 1fr)', gap: '1px', marginBottom: '8px' }}>
                            <div style={{ fontSize: '0.6rem', color: '#94a3b8', fontStyle: 'italic', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                                {!isLocked ? (
                                    <input
                                        value={section.cornerLabel || ''}
                                        onChange={(e) => {
                                            const newLayouts = { ...gamePlanLayouts };
                                            newLayouts.CALL_SHEET.sections[sectionIdx].cornerLabel = e.target.value;
                                            if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                        }}
                                        style={{ width: '100%', fontSize: '0.6rem', border: 'none', background: 'transparent', textAlign: 'center', color: '#94a3b8' }}
                                        placeholder="Label..."
                                    />
                                ) : (
                                    section.cornerLabel || ''
                                )}
                            </div>
                            {headings.map((h, hIdx) => (
                                <div key={hIdx} style={{ textAlign: 'center' }}>
                                    {!isLocked ? (
                                        <input
                                            value={h}
                                            onChange={(e) => {
                                                const newLayouts = { ...gamePlanLayouts };
                                                const newSections = [...newLayouts.CALL_SHEET.sections];
                                                const newHeadings = [...(newSections[sectionIdx].gridHeadings || ['LEFT HASH', 'MIDDLE', 'RIGHT HASH', 'NOTES'])];
                                                newHeadings[hIdx] = e.target.value;
                                                newSections[sectionIdx] = { ...newSections[sectionIdx], gridHeadings: newHeadings };
                                                newLayouts.CALL_SHEET = { ...newLayouts.CALL_SHEET, sections: newSections };
                                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                            }}
                                            style={{ width: '100%', fontSize: '0.7rem', fontWeight: 'bold', color: '#64748b', textAlign: 'center', border: 'none', background: 'transparent' }}
                                        />
                                    ) : (
                                        <div style={{ fontSize: '0.7rem', fontWeight: 'bold', color: '#64748b' }}>{h}</div>
                                    )}
                                </div>
                            ))}
                        </div>

                        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '1px' }}>
                            {Array.from({ length: 5 }).map((_, rIdx) => {
                                const startIdx = rIdx * 4;
                                const rowPlays = allPlays.slice(startIdx, startIdx + 4);
                                const rowLabel = (section.rowLabels || ['Group 1', 'Group 2', 'Group 3', 'Group 4', 'Group 5'])[rIdx];

                                return (
                                    <div key={rIdx} style={{ display: 'grid', gridTemplateColumns: '50px repeat(4, 1fr)', gap: '1px', flex: 1 }}>
                                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', background: '#f1f5f9', borderRadius: '4px' }}>
                                            {!isLocked ? (
                                                <input
                                                    value={rowLabel || ''}
                                                    onChange={(e) => {
                                                        const newLayouts = { ...gamePlanLayouts };
                                                        const newSections = [...newLayouts.CALL_SHEET.sections];
                                                        const newLabels = [...(newSections[sectionIdx].rowLabels || ['Group 1', 'Group 2', 'Group 3', 'Group 4', 'Group 5'])];
                                                        newLabels[rIdx] = e.target.value;
                                                        newSections[sectionIdx] = { ...newSections[sectionIdx], rowLabels: newLabels };
                                                        newLayouts.CALL_SHEET = { ...newLayouts.CALL_SHEET, sections: newSections };
                                                        if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                    }}
                                                    style={{ width: '100%', fontSize: '0.65rem', fontWeight: '600', color: '#475569', textAlign: 'center', border: 'none', background: 'transparent', padding: '0' }}
                                                />
                                            ) : (
                                                <span style={{ fontSize: '0.65rem', fontWeight: '600', color: '#475569' }}>{rowLabel}</span>
                                            )}
                                        </div>
                                        {rowPlays.map((play, cIdx) => (
                                            <div key={cIdx} style={{ position: 'relative', height: '100%', minHeight: '50px' }}>
                                                <PlaySlot
                                                    playId={play.type === 'GAP' ? null : play.id}
                                                    onUpdate={(newPlayId) => {
                                                        handleGridCellUpdate(section.id, startIdx + cIdx, newPlayId);
                                                    }}
                                                    isLocked={isLocked}
                                                />
                                            </div>
                                        ))}
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                );
            };

            const renderScriptSection = (section, sectionIdx) => {
                return (
                    <div style={{ background: 'white', borderRadius: '8px', border: '1px solid #cbd5e1', padding: '1rem' }}>
                        <div style={{ padding: '2rem', textAlign: 'center', color: '#666' }}>Script Section (Use Modular + Script Box for now)</div>
                    </div>
                );
            };
            const renderFieldPositionSection = (section, sectionIdx) => renderGridSection(section, sectionIdx);

            const renderBox = (box, sectionIdx, boxIdx, isExpanded = false) => {
                const isEditing = editingHeader && editingHeader.sectionIdx === sectionIdx && editingHeader.rowIdx === boxIdx;
                const isBoxEditing = editingBox && editingBox.sectionIdx === sectionIdx && editingBox.boxIdx === boxIdx;

                // Summary Logic
                let summaryText = "";
                if (box.type === 'script') {
                    const playCount = (box.rows || []).filter(r => r.content).length;
                    summaryText = `${playCount} Plays in Script`;
                } else {
                    const playCount = getGridPlays(box.setId).filter(p => p.type !== 'GAP').length;
                    summaryText = `${playCount} Situational Plays`;
                }

                // Default spans: Grid = 5, Script = 2
                const defaultSpan = box.type === 'grid' ? 5 : 2;
                const span = box.colSpan || defaultSpan;

                return (
                    <div
                        key={box.setId}
                        draggable={!isLocked}
                        onDragStart={(e) => handleDragStart(e, sectionIdx, boxIdx)}
                        onDragOver={handleDragOver}
                        onDrop={(e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            handleDrop(e, sectionIdx, boxIdx);
                        }}
                        style={{
                            // Flexbox expansion logic
                            // Flexbox expansion logic
                            flexGrow: isExpanded ? span : 0,
                            gridColumn: isExpanded ? 'auto' : `span ${span}`,
                            maxWidth: isExpanded ? '100%' : undefined,
                            minWidth: isExpanded ? '125px' : undefined, // Force wrap if too squished
                            flexBasis: isExpanded ? '0' : undefined, // Ignore size, use grow ratio

                            border: isEditing ? '2px solid var(--accent)' : '1px solid #ddd',
                            borderRadius: '4px', overflow: 'hidden',
                            minHeight: '80px', // Smaller collapsed height
                            backgroundColor: 'white', cursor: !isLocked ? 'move' : 'default',
                            opacity: draggedCell && draggedCell.sectionIdx === sectionIdx && draggedCell.rowIdx === boxIdx ? 0.5 : (box.hidden && !isLocked ? 0.5 : 1),
                            display: (box.hidden && isLocked) ? 'none' : 'block',
                            position: 'relative'
                        }}
                        onDoubleClick={(e) => {
                            if (isLocked) return;
                            e.preventDefault();
                            e.stopPropagation();
                            setEditingBox({ sectionIdx, boxIdx });
                        }}
                    >
                        <div style={{ backgroundColor: box.color, color: 'white', padding: '0.25rem 0.5rem', fontWeight: 'bold', fontSize: '0.8rem', textAlign: 'center', textTransform: 'uppercase', display: 'flex', justifyContent: 'center', alignItems: 'center', position: 'relative' }}>
                            {isEditing ? (
                                <div style={{ display: 'flex', alignItems: 'center', width: '100%', gap: '4px' }}>
                                    <input
                                        autoFocus
                                        defaultValue={box.header}
                                        onBlur={(e) => saveHeader(sectionIdx, boxIdx, e.target.value)}
                                        onKeyDown={(e) => { if (e.key === 'Enter') saveHeader(sectionIdx, boxIdx, e.target.value); }}
                                        style={{ background: 'rgba(255,255,255,0.2)', border: 'none', color: 'white', textAlign: 'center', flex: 1, fontSize: '0.8rem', fontWeight: 'bold', outline: 'none' }}
                                    />
                                    <input
                                        type="color"
                                        value={box.color || '#8b5cf6'}
                                        onChange={(e) => {
                                            const newLayouts = { ...gamePlanLayouts };
                                            newLayouts.CALL_SHEET.sections[sectionIdx].boxes[boxIdx].color = e.target.value;
                                            if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                        }}
                                        style={{ width: '20px', height: '20px', border: '1px solid rgba(255,255,255,0.3)', cursor: 'pointer', padding: 0 }}
                                    />
                                    <div style={{ cursor: 'pointer' }} onClick={() => setEditingHeader(null)}><Icon name="X" size={14} /></div>
                                </div>
                            ) : (
                                <>
                                    <span style={{ cursor: 'default', width: '100%', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{box.header}</span>
                                    {!isLocked && (
                                        <div style={{ position: 'absolute', right: '4px', cursor: 'pointer' }} onClick={(e) => { e.stopPropagation(); setEditingHeader({ sectionIdx, rowIdx: boxIdx }); }}>
                                            <Icon name="Pencil" size={14} />
                                        </div>
                                    )}
                                </>
                            )}
                        </div>

                        {/* Summary View */}
                        <div style={{ padding: '1rem', textAlign: 'center', color: '#64748b', fontSize: '0.85rem' }}>
                            <div style={{ fontWeight: 'bold', fontSize: '1.2rem', color: '#1e293b' }}>
                                {box.type === 'script' ? '📜' : '🔢'}
                            </div>
                            <div style={{ marginTop: '0.5rem' }}>{summaryText}</div>
                            {box.notes && (
                                <div style={{ marginTop: '0.5rem', fontSize: '0.7rem', color: '#64748b', fontStyle: 'italic', overflow: 'hidden', textOverflow: 'ellipsis', display: '-webkit-box', WebkitLineClamp: 2, WebkitBoxOrient: 'vertical', maxHeight: '2.4em' }}>
                                    "{box.notes}"
                                </div>
                            )}
                            <div style={{ fontSize: '0.7rem', color: '#94a3b8', fontStyle: 'italic', marginTop: '0.5rem' }}>Double-click to edit</div>
                        </div>

                    </div>
                );
            };

            const renderCallSheet = () => {

                const layout = gamePlanLayouts.CALL_SHEET;

                // Safety check for gamePlan
                const safeGamePlan = gamePlan || { miniScripts: [] };
                const miniScripts = safeGamePlan.miniScripts || [];

                return (
                    <div className="animate-fade-in" style={{ height: '100%', overflowY: 'auto', background: 'white', borderRadius: '8px', position: 'relative' }}>
                        {/* CONTROL BAR */}
                        <div style={{ position: 'sticky', top: 0, zIndex: 40, backgroundColor: 'white', padding: '1rem', borderBottom: '1px solid #e2e8f0', display: 'flex', justifyContent: 'flex-end', gap: '0.5rem', alignItems: 'center' }}>
                            {!isLocked && (
                                <>
                                    {/* Layout Versions Dropdown */}
                                    <div style={{ position: 'relative', display: 'inline-block', marginRight: '0.5rem' }}>
                                        <button
                                            className="btn btn-sm"
                                            onClick={() => setShowLayoutVersions(!showLayoutVersions)}
                                            style={{ fontSize: '0.75rem', background: '#e5e7eb', color: '#374151', display: 'flex', alignItems: 'center', gap: '4px' }}
                                        >
                                            <Icon name="Save" size={14} /> Layout Versions
                                        </button>

                                        {showLayoutVersions && (
                                            <div style={{ position: 'absolute', top: '100%', right: 0, zIndex: 50, background: 'white', border: '1px solid #cbd5e1', borderRadius: '4px', boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)', minWidth: '250px', padding: '0.5rem' }}>
                                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.5rem', paddingBottom: '0.25rem', borderBottom: '1px solid #e2e8f0' }}>
                                                    <div style={{ fontWeight: 'bold', fontSize: '0.75rem', color: '#64748b' }}>SAVED LAYOUTS</div>
                                                    <button
                                                        onClick={() => setShowLayoutVersions(false)}
                                                        style={{ background: 'none', border: 'none', cursor: 'pointer', color: '#94a3b8' }}
                                                    >
                                                        <Icon name="X" size={12} />
                                                    </button>
                                                </div>

                                                {/* Save Controls */}
                                                {layoutSaveState.isSaving ? (
                                                    <div style={{ marginBottom: '0.5rem' }}>
                                                        <input
                                                            autoFocus
                                                            className="form-input"
                                                            style={{ fontSize: '0.75rem', padding: '4px', width: '100%', marginBottom: '4px' }}
                                                            placeholder="Version Name..."
                                                            value={layoutSaveState.name}
                                                            onChange={(e) => setLayoutSaveState({ ...layoutSaveState, name: e.target.value })}
                                                            onKeyDown={(e) => {
                                                                if (e.key === 'Enter' && layoutSaveState.name && onSaveLayoutVersion) {
                                                                    onSaveLayoutVersion(layoutSaveState.name);
                                                                    setLayoutSaveState({ isSaving: false, name: '' });
                                                                }
                                                                if (e.key === 'Escape') setLayoutSaveState({ isSaving: false, name: '' });
                                                            }}
                                                        />
                                                        <div style={{ display: 'flex', gap: '4px' }}>
                                                            <button
                                                                className="btn btn-xs btn-primary"
                                                                style={{ flex: 1 }}
                                                                disabled={!layoutSaveState.name}
                                                                onClick={() => {
                                                                    if (layoutSaveState.name && onSaveLayoutVersion) {
                                                                        onSaveLayoutVersion(layoutSaveState.name);
                                                                        setLayoutSaveState({ isSaving: false, name: '' });
                                                                    }
                                                                }}
                                                            >
                                                                Save
                                                            </button>
                                                            <button
                                                                className="btn btn-xs"
                                                                style={{ flex: 1, background: '#e2e8f0', color: '#475569' }}
                                                                onClick={() => setLayoutSaveState({ isSaving: false, name: '' })}
                                                            >
                                                                Cancel
                                                            </button>
                                                        </div>
                                                    </div>
                                                ) : (
                                                    <button
                                                        className="btn btn-xs btn-primary"
                                                        style={{ width: '100%', marginBottom: '0.5rem', fontSize: '0.75rem' }}
                                                        onClick={() => setLayoutSaveState({ isSaving: true, name: '' })}
                                                    >
                                                        + Save Current Layout
                                                    </button>
                                                )}

                                                <div style={{ maxHeight: '150px', overflowY: 'auto' }}>
                                                    {Object.keys(layoutVersions).length === 0 && <div style={{ fontSize: '0.75rem', color: '#94a3b8', fontStyle: 'italic', padding: '0.25rem' }}>No saved layouts</div>}
                                                    {Object.keys(layoutVersions).map(versionName => (
                                                        <div key={versionName} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '0.25rem', borderBottom: '1px solid #f1f5f9' }}>
                                                            <span style={{ fontSize: '0.75rem', fontWeight: '500', color: '#334155' }}>{versionName}</span>

                                                            {/* Item Actions */}
                                                            {layoutConfirmAction?.name === versionName ? (
                                                                <div style={{ display: 'flex', gap: '4px', alignItems: 'center' }}>
                                                                    <span style={{ fontSize: '0.65rem', color: layoutConfirmAction.type === 'delete' ? '#ef4444' : '#3b82f6', marginRight: '2px' }}>
                                                                        {layoutConfirmAction.type === 'delete' ? 'Delete?' : 'Load?'}
                                                                    </span>
                                                                    <button
                                                                        className="btn btn-icon"
                                                                        style={{ color: 'var(--success)' }}
                                                                        onClick={() => {
                                                                            if (layoutConfirmAction.type === 'delete' && onDeleteLayoutVersion) onDeleteLayoutVersion(versionName);
                                                                            if (layoutConfirmAction.type === 'load' && onLoadLayoutVersion) onLoadLayoutVersion(versionName);
                                                                            setLayoutConfirmAction(null);
                                                                        }}
                                                                    >
                                                                        <Icon name="Check" size={12} />
                                                                    </button>
                                                                    <button
                                                                        className="btn btn-icon"
                                                                        style={{ color: 'var(--text-secondary)' }}
                                                                        onClick={() => setLayoutConfirmAction(null)}
                                                                    >
                                                                        <Icon name="X" size={12} />
                                                                    </button>
                                                                </div>
                                                            ) : (
                                                                <div style={{ display: 'flex', gap: '4px' }}>
                                                                    <button
                                                                        title="Load"
                                                                        style={{ background: 'none', border: 'none', cursor: 'pointer', color: '#3b82f6', padding: '2px' }}
                                                                        onClick={() => setLayoutConfirmAction({ type: 'load', name: versionName })}
                                                                    >
                                                                        <Icon name="Download" size={12} />
                                                                    </button>
                                                                    <button
                                                                        title="Delete"
                                                                        style={{ background: 'none', border: 'none', cursor: 'pointer', color: '#ef4444', padding: '2px' }}
                                                                        onClick={() => setLayoutConfirmAction({ type: 'delete', name: versionName })}
                                                                    >
                                                                        <Icon name="Trash2" size={12} />
                                                                    </button>
                                                                </div>
                                                            )}
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        )}
                                    </div>

                                    {confirmResetLayout ? (
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                                            <span style={{ fontSize: '0.75rem', color: '#dc2626', fontWeight: 'bold' }}>Reset?</span>
                                            <button
                                                className="btn btn-sm"
                                                style={{ fontSize: '0.75rem', padding: '0.25rem 0.5rem', background: '#dc2626', color: 'white' }}
                                                onClick={() => {
                                                    onUpdateLayouts(GAME_PLAN_LAYOUTS);
                                                    setConfirmResetLayout(false);
                                                }}
                                            >
                                                Yes
                                            </button>
                                            <button
                                                className="btn btn-sm"
                                                style={{ fontSize: '0.75rem', padding: '0.25rem 0.5rem', background: '#e5e7eb', color: '#374151' }}
                                                onClick={() => setConfirmResetLayout(false)}
                                            >
                                                No
                                            </button>
                                        </div>
                                    ) : (
                                        <button
                                            className="btn btn-sm"
                                            style={{ fontSize: '0.75rem', background: '#e5e7eb', color: '#374151' }}
                                            onClick={() => setConfirmResetLayout(true)}
                                        >
                                            ↺ Reset Layout
                                        </button>
                                    )}
                                    <div style={{ width: '1px', height: '20px', background: '#ccc', margin: '0 0.5rem' }}></div>
                                    {isCreatingScript ? (
                                        <input
                                            autoFocus
                                            placeholder="New Script Name..."
                                            style={{ fontSize: '0.8rem', padding: '0.25rem', borderRadius: '4px', border: '1px solid var(--primary)' }}
                                            onKeyDown={(e) => {
                                                if (e.key === 'Enter') handleSaveNewScript(e.target.value);
                                                if (e.key === 'Escape') setIsCreatingScript(false);
                                            }}
                                            onBlur={() => setIsCreatingScript(false)}
                                        />
                                    ) : (
                                        <button onClick={() => setIsCreatingScript(true)} className="btn btn-secondary" style={{ display: 'flex', alignItems: 'center', gap: '6px', backgroundColor: 'var(--accent)', color: 'white' }}>
                                            + Add Script
                                        </button>
                                    )}
                                </>
                            )}
                            {!isLocked && (
                                <button
                                    className="btn btn-secondary"
                                    onClick={() => {
                                        const newLayouts = { ...gamePlanLayouts };
                                        const sheet = { ...newLayouts.CALL_SHEET };
                                        sheet.sections.push({
                                            id: `section_${Date.now()}`,
                                            title: 'New Section',
                                            type: 'unconfigured',
                                            color: '#1e293b',
                                            boxes: []
                                        });
                                        newLayouts.CALL_SHEET = sheet;
                                        if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                    }}
                                    style={{
                                        display: 'flex', alignItems: 'center', gap: '6px',
                                        backgroundColor: 'var(--accent)',
                                        color: 'white'
                                    }}
                                >
                                    + Add Section
                                </button>
                            )}
                        </div>


                        {/* PLAYER TOUCHES SUMMARY */}

                        <div style={{ padding: '1rem' }}>
                            {(layout?.sections || []).map((section, idx) => (
                                <div
                                    key={idx}
                                    draggable={!isLocked}
                                    onDragStart={(e) => handleSectionDragStart(e, idx)}
                                    onDragOver={handleSectionDragOver}
                                    onDrop={(e) => handleSectionDrop(e, idx)}
                                    style={{
                                        marginBottom: '2rem',
                                        cursor: !isLocked ? 'grab' : 'default',
                                        opacity: draggedSection?.sectionIdx === idx ? 0.5 : 1,
                                        border: draggedSection && draggedSection.sectionIdx !== idx ? '2px dashed #cbd5e1' : 'none',
                                        borderRadius: '8px',
                                        padding: draggedSection ? '0.5rem' : '0',
                                        transition: 'opacity 0.2s, border 0.2s'
                                    }}
                                >
                                    {/* Section Header */}
                                    {section.title && (
                                        <div
                                            style={{ marginBottom: '1rem', borderBottom: '2px solid #ddd', paddingBottom: '0.25rem', position: 'relative' }}
                                            onDragOver={(e) => {
                                                if (isLocked) return;
                                                e.preventDefault();
                                                e.dataTransfer.dropEffect = 'move';
                                            }}
                                            onDrop={(e) => {
                                                if (isLocked || !draggedCell) return;
                                                e.preventDefault();

                                                // If dropped on the same section, do nothing (or maybe move to top?)
                                                if (draggedCell.sectionIdx === idx) return;

                                                // Move dragged item to this section
                                                const newLayouts = { ...gamePlanLayouts };
                                                const sheet = { ...newLayouts.CALL_SHEET };
                                                sheet.sections = [...sheet.sections];

                                                // Source
                                                const sourceBoxes = [...sheet.sections[draggedCell.sectionIdx].boxes];
                                                const itemToMove = sourceBoxes[draggedCell.rowIdx];
                                                sourceBoxes.splice(draggedCell.rowIdx, 1);
                                                sheet.sections[draggedCell.sectionIdx] = { ...sheet.sections[draggedCell.sectionIdx], boxes: sourceBoxes };

                                                // Target (Append to this section)
                                                const targetBoxes = [...sheet.sections[idx].boxes, itemToMove];
                                                sheet.sections[idx] = { ...sheet.sections[idx], boxes: targetBoxes };

                                                newLayouts.CALL_SHEET = sheet;
                                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                setDraggedCell(null);
                                            }}
                                        >
                                            {/* Editable Title with Drag Handle */}
                                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                {!isLocked && (
                                                    <span
                                                        style={{
                                                            cursor: 'grab',
                                                            fontSize: '1.2rem',
                                                            opacity: 0.5,
                                                            userSelect: 'none',
                                                            lineHeight: 1
                                                        }}
                                                        title="Drag to reorder section"
                                                    >
                                                        ⋮⋮
                                                    </span>
                                                )}
                                                <h3
                                                    style={{ fontSize: '1.1rem', fontWeight: 'bold', color: section.headerColor || '#1e293b', margin: 0, cursor: !isLocked ? 'pointer' : 'default', textTransform: 'uppercase', display: 'inline-block' }}
                                                    onClick={() => !isLocked && setEditingHeader({ sectionIdx: idx, isSectionTitle: true })}
                                                >
                                                    {section.title}
                                                </h3>
                                                {!isLocked && (
                                                    <button
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            setEditingHeader({ sectionIdx: idx, isSectionTitle: true });
                                                        }}
                                                        style={{
                                                            background: 'none', border: 'none', cursor: 'pointer', color: '#94a3b8',
                                                            padding: '4px', display: 'flex', alignItems: 'center'
                                                        }}
                                                        title="Edit Section"
                                                    >
                                                        <Icon name="Edit2" size={14} />
                                                    </button>
                                                )}
                                            </div>

                                            {/* Section Edit Menu */}
                                            {editingHeader && editingHeader.sectionIdx === idx && editingHeader.isSectionTitle && (
                                                <div style={{
                                                    position: 'absolute', top: '100%', left: 0, width: '250px', zIndex: 1000,
                                                    background: 'white', border: '1px solid #ccc', borderRadius: '4px',
                                                    boxShadow: '0 4px 10px rgba(0,0,0,0.2)', padding: '0.75rem',
                                                    display: 'flex', flexDirection: 'column', gap: '8px', color: '#1e293b',
                                                    marginTop: '4px'
                                                }}
                                                    onClick={(e) => e.stopPropagation()}
                                                >
                                                    <div style={{ fontSize: '0.75rem', fontWeight: 'bold', color: '#64748b', textTransform: 'uppercase', marginBottom: '2px' }}>Edit Section</div>

                                                    {/* Rename */}
                                                    <input
                                                        autoFocus
                                                        defaultValue={section.title}
                                                        placeholder="Section Name..."
                                                        onKeyDown={(e) => {
                                                            if (e.key === 'Enter') {
                                                                const newLayouts = { ...gamePlanLayouts };
                                                                newLayouts.CALL_SHEET.sections[idx].title = e.target.value;
                                                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                                setEditingHeader(null);
                                                            }
                                                        }}
                                                        style={{ width: '100%', border: '1px solid #cbd5e1', borderRadius: '4px', padding: '6px', fontSize: '0.9rem', color: '#0f172a' }}
                                                    />

                                                    {/* Layout Type */}
                                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                                        <label style={{ fontSize: '0.75rem', color: '#64748b' }}>Layout Type</label>
                                                        <select
                                                            value={section.type === 'grid' || section.type === 'field_position' ? 'grid' : 'modular'}
                                                            onChange={(e) => {
                                                                const newLayouts = { ...gamePlanLayouts };
                                                                const newType = e.target.value;
                                                                newLayouts.CALL_SHEET.sections[idx].type = newType;

                                                                if (newType === 'grid') {
                                                                    if (!newLayouts.CALL_SHEET.sections[idx].gridHeadings) {
                                                                        newLayouts.CALL_SHEET.sections[idx].gridHeadings = ['LEFT HASH', 'MIDDLE', 'RIGHT HASH', 'NOTES'];
                                                                    }
                                                                    if (!newLayouts.CALL_SHEET.sections[idx].rowLabels) {
                                                                        newLayouts.CALL_SHEET.sections[idx].rowLabels = ['Group 1', 'Group 2', 'Group 3', 'Group 4', 'Group 5'];
                                                                    }
                                                                } else {
                                                                    // Ensure boxes array exists if switching to modular
                                                                    if (!newLayouts.CALL_SHEET.sections[idx].boxes) {
                                                                        newLayouts.CALL_SHEET.sections[idx].boxes = [];
                                                                    }
                                                                }

                                                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                            }}
                                                            style={{ width: '100%', border: '1px solid #cbd5e1', borderRadius: '4px', padding: '6px', fontSize: '0.9rem', color: '#0f172a', background: 'white' }}
                                                        >
                                                            <option value="modular">Modular Container</option>
                                                            <option value="grid">Stand-alone Grid</option>
                                                        </select>
                                                    </div>

                                                    {/* Color Picker */}
                                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                                        <label style={{ fontSize: '0.75rem', color: '#64748b' }}>Header Color</label>
                                                        <input
                                                            type="color"
                                                            value={section.headerColor || '#1e293b'}
                                                            onChange={(e) => {
                                                                const newLayouts = { ...gamePlanLayouts };
                                                                newLayouts.CALL_SHEET.sections[idx].headerColor = e.target.value;
                                                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                            }}
                                                            style={{ width: '100%', height: '32px', border: '1px solid #cbd5e1', borderRadius: '4px', cursor: 'pointer' }}
                                                        />
                                                    </div>

                                                    {idx >= 0 && (
                                                        <button
                                                            className="btn-sm"
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                toggleSectionExpansion(idx);
                                                                setEditingHeader(null);
                                                            }}
                                                            style={{
                                                                background: section.expandToFill ? '#dcfce7' : '#e0f2fe',
                                                                color: section.expandToFill ? '#166534' : '#0369a1',
                                                                border: section.expandToFill ? '1px solid #86efac' : '1px solid #bae6fd',
                                                                width: '100%', fontSize: '0.8rem', padding: '6px', cursor: 'pointer',
                                                                borderRadius: '4px', textAlign: 'left', display: 'flex', alignItems: 'center', gap: '6px',
                                                                marginBottom: '4px'
                                                            }}
                                                        >
                                                            <Icon name={section.expandToFill ? "Minimize" : "Maximize"} size={12} />
                                                            {section.expandToFill ? "Fixed Width" : "Expand to Fill"}
                                                        </button>
                                                    )}

                                                    {/* Delete Section */}
                                                    {idx >= 0 && (
                                                        <button
                                                            className="btn-sm"
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                if (window.confirm('Delete this section? All boxes will move to the section above.')) {
                                                                    const newLayouts = { ...gamePlanLayouts };
                                                                    const sheet = { ...newLayouts.CALL_SHEET };
                                                                    sheet.sections = [...sheet.sections];

                                                                    // Move all boxes from this section to the previous section
                                                                    // If idx is 0, we can't move to previous. Just delete? Or warn?
                                                                    // If idx > 0
                                                                    if (idx > 0) {
                                                                        const currentSectionBoxes = [...sheet.sections[idx].boxes];
                                                                        const previousSectionBoxes = [...sheet.sections[idx - 1].boxes];
                                                                        sheet.sections[idx - 1] = {
                                                                            ...sheet.sections[idx - 1],
                                                                            boxes: [...previousSectionBoxes, ...currentSectionBoxes]
                                                                        };
                                                                    } else {
                                                                        // Index 0, just delete? Or maybe move to next? 
                                                                        // Let's just delete for now, user confirmed.
                                                                    }

                                                                    // Remove this section
                                                                    sheet.sections.splice(idx, 1);

                                                                    newLayouts.CALL_SHEET = sheet;
                                                                    if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                                }
                                                                setEditingHeader(null);
                                                            }}
                                                            style={{
                                                                background: '#fee2e2', color: '#dc2626', border: '1px solid #fca5a5',
                                                                width: '100%', fontSize: '0.8rem', padding: '6px', cursor: 'pointer',
                                                                borderRadius: '4px', textAlign: 'left', display: 'flex', alignItems: 'center', gap: '6px'
                                                            }}
                                                        >
                                                            <Icon name="Trash2" size={12} /> Delete Section
                                                        </button>
                                                    )}

                                                    <div style={{ textAlign: 'right', marginTop: '4px' }}>
                                                        <span
                                                            style={{ fontSize: '0.75rem', color: '#64748b', cursor: 'pointer', textDecoration: 'underline' }}
                                                            onClick={() => setEditingHeader(null)}
                                                        >
                                                            Close
                                                        </span>
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    )}

                                    {/* Content based on Type */}
                                    {section.type === 'unconfigured' ? (
                                        <div style={{
                                            border: '2px dashed #cbd5e1', borderRadius: '8px', padding: '3rem',
                                            background: '#f8fafc',
                                            display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '2rem'
                                        }}>
                                            <div style={{ textAlign: 'center' }}>
                                                <h3 style={{ fontSize: '1.2rem', fontWeight: 'bold', color: '#475569', marginBottom: '0.5rem' }}>Configuration Required</h3>
                                                <p style={{ color: '#94a3b8' }}>Select a layout type for this section.</p>
                                            </div>

                                            <div style={{ display: 'flex', gap: '2rem', flexWrap: 'wrap', justifyContent: 'center' }}>
                                                {/* OPTION 1: Stand-alone Grid */}
                                                <div
                                                    onClick={() => {
                                                        const newLayouts = { ...gamePlanLayouts };
                                                        newLayouts.CALL_SHEET.sections[idx].type = 'grid';
                                                        newLayouts.CALL_SHEET.sections[idx].gridHeadings = ['LEFT HASH', 'MIDDLE', 'RIGHT HASH', 'NOTES'];
                                                        newLayouts.CALL_SHEET.sections[idx].rowLabels = ['Group 1', 'Group 2', 'Group 3', 'Group 4', 'Group 5'];
                                                        if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                    }}
                                                    style={{
                                                        background: 'white', border: '1px solid #e2e8f0', borderRadius: '8px', padding: '2rem',
                                                        cursor: 'pointer', width: '220px', textAlign: 'center', transition: 'all 0.2s',
                                                        boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)'
                                                    }}
                                                    onMouseEnter={e => { e.currentTarget.style.borderColor = 'var(--primary)'; e.currentTarget.style.transform = 'translateY(-2px)'; }}
                                                    onMouseLeave={e => { e.currentTarget.style.borderColor = '#e2e8f0'; e.currentTarget.style.transform = 'translateY(0)'; }}
                                                >
                                                    <div style={{ fontSize: '3rem', marginBottom: '1rem' }}>▦</div>
                                                    <div style={{ fontWeight: 'bold', color: '#334155', marginBottom: '0.5rem' }}>Stand-alone Grid</div>
                                                    <div style={{ fontSize: '0.8rem', color: '#94a3b8', lineHeight: '1.4' }}>
                                                        A single 5x4 "Strike 'Em Out" grid. Best for Field Zone or specialized situational sheets.
                                                    </div>
                                                </div>

                                                {/* OPTION 2: Modular Section */}
                                                <div
                                                    onClick={() => {
                                                        const newLayouts = { ...gamePlanLayouts };
                                                        newLayouts.CALL_SHEET.sections[idx].type = 'modular'; // 'modular' triggers default box container layout
                                                        newLayouts.CALL_SHEET.sections[idx].boxes = [];
                                                        if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                    }}
                                                    style={{
                                                        background: 'white', border: '1px solid #e2e8f0', borderRadius: '8px', padding: '2rem',
                                                        cursor: 'pointer', width: '220px', textAlign: 'center', transition: 'all 0.2s',
                                                        boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)'
                                                    }}
                                                    onMouseEnter={e => { e.currentTarget.style.borderColor = 'var(--accent)'; e.currentTarget.style.transform = 'translateY(-2px)'; }}
                                                    onMouseLeave={e => { e.currentTarget.style.borderColor = '#e2e8f0'; e.currentTarget.style.transform = 'translateY(0)'; }}
                                                >
                                                    <div style={{ fontSize: '3rem', marginBottom: '1rem' }}>▣</div>
                                                    <div style={{ fontWeight: 'bold', color: '#334155', marginBottom: '0.5rem' }}>Modular Container</div>
                                                    <div style={{ fontSize: '0.8rem', color: '#94a3b8', lineHeight: '1.4' }}>
                                                        A flexible container. Add multiple Script Boxes, Grid Boxes, or mix and match.
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    ) : section.type === 'script' ? (
                                        renderScriptSection(section, idx)
                                    ) : section.type === 'grid' ? (
                                        renderGridSection(section, idx)
                                    ) : section.type === 'field_position' ? (
                                        renderFieldPositionSection(section, idx)
                                    ) : section.type === 'standard' ? (
                                        renderStandardSection(section, idx)
                                    ) : (
                                        /* Default/Grid Layout */
                                        <div
                                            style={{
                                                display: section.expandToFill ? 'flex' : 'grid',
                                                flexWrap: section.expandToFill ? 'wrap' : undefined,
                                                gridTemplateColumns: section.expandToFill ? undefined : `repeat(7, 1fr)`,
                                                gap: '4px',
                                                minHeight: '100px', // Ensure empty sections are drop targets
                                                border: isLocked ? 'none' : '1px dashed #cbd5e1', // Visual cue
                                                borderRadius: '8px',
                                                padding: '4px'
                                            }}
                                            onDragOver={(e) => {
                                                if (isLocked) return;
                                                e.preventDefault();
                                                e.dataTransfer.dropEffect = 'move';
                                            }}
                                            onDrop={(e) => {
                                                // This handles drop on empty space in section
                                                if (isLocked || !draggedCell) return;
                                                e.preventDefault();
                                                e.stopPropagation();

                                                if (draggedCell.sectionIdx === idx) return; // Same section, no-op if dropped on container (append? already there)

                                                // Move dragged item to this section (Append)
                                                const newLayouts = { ...gamePlanLayouts };
                                                const sheet = { ...newLayouts.CALL_SHEET };
                                                sheet.sections = [...sheet.sections];

                                                const sourceBoxes = [...sheet.sections[draggedCell.sectionIdx].boxes];
                                                const itemToMove = sourceBoxes[draggedCell.rowIdx];
                                                sourceBoxes.splice(draggedCell.rowIdx, 1);
                                                sheet.sections[draggedCell.sectionIdx] = { ...sheet.sections[draggedCell.sectionIdx], boxes: sourceBoxes };

                                                const targetBoxes = [...sheet.sections[idx].boxes, itemToMove];
                                                sheet.sections[idx] = { ...sheet.sections[idx], boxes: targetBoxes };

                                                newLayouts.CALL_SHEET = sheet;
                                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                setDraggedCell(null);
                                            }}
                                        >
                                            {(section.boxes || []).map((box, boxIdx) => renderBox(box, idx, boxIdx, section.expandToFill))}
                                        </div>
                                    )}
                                </div>
                            ))
                            }
                        </div>
                    </div>
                );
            };

            // spreadsheet editing state
            const [isSheetEditing, setIsSheetEditing] = useState(false);
            const [playDragOverBox, setPlayDragOverBox] = useState(null); // { sectionIdx, boxIdx } - for visual feedback when dragging plays

            const handleAddSheetSection = () => {
                const newSection = {
                    title: 'New Section',
                    boxes: []
                };
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                sheet.sections = [...(sheet.sections || []), newSection];
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
            };

            const handleUpdateSheetSection = (index, updatedSection) => {
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                const newSections = [...sheet.sections];
                newSections[index] = updatedSection;
                sheet.sections = newSections;
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
            };

            const handleDeleteSheetSection = (index) => {
                if (!confirm('Delete this section and all its boxes?')) return;
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                const newSections = [...sheet.sections];
                newSections.splice(index, 1);
                sheet.sections = newSections;
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
            };

            const handleAddSheetBox = (sectionIndex) => {
                const newBox = {
                    header: 'New Box',
                    setId: `box_${Date.now()}`,
                    color: '#3b82f6',
                    type: 'script', // Default to script
                    colSpan: 2, // Default width
                    rows: []
                };
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                const newSections = [...sheet.sections];
                const targetSection = { ...newSections[sectionIndex] };
                targetSection.boxes = [...(targetSection.boxes || []), newBox];
                newSections[sectionIndex] = targetSection;
                sheet.sections = newSections;
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
            };

            const handleDeleteSheetBox = (sectionIndex, boxIndex) => {
                if (!confirm('Delete this box?')) return;
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                const newSections = [...sheet.sections];
                const targetSection = { ...newSections[sectionIndex] };
                const newBoxes = [...targetSection.boxes];
                newBoxes.splice(boxIndex, 1);
                targetSection.boxes = newBoxes;
                newSections[sectionIndex] = targetSection;
                sheet.sections = newSections;
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
            };

            const handleSheetBoxDrop = (e, targetSectionIdx, targetBoxIdx) => {
                e.preventDefault();

                // Check if this is a play being dropped from Play Bank
                const playData = e.dataTransfer.getData('application/react-dnd');
                if (playData) {
                    try {
                        const { playId } = JSON.parse(playData);
                        if (playId) {
                            // Get the target box's setId
                            const targetBox = gamePlanLayouts?.CALL_SHEET?.sections?.[targetSectionIdx]?.boxes?.[targetBoxIdx];
                            if (targetBox && targetBox.setId) {
                                // Add to Quick List (assignedPlayIds), not to script rows (playIds)
                                handleAddToQuickList(targetBox.setId, playId);
                            }
                            return;
                        }
                    } catch (err) {
                        console.error('Error parsing play drop data:', err);
                    }
                }

                // Otherwise, handle box reordering (edit mode only)
                if (!isSheetEditing || !draggedCell) return;

                // draggedCell contains { sectionIdx, boxIdx } from the start
                // We need to move the box from source to target

                const sourceSectionIdx = draggedCell.sectionIdx;
                const sourceBoxIdx = draggedCell.boxIdx;

                if (sourceSectionIdx === targetSectionIdx && sourceBoxIdx === targetBoxIdx) return;

                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                const newSections = [...sheet.sections];

                const sourceSection = { ...newSections[sourceSectionIdx] };
                const sourceBoxes = [...sourceSection.boxes];
                const [movedBox] = sourceBoxes.splice(sourceBoxIdx, 1);

                if (sourceSectionIdx === targetSectionIdx) {
                    // Same section move
                    sourceBoxes.splice(targetBoxIdx, 0, movedBox);
                    sourceSection.boxes = sourceBoxes;
                    newSections[sourceSectionIdx] = sourceSection;
                } else {
                    // Different section move
                    const targetSection = { ...newSections[targetSectionIdx] };
                    const targetBoxes = [...targetSection.boxes];

                    // Update source first
                    sourceSection.boxes = sourceBoxes;
                    newSections[sourceSectionIdx] = sourceSection;

                    // Update target
                    targetBoxes.splice(targetBoxIdx, 0, movedBox);
                    targetSection.boxes = targetBoxes;
                    newSections[targetSectionIdx] = targetSection;
                }

                sheet.sections = newSections;
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                setDraggedCell(null);
            };

            const handleSheetSectionDragOver = (e) => {
                if (!isSheetEditing || !draggedCell) return;
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'move';
            };

            const handleSheetSectionDrop = (e, targetSectionIdx) => {
                if (!isSheetEditing || !draggedCell) return;
                e.preventDefault();
                e.stopPropagation();

                // If dropping on same section, usually handled by box drop, but allowed for append.
                if (draggedCell.sectionIdx === targetSectionIdx) return;

                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                const newSections = [...sheet.sections];

                const sourceSection = { ...newSections[draggedCell.sectionIdx] };
                const sourceBoxes = [...(sourceSection.boxes || [])];

                if (!sourceBoxes[draggedCell.boxIdx]) return;

                const [movedBox] = sourceBoxes.splice(draggedCell.boxIdx, 1);

                // Update source
                sourceSection.boxes = sourceBoxes;
                newSections[draggedCell.sectionIdx] = sourceSection;

                // Update target (Append)
                const targetSection = { ...newSections[targetSectionIdx] };
                const targetBoxes = [...(targetSection.boxes || []), movedBox];
                targetSection.boxes = targetBoxes;
                newSections[targetSectionIdx] = targetSection;

                sheet.sections = newSections;
                newLayouts.CALL_SHEET = sheet;
                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                setDraggedCell(null);
            };

            const renderFZDnDView = () => {
                // Build week title for print header
                const weekTitle = currentWeek?.name || `Week ${currentWeek?.weekNumber || ''}`;
                const opponentTitle = currentWeek?.opponent ? `vs. ${currentWeek.opponent}` : '';

                const FZDND_ZONES = [
                    { id: 'openers', title: 'Openers vs.', color: '#fef08a', textColor: 'black', columns: ['1st & 10', '2nd & <5', '2nd & 5+', '3rd & <5', '3rd & 5+'] },
                    { id: 'black', title: 'Black Zone (Goalline to -10)', color: 'black', textColor: 'white' },
                    { id: 'red', title: 'Red Zone (-10 to -40)', color: '#ef4444', textColor: 'white' },
                    { id: 'yellow', title: 'Yellow Zone (-40 to +40)', color: '#fef08a', textColor: 'black' },
                    { id: 'gold', title: 'Gold Zone - Take A Shot (+40 to Endzone)', color: '#f59e0b', textColor: 'black' },
                    { id: 'green', title: 'Green Zone (+20 to Endzone)', color: '#22c55e', textColor: 'black' },
                    { id: '4min', title: '4:00 Offense', color: '#1e1b4b', textColor: '#fef08a' }, // Dark Blue
                    { id: '2min', title: '2:00 Offense', color: '#dc2626', textColor: 'black', columns: ['Personnel', 'Timeouts', 'Max Protect', 'First Downs', 'Think Plays'] },
                    { id: '2pt', title: 'Two Point Plays', color: 'black', textColor: 'white', columns: [' ', ' '] }
                ];

                const handleFZDnDDrop = (e, zoneId, colIdx) => {
                    e.preventDefault();
                    if (isLocked) return;
                    try {
                        const data = JSON.parse(e.dataTransfer.getData('application/react-dnd'));
                        if (data && data.playId) {
                            const setId = `fzdnd_${zoneId}_${colIdx}`;
                            let newSets = [...(gamePlan?.sets || [])];
                            let setIndex = newSets.findIndex(s => s.id === setId);

                            if (setIndex === -1) {
                                newSets.push({ id: setId, name: `${zoneId} - ${colIdx}`, playIds: [data.playId] });
                            } else {
                                const existingSet = { ...newSets[setIndex] };
                                if (!existingSet.playIds.includes(data.playId)) {
                                    existingSet.playIds = [...existingSet.playIds, data.playId];
                                    newSets[setIndex] = existingSet;
                                }
                            }
                            onUpdateGamePlan({ ...gamePlan, sets: newSets });
                        }
                    } catch (e) { }
                };

                const handleRemoveFromFZDnD = (zoneId, colIdx, playId) => {
                    const setId = `fzdnd_${zoneId}_${colIdx}`;
                    let newSets = [...(gamePlan?.sets || [])];
                    let setIndex = newSets.findIndex(s => s.id === setId);
                    if (setIndex !== -1) {
                        const existingSet = { ...newSets[setIndex] };
                        existingSet.playIds = existingSet.playIds.filter(id => id !== playId);
                        newSets[setIndex] = existingSet;
                        onUpdateGamePlan({ ...gamePlan, sets: newSets });
                    }
                };

                const updateZoneNote = (zoneId, note) => {
                    const newNotes = { ...(gamePlan?.zoneNotes || {}) };
                    newNotes[zoneId] = note;
                    onUpdateGamePlan({ ...gamePlan, zoneNotes: newNotes });
                };

                const updatePlayWristband = (playId, slot) => {
                    // Validation Logic
                    let isBlocked = false;
                    const currentWbSettings = currentWeek?.wristbands || {};
                    const enabledSections = currentWbSettings.enabledSections || {};

                    const cardKeys = ['card1', 'card2', 'card3', 'card4', 'card5', 'card6'];
                    for (const key of cardKeys) {
                        if (enabledSections[key] !== false) continue;
                        const card = currentWbSettings[key];
                        if (!card) continue;
                        const cardNum = parseInt(key.replace('card', ''));

                        if (card.type && (card.type === 'wiz')) {
                            for (let i = 1; i <= 16; i++) {
                                if (slot === `${cardNum}${String(i).padStart(2, '0')}`) isBlocked = true;
                            }
                        } else {
                            const start = cardNum * 100 + 1;
                            const end = start + 47;
                            const num = parseInt(slot);
                            if (!isNaN(num) && num >= start && num <= end && String(num) === slot) isBlocked = true;
                        }
                    }

                    // Check Staples
                    if (enabledSections.staples === false) {
                        const num = parseInt(slot);
                        if (!isNaN(num) && num >= 10 && num <= 89 && String(num) === slot) isBlocked = true;
                    }

                    if (isBlocked) {
                        alert("This wristband section is disabled.");
                        return;
                    }

                    if (onUpdatePlay) {
                        const play = plays.find(p => p.id === playId);
                        if (play) {
                            onUpdatePlay({ ...play, wristbandSlot: slot });
                        }
                    }
                };

                return (
                    <div style={{ display: 'flex', flexDirection: 'column', height: '100%', overflow: 'hidden' }}>
                        {/* Print Header - Only visible when printing */}
                        <div className="print-only" style={{
                            display: 'none',
                            alignItems: 'center',
                            justifyContent: 'space-between',
                            padding: '10px 20px',
                            borderBottom: '2px solid black',
                            background: 'white'
                        }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                                {teamLogo && (teamLogo.startsWith('http') || teamLogo.startsWith('data:')) ? (
                                    <img src={teamLogo} alt="Logo" style={{ height: '50px', width: 'auto' }} />
                                ) : teamLogo ? (
                                    <span style={{ fontSize: '2rem' }}>{teamLogo}</span>
                                ) : null}
                                <div>
                                    <div style={{ fontSize: '1.25rem', fontWeight: 'bold', color: 'black' }}>
                                        {weekTitle} {opponentTitle && `- ${opponentTitle}`}
                                    </div>
                                    <div style={{ fontSize: '0.85rem', color: '#475569', fontWeight: '600' }}>
                                        Field Zone Down & Distance
                                    </div>
                                </div>
                            </div>
                            <div style={{ fontSize: '0.75rem', color: '#64748b', textAlign: 'right' }}>
                                {new Date().toLocaleDateString()}
                            </div>
                        </div>
                        <div style={{ flex: 1, height: '100%', overflowY: 'auto', padding: '20px', background: 'white' }}>
                            {FZDND_ZONES.map((zone) => {
                                const definedCols = zone.columns || ['1st and 10', '2nd and <5', '2nd and 5+', '3rd and <5', '3rd and 5+'];
                                // Get custom zone data from gamePlan
                                const customZone = (gamePlan?.customZones || {})[zone.id] || {};
                                const zoneTitle = customZone.title || zone.title;
                                const zoneColor = customZone.color || zone.color;
                                const zoneTextColor = customZone.textColor || zone.textColor || '#000';
                                const zonePhilosophy = (gamePlan?.zoneNotes || {})[zone.id] || '';

                                const customCols = (gamePlan?.customColumns || {})[zone.id] || {};

                                return (
                                    <div key={zone.id} className="fzdnd-zone-container" style={{ marginBottom: '0', border: '1px solid black' }}>
                                        {/* SPLIT HEADER: Title Left, Philosophy Right */}
                                        <div style={{
                                            display: 'grid',
                                            gridTemplateColumns: '1fr 1fr',
                                            borderBottom: '1px solid black',
                                            background: zoneColor
                                        }}>
                                            {/* Zone Title - Left Side - Editable */}
                                            <div style={{
                                                borderRight: '1px solid black',
                                                padding: '4px 8px',
                                                display: 'flex',
                                                alignItems: 'center',
                                                gap: '8px'
                                            }}>
                                                <input
                                                    type="text"
                                                    value={zoneTitle}
                                                    onChange={(e) => {
                                                        const newCustomZones = { ...(gamePlan?.customZones || {}) };
                                                        newCustomZones[zone.id] = {
                                                            ...newCustomZones[zone.id],
                                                            title: e.target.value
                                                        };
                                                        onUpdateGamePlan({ ...gamePlan, customZones: newCustomZones });
                                                    }}
                                                    disabled={isLocked}
                                                    className="hide-on-print"
                                                    style={{
                                                        flex: 1,
                                                        background: 'transparent',
                                                        border: 'none',
                                                        color: zoneTextColor,
                                                        fontWeight: 'bold',
                                                        fontSize: '1rem',
                                                        textTransform: 'uppercase',
                                                        outline: 'none',
                                                        cursor: isLocked ? 'default' : 'text'
                                                    }}
                                                />
                                                <span className="print-only-text" style={{
                                                    flex: 1,
                                                    color: zoneTextColor,
                                                    fontWeight: 'bold',
                                                    fontSize: '1rem',
                                                    textTransform: 'uppercase'
                                                }}>
                                                    {zoneTitle}
                                                </span>
                                                {!isLocked && (
                                                    <div style={{ display: 'flex', gap: '4px' }}>
                                                        <input
                                                            type="color"
                                                            value={zoneColor}
                                                            onChange={(e) => {
                                                                const newCustomZones = { ...(gamePlan?.customZones || {}) };
                                                                newCustomZones[zone.id] = {
                                                                    ...newCustomZones[zone.id],
                                                                    color: e.target.value
                                                                };
                                                                onUpdateGamePlan({ ...gamePlan, customZones: newCustomZones });
                                                            }}
                                                            style={{
                                                                width: '18px',
                                                                height: '18px',
                                                                border: '1px solid rgba(0,0,0,0.3)',
                                                                borderRadius: '3px',
                                                                cursor: 'pointer',
                                                                padding: 0
                                                            }}
                                                            title="Change zone color"
                                                        />
                                                        <input
                                                            type="color"
                                                            value={zoneTextColor}
                                                            onChange={(e) => {
                                                                const newCustomZones = { ...(gamePlan?.customZones || {}) };
                                                                newCustomZones[zone.id] = {
                                                                    ...newCustomZones[zone.id],
                                                                    textColor: e.target.value
                                                                };
                                                                onUpdateGamePlan({ ...gamePlan, customZones: newCustomZones });
                                                            }}
                                                            style={{
                                                                width: '18px',
                                                                height: '18px',
                                                                border: '1px solid rgba(0,0,0,0.3)',
                                                                borderRadius: '3px',
                                                                cursor: 'pointer',
                                                                padding: 0
                                                            }}
                                                            title="Change text color"
                                                        />
                                                    </div>
                                                )}
                                            </div>

                                            {/* Philosophy Notes - Right Side */}
                                            <div style={{ padding: '4px 8px' }}>
                                                <input
                                                    type="text"
                                                    value={zonePhilosophy}
                                                    onChange={(e) => updateZoneNote(zone.id, e.target.value)}
                                                    disabled={isLocked}
                                                    placeholder="Philosophy reminders..."
                                                    style={{
                                                        width: '100%',
                                                        background: 'transparent',
                                                        border: 'none',
                                                        color: zoneTextColor,
                                                        fontWeight: '600',
                                                        fontSize: '0.9rem',
                                                        fontStyle: 'italic',
                                                        textAlign: 'center',
                                                        outline: 'none',
                                                        cursor: isLocked ? 'default' : 'text'
                                                    }}
                                                />
                                            </div>
                                        </div>

                                        {/* Content Grid */}
                                        <div className="fzdnd-content-wrapper" style={{ display: 'flex', flexDirection: 'column' }}>
                                            {definedCols.length > 0 && (
                                                <>
                                                    {/* COLUMN HEADERS */}
                                                    <div className="fzdnd-header-row" style={{
                                                        display: 'grid',
                                                        gridTemplateColumns: `40px repeat(${definedCols.length}, minmax(0, 1fr))`
                                                    }}>
                                                        <div style={{ borderRight: '1px solid black', borderBottom: '1px solid black' }}></div>
                                                        {definedCols.map((colName, cIdx) => (
                                                            <div key={`header-${cIdx}`} style={{
                                                                padding: '4px',
                                                                textAlign: 'center',
                                                                borderRight: cIdx < definedCols.length - 1 ? '1px solid black' : 'none',
                                                                borderBottom: '1px solid black',
                                                                background: 'white',
                                                                display: 'flex',
                                                                alignItems: 'center',
                                                                justifyContent: 'center'
                                                            }}>
                                                                <input
                                                                    type="text"
                                                                    value={customCols[cIdx] || colName}
                                                                    onChange={(e) => {
                                                                        const newCustomCols = { ...(gamePlan?.customColumns || {}) };
                                                                        newCustomCols[zone.id] = {
                                                                            ...(newCustomCols[zone.id] || {}),
                                                                            [cIdx]: e.target.value
                                                                        };
                                                                        onUpdateGamePlan({ ...gamePlan, customColumns: newCustomCols });
                                                                    }}
                                                                    disabled={isLocked}
                                                                    style={{
                                                                        width: '100%',
                                                                        background: 'transparent',
                                                                        border: 'none',
                                                                        color: 'black',
                                                                        fontWeight: '800',
                                                                        fontSize: '0.85rem',
                                                                        fontStyle: 'italic',
                                                                        textAlign: 'center',
                                                                        outline: 'none',
                                                                        cursor: isLocked ? 'default' : 'text'
                                                                    }}
                                                                />
                                                                <span className="print-only-text" style={{
                                                                    color: 'black',
                                                                    fontWeight: '800',
                                                                    fontSize: '0.85rem',
                                                                    fontStyle: 'italic',
                                                                    textAlign: 'center'
                                                                }}>
                                                                    {customCols[cIdx] || colName}
                                                                </span>
                                                            </div>
                                                        ))}
                                                    </div>

                                                    {/* ROWS */}
                                                    {[0, 1, 2, 3, 4].map(rowIdx => {
                                                        const rowKey = `${zone.id}_${rowIdx}`;
                                                        const isRowCollapsed = collapsedFZDnDRows.has(rowKey);

                                                        if (isRowCollapsed) {
                                                            return (
                                                                <div
                                                                    key={`row-${rowIdx}`}
                                                                    className="hide-on-print"
                                                                    onClick={() => toggleFZDnDRow(zone.id, rowIdx)}
                                                                    style={{
                                                                        padding: '4px 8px',
                                                                        background: '#eff6ff',
                                                                        cursor: 'pointer',
                                                                        borderBottom: '1px solid #cbd5e1',
                                                                        color: '#1e3a8a',
                                                                        fontSize: '0.8rem',
                                                                        fontStyle: 'italic',
                                                                        display: 'flex',
                                                                        alignItems: 'center',
                                                                        gap: '0.5rem'
                                                                    }}
                                                                    title="Click to expand row"
                                                                >
                                                                    <span style={{ fontSize: '0.7rem' }}>▶</span>
                                                                    <span>Row {rowIdx + 1} (Collapsed)</span>
                                                                </div>
                                                            );
                                                        }

                                                        return (
                                                            <div
                                                                key={`row-${rowIdx}`}
                                                                className="fzdnd-row-container"
                                                                style={{
                                                                    display: 'grid',
                                                                    gridTemplateColumns: `40px repeat(${definedCols.length}, minmax(0, 1fr))`,
                                                                    minHeight: '32px'
                                                                }}
                                                            >
                                                                {/* COLLAPSE ARROW */}
                                                                <div
                                                                    className="fzdnd-toggle-cell"
                                                                    onClick={() => toggleFZDnDRow(zone.id, rowIdx)}
                                                                    style={{
                                                                        borderRight: '1px solid black',
                                                                        borderBottom: '1px solid black',
                                                                        background: '#dbeafe',
                                                                        cursor: 'pointer',
                                                                        display: 'flex',
                                                                        alignItems: 'center',
                                                                        justifyContent: 'center',
                                                                        fontSize: '0.7rem',
                                                                        color: '#1e40af'
                                                                    }}
                                                                    title="Click to collapse row"
                                                                >
                                                                    <span className="hide-on-print">▼</span>
                                                                </div>

                                                                {/* CELLS FOR EACH COLUMN */}
                                                                {definedCols.map((_, cIdx) => {
                                                                    const setId = `fzdnd_${zone.id}_${cIdx}`;
                                                                    const set = Array.isArray(gamePlan?.sets) ? gamePlan.sets.find(s => s.id === setId) : (gamePlan?.sets && typeof gamePlan.sets === 'object' ? (Object.values(gamePlan.sets).find(s => s.id === setId) || gamePlan.sets[setId]) : null);
                                                                    const playId = set?.playIds?.[rowIdx];
                                                                    const play = playId ? plays.find(p => p.id === playId) : null;

                                                                    return (
                                                                        <div
                                                                            key={`cell-${cIdx}`}
                                                                            className="fzdnd-cell"
                                                                            style={{
                                                                                borderRight: cIdx < definedCols.length - 1 ? '1px solid black' : 'none',
                                                                                borderBottom: '1px solid black',
                                                                                background: play ? (play.priority ? '#fef08a' : (rowIdx % 2 === 0 ? 'white' : '#f8fafc')) : 'white',
                                                                                padding: play ? '4px 6px' : '0',
                                                                                minHeight: '32px',
                                                                                display: 'flex',
                                                                                alignItems: 'center'
                                                                            }}
                                                                            onDragOver={(e) => e.preventDefault()}
                                                                            onDrop={(e) => {
                                                                                e.preventDefault();
                                                                                const playId = e.dataTransfer.getData('playId');
                                                                                if (!playId) return;

                                                                                const setId = `fzdnd_${zone.id}_${cIdx}`;
                                                                                let sets = [...(gamePlan?.sets || [])];
                                                                                let set = sets.find(s => s.id === setId);

                                                                                if (!set) {
                                                                                    set = { id: setId, playIds: [] };
                                                                                    sets.push(set);
                                                                                }

                                                                                // Ensure playIds array has at least rowIdx + 1 elements
                                                                                while (set.playIds.length <= rowIdx) {
                                                                                    set.playIds.push(null);
                                                                                }

                                                                                // Set the play at this row index
                                                                                set.playIds[rowIdx] = playId;

                                                                                onUpdateGamePlan({ ...gamePlan, sets });
                                                                            }}
                                                                        >
                                                                            {play ? (
                                                                                <div
                                                                                    style={{
                                                                                        display: 'flex',
                                                                                        justifyContent: 'space-between',
                                                                                        alignItems: 'center',
                                                                                        width: '100%',
                                                                                        fontSize: '0.8rem',
                                                                                        fontWeight: '600',
                                                                                        color: 'black',
                                                                                        cursor: 'context-menu'
                                                                                    }}
                                                                                    onContextMenu={(e) => {
                                                                                        e.preventDefault();
                                                                                        e.stopPropagation();
                                                                                        openPlayDetails(play.id);
                                                                                    }}
                                                                                >
                                                                                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px', flex: 1, minWidth: 0 }}>
                                                                                        <span style={{ overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                                                                                            {play.name}
                                                                                        </span>

                                                                                        {/* WRISTBAND INPUT WITH AUTOCOMPLETE */}
                                                                                        {(() => {
                                                                                            const isFocused = fzdndWbAutocomplete.playId === play.id;

                                                                                            // Get used slots excluding current play
                                                                                            const usedSlots = new Set(
                                                                                                plays
                                                                                                    .filter(p => p.id !== play.id && p.wristbandSlot)
                                                                                                    .map(p => p.wristbandSlot)
                                                                                            );

                                                                                            // Filter available slots
                                                                                            const availableSlots = (validWristbandSlots || [])
                                                                                                .filter(slot => !usedSlots.has(slot));

                                                                                            const query = isFocused ? fzdndWbAutocomplete.query : '';

                                                                                            // Filter slots based on query
                                                                                            const filteredSlots = query
                                                                                                ? availableSlots.filter(s => s.toString().includes(query)).slice(0, 10)
                                                                                                : [];

                                                                                            return (
                                                                                                <div style={{ position: 'relative', width: '36px' }}>
                                                                                                    <input
                                                                                                        type="text"
                                                                                                        value={isFocused ? query : (play.wristbandSlot || '')}
                                                                                                        placeholder="#"
                                                                                                        onFocus={() => setFzdndWbAutocomplete({
                                                                                                            playId: play.id,
                                                                                                            query: play.wristbandSlot || ''
                                                                                                        })}
                                                                                                        onChange={(e) => {
                                                                                                            setFzdndWbAutocomplete({
                                                                                                                playId: play.id,
                                                                                                                query: e.target.value
                                                                                                            });
                                                                                                        }}
                                                                                                        onKeyDown={(e) => {
                                                                                                            if (e.key === 'Enter' && query.trim()) {
                                                                                                                // Select first match or use typed value
                                                                                                                const slot = filteredSlots.length > 0
                                                                                                                    ? filteredSlots[0]
                                                                                                                    : query.trim();
                                                                                                                updatePlayWristband(play.id, slot);
                                                                                                                setFzdndWbAutocomplete({ playId: null, query: '' });
                                                                                                            } else if (e.key === 'Escape') {
                                                                                                                setFzdndWbAutocomplete({ playId: null, query: '' });
                                                                                                            }
                                                                                                        }}
                                                                                                        onBlur={() => {
                                                                                                            setTimeout(() => {
                                                                                                                if (fzdndWbAutocomplete.playId === play.id) {
                                                                                                                    // Save the value on blur
                                                                                                                    if (fzdndWbAutocomplete.query.trim()) {
                                                                                                                        updatePlayWristband(play.id, fzdndWbAutocomplete.query.trim());
                                                                                                                    }
                                                                                                                    setFzdndWbAutocomplete({ playId: null, query: '' });
                                                                                                                }
                                                                                                            }, 200);
                                                                                                        }}
                                                                                                        onClick={(e) => e.stopPropagation()}
                                                                                                        style={{
                                                                                                            width: '100%',
                                                                                                            fontSize: '0.75rem',
                                                                                                            border: isFocused ? '1px solid #3b82f6' : '1px solid #94a3b8',
                                                                                                            borderRadius: '4px',
                                                                                                            textAlign: 'center',
                                                                                                            background: play.wristbandSlot ? '#dbeafe' : 'white',
                                                                                                            color: play.wristbandSlot ? '#1e40af' : '#64748b',
                                                                                                            fontWeight: 'bold',
                                                                                                            outline: 'none'
                                                                                                        }}
                                                                                                    />

                                                                                                    {/* AUTOCOMPLETE DROPDOWN */}
                                                                                                    {isFocused && filteredSlots.length > 0 && (
                                                                                                        <div style={{
                                                                                                            position: 'absolute',
                                                                                                            top: '100%',
                                                                                                            left: 0,
                                                                                                            minWidth: '60px',
                                                                                                            background: 'white',
                                                                                                            border: '1px solid #cbd5e1',
                                                                                                            borderRadius: '4px',
                                                                                                            boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
                                                                                                            maxHeight: '200px',
                                                                                                            overflowY: 'auto',
                                                                                                            zIndex: 1000,
                                                                                                            marginTop: '2px'
                                                                                                        }}>
                                                                                                            {filteredSlots.map(slot => (
                                                                                                                <div
                                                                                                                    key={slot}
                                                                                                                    onMouseDown={(e) => {
                                                                                                                        e.preventDefault();
                                                                                                                        updatePlayWristband(play.id, slot);
                                                                                                                        setFzdndWbAutocomplete({ playId: null, query: '' });
                                                                                                                    }}
                                                                                                                    style={{
                                                                                                                        padding: '6px 8px',
                                                                                                                        cursor: 'pointer',
                                                                                                                        fontSize: '0.75rem',
                                                                                                                        borderBottom: '1px solid #f1f5f9',
                                                                                                                        background: 'white',
                                                                                                                        color: '#1f2937',
                                                                                                                        textAlign: 'center',
                                                                                                                        fontWeight: 'bold'
                                                                                                                    }}
                                                                                                                    onMouseEnter={(e) => e.currentTarget.style.background = '#dbeafe'}
                                                                                                                    onMouseLeave={(e) => e.currentTarget.style.background = 'white'}
                                                                                                                >
                                                                                                                    {slot}{getWristbandTypeIndicator(slot)}
                                                                                                                </div>
                                                                                                            ))}
                                                                                                        </div>
                                                                                                    )}
                                                                                                </div>
                                                                                            );
                                                                                        })()}
                                                                                    </div>
                                                                                    {!isLocked && (
                                                                                        <button
                                                                                            onClick={() => {
                                                                                                const setId = `fzdnd_${zone.id}_${cIdx}`;
                                                                                                let sets = [...(gamePlan?.sets || [])];
                                                                                                let set = sets.find(s => s.id === setId);
                                                                                                if (set && set.playIds[rowIdx]) {
                                                                                                    set.playIds[rowIdx] = null;
                                                                                                    onUpdateGamePlan({ ...gamePlan, sets });
                                                                                                }
                                                                                            }}
                                                                                            style={{
                                                                                                border: 'none',
                                                                                                background: 'none',
                                                                                                color: '#dc2626',
                                                                                                cursor: 'pointer',
                                                                                                fontSize: '1rem',
                                                                                                fontWeight: 'bold'
                                                                                            }}
                                                                                        >
                                                                                            ×
                                                                                        </button>
                                                                                    )}
                                                                                </div>
                                                                            ) : (
                                                                                // AUTOCOMPLETE INPUT FOR EMPTY CELLS
                                                                                (() => {
                                                                                    const isFocused = fzdndAutocomplete.zoneId === zone.id &&
                                                                                        fzdndAutocomplete.rowIdx === rowIdx &&
                                                                                        fzdndAutocomplete.colIdx === cIdx;

                                                                                    const query = isFocused ? fzdndAutocomplete.query : '';

                                                                                    // Filter plays based on query
                                                                                    const filteredPlays = query
                                                                                        ? plays.filter(p => p.name.toLowerCase().includes(query.toLowerCase())).slice(0, 10)
                                                                                        : [];

                                                                                    const showCreateOption = query.trim() && filteredPlays.length === 0;

                                                                                    return (
                                                                                        <div style={{ position: 'relative', width: '100%', padding: '2px' }}>
                                                                                            <input
                                                                                                type="text"
                                                                                                placeholder="Type play name..."
                                                                                                value={query}
                                                                                                disabled={isLocked}
                                                                                                onFocus={() => setFzdndAutocomplete({
                                                                                                    zoneId: zone.id,
                                                                                                    rowIdx,
                                                                                                    colIdx: cIdx,
                                                                                                    query: ''
                                                                                                })}
                                                                                                onChange={(e) => setFzdndAutocomplete({
                                                                                                    zoneId: zone.id,
                                                                                                    rowIdx,
                                                                                                    colIdx: cIdx,
                                                                                                    query: e.target.value.toUpperCase()
                                                                                                })}
                                                                                                onKeyDown={(e) => {
                                                                                                    if (e.key === 'Enter' && query.trim()) {
                                                                                                        if (filteredPlays.length > 0) {
                                                                                                            assignPlayToFZDnDCell(zone.id, rowIdx, cIdx, filteredPlays[0].id);
                                                                                                        } else {
                                                                                                            createFZDnDPlay(query, zone.id, rowIdx, cIdx);
                                                                                                        }
                                                                                                    } else if (e.key === 'Escape') {
                                                                                                        setFzdndAutocomplete({ zoneId: null, rowIdx: null, colIdx: null, query: '' });
                                                                                                    }
                                                                                                }}
                                                                                                onBlur={() => {
                                                                                                    setTimeout(() => {
                                                                                                        setFzdndAutocomplete({ zoneId: null, rowIdx: null, colIdx: null, query: '' });
                                                                                                    }, 200);
                                                                                                }}
                                                                                                style={{
                                                                                                    width: '100%',
                                                                                                    fontSize: '0.8rem',
                                                                                                    padding: '4px 6px',
                                                                                                    border: isFocused ? '1px solid #3b82f6' : '1px solid #e2e8f0',
                                                                                                    borderRadius: '4px',
                                                                                                    outline: 'none',
                                                                                                    background: 'white',
                                                                                                    color: '#1f2937',
                                                                                                    cursor: isLocked ? 'not-allowed' : 'text'
                                                                                                }}
                                                                                            />

                                                                                            {/* AUTOCOMPLETE DROPDOWN */}
                                                                                            {isFocused && (filteredPlays.length > 0 || showCreateOption) && (
                                                                                                <div style={{
                                                                                                    position: 'absolute',
                                                                                                    top: '100%',
                                                                                                    left: 0,
                                                                                                    right: 0,
                                                                                                    background: 'white',
                                                                                                    border: '1px solid #cbd5e1',
                                                                                                    borderRadius: '4px',
                                                                                                    boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
                                                                                                    maxHeight: '200px',
                                                                                                    overflowY: 'auto',
                                                                                                    zIndex: 1000,
                                                                                                    marginTop: '2px'
                                                                                                }}>
                                                                                                    {filteredPlays.map(p => (
                                                                                                        <div
                                                                                                            key={p.id}
                                                                                                            onMouseDown={(e) => {
                                                                                                                e.preventDefault();
                                                                                                                assignPlayToFZDnDCell(zone.id, rowIdx, cIdx, p.id);
                                                                                                            }}
                                                                                                            style={{
                                                                                                                padding: '6px 8px',
                                                                                                                cursor: 'pointer',
                                                                                                                fontSize: '0.8rem',
                                                                                                                borderBottom: '1px solid #f1f5f9',
                                                                                                                background: 'white',
                                                                                                                color: '#1f2937',
                                                                                                                ':hover': { background: '#f8fafc' }
                                                                                                            }}
                                                                                                            onMouseEnter={(e) => e.currentTarget.style.background = '#f8fafc'}
                                                                                                            onMouseLeave={(e) => e.currentTarget.style.background = 'white'}
                                                                                                        >
                                                                                                            {p.name}
                                                                                                        </div>
                                                                                                    ))}
                                                                                                    {showCreateOption && (
                                                                                                        <div
                                                                                                            onMouseDown={(e) => {
                                                                                                                e.preventDefault();
                                                                                                                createFZDnDPlay(query, zone.id, rowIdx, cIdx);
                                                                                                            }}
                                                                                                            style={{
                                                                                                                padding: '6px 8px',
                                                                                                                cursor: 'pointer',
                                                                                                                fontSize: '0.8rem',
                                                                                                                background: '#eff6ff',
                                                                                                                color: '#1e40af',
                                                                                                                fontWeight: '600',
                                                                                                                fontStyle: 'italic'
                                                                                                            }}
                                                                                                            onMouseEnter={(e) => e.currentTarget.style.background = '#dbeafe'}
                                                                                                            onMouseLeave={(e) => e.currentTarget.style.background = '#eff6ff'}
                                                                                                        >
                                                                                                            + Create "{query}"
                                                                                                        </div>
                                                                                                    )}
                                                                                                </div>
                                                                                            )}
                                                                                        </div>
                                                                                    );
                                                                                })()
                                                                            )}
                                                                        </div>
                                                                    );
                                                                })}
                                                            </div>
                                                        );
                                                    })}
                                                </>
                                            )}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                );
            };

            const renderSheetView = (isPrintMode = false) => {
                // Build week title for print header
                const weekTitle = currentWeek?.name || `Week ${currentWeek?.weekNumber || ''}`;
                const opponentTitle = currentWeek?.opponent ? `vs. ${currentWeek.opponent}` : '';

                return (
                    <div className="animate-fade-in" style={{ height: '100%', overflowY: 'auto', padding: '1rem' }}>

                        {/* Print Header - Only visible when printing */}
                        <div className="print-only" style={{
                            display: 'none',
                            alignItems: 'center',
                            justifyContent: 'space-between',
                            marginBottom: '1rem',
                            paddingBottom: '0.5rem',
                            borderBottom: '2px solid black'
                        }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                                {teamLogo && (teamLogo.startsWith('http') || teamLogo.startsWith('data:')) ? (
                                    <img src={teamLogo} alt="Logo" style={{ height: '50px', width: 'auto' }} />
                                ) : teamLogo ? (
                                    <span style={{ fontSize: '2rem' }}>{teamLogo}</span>
                                ) : null}
                                <div>
                                    <div style={{ fontSize: '1.25rem', fontWeight: 'bold', color: 'black' }}>
                                        {weekTitle} {opponentTitle && `- ${opponentTitle}`}
                                    </div>
                                    <div style={{ fontSize: '0.85rem', color: '#475569', fontWeight: '600' }}>
                                        Situations & Scripts
                                    </div>
                                </div>
                            </div>
                            <div style={{ fontSize: '0.75rem', color: '#64748b', textAlign: 'right' }}>
                                {new Date().toLocaleDateString()}
                            </div>
                        </div>

                        {/* Edit Toolbar */}
                        <div style={{ display: 'flex', justifyContent: 'flex-end', marginBottom: '1rem' }}>
                            {!isLocked && (
                                <button
                                    onClick={() => setIsSheetEditing(!isSheetEditing)}
                                    style={{
                                        padding: '6px 12px',
                                        borderRadius: '6px',
                                        fontSize: '0.85rem',
                                        fontWeight: '600',
                                        cursor: 'pointer',
                                        backgroundColor: isSheetEditing ? '#2563eb' : 'white',
                                        color: isSheetEditing ? 'white' : '#0f172a',
                                        border: isSheetEditing ? '1px solid #2563eb' : '1px solid #94a3b8',
                                        boxShadow: '0 1px 2px 0 rgba(0, 0, 0, 0.05)'
                                    }}
                                >
                                    {isSheetEditing ? 'Done Editing' : 'Edit Layout'}
                                </button>
                            )}
                        </div>

                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(7, 1fr)', gap: '1rem', alignItems: 'start' }}>
                            {(gamePlanLayouts?.CALL_SHEET?.sections || []).map((section, sIdx) => {
                                // Show all boxes in edit mode
                                const visibleBoxes = isSheetEditing ? (section.boxes || []) : (section.boxes || []).filter(b => !b.hidden);
                                if (!isSheetEditing && visibleBoxes.length === 0) return null;

                                return (
                                    <div
                                        key={sIdx}
                                        className={`call-sheet-section${section.expandToFill ? ' expand-full-width' : ''}`}
                                        style={{ gridColumn: '1 / -1', breakInside: 'avoid', marginBottom: '0.5rem', border: isSheetEditing ? '1px dashed #3b82f6' : '1px solid #cbd5e1', borderRadius: '4px', overflow: 'hidden', background: 'white', display: 'flex', flexDirection: 'column' }}
                                        onDragOver={handleSheetSectionDragOver}
                                        onDrop={(e) => handleSheetSectionDrop(e, sIdx)}
                                    >
                                        <div style={{
                                            background: '#f1f5f9', padding: '0.5rem', fontWeight: 'bold',
                                            borderBottom: '1px solid #cbd5e1', textTransform: 'uppercase', fontSize: '0.8rem',
                                            color: '#334155', display: 'flex', justifyContent: 'space-between', alignItems: 'center'
                                        }}>
                                            {isSheetEditing ? (
                                                <div style={{ display: 'flex', gap: '8px', flex: 1, alignItems: 'center' }}>
                                                    <input
                                                        value={section.title}
                                                        onChange={(e) => handleUpdateSheetSection(sIdx, { ...section, title: e.target.value })}
                                                        style={{ flex: 1, padding: '2px 4px', fontSize: '0.8rem', fontWeight: 'bold' }}
                                                    />
                                                    <button
                                                        className="btn-sm"
                                                        onClick={() => handleUpdateSheetSection(sIdx, { ...section, expandToFill: !section.expandToFill })}
                                                        style={{
                                                            background: section.expandToFill ? 'var(--accent)' : '#e2e8f0',
                                                            color: section.expandToFill ? 'white' : '#64748b',
                                                            fontSize: '0.7rem',
                                                            padding: '4px 8px',
                                                            whiteSpace: 'nowrap'
                                                        }}
                                                        title={section.expandToFill ? 'Return to fixed width layout' : 'Expand boxes to fill row equally'}
                                                    >
                                                        {section.expandToFill ? '📏 Fixed Width' : '↔️ Expand to Fill'}
                                                    </button>
                                                    <button className="btn-sm" style={{ color: '#ef4444' }} onClick={() => handleDeleteSheetSection(sIdx)}>
                                                        <Icon name="Trash2" size={14} />
                                                    </button>
                                                </div>
                                            ) : (
                                                <span>{section.title}</span>
                                            )}
                                        </div>
                                        <div style={{
                                            display: 'flex', flexDirection: 'column',
                                            borderTop: '0',
                                            padding: isSheetEditing ? '4px' : '0'
                                        }}>
                                            {(() => {
                                                // 1. Group boxes into rows based on Grid Logic (7 cols)
                                                const rows = [];
                                                let currentRow = [];
                                                let currentSpan = 0;

                                                visibleBoxes.forEach((box, bIdx) => {
                                                    const span = Number(box.colSpan) > 1 ? Number(box.colSpan) : (box.type === 'grid' ? 5 : 2);

                                                    if (currentSpan + span > 7 && currentRow.length > 0) {
                                                        // Push previous row
                                                        rows.push(currentRow);
                                                        // Start new row
                                                        currentRow = [];
                                                        currentSpan = 0;
                                                    }

                                                    currentRow.push({ box, originalIndex: bIdx, span });
                                                    currentSpan += span;
                                                });

                                                if (currentRow.length > 0) {
                                                    rows.push(currentRow);
                                                }

                                                // 2. Render each row
                                                return rows.map((rowBoxes, rIdx) => (
                                                    <div key={rIdx} style={{
                                                        display: section.expandToFill ? 'flex' : 'grid',
                                                        gridTemplateColumns: section.expandToFill ? undefined : 'repeat(7, 1fr)',
                                                        width: '100%',
                                                        gap: isSheetEditing ? '4px' : '0',
                                                        marginBottom: isSheetEditing ? '4px' : '0'
                                                    }}>
                                                        {rowBoxes.map(({ box, originalIndex: bIdx, span }, i) => {
                                                            // Calculate isFirstInRow for legacy badge logic (simplified)
                                                            const isFirstInRow = i === 0;
                                                            const currentBoxRowNumber = rIdx + 1; // 1-based row number


                                                            const renderBoxContent = () => {
                                                                if (box.type === 'grid') {
                                                                    const cols = box.gridColumns || 4;
                                                                    const rowsCount = box.gridRows || 5;
                                                                    const totalSlots = cols * rowsCount;

                                                                    const gridPlays = (getGridPlays(box.setId, totalSlots, box.assignedPlayIds) || []);
                                                                    const headings = box.gridHeadings || Array(cols).fill('').map((_, i) => i === 0 ? 'LEFT HASH' : (i === cols - 1 ? 'NOTES' : `COL ${i + 1}`));

                                                                    const rows = [];
                                                                    for (let i = 0; i < gridPlays.length; i += cols) {
                                                                        rows.push(gridPlays.slice(i, i + cols));
                                                                    }

                                                                    // Helper: Check if a grid row is empty (all cells are empty or dashes)
                                                                    const isGridRowEmpty = (rowSlots) => {
                                                                        return rowSlots.every(slot => {
                                                                            if (slot.type === 'GAP') return true;
                                                                            const play = plays.find(p => p.id === slot.id);
                                                                            return !play || !play.name || play.name === '-' || play.name.trim() === '';
                                                                        });
                                                                    };

                                                                    // Helper: Check if entire grid has no filled rows
                                                                    const isGridEmpty = (rows) => {
                                                                        return rows.every(rowSlots => isGridRowEmpty(rowSlots));
                                                                    };

                                                                    // Skip rendering completely empty grids in print mode
                                                                    if (isPrintMode && isGridEmpty(rows)) {
                                                                        return null;
                                                                    }

                                                                    return (
                                                                        <div style={{ display: 'grid', gridTemplateColumns: `min-content repeat(${cols}, 1fr)`, gap: '0', width: '100%' }}>
                                                                            {/* Header Row */}
                                                                            <div style={{ padding: '2px', fontSize: '0.55rem', fontWeight: 'bold', color: '#94a3b8', textAlign: 'center', alignSelf: 'end' }}>
                                                                                {box.cornerLabel || '#'}
                                                                            </div>
                                                                            {headings.slice(0, cols).map((h, i) => (
                                                                                <div key={`h-${i}`} style={{
                                                                                    padding: '2px', fontSize: '0.55rem', fontWeight: 'bold', color: '#64748b', textAlign: 'center',
                                                                                    background: '#f1f5f9', whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis',
                                                                                    borderRight: i < cols - 1 ? '1px solid #cbd5e1' : 'none',
                                                                                    borderBottom: '1px solid #cbd5e1'
                                                                                }}>
                                                                                    {h}
                                                                                </div>
                                                                            ))}

                                                                            {/* Data Rows - skip empty rows in print mode only */}
                                                                            {rows.map((rowSlots, rIdx) => {
                                                                                const isEmpty = isGridRowEmpty(rowSlots);
                                                                                // Skip rendering empty rows only in print mode
                                                                                if (isEmpty && isPrintMode) return null;
                                                                                return (
                                                                                    <React.Fragment key={rIdx}>
                                                                                        <div style={{
                                                                                            padding: '2px', fontSize: '0.6rem', color: '#94a3b8', textAlign: 'right', fontWeight: 'bold',
                                                                                            display: 'flex', alignItems: 'center', justifyContent: 'flex-end', minWidth: '15px',
                                                                                            borderBottom: '1px dotted #f1f5f9'
                                                                                        }}>
                                                                                            {(box.gridRowLabels && box.gridRowLabels[rIdx]) || (rIdx + 1)}
                                                                                        </div>
                                                                                        {rowSlots.map((slot, cIdx) => {
                                                                                            const play = plays.find(p => p.id === slot.id);
                                                                                            return (
                                                                                                <div key={cIdx} style={{
                                                                                                    fontSize: '0.6rem', overflow: 'hidden',
                                                                                                    background: play?.priority ? '#fef08a' : (slot.type === 'GAP' ? 'transparent' : '#f8fafc'),
                                                                                                    padding: '2px', minHeight: '18px', color: '#334155',
                                                                                                    display: 'flex', alignItems: 'center', flexWrap: 'wrap',
                                                                                                    borderRight: cIdx < cols - 1 ? '1px solid #e2e8f0' : 'none',
                                                                                                    borderBottom: '1px dotted #e2e8f0',
                                                                                                    wordBreak: 'break-word'
                                                                                                }} title={play ? play.name : ''}>
                                                                                                    {play ? (
                                                                                                        <span style={{ display: 'inline', lineHeight: '1.2' }}>
                                                                                                            <span style={{ fontWeight: '500' }}>{getPlayDisplayName(play)}</span>
                                                                                                            {getWristbandLabel(play) && <span style={{ marginLeft: '3px', fontWeight: 'bold', color: '#3b82f6', fontSize: '0.85em' }}>{getWristbandLabel(play)}</span>}
                                                                                                        </span>
                                                                                                    ) : (slot.type === 'GAP' ? '' : '-')}
                                                                                                </div>
                                                                                            );
                                                                                        })}
                                                                                    </React.Fragment>
                                                                                );
                                                                            })}
                                                                        </div>
                                                                    );
                                                                }
                                                                if (box.type === 'script' && box.rows && box.rows.length > 0) {
                                                                    // Filter to only non-empty rows for print mode
                                                                    const rowsToRender = isPrintMode ? box.rows.filter(row => {
                                                                        const playLeft = plays.find(p => p.id === row.content);
                                                                        const playRight = plays.find(p => p.id === row.contentRight);
                                                                        return playLeft || playRight;
                                                                    }) : box.rows;

                                                                    // If all rows are empty in print mode, return null
                                                                    if (isPrintMode && rowsToRender.length === 0) {
                                                                        return null;
                                                                    }

                                                                    return (
                                                                        <div style={{ display: 'grid', gridTemplateColumns: 'minmax(0, 1fr) minmax(0, 1fr)', columnGap: '0', rowGap: '0' }}>
                                                                            {rowsToRender.map((row, rIdx) => {
                                                                                const playLeft = plays.find(p => p.id === row.content);
                                                                                const playRight = plays.find(p => p.id === row.contentRight);
                                                                                return [
                                                                                    <div key={`${rIdx}-L`} style={{
                                                                                        display: 'flex', gap: '4px', alignItems: 'baseline', lineHeight: '1.2',
                                                                                        borderBottom: '1px dotted #f1f5f9',
                                                                                        borderRight: '1px solid #e2e8f0', paddingRight: '4px',
                                                                                        background: playLeft?.priority ? '#fef08a' : 'transparent',
                                                                                        flexWrap: 'wrap'
                                                                                    }}>
                                                                                        <span style={{ color: '#64748b', width: '16px', textAlign: 'right', flexShrink: 0, fontWeight: 'bold', fontSize: '0.7rem' }}>{row.label || rIdx + 1}</span>
                                                                                        {playLeft ? (
                                                                                            <span style={{ fontWeight: '600', color: '#1e293b', fontSize: '0.65rem', wordBreak: 'break-word' }}>
                                                                                                {playLeft.name}
                                                                                                {getWristbandLabel(playLeft) && <span style={{ marginLeft: '3px', fontSize: '0.85em', color: '#3b82f6', fontWeight: 'bold' }}>{getWristbandLabel(playLeft)}</span>}
                                                                                            </span>
                                                                                        ) : (
                                                                                            <span style={{ color: '#cbd5e1', fontStyle: 'italic' }}>-</span>
                                                                                        )}
                                                                                    </div>,
                                                                                    <div key={`${rIdx}-R`} style={{
                                                                                        display: 'flex', gap: '4px', alignItems: 'baseline', lineHeight: '1.2',
                                                                                        borderBottom: '1px dotted #f1f5f9',
                                                                                        paddingLeft: '4px',
                                                                                        background: playRight?.priority ? '#fef08a' : 'transparent',
                                                                                        flexWrap: 'wrap'
                                                                                    }}>
                                                                                        {playRight ? (
                                                                                            <span style={{ fontWeight: '600', color: '#1e293b', fontSize: '0.65rem', wordBreak: 'break-word' }}>
                                                                                                {playRight.name}
                                                                                                {getWristbandLabel(playRight) && <span style={{ marginLeft: '3px', fontSize: '0.85em', color: '#3b82f6', fontWeight: 'bold' }}>{getWristbandLabel(playRight)}</span>}
                                                                                            </span>
                                                                                        ) : (
                                                                                            <span style={{ color: '#cbd5e1', fontStyle: 'italic' }}>+</span>
                                                                                        )}
                                                                                    </div>
                                                                                ];
                                                                            })}
                                                                        </div>
                                                                    );
                                                                }
                                                                const playsInBox = getPlaysForSet(box.setId);
                                                                if (playsInBox.length === 0) {
                                                                    // In print mode, return null for empty boxes; otherwise show "Empty"
                                                                    return isPrintMode ? null : <div style={{ color: '#cbd5e1', fontStyle: 'italic', paddingTop: '4px' }}>Empty</div>;
                                                                }
                                                                return (
                                                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '3px' }}>
                                                                        {playsInBox.map((p, pIdx) => (
                                                                            <div key={pIdx} style={{ display: 'flex', gap: '4px', alignItems: 'baseline', lineHeight: '1.2', background: p.priority ? '#fef08a' : 'transparent' }}>
                                                                                <span style={{ color: '#94a3b8', width: '14px', textAlign: 'right', flexShrink: 0 }}>{pIdx + 1}.</span>
                                                                                <span style={{ fontWeight: '600', color: '#1e293b' }}>{p.name}</span>
                                                                                {p.formation && <span style={{ color: '#64748b', fontSize: '0.65rem' }}>({p.formation})</span>}
                                                                            </div>
                                                                        ))}
                                                                    </div>
                                                                );
                                                            };
                                                            const playsInBox = getPlaysForSet(box.setId);

                                                            // Get quicklist count for badge display
                                                            const getQuickListCount = (setId) => {
                                                                let set = null;
                                                                if (Array.isArray(gamePlan?.sets)) {
                                                                    set = gamePlan.sets.find(s => s.id === setId);
                                                                } else if (gamePlan?.sets && typeof gamePlan.sets === 'object') {
                                                                    set = Object.values(gamePlan.sets).find(s => s.id === setId) || gamePlan.sets[setId];
                                                                }
                                                                if (!set && setId?.startsWith('ms_')) {
                                                                    if (Array.isArray(gamePlan?.miniScripts)) {
                                                                        set = gamePlan.miniScripts.find(s => s.id === setId);
                                                                    } else if (gamePlan?.miniScripts && typeof gamePlan.miniScripts === 'object') {
                                                                        set = Object.values(gamePlan.miniScripts).find(s => s.id === setId) || gamePlan.miniScripts[setId];
                                                                    }
                                                                }
                                                                return set?.assignedPlayIds?.length || 0;
                                                            };
                                                            const quickListCount = getQuickListCount(box.setId);

                                                            return (
                                                                <div
                                                                    key={bIdx}
                                                                    draggable={isSheetEditing}
                                                                    onDragStart={(e) => {
                                                                        if (!isSheetEditing) return;
                                                                        setDraggedCell({ sectionIdx: sIdx, boxIdx: bIdx });
                                                                        e.dataTransfer.effectAllowed = 'move';
                                                                        e.stopPropagation();
                                                                    }}
                                                                    onDragOver={(e) => {
                                                                        e.preventDefault();
                                                                        // Accept both box reordering (edit mode) and play drops from Play Bank
                                                                        e.dataTransfer.dropEffect = isSheetEditing ? 'move' : 'copy';
                                                                    }}
                                                                    onDragEnter={(e) => {
                                                                        e.preventDefault();
                                                                        // Track which box is being hovered for visual feedback
                                                                        if (!isSheetEditing) {
                                                                            setPlayDragOverBox({ sectionIdx: sIdx, boxIdx: bIdx });
                                                                        }
                                                                    }}
                                                                    onDragLeave={(e) => {
                                                                        // Only clear if we're leaving this specific box
                                                                        if (playDragOverBox?.sectionIdx === sIdx && playDragOverBox?.boxIdx === bIdx) {
                                                                            setPlayDragOverBox(null);
                                                                        }
                                                                    }}
                                                                    onDrop={(e) => {
                                                                        setPlayDragOverBox(null);
                                                                        handleSheetBoxDrop(e, sIdx, bIdx);
                                                                    }}
                                                                    style={{
                                                                        flexGrow: section.expandToFill ? span : 0,
                                                                        flexBasis: section.expandToFill ? '0' : undefined,
                                                                        minWidth: section.expandToFill ? '125px' : undefined,
                                                                        gridColumn: section.expandToFill ? 'auto' : `span ${span}`,
                                                                        borderBottom: !isSheetEditing && Math.floor(bIdx / 2) < Math.ceil(visibleBoxes.length / 2) - 1 ? '1px solid #cbd5e1' : 'none',
                                                                        borderRight: !isSheetEditing && bIdx % 2 === 0 ? '1px solid #cbd5e1' : 'none',
                                                                        border: isSheetEditing ? '1px solid #e2e8f0' : (playDragOverBox?.sectionIdx === sIdx && playDragOverBox?.boxIdx === bIdx ? '2px dashed #3b82f6' : undefined),
                                                                        background: playDragOverBox?.sectionIdx === sIdx && playDragOverBox?.boxIdx === bIdx ? '#eff6ff' : 'white',
                                                                        minHeight: isPrintMode ? 'auto' : '120px',
                                                                        cursor: isSheetEditing ? 'grab' : 'pointer',
                                                                        display: 'flex', flexDirection: 'column',
                                                                        opacity: (draggedCell?.sectionIdx === sIdx && draggedCell?.boxIdx === bIdx) ? 0.5 : 1,
                                                                        transition: 'background 0.15s, border 0.15s'
                                                                    }}
                                                                    onClick={() => {
                                                                        if (!isSheetEditing) setEditingBox({ box, sectionIdx: sIdx, boxIdx: bIdx });
                                                                    }}
                                                                >
                                                                    {/* Sheet Box Header */}
                                                                    <div style={{
                                                                        padding: '4px 8px',
                                                                        background: box.color || '#3b82f6',
                                                                        color: 'white',
                                                                        fontSize: '0.75rem',
                                                                        fontWeight: 'bold',
                                                                        display: 'flex', justifyContent: 'space-between', alignItems: 'center'
                                                                    }}>
                                                                        <span style={{ whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>{box.header}</span>
                                                                        {isSheetEditing ? (
                                                                            <div
                                                                                onClick={(e) => { e.stopPropagation(); handleDeleteSheetBox(sIdx, bIdx); }}
                                                                                style={{ cursor: 'pointer', padding: '0 4px' }}
                                                                            >
                                                                                ×
                                                                            </div>
                                                                        ) : (
                                                                            <div style={{ display: 'flex', gap: '4px', alignItems: 'center' }}>
                                                                                {suggestions[box.setId]?.length > 0 && (
                                                                                    <span style={{ fontSize: '0.65rem', background: '#ef4444', padding: '0 4px', borderRadius: '4px', fontWeight: '700' }}>
                                                                                        {suggestions[box.setId].length}★
                                                                                    </span>
                                                                                )}
                                                                                <span style={{ fontSize: '0.7rem', opacity: 0.9, background: 'rgba(0,0,0,0.2)', padding: '0 4px', borderRadius: '4px' }}>{quickListCount}</span>
                                                                            </div>
                                                                        )}
                                                                    </div>

                                                                    {/* Sheet Box Content */}
                                                                    <div style={{ padding: isPrintMode ? '2px' : '6px', fontSize: '0.7rem', flex: isPrintMode ? 'none' : 1 }}>
                                                                        {/* Row Expand Badge - only show on first box of each row */}
                                                                        {isFirstInRow && isSheetEditing && (
                                                                            <button
                                                                                className="btn-sm"
                                                                                onClick={(e) => {
                                                                                    e.stopPropagation();
                                                                                    const expandedRows = section.expandedRows || [];
                                                                                    const isExpanded = expandedRows.includes(currentBoxRowNumber);
                                                                                    const newExpandedRows = isExpanded
                                                                                        ? expandedRows.filter(r => r !== currentBoxRowNumber)
                                                                                        : [...expandedRows, currentBoxRowNumber];
                                                                                    handleUpdateSheetSection(sIdx, { ...section, expandedRows: newExpandedRows });
                                                                                }}
                                                                                style={{
                                                                                    position: 'absolute',
                                                                                    top: '2px',
                                                                                    left: '2px',
                                                                                    background: (section.expandedRows || []).includes(currentBoxRowNumber) ? 'var(--accent)' : '#e2e8f0',
                                                                                    color: (section.expandedRows || []).includes(currentBoxRowNumber) ? 'white' : '#64748b',
                                                                                    fontSize: '0.6rem',
                                                                                    padding: '2px 4px',
                                                                                    zIndex: 100,
                                                                                    borderRadius: '3px'
                                                                                }}
                                                                                title={(section.expandedRows || []).includes(currentBoxRowNumber) ? 'Fixed Width' : 'Expand Row'}
                                                                            >
                                                                                {(section.expandedRows || []).includes(currentBoxRowNumber) ? '📏' : '↔️'}
                                                                            </button>
                                                                        )}

                                                                        {/* Render Strategy: Script Rows vs Assigned Plays */}
                                                                        {renderBoxContent()}
                                                                    </div>
                                                                </div>
                                                            );
                                                        })}
                                                    </div>
                                                ))
                                            })()}
                                            {isSheetEditing && (
                                                <div
                                                    style={{
                                                        border: '2px dashed #e2e8f0', borderRadius: '4px', minHeight: '120px',
                                                        display: 'flex', alignItems: 'center', justifyContent: 'center',
                                                        cursor: 'pointer', color: '#64748b', fontWeight: '500', background: '#f8fafc'
                                                    }}
                                                    onClick={() => handleAddSheetBox(sIdx)}
                                                >
                                                    + Add Box
                                                </div>
                                            )}
                                        </div>
                                    </div >
                                );
                            })
                            }

                            {
                                isSheetEditing && (
                                    <button
                                        style={{
                                            border: '2px dashed #cbd5e1',
                                            height: '80px',
                                            width: '100%',
                                            gridColumn: '1 / -1',
                                            background: '#f1f5f9',
                                            color: '#475569',
                                            fontWeight: '600',
                                            borderRadius: '8px',
                                            cursor: 'pointer',
                                            fontSize: '0.9rem',
                                            display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px'
                                        }}
                                        onClick={handleAddSheetSection}
                                    >
                                        <span style={{ fontSize: '1.2rem' }}>+</span> Add New Section
                                    </button>
                                )
                            }
                        </div >
                    </div >
                );
            };

            const renderMatrix = () => {
                const layout = GAME_PLAN_LAYOUTS.MATRIX;

                // Group columns by pitch type
                const columnGroups = [
                    { id: 'FB', label: 'BASE/INITIAL', cols: layout.cols.slice(0, 2) },
                    { id: 'CB', label: 'BASE W/ DRESSING', cols: layout.cols.slice(2, 4) },
                    { id: 'CU', label: 'CONVERT', cols: layout.cols.slice(4, 6) },
                    { id: 'SO', label: 'EXPLOSIVE', cols: layout.cols.slice(6, 8) }
                ];

                const toggleGroup = (groupId) => {
                    setCollapsedGroups(prev => {
                        const newCollapsed = new Set(prev);
                        if (newCollapsed.has(groupId)) {
                            newCollapsed.delete(groupId);
                        } else {
                            newCollapsed.add(groupId);
                        }
                        return newCollapsed;
                    });
                };

                return (
                    <div className="animate-fade-in" style={{ height: '100%', overflowX: 'auto', overflowY: 'auto' }}>
                        <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '0.75rem' }}>
                            <thead>
                                <tr>
                                    <th rowSpan={2} style={{ padding: '0.5rem', border: '1px solid var(--border)', width: '120px', position: 'sticky', left: 0, top: 0, backgroundColor: 'white', zIndex: 20 }}>Formation / Type</th>
                                    {columnGroups.map(group => {
                                        const isCollapsed = collapsedGroups.has(group.id);
                                        return (
                                            <React.Fragment key={group.id}>
                                                {isCollapsed ? (
                                                    <th
                                                        rowSpan={2}
                                                        style={{ padding: '0.5rem', border: '1px solid var(--border)', backgroundColor: '#334155', color: 'white', cursor: 'pointer', minWidth: '60px', top: 0, position: 'sticky', zIndex: 10 }}
                                                        onClick={() => toggleGroup(group.id)}
                                                        title={`Click to expand ${group.label}`}
                                                    >
                                                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '0.25rem' }}>
                                                            <span>▶</span>
                                                            <span style={{ writingMode: 'vertical-rl', transform: 'rotate(180deg)' }}>{group.label}</span>
                                                        </div>
                                                    </th>
                                                ) : (
                                                    <th
                                                        colSpan={2}
                                                        style={{
                                                            padding: '0.5rem',
                                                            border: '1px solid var(--border)',
                                                            backgroundColor: '#334155',
                                                            color: 'white',
                                                            cursor: 'pointer',
                                                            textAlign: 'center',
                                                            top: 0,
                                                            position: 'sticky',
                                                            zIndex: 10
                                                        }}
                                                        onClick={() => toggleGroup(group.id)}
                                                        title={`Click to collapse ${group.label}`}
                                                    >
                                                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', justifyContent: 'center' }}>
                                                            <span style={{ fontSize: '0.7rem' }}>▼</span>
                                                            <span>{group.label}</span>
                                                        </div>
                                                    </th>
                                                )}
                                            </React.Fragment>
                                        );
                                    })}
                                </tr>
                                <tr>
                                    {columnGroups.map(group => {
                                        if (collapsedGroups.has(group.id)) return null;
                                        const leftHashCollapsed = collapsedHashColumns.has(`${group.id}_LEFT`);
                                        const rightHashCollapsed = collapsedHashColumns.has(`${group.id}_RIGHT`);
                                        return (
                                            <React.Fragment key={group.id + '_sub'}>
                                                {!leftHashCollapsed && (
                                                    <th
                                                        style={{
                                                            padding: '0.25rem',
                                                            border: '1px solid var(--border)',
                                                            backgroundColor: '#475569',
                                                            color: 'white',
                                                            fontSize: '0.7rem',
                                                            textAlign: 'center',
                                                            top: '35px',
                                                            position: 'sticky',
                                                            zIndex: 10,
                                                            cursor: 'pointer'
                                                        }}
                                                        onClick={() => toggleHashColumn(group.id, 'LEFT')}
                                                        title="Click to collapse LEFT HASH"
                                                    >
                                                        ◀ LEFT HASH
                                                    </th>
                                                )}
                                                {leftHashCollapsed && (
                                                    <th
                                                        style={{
                                                            padding: '0.25rem',
                                                            border: '1px solid var(--border)',
                                                            backgroundColor: '#64748b',
                                                            color: 'white',
                                                            fontSize: '0.7rem',
                                                            textAlign: 'center',
                                                            top: '35px',
                                                            position: 'sticky',
                                                            zIndex: 10,
                                                            cursor: 'pointer',
                                                            width: '20px'
                                                        }}
                                                        onClick={() => toggleHashColumn(group.id, 'LEFT')}
                                                        title="Click to expand LEFT HASH"
                                                    >
                                                        ▶
                                                    </th>
                                                )}
                                                {!rightHashCollapsed && (
                                                    <th
                                                        style={{
                                                            padding: '0.25rem',
                                                            border: '1px solid var(--border)',
                                                            backgroundColor: '#475569',
                                                            color: 'white',
                                                            fontSize: '0.7rem',
                                                            textAlign: 'center',
                                                            top: '35px',
                                                            position: 'sticky',
                                                            zIndex: 10,
                                                            cursor: 'pointer'
                                                        }}
                                                        onClick={() => toggleHashColumn(group.id, 'RIGHT')}
                                                        title="Click to collapse RIGHT HASH"
                                                    >
                                                        RIGHT HASH ▶
                                                    </th>
                                                )}
                                                {rightHashCollapsed && (
                                                    <th
                                                        style={{
                                                            padding: '0.25rem',
                                                            border: '1px solid var(--border)',
                                                            backgroundColor: '#64748b',
                                                            color: 'white',
                                                            fontSize: '0.7rem',
                                                            textAlign: 'center',
                                                            top: '35px',
                                                            position: 'sticky',
                                                            zIndex: 10,
                                                            cursor: 'pointer',
                                                            width: '20px'
                                                        }}
                                                        onClick={() => toggleHashColumn(group.id, 'RIGHT')}
                                                        title="Click to expand RIGHT HASH"
                                                    >
                                                        ◀
                                                    </th>
                                                )}
                                            </React.Fragment>
                                        );
                                    })}
                                </tr>
                            </thead>
                            <tbody>
                                {layout.formations.map(formation => (
                                    <React.Fragment key={formation.id}>
                                        {/* Formation Header Row */}
                                        <tr>
                                            <td
                                                colSpan={columnGroups.reduce((acc, g) => {
                                                    if (collapsedGroups.has(g.id)) return acc + 1;
                                                    // Always count 2 columns per group (visible + collapsed)
                                                    return acc + 2;
                                                }, 1)}
                                                style={{ padding: '2px 4px', border: '1px solid var(--border)', fontWeight: 'bold', backgroundColor: formation.color, color: 'white', fontSize: '0.8rem', lineHeight: '1.1', cursor: 'pointer' }}
                                                onClick={() => setEditingFormationId(formation.id)}
                                            >
                                                {editingFormationId === formation.id ? (
                                                    <input
                                                        autoFocus
                                                        defaultValue={(gamePlan?.formationOverrides || {})[formation.id] || formation.label}
                                                        style={{ background: 'white', color: 'black', border: 'none', padding: '2px 4px', borderRadius: '2px', width: '200px' }}
                                                        onBlur={(e) => handleUpdateFormationName(formation.id, e.target.value)}
                                                        onKeyDown={(e) => {
                                                            if (e.key === 'Enter') handleUpdateFormationName(formation.id, e.target.currentTarget.value);
                                                        }}
                                                        onClick={(e) => e.stopPropagation()}
                                                    />
                                                ) : (
                                                    (gamePlan?.formationOverrides || {})[formation.id] || formation.label
                                                )}
                                            </td>
                                        </tr>
                                        {/* Play Type Rows */}
                                        {layout.playTypes.map(playType => {
                                            const isRowCollapsed = collapsedRows.has(playType.id);
                                            const totalColSpan = columnGroups.reduce((acc, g) => {
                                                if (collapsedGroups.has(g.id)) return acc + 1;
                                                // Always count full columns (2)
                                                return acc + g.cols.length;
                                            }, 1);

                                            if (isRowCollapsed) {
                                                return (
                                                    <tr key={`${formation.id}_${playType.id}`}>
                                                        <td
                                                            colSpan={totalColSpan}
                                                            style={{
                                                                padding: '0.5rem',
                                                                border: '1px solid var(--border)',
                                                                fontWeight: '500',
                                                                backgroundColor: '#eff6ff',
                                                                cursor: 'pointer',
                                                                color: '#1e3a8a',
                                                                fontSize: '0.8rem',
                                                                fontStyle: 'italic'
                                                            }}
                                                            onClick={() => toggleRow(playType.id)}
                                                        >
                                                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                                <span style={{ fontSize: '0.7rem' }}>▶</span>
                                                                <span>{playType.label} (Collapsed)</span>
                                                            </div>
                                                        </td>
                                                    </tr>
                                                );
                                            }

                                            return (
                                                <tr key={`${formation.id}_${playType.id}`}>
                                                    <td
                                                        style={{
                                                            padding: '2px 4px',
                                                            border: '1px solid var(--border)',
                                                            fontWeight: 'bold',
                                                            backgroundColor: '#dbeafe',
                                                            position: 'sticky',
                                                            left: 0,
                                                            zIndex: 5,
                                                            cursor: 'pointer',
                                                            color: '#1e40af',
                                                            fontSize: '0.75rem',
                                                            lineHeight: '1.1'
                                                        }}
                                                        onClick={() => toggleRow(playType.id)}
                                                        title="Click to collapse row"
                                                    >
                                                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                            <span style={{ fontSize: '0.7rem' }}>▼</span>
                                                            {playType.label}
                                                        </div>
                                                    </td>
                                                    {columnGroups.map(group => {
                                                        const isCollapsed = collapsedGroups.has(group.id);
                                                        const leftHashCollapsed = collapsedHashColumns.has(`${group.id}_LEFT`);
                                                        const rightHashCollapsed = collapsedHashColumns.has(`${group.id}_RIGHT`);

                                                        if (isCollapsed) {
                                                            // Show collapsed placeholder
                                                            return (
                                                                <td
                                                                    key={group.id}
                                                                    style={{ padding: '0.25rem', border: '1px solid var(--border)', backgroundColor: '#e5e7eb', textAlign: 'center' }}
                                                                >
                                                                    <span style={{ fontSize: '0.7rem', color: '#6b7280' }}>•••</span>
                                                                </td>
                                                            );
                                                        } else {
                                                            // Show expanded columns
                                                            return group.cols.map(col => {
                                                                const commonStyle = { padding: '0', border: '1px solid #e2e8f0', verticalAlign: 'middle', backgroundColor: '#f8fafc', width: '20px' };

                                                                // Show placeholder for collapsed LEFT HASH
                                                                if (col.id === 'LEFT' && leftHashCollapsed) {
                                                                    return <td key={`matrix_${formation.id}_${playType.id}_${col.id}_collapsed`} style={commonStyle}></td>;
                                                                }
                                                                // Show placeholder for collapsed RIGHT HASH
                                                                if (col.id === 'RIGHT' && rightHashCollapsed) {
                                                                    return <td key={`matrix_${formation.id}_${playType.id}_${col.id}_collapsed`} style={commonStyle}></td>;
                                                                }

                                                                const setId = `matrix_${formation.id}_${playType.id}_${col.id}`;
                                                                return (
                                                                    <td
                                                                        key={setId}
                                                                        style={{ padding: '0', border: '1px solid #ddd', verticalAlign: 'top', cursor: 'default', backgroundColor: 'white', lineHeight: '1' }}
                                                                    >
                                                                        {renderPlayListSimple(setId)}
                                                                        {onQuickAddPlay && (
                                                                            <GridPlayInput
                                                                                setId={setId}
                                                                                onSelectPlay={(playId) => handleAddPlayToSet(setId, playId)}
                                                                                onQuickAdd={(name) => handleQuickAddToSet(setId, name)}
                                                                            />
                                                                        )}
                                                                    </td>
                                                                );
                                                            });
                                                        }
                                                    })}
                                                </tr>
                                            );
                                        })}
                                    </React.Fragment>
                                ))}
                            </tbody>
                        </table>
                    </div>
                );
            };

            const handleConfigureSection = (sectionIdx, type) => {
                const newLayouts = { ...gamePlanLayouts };
                const sheet = { ...newLayouts.CALL_SHEET };
                const section = { ...sheet.sections[sectionIdx] };

                section.type = type;

                // Initialize defaults based on type
                if (type === 'script') {
                    // Script gets 1 column
                    section.cols = 1;
                    // Ensure rows exist
                    if (!section.rows) section.rows = [];
                } else if (type === 'grid') {
                    // Grid Section defaults
                    if (!section.gridHeadings) section.gridHeadings = ['LEFT HASH', 'MIDDLE', 'RIGHT HASH', 'NOTES'];
                    if (!section.rowLabels) section.rowLabels = ['Group 1', 'Group 2', 'Group 3', 'Group 4', 'Group 5'];
                } else if (type === 'field_position') {
                    // Field Position defaults -> Treat as Grid Section for now as per user request for "Strike Em Out" grid
                    if (!section.gridHeadings) section.gridHeadings = ['LEFT HASH', 'MIDDLE', 'RIGHT HASH', 'NOTES'];
                    if (!section.rowLabels) section.rowLabels = ['Group 1', 'Group 2', 'Group 3', 'Group 4', 'Group 5'];
                    section.type = 'grid'; // Force to grid type internally to reuse logic
                } else if (type === 'standard') {
                } else if (type === 'standard') {
                    // Standard defaults (Spreadsheet)
                    section.cols = 1; // It renders as a list
                    if (!section.rows) section.rows = [];
                }

                sheet.sections[sectionIdx] = section;
                newLayouts.CALL_SHEET = sheet;

                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                setConfiguringSection(null);
            };

            const renderSectionConfigurationModal = () => {
                if (!configuringSection) return null;
                const sectionIdx = configuringSection.idx;
                const section = gamePlanLayouts.CALL_SHEET.sections[sectionIdx];
                if (!section) return null; // Safety check

                return (
                    <div className="modal-overlay" onClick={() => setConfiguringSection(null)} style={{ zIndex: 2000 }}>
                        <div className="modal-content" onClick={e => e.stopPropagation()} style={{ width: '500px' }}>
                            <div className="modal-header">
                                <h3>Configure Box Type</h3>
                                <button className="modal-close" onClick={() => setConfiguringSection(null)}>×</button>
                            </div>
                            <div className="modal-body">
                                <p style={{ marginBottom: '1rem', color: '#666' }}>Select a layout type for "{section.title}":</p>

                                <div style={{ display: 'grid', gap: '1rem' }}>
                                    {/* Script Menu */}
                                    <div
                                        onClick={() => handleConfigureSection(sectionIdx, 'script')}
                                        style={{
                                            border: '1px solid #ddd', borderRadius: '8px', padding: '1rem', cursor: 'pointer',
                                            display: 'flex', gap: '1rem', alignItems: 'center',
                                            background: '#f8fafc', transition: 'all 0.2s'
                                        }}
                                        onMouseEnter={e => e.currentTarget.style.borderColor = 'var(--primary)'}
                                        onMouseLeave={e => e.currentTarget.style.borderColor = '#ddd'}
                                    >
                                        <div style={{ fontSize: '2rem' }}>📜</div>
                                        <div>
                                            <div style={{ fontWeight: 'bold' }}>Script Menu</div>
                                            <div style={{ fontSize: '0.8rem', color: '#666' }}>Vertical list with editable tempo indicators.</div>
                                        </div>
                                    </div>

                                    {/* Field Position Menu */}
                                    <div
                                        onClick={() => handleConfigureSection(sectionIdx, 'field_position')}
                                        style={{
                                            border: '1px solid #ddd', borderRadius: '8px', padding: '1rem', cursor: 'pointer',
                                            display: 'flex', gap: '1rem', alignItems: 'center',
                                            background: '#f8fafc', transition: 'all 0.2s'
                                        }}
                                        onMouseEnter={e => e.currentTarget.style.borderColor = 'var(--primary)'}
                                        onMouseLeave={e => e.currentTarget.style.borderColor = '#ddd'}
                                    >
                                        <div style={{ fontSize: '2rem' }}>🏟️</div>
                                        <div>
                                            <div style={{ fontWeight: 'bold' }}>Field Position Menu</div>
                                            <div style={{ fontSize: '0.8rem', color: '#666' }}>Strike 'Em Out style table with editable headers.</div>
                                        </div>
                                    </div>

                                    {/* Standard Menu */}
                                    <div
                                        onClick={() => handleConfigureSection(sectionIdx, 'standard')}
                                        style={{
                                            border: '1px solid #ddd', borderRadius: '8px', padding: '1rem', cursor: 'pointer',
                                            display: 'flex', gap: '1rem', alignItems: 'center',
                                            background: '#f8fafc', transition: 'all 0.2s'
                                        }}
                                        onMouseEnter={e => e.currentTarget.style.borderColor = 'var(--primary)'}
                                        onMouseLeave={e => e.currentTarget.style.borderColor = '#ddd'}
                                    >
                                        <div style={{ fontSize: '2rem' }}>📋</div>
                                        <div>
                                            <div style={{ fontWeight: 'bold' }}>Standard Menu</div>
                                            <div style={{ fontSize: '0.8rem', color: '#666' }}>Spreadsheet-style list with quick add support.</div>
                                        </div>
                                    </div>

                                    {/* Situational Menu (Grid) */}
                                    <div
                                        onClick={() => handleConfigureSection(sectionIdx, 'grid')}
                                        style={{
                                            border: '1px solid #ddd', borderRadius: '8px', padding: '1rem', cursor: 'pointer',
                                            display: 'flex', gap: '1rem', alignItems: 'center',
                                            background: '#f8fafc', transition: 'all 0.2s'
                                        }}
                                        onMouseEnter={e => e.currentTarget.style.borderColor = 'var(--primary)'}
                                        onMouseLeave={e => e.currentTarget.style.borderColor = '#ddd'}
                                    >
                                        <div style={{ fontSize: '2rem' }}>🔢</div>
                                        <div>
                                            <div style={{ fontWeight: 'bold' }}>Situational Menu</div>
                                            <div style={{ fontSize: '0.8rem', color: '#666' }}>Grid layout for holding Situational Boxes (e.g. 3rd Down).</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            };

            const renderPlaySelector = () => {

                if (!showPlaySelector) return null;

                // Find the box being edited
                let activeBox = null;
                gamePlanLayouts.CALL_SHEET.sections.forEach(section => {
                    const found = (section.boxes || []).find(b => b.setId === activeCellSetId);
                    if (found) activeBox = found;
                });

                const isGridMode = activeBox?.type === 'grid';
                const gridPlays = getGridPlays(activeCellSetId);

                // Split into Left (0-9) and Right (10-19) for normal mode
                const leftPlays = gridPlays.slice(0, 10); // Indices 0-9
                const rightPlays = gridPlays.slice(10, 20); // Indices 10-19

                // Slice for Grid mode (16 plays)
                const gridModePlays = gridPlays.slice(0, 16);
                const gridHeadings = activeBox?.gridHeadings || ['LEFT HASH', 'MIDDLE', 'RIGHT HASH', 'NOTES'];
                const gridRowLabels = activeBox?.gridRowLabels || ['Group 1', 'Group 2', 'Group 3', 'Group 4'];
                const cornerLabel = activeBox?.cornerLabel || 'Group/Type';

                // Wristband Input Component with Autocomplete
                const WristbandInput = ({ play, playIndex }) => {
                    const assignedCoords = getAssignedWristbandCoordinates(play.id);
                    const isDuplicate = play.wristbandSlot && assignedCoords.has(play.wristbandSlot.trim());
                    const currentValue = play.wristbandSlot || '';

                    // Generate suggested coordinates (101-199, 201-299, etc.)
                    const suggestedCoords = [];
                    for (let i = 101; i <= 999; i++) {
                        const coord = i.toString();
                        if (!assignedCoords.has(coord)) {
                            suggestedCoords.push(coord);
                        }
                        if (suggestedCoords.length >= 50) break; // Limit suggestions
                    }

                    // Filter suggestions based on current input
                    const filteredSuggestions = currentValue
                        ? suggestedCoords.filter(c => c.startsWith(currentValue))
                        : suggestedCoords.slice(0, 10);

                    const isFocused = wristbandFocus === playIndex;

                    const validateWristbandAssignment = (val) => {
                        let isBlocked = false;
                        const currentWbSettings = currentWeek?.wristbands || {};
                        const enabledSections = currentWbSettings.enabledSections || {};

                        const cardKeys = ['card1', 'card2', 'card3', 'card4', 'card5', 'card6'];
                        for (const key of cardKeys) {
                            if (enabledSections[key] !== false) continue;
                            const card = currentWbSettings[key];
                            if (!card) continue;
                            const cardNum = parseInt(key.replace('card', ''));

                            if (card.type && (card.type === 'wiz')) {
                                for (let i = 1; i <= 16; i++) {
                                    if (val === `${cardNum}${String(i).padStart(2, '0')}`) isBlocked = true;
                                }
                            } else {
                                const start = cardNum * 100 + 1;
                                const end = start + 47;
                                const num = parseInt(val);
                                if (!isNaN(num) && num >= start && num <= end && String(num) === val) isBlocked = true;
                            }
                        }

                        // Check Staples
                        if (enabledSections.staples === false) {
                            const num = parseInt(val);
                            if (!isNaN(num) && num >= 10 && num <= 89 && String(num) === val) isBlocked = true;
                        }

                        if (isBlocked) {
                            alert("This wristband section is disabled.");
                            return false;
                        }
                        return true;
                    };

                    return (
                        <div style={{ position: 'relative' }}>
                            <input
                                type="text"
                                value={currentValue}
                                placeholder="#"
                                onFocus={() => setWristbandFocus(playIndex)}
                                onBlur={() => {
                                    // Delay to allow dropdown click to register
                                    setTimeout(() => setWristbandFocus(null), 150);
                                }}
                                onChange={(e) => {
                                    const val = e.target.value;
                                    if (validateWristbandAssignment(val)) {
                                        if (onUpdatePlay) onUpdatePlay({ ...play, wristbandSlot: val });
                                    }
                                }}
                                style={{
                                    width: '30px',
                                    fontSize: '0.7rem',
                                    textAlign: 'center',
                                    padding: '2px',
                                    border: isDuplicate ? '2px solid #dc2626' : '1px solid #ccc',
                                    borderRadius: '2px',
                                    color: isDuplicate ? '#dc2626' : '#1e293b',
                                    fontWeight: isDuplicate ? 'bold' : 'normal',
                                    background: isDuplicate ? '#fee2e2' : 'white'
                                }}
                                title={isDuplicate ? 'Warning: This coordinate is already assigned!' : ''}
                            />
                            {/* Autocomplete Dropdown */}
                            {isFocused && filteredSuggestions.length > 0 && (
                                <div style={{
                                    position: 'absolute',
                                    top: '100%',
                                    left: 0,
                                    zIndex: 10000,
                                    background: 'white',
                                    border: '1px solid #cbd5e1',
                                    borderRadius: '4px',
                                    boxShadow: '0 4px 10px rgba(0,0,0,0.2)',
                                    maxHeight: '150px',
                                    overflowY: 'auto',
                                    minWidth: '60px',
                                    marginTop: '2px'
                                }}>
                                    {filteredSuggestions.map(coord => (
                                        <div
                                            key={coord}
                                            onMouseDown={(e) => {
                                                e.preventDefault(); // Prevent blur
                                                if (validateWristbandAssignment(coord)) {
                                                    if (onUpdatePlay) {
                                                        onUpdatePlay({ ...play, wristbandSlot: coord });
                                                    }
                                                }
                                                setWristbandFocus(null);
                                            }}
                                            style={{
                                                padding: '4px 8px',
                                                cursor: 'pointer',
                                                fontSize: '0.75rem',
                                                color: '#1e293b',
                                                background: 'white'
                                            }}
                                            onMouseEnter={(e) => e.target.style.background = '#f1f5f9'}
                                            onMouseLeave={(e) => e.target.style.background = 'white'}
                                        >
                                            {coord}
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>
                    );
                };

                return (
                    <div style={{
                        position: 'fixed', top: 0, left: 0, width: '100vw', height: '100vh',
                        backgroundColor: 'rgba(0,0,0,0.8)', zIndex: 1000, display: 'flex', justifyContent: 'center', alignItems: 'center'
                    }} onClick={() => setShowPlaySelector(false)}>
                        <div style={{ width: '90%', height: '90%', backgroundColor: 'var(--bg-panel)', borderRadius: '12px', padding: '1.5rem', display: 'flex', flexDirection: 'column' }} onClick={e => e.stopPropagation()}>
                            <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem', alignItems: 'center' }}>
                                <h2>Select Plays {activeBox?.header ? `(${activeBox.header})` : ''}</h2>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>

                                    <button className="btn" onClick={() => setShowPlaySelector(false)}>Close</button>
                                </div>
                            </div>

                            {/* Filters Row - Condensed */}
                            <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '1rem', alignItems: 'center' }}>
                                <input
                                    type="text"
                                    className="form-input"
                                    placeholder="🔍 Search..."
                                    value={playSelectorFilters.search || ''}
                                    onChange={e => setPlaySelectorFilters({ ...playSelectorFilters, search: e.target.value })}
                                    style={{ flex: 1 }}
                                />
                                <select className="form-select" style={{ width: '150px' }} value={playSelectorFilters.formation} onChange={e => setPlaySelectorFilters({ ...playSelectorFilters, formation: e.target.value })}>
                                    <option value="">All Formations</option>
                                    {uniqueFormations.map(f => <option key={f} value={f}>{f}</option>)}
                                </select>
                                <select className="form-select" style={{ width: '150px' }} value={playSelectorFilters.concept} onChange={e => setPlaySelectorFilters({ ...playSelectorFilters, concept: e.target.value })}>
                                    <option value="">All Concepts</option>
                                    {uniqueConcepts.map(c => <option key={c} value={c}>{c}</option>)}
                                </select>
                                <select className="form-select" style={{ width: '150px' }} value={playSelectorFilters.situation} onChange={e => setPlaySelectorFilters({ ...playSelectorFilters, situation: e.target.value })}>
                                    <option value="">All Situations</option>
                                    {situationTags.map(s => <option key={s} value={s}>{s}</option>)}
                                </select>
                                <select className="form-select" style={{ width: '150px' }} value={playSelectorFilters.tag} onChange={e => setPlaySelectorFilters({ ...playSelectorFilters, tag: e.target.value })}>
                                    <option value="">All Tags</option>
                                    {allTags.map(t => <option key={t} value={t}>{t}</option>)}
                                </select>
                            </div>

                            <div style={{ display: 'flex', flex: 1, gap: '1rem', overflow: 'hidden' }}>

                                {/* GRID SIDE */}
                                <div style={{ flex: isGridMode ? '1' : '0 0 450px', maxWidth: isGridMode ? 'none' : '450px', display: 'flex', flexDirection: 'column', borderRight: '1px solid var(--border)', paddingRight: '1rem' }}>
                                    <h4 style={{ marginBottom: '0.5rem', textAlign: 'center' }}>Selected Plays (Drag to Move)</h4>

                                    {isGridMode ? (
                                        /* 4x4 Grid Mode */
                                        <div style={{ display: 'flex', flexDirection: 'column', height: '100%', overflow: 'hidden' }}>
                                            {/* Column Headers Row */}
                                            <div style={{ display: 'grid', gridTemplateColumns: '120px repeat(4, 1fr)', gap: '10px', marginBottom: '8px' }}>
                                                {/* Corner Label */}
                                                <div style={{ position: 'relative' }}>
                                                    <input
                                                        value={cornerLabel}
                                                        onChange={(e) => {
                                                            const newLayouts = { ...gamePlanLayouts };
                                                            const sheet = { ...newLayouts.CALL_SHEET };
                                                            sheet.sections.forEach(section => {
                                                                (section.boxes || []).forEach(b => {
                                                                    if (b.setId === activeCellSetId) {
                                                                        b.cornerLabel = e.target.value;
                                                                    }
                                                                });
                                                            });
                                                            if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                        }}
                                                        style={{
                                                            width: '100%', fontSize: '0.7rem', fontWeight: 'bold',
                                                            background: '#475569', color: 'white', border: 'none',
                                                            padding: '6px 4px', borderRadius: '4px', textAlign: 'center'
                                                        }}
                                                        placeholder="Corner..."
                                                    />
                                                </div>
                                                {gridHeadings.map((h, i) => (
                                                    <div key={i} style={{ textAlign: 'center', position: 'relative' }}>
                                                        <input
                                                            value={h}
                                                            onChange={(e) => {
                                                                const newLayouts = { ...gamePlanLayouts };
                                                                const sheet = { ...newLayouts.CALL_SHEET };
                                                                sheet.sections.forEach(section => {
                                                                    (section.boxes || []).forEach(b => {
                                                                        if (b.setId === activeCellSetId) {
                                                                            if (!b.gridHeadings) b.gridHeadings = ['LEFT HASH', 'MIDDLE', 'RIGHT HASH', 'NOTES'];
                                                                            b.gridHeadings[i] = e.target.value;
                                                                        }
                                                                    });
                                                                });
                                                                if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                            }}
                                                            style={{
                                                                width: '100%', fontSize: '0.7rem', fontWeight: 'bold',
                                                                background: '#334155', color: 'white', border: 'none',
                                                                padding: '6px 4px', borderRadius: '4px', textAlign: 'center'
                                                            }}
                                                        />
                                                    </div>
                                                ))}
                                            </div>

                                            {/* Grid Body with Row Labels */}
                                            <div style={{ display: 'flex', flexDirection: 'column', gap: '8px', flex: 1, overflowY: 'auto', paddingBottom: '1rem' }}>
                                                {[0, 1, 2, 3].map(rowNum => (
                                                    <div key={rowNum} style={{ display: 'grid', gridTemplateColumns: '120px repeat(4, 1fr)', gap: '8px', alignItems: 'stretch' }}>
                                                        {/* Row Label */}
                                                        <div style={{ display: 'flex', alignItems: 'center' }}>
                                                            <input
                                                                value={gridRowLabels[rowNum]}
                                                                onChange={(e) => {
                                                                    const newLayouts = { ...gamePlanLayouts };
                                                                    const sheet = { ...newLayouts.CALL_SHEET };
                                                                    sheet.sections.forEach(section => {
                                                                        (section.boxes || []).forEach(b => {
                                                                            if (b.setId === activeCellSetId) {
                                                                                if (!b.gridRowLabels) b.gridRowLabels = ['Group 1', 'Group 2', 'Group 3', 'Group 4'];
                                                                                b.gridRowLabels[rowNum] = e.target.value;
                                                                            }
                                                                        });
                                                                    });
                                                                    if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                                                                }}
                                                                style={{
                                                                    width: '100%', fontSize: '0.7rem', fontWeight: 'bold',
                                                                    background: '#334155', color: 'white', border: 'none',
                                                                    padding: '6px 4px', borderRadius: '4px', textAlign: 'center',
                                                                    height: '100%'
                                                                }}
                                                            />
                                                        </div>

                                                        {/* 4 Data Cells for this row */}
                                                        {[0, 1, 2, 3].map(colNum => {
                                                            const idx = rowNum * 4 + colNum;
                                                            const p = gridModePlays[idx];
                                                            return (
                                                                <div key={idx}
                                                                    draggable
                                                                    onDragStart={(e) => {
                                                                        e.dataTransfer.setData('text/plain', idx);
                                                                        setDraggedGridIndex(idx);
                                                                    }}
                                                                    onDragOver={(e) => { e.preventDefault(); }}
                                                                    onDrop={(e) => {
                                                                        e.preventDefault();
                                                                        const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                                                                        handleGridMove(fromIdx, idx);
                                                                        setDraggedGridIndex(null);
                                                                    }}
                                                                    style={{
                                                                        height: '100px', border: '2px dashed #cbd5e1', borderRadius: '8px',
                                                                        display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: '8px', gap: '4px',
                                                                        background: p.type === 'GAP' ? '#f8fafc' : 'white',
                                                                        opacity: draggedGridIndex === idx ? 0.5 : 1,
                                                                        transition: 'all 0.2s',
                                                                        textAlign: 'center',
                                                                        cursor: p.type !== 'GAP' ? 'pointer' : 'default'
                                                                    }}
                                                                    onDoubleClick={(e) => {
                                                                        if (isLocked || p.type === 'GAP') return;
                                                                        e.stopPropagation();
                                                                        setAssignmentModalState({ playId: p.id, x: e.clientX, y: e.clientY });
                                                                    }}
                                                                >
                                                                    {p.type !== 'GAP' ? (
                                                                        <>
                                                                            <div style={{ width: '100%', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                                                {showWristband && <WristbandInput play={p} playIndex={idx} />}
                                                                                <div
                                                                                    style={{ cursor: 'pointer', color: '#94a3b8', fontSize: '14px', padding: '2px' }}
                                                                                    onClick={() => handleGridRemove(idx)}
                                                                                >✖</div>
                                                                            </div>
                                                                            <div style={{ flex: 1, fontSize: '0.85rem', fontWeight: 'bold', color: '#1e293b', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                                                                                {p.name}
                                                                            </div>
                                                                            <div style={{ fontSize: '0.65rem', color: '#64748b' }}>{p.formation}</div>
                                                                        </>
                                                                    ) : (
                                                                        <div style={{ color: '#94a3b8', fontSize: '0.75rem' }}>+ Empty</div>
                                                                    )}
                                                                </div>
                                                            );
                                                        })}
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    ) : (
                                        /* Default 2-Column List */
                                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px', height: '100%', overflowY: 'auto' }}>

                                            {/* Left Column */}
                                            <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                                <div style={{ textAlign: 'center', fontWeight: 'bold', fontSize: '0.8rem', background: '#334155', color: 'white', padding: '4px', borderRadius: '4px' }}>LEFT HASH</div>
                                                {leftPlays.map((p, idx) => (
                                                    <div key={idx}
                                                        draggable
                                                        onDragStart={(e) => {
                                                            e.dataTransfer.setData('text/plain', idx); // Global index 0-9
                                                            setDraggedGridIndex(idx);
                                                        }}
                                                        onDragOver={(e) => { e.preventDefault(); }}
                                                        onDrop={(e) => {
                                                            e.preventDefault();
                                                            const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                                                            handleGridMove(fromIdx, idx);
                                                            setDraggedGridIndex(null);
                                                        }}
                                                        style={{
                                                            height: '40px', border: '1px solid #cbd5e1', borderRadius: '4px',
                                                            display: 'flex', alignItems: 'center', padding: '0 4px', gap: '4px',
                                                            background: p.type === 'GAP' ? '#f8fafc' : 'white',
                                                            opacity: draggedGridIndex === idx ? 0.5 : 1,
                                                            cursor: 'pointer'
                                                        }}
                                                        onDoubleClick={(e) => {
                                                            if (isLocked) return;
                                                            e.stopPropagation();
                                                            setAssignmentModalState({ playId: p.id, x: e.clientX, y: e.clientY });
                                                        }}
                                                    >
                                                        {p.type !== 'GAP' && (
                                                            <>
                                                                {showWristband && (
                                                                    <WristbandInput play={p} playIndex={idx} />
                                                                )}
                                                                <div style={{ flex: 1, fontSize: '0.7rem', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap', fontWeight: 'bold', color: '#1e293b' }} title={p.name}>
                                                                    {p.name}
                                                                </div>
                                                                <div
                                                                    style={{ cursor: 'pointer', color: '#94a3b8', fontSize: '10px' }}
                                                                    onClick={() => handleGridRemove(idx)}
                                                                >✖</div>
                                                            </>
                                                        )}
                                                    </div>
                                                ))}
                                            </div>

                                            {/* Right Column */}
                                            <div style={{ display: 'flex', flexDirection: 'column', gap: '4px' }}>
                                                <div style={{ textAlign: 'center', fontWeight: 'bold', fontSize: '0.8rem', background: '#334155', color: 'white', padding: '4px', borderRadius: '4px' }}>RIGHT HASH</div>
                                                {rightPlays.map((p, localIdx) => {
                                                    const globalIdx = localIdx + 10;
                                                    return (
                                                        <div key={globalIdx}
                                                            draggable
                                                            onDragStart={(e) => {
                                                                e.dataTransfer.setData('text/plain', globalIdx);
                                                                setDraggedGridIndex(globalIdx);
                                                            }}
                                                            onDragOver={(e) => { e.preventDefault(); }}
                                                            onDrop={(e) => {
                                                                e.preventDefault();
                                                                const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                                                                handleGridMove(fromIdx, globalIdx);
                                                                setDraggedGridIndex(null);
                                                            }}
                                                            style={{
                                                                height: '40px', border: '1px solid #cbd5e1', borderRadius: '4px',
                                                                display: 'flex', alignItems: 'center', padding: '0 4px', gap: '4px',
                                                                background: p.type === 'GAP' ? '#f8fafc' : 'white',
                                                                opacity: draggedGridIndex === globalIdx ? 0.5 : 1,
                                                                cursor: 'pointer'
                                                            }}
                                                            onDoubleClick={(e) => {
                                                                if (isLocked) return;
                                                                e.stopPropagation();
                                                                setAssignmentModalState({ playId: p.id, x: e.clientX, y: e.clientY });
                                                            }}
                                                        >
                                                            {p.type !== 'GAP' && (
                                                                <>
                                                                    {showWristband && (
                                                                        <WristbandInput play={p} playIndex={globalIdx} />
                                                                    )}
                                                                    <div style={{ flex: 1, fontSize: '0.7rem', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap', fontWeight: 'bold', color: '#1e293b' }} title={p.name}>
                                                                        {p.name}
                                                                    </div>
                                                                    <div
                                                                        style={{ cursor: 'pointer', color: '#94a3b8', fontSize: '10px' }}
                                                                        onClick={() => handleGridRemove(globalIdx)}
                                                                    >✖</div>
                                                                </>
                                                            )}
                                                        </div>
                                                    );
                                                })}
                                            </div>

                                        </div>
                                    )}
                                </div>

                                {/* AVAILABLE PLAYS */}
                                <div style={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
                                    <h4 style={{ marginBottom: '0.5rem' }}>Available Plays</h4>
                                    <div style={{ flex: 1, overflowY: 'auto', display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(130px, 1fr))', gap: '0.5rem', alignContent: 'start', paddingRight: '4px' }}>
                                        {filteredSelectorPlays.map(play => (
                                            <div key={play.id}
                                                style={{ padding: '0.4rem', border: '1px solid var(--border)', borderRadius: '4px', cursor: 'pointer', backgroundColor: 'white', display: 'flex', flexDirection: 'column', boxShadow: '0 1px 2px rgba(0,0,0,0.05)' }}
                                                onClick={() => handleGridAdd(play.id)}
                                            >
                                                <div style={{ fontWeight: 'bold', fontSize: '0.75rem', marginBottom: '2px', lineHeight: '1.2', color: '#1e293b' }}>{play.name}</div>
                                                <div style={{ fontSize: '0.65rem', color: '#64748b', marginBottom: '4px' }}>{play.formation}</div>
                                                {play.image && (
                                                    <div style={{ height: '50px', backgroundColor: '#f8fafc', display: 'flex', justifyContent: 'center', alignItems: 'center', marginBottom: '4px', borderRadius: '2px' }}>
                                                        <img src={play.image} style={{ maxWidth: '100%', maxHeight: '100%', objectFit: 'contain' }} />
                                                    </div>
                                                )}
                                                <button className="btn btn-sm btn-primary" style={{ width: '100%', fontSize: '0.7rem', padding: '2px 0' }}>Add</button>
                                            </div>
                                        ))}
                                        {filteredSelectorPlays.length === 0 && (
                                            <div style={{ gridColumn: '1 / -1', textAlign: 'center', padding: '2rem', color: 'var(--text-secondary)' }}>
                                                No plays match filters.
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            };

            const renderStaples = () => {
                const staplesLayout = gamePlanLayouts.STAPLES || { sections: [] };

                const updateStaplesLayout = (newLayout) => {
                    const newLayouts = { ...gamePlanLayouts, STAPLES: newLayout };
                    if (onUpdateLayouts) onUpdateLayouts(newLayouts);
                };

                const handleAddSection = () => {
                    const newSection = {
                        id: `staple_sec_${Date.now()}`,
                        title: "New Staples Section",
                        columns: ["Column 1", "Column 2", "Column 3"],
                        rows: [
                            { id: `row_${Date.now()}_1`, label: "Row 1", cells: {} },
                            { id: `row_${Date.now()}_2`, label: "Row 2", cells: {} }
                        ]
                    };
                    updateStaplesLayout({ ...staplesLayout, sections: [...staplesLayout.sections, newSection] });
                };

                const handleUpdateSection = (sectionIdx, updatedSection) => {
                    const newSections = [...staplesLayout.sections];
                    newSections[sectionIdx] = updatedSection;
                    updateStaplesLayout({ ...staplesLayout, sections: newSections });
                };

                const handleDeleteSection = (sectionIdx) => {
                    if (!confirm("Are you sure you want to delete this section?")) return;
                    const newSections = [...staplesLayout.sections];
                    newSections.splice(sectionIdx, 1);
                    updateStaplesLayout({ ...staplesLayout, sections: newSections });
                };

                return (
                    <div style={{ padding: '1rem', height: '100%', overflowY: 'auto' }}>
                        <div style={{ marginBottom: '1rem', display: 'flex', justifyContent: 'flex-end' }}>
                            {!isLocked && (
                                <button className="btn btn-primary" onClick={handleAddSection}>
                                    + Add Staples Section
                                </button>
                            )}
                        </div>

                        <div style={{ display: 'flex', flexDirection: 'column', gap: '2rem' }}>
                            {staplesLayout.sections.map((section, sIdx) => (
                                <StapleSection
                                    key={section.id}
                                    section={section}
                                    index={sIdx}
                                    isLocked={isLocked}
                                    onUpdate={(updated) => handleUpdateSection(sIdx, updated)}
                                    onDelete={() => handleDeleteSection(sIdx)}
                                    plays={plays}
                                />
                            ))}
                        </div>

                        {staplesLayout.sections.length === 0 && (
                            <div style={{ textAlign: 'center', padding: '4rem', color: '#94a3b8', border: '2px dashed #e2e8f0', borderRadius: '8px' }}>
                                <h3>No Staples Sections Yet</h3>
                                <p>Click the button above to create a customizable grid for your staple plays.</p>
                            </div>
                        )}
                    </div>
                );
            };

            const StapleSection = ({ section, index, isLocked, onUpdate, onDelete, plays }) => {
                const [isEditingLayout, setIsEditingLayout] = useState(false);

                const handleTitleChange = (e) => onUpdate({ ...section, title: e.target.value });

                const handleAddColumn = () => {
                    onUpdate({ ...section, columns: [...section.columns, "New Col"] });
                };
                const handleRemoveColumn = (colIdx) => {
                    const newCols = [...section.columns];
                    newCols.splice(colIdx, 1);
                    // Cleanup cells data
                    const newRows = section.rows.map(row => {
                        const newCells = {};
                        Object.keys(row.cells).forEach(key => {
                            const k = parseInt(key);
                            if (k < colIdx) newCells[k] = row.cells[k];
                            else if (k > colIdx) newCells[k - 1] = row.cells[k];
                        });
                        return { ...row, cells: newCells };
                    });
                    onUpdate({ ...section, columns: newCols, rows: newRows });
                };
                const handleColNameChange = (colIdx, val) => {
                    const newCols = [...section.columns];
                    newCols[colIdx] = val;
                    onUpdate({ ...section, columns: newCols });
                };

                const handleAddRow = () => {
                    onUpdate({
                        ...section,
                        rows: [...section.rows, { id: `row_${Date.now()}`, label: "New Row", cells: {} }]
                    });
                };
                const handleRemoveRow = (rowIdx) => {
                    const newRows = [...section.rows];
                    newRows.splice(rowIdx, 1);
                    onUpdate({ ...section, rows: newRows });
                };
                const handleRowLabelChange = (rowIdx, val) => {
                    const newRows = [...section.rows];
                    newRows[rowIdx] = { ...newRows[rowIdx], label: val };
                    onUpdate({ ...section, rows: newRows });
                };

                const handleDrop = (e, rowIdx, colIdx) => {
                    e.preventDefault();
                    if (isLocked) return;
                    try {
                        const data = JSON.parse(e.dataTransfer.getData('application/react-dnd'));
                        if (data && data.playId) {
                            const newRows = [...section.rows];
                            const currentCells = { ...(newRows[rowIdx].cells || {}) };
                            newRows[rowIdx] = {
                                ...newRows[rowIdx],
                                cells: { ...currentCells, [colIdx]: data.playId }
                            };
                            onUpdate({ ...section, rows: newRows });
                        }
                    } catch (e) { }
                };

                const handleClearCell = (rowIdx, colIdx) => {
                    const newRows = [...section.rows];
                    const currentCells = { ...newRows[rowIdx].cells };
                    delete currentCells[colIdx];
                    newRows[rowIdx] = { ...newRows[rowIdx], cells: currentCells };
                    onUpdate({ ...section, rows: newRows });
                };

                return (
                    <div style={{ background: 'white', border: '1px solid #e2e8f0', borderRadius: '8px', overflow: 'hidden' }}>
                        {/* Header */}
                        <div style={{ padding: '0.75rem 1rem', background: '#f1f5f9', borderBottom: '1px solid #e2e8f0', display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                            {isEditingLayout ? (
                                <input
                                    value={section.title}
                                    onChange={handleTitleChange}
                                    style={{ fontSize: '1.1rem', fontWeight: 'bold', border: '1px solid #cbd5e1', padding: '4px', borderRadius: '4px' }}
                                />
                            ) : (
                                <h3 style={{ margin: 0, fontSize: '1.2rem', color: '#334155' }}>{section.title}</h3>
                            )}

                            {!isLocked && (
                                <div style={{ display: 'flex', gap: '8px' }}>
                                    <button
                                        className={`btn-sm ${isEditingLayout ? 'btn-primary' : 'btn-secondary'}`}
                                        onClick={() => setIsEditingLayout(!isEditingLayout)}
                                    >
                                        {isEditingLayout ? 'Done Editing' : 'Edit Layout'}
                                    </button>
                                    <button className="btn-sm" style={{ color: '#ef4444' }} onClick={onDelete}>
                                        <Icon name="Trash2" size={16} />
                                    </button>
                                </div>
                            )}
                        </div>

                        {/* Grid Content */}
                        <div style={{ padding: '1rem', overflowX: 'auto' }}>
                            <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                                <thead>
                                    <tr>
                                        <th style={{ width: '150px', padding: '8px', textAlign: 'left', borderBottom: '2px solid #e2e8f0', color: '#64748b', fontSize: '0.8rem' }}>
                                            {isEditingLayout ? "ROW LABELS" : ""}
                                        </th>
                                        {section.columns.map((col, cIdx) => (
                                            <th key={cIdx} style={{ padding: '8px', minWidth: '120px', textAlign: 'center', borderBottom: '2px solid #e2e8f0' }}>
                                                {isEditingLayout ? (
                                                    <div style={{ display: 'flex', gap: '4px', alignItems: 'center', justifyContent: 'center' }}>
                                                        <input
                                                            value={col}
                                                            onChange={(e) => handleColNameChange(cIdx, e.target.value)}
                                                            style={{ width: '100%', fontSize: '0.8rem', textAlign: 'center', padding: '2px' }}
                                                        />
                                                        <div style={{ cursor: 'pointer', color: '#ef4444' }} onClick={() => handleRemoveColumn(cIdx)}>×</div>
                                                    </div>
                                                ) : (
                                                    <div style={{ fontSize: '0.8rem', fontWeight: 'bold', color: '#475569', textTransform: 'uppercase' }}>{col}</div>
                                                )}
                                            </th>
                                        ))}
                                        {isEditingLayout && (
                                            <th style={{ width: '40px', padding: '8px', borderBottom: '2px solid #e2e8f0' }}>
                                                <button className="btn-sm" style={{ fontSize: '1.2rem', padding: '0 6px' }} onClick={handleAddColumn}>+</button>
                                            </th>
                                        )}
                                    </tr>
                                </thead>
                                <tbody>
                                    {section.rows.map((row, rIdx) => (
                                        <tr key={row.id}>
                                            <td style={{ padding: '8px', borderBottom: '1px solid #f1f5f9', fontWeight: 'bold', color: '#475569', fontSize: '0.9rem' }}>
                                                {isEditingLayout ? (
                                                    <div style={{ display: 'flex', gap: '4px', alignItems: 'center' }}>
                                                        <div style={{ cursor: 'pointer', color: '#ef4444' }} onClick={() => handleRemoveRow(rIdx)}>×</div>
                                                        <input
                                                            value={row.label}
                                                            onChange={(e) => handleRowLabelChange(rIdx, e.target.value)}
                                                            style={{ width: '100%', fontSize: '0.9rem', padding: '2px' }}
                                                        />
                                                    </div>
                                                ) : (
                                                    row.label
                                                )}
                                            </td>
                                            {section.columns.map((col, cIdx) => {
                                                const playId = row.cells ? row.cells[cIdx] : null;
                                                const play = playId ? plays.find(p => p.id === playId) : null;
                                                return (
                                                    <td
                                                        key={cIdx}
                                                        style={{ padding: '4px', borderBottom: '1px solid #f1f5f9', borderLeft: '1px solid #f1f5f9', textAlign: 'center' }}
                                                        onDragOver={e => e.preventDefault()}
                                                        onDrop={e => handleDrop(e, rIdx, cIdx)}
                                                    >
                                                        {play ? (
                                                            <div style={{
                                                                background: '#f0f9ff', border: '1px solid #bae6fd', borderRadius: '4px',
                                                                padding: '4px', fontSize: '0.8rem', position: 'relative',
                                                                display: 'flex', alignItems: 'center', justifyContent: 'center',
                                                                cursor: 'pointer'
                                                            }}
                                                                onDoubleClick={(e) => {
                                                                    if (isLocked) return;
                                                                    e.stopPropagation();
                                                                    setAssignmentModalState({ playId: play.id, x: e.clientX, y: e.clientY });
                                                                }}
                                                            >
                                                                <div style={{ overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{getPlayDisplayName(play)}</div>
                                                                {!isLocked && (
                                                                    <div
                                                                        onClick={() => handleClearCell(rIdx, cIdx)}
                                                                        style={{ position: 'absolute', right: '-4px', top: '-4px', background: '#ef4444', color: 'white', borderRadius: '50%', width: '14px', height: '14px', fontSize: '0.6rem', display: 'flex', alignItems: 'center', justifyContent: 'center', cursor: 'pointer' }}
                                                                    >×</div>
                                                                )}
                                                            </div>
                                                        ) : (
                                                            <div style={{ height: '32px', background: '#fafafa', borderRadius: '4px', border: '1px dashed #e2e8f0' }}></div>
                                                        )}
                                                    </td>
                                                );
                                            })}
                                            {isEditingLayout && <td style={{ borderBottom: '1px solid #f1f5f9' }}></td>}
                                        </tr>
                                    ))}
                                    {isEditingLayout && (
                                        <tr>
                                            <td style={{ padding: '8px' }}>
                                                <button className="btn-sm" onClick={handleAddRow}>+ Add Row</button>
                                            </td>
                                            <td colSpan={section.columns.length + 1}></td>
                                        </tr>
                                    )}
                                </tbody>
                            </table>
                        </div>
                    </div>
                );
            };


            const renderPriorityPlays = () => {
                // Use playCategories (Play Buckets) directly as the categories
                const CATEGORIES = (playCategories && playCategories.length > 0) ? playCategories : DEFAULT_PLAY_CATEGORIES;

                const priorityCategories = gamePlan?.priorityCategories || {};

                // Determine assigned IDs to filter Inbox
                const getAllAssignedIds = () => Object.values(priorityCategories).flat();
                const assignedIds = new Set(getAllAssignedIds());

                // Get all plays that are in the game plan (from any source: matrix, FZDND, scripts)
                const getAllGamePlanPlayIds = () => {
                    const playIds = new Set();

                    // Collect from all sets (includes matrix cells, FZDND, and script sections)
                    if (gamePlan?.sets && Array.isArray(gamePlan.sets)) {
                        gamePlan.sets.forEach(set => {
                            if (set.playIds && Array.isArray(set.playIds)) {
                                set.playIds.forEach(item => {
                                    const id = typeof item === 'string' ? item : item?.id;
                                    if (id && id !== 'GAP' && !id.startsWith('NOTE:')) {
                                        playIds.add(id);
                                    }
                                });
                            }
                        });
                    }

                    // Collect from mini scripts
                    if (gamePlan?.miniScripts && Array.isArray(gamePlan.miniScripts)) {
                        gamePlan.miniScripts.forEach(script => {
                            if (script.playIds && Array.isArray(script.playIds)) {
                                script.playIds.forEach(item => {
                                    const id = typeof item === 'string' ? item : item?.id;
                                    if (id && id !== 'GAP' && !id.startsWith('NOTE:')) {
                                        playIds.add(id);
                                    }
                                });
                            }
                        });
                    }

                    return playIds;
                };

                const gamePlanPlayIds = getAllGamePlanPlayIds();

                // Plays that are in the game plan but not yet assigned to a priority category
                const unassignedPriorityPlays = plays.filter(p => gamePlanPlayIds.has(p.id) && !assignedIds.has(p.id));

                const updateCategories = (newCategories) => {
                    if (onUpdateGamePlan) {
                        onUpdateGamePlan({ ...gamePlan, priorityCategories: newCategories });
                    }
                };



                // Handle changes for a specific category
                const handleCategoryListChange = (newItems, catId) => {
                    const newIds = newItems.map(p => p.id);
                    const newCats = { ...priorityCategories };

                    // 1. Update this category
                    newCats[catId] = newIds;

                    // 2. Remove these IDs from ALL other categories to prevent duplicates
                    const idsInThisCategory = new Set(newIds);
                    Object.keys(newCats).forEach(k => {
                        if (k !== catId && newCats[k]) {
                            newCats[k] = newCats[k].filter(id => !idsInThisCategory.has(id));
                        }
                    });

                    // 3. Update playCategory on plays that were moved (using playCategory instead of bucketId)
                    newItems.forEach(play => {
                        if (play.playCategory !== catId && onUpdatePlay) {
                            onUpdatePlay(play.id, { playCategory: catId });
                        }
                    });

                    updateCategories(newCats);
                };

                // Handle changes for Inbox
                const handleInboxListChange = (newItems) => {
                    // Logic: If item is in Inbox, it must NOT be in any category.
                    const inboxIds = new Set(newItems.map(p => p.id));

                    const newCats = { ...priorityCategories };
                    let changed = false;

                    Object.keys(newCats).forEach(k => {
                        if (newCats[k]) {
                            const originalLen = newCats[k].length;
                            newCats[k] = newCats[k].filter(id => !inboxIds.has(id));
                            if (newCats[k].length !== originalLen) changed = true;
                        }
                    });

                    // Clear playCategory for plays moved to inbox
                    newItems.forEach(play => {
                        if (play.playCategory && onUpdatePlay) {
                            onUpdatePlay(play.id, { playCategory: null });
                        }
                    });

                    // If items were moved TO inbox (from category), 'changed' will be true.
                    // If items were reordered in Inbox, 'changed' is false, and we do nothing (Inbox has no order).
                    // If item removed from Inbox (to Category), that event handles itself via handleCategoryListChange.

                    if (changed) {
                        updateCategories(newCats);
                    }
                };

                // Helper to remove from category directly via X button (if we add it back)
                const handleRemoveFromCategory = (catId, playId) => {
                    if (isLocked) return;
                    const newCats = { ...priorityCategories };
                    if (newCats[catId]) {
                        newCats[catId] = newCats[catId].filter(id => id !== playId);
                        updateCategories(newCats);
                    }
                };

                const handleUnstar = (playId) => {
                    if (isLocked) return;
                    if (onUpdatePlay) onUpdatePlay(playId, { priority: false });
                    // Cleanup from categories
                    const newCats = { ...priorityCategories };
                    let changed = false;
                    Object.keys(newCats).forEach(k => {
                        if (newCats[k] && newCats[k].includes(playId)) {
                            newCats[k] = newCats[k].filter(id => id !== playId);
                            changed = true;
                        }
                    });
                    if (changed) updateCategories(newCats);
                };

                return (
                    <div style={{ display: 'flex', height: '100%', gap: '1rem' }}>
                        {/* LEFT: Play Bucket Boxes (flat grid) */}
                        <div style={{ flex: 3, display: 'flex', flexDirection: 'column', gap: '1rem', overflowY: 'auto', paddingRight: '0.5rem', paddingBottom: '20px' }}>
                            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(280px, 1fr))', gap: '1rem' }}>
                                {CATEGORIES.map(bucket => {
                                    const playIds = priorityCategories[bucket.id] || [];
                                    const listItems = playIds.map(id => plays.find(p => p.id === id)).filter(p => p && p.priority);

                                    return (
                                        <div
                                            key={bucket.id}
                                            className="card"
                                            style={{ display: 'flex', flexDirection: 'column', background: 'var(--bg-panel)', border: '1px solid var(--border)', minHeight: '200px' }}
                                        >
                                            <h4 style={{ margin: '0 0 0.5rem 0', paddingBottom: '0.5rem', borderBottom: '1px solid var(--border)', color: 'var(--text-main)', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                <span style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                    {bucket.color && (
                                                        <span style={{ width: '12px', height: '12px', borderRadius: '50%', background: bucket.color, flexShrink: 0 }}></span>
                                                    )}
                                                    {bucket.label}
                                                </span>
                                                <span className="badge">{playIds.length}</span>
                                            </h4>
                                            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', overflowY: 'auto' }}>
                                                <PrioritySortableColumn
                                                    items={listItems}
                                                    onListChange={(newItems) => handleCategoryListChange(newItems, bucket.id)}
                                                    style={{ minHeight: '100px', display: 'flex', flexDirection: 'column', gap: '0' }}
                                                    isLocked={isLocked}
                                                    onItemDoubleClick={(play, e) => setAssignmentModalState({ playId: play.id, x: e.clientX, y: e.clientY })}
                                                />
                                                {listItems.length === 0 && (
                                                    <div style={{ fontStyle: 'italic', opacity: 0.5, fontSize: '0.8rem', padding: '0.5rem', textAlign: 'center', pointerEvents: 'none' }}>
                                                        Drop plays here
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>

                        {/* RIGHT: Inbox (Unassigned) */}
                        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', background: 'var(--bg-panel)', border: '1px solid var(--border)', borderRadius: '8px', overflow: 'hidden' }}>
                            <div style={{ padding: '0.75rem', background: '#eff6ff', borderBottom: '1px solid var(--border)' }}>
                                <h4 style={{ margin: 0, color: '#1d4ed8', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                    <Icon name="Star" size={16} color="#eab308" style={{ fill: '#eab308' }} />
                                    Unassigned/Non-Priority Plays
                                </h4>
                            </div>
                            <div style={{ flex: 1, overflowY: 'auto', padding: '0', display: 'flex', flexDirection: 'column' }}>
                                {/* Inbox is also a Sortable to allow two-way dragging */}
                                <PrioritySortableColumn
                                    items={unassignedPriorityPlays}
                                    onListChange={handleInboxListChange}
                                    style={{ minHeight: '200px', padding: '0.5rem', display: 'flex', flexDirection: 'column', gap: '0.5rem' }}
                                    isLocked={isLocked}
                                    onItemDoubleClick={(play, e) => setAssignmentModalState({ playId: play.id, x: e.clientX, y: e.clientY })}
                                />
                                {unassignedPriorityPlays.length === 0 && (
                                    <div style={{ padding: '2rem', textAlign: 'center', opacity: 0.5, fontStyle: 'italic', fontSize: '0.9rem' }}>
                                        No plays in game plan yet. <br />Add plays via Strike 'Em Out, FZDND, or Situations & Scripts.
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                );
            };

            return (
                <div className="game-plan-container" style={{ display: 'flex', flexDirection: 'column', height: 'calc(100vh - 100px)', gap: '1rem' }}>

                    <style media="print">{`
                        @media print {
                            @page {
                                size: ${viewMode === 'sheet' ? 'landscape' : 'portrait'};
                                margin: 0.25in;
                            }
                            body { 
                                margin: 0; 
                                padding: 0; 
                                -webkit-print-color-adjust: exact !important; 
                                print-color-adjust: exact !important; 
                            }
                            .sidebar, .app-sidebar, header, nav, .app-toolbar, .no-print { 
                                display: none !important; 
                            }
                            /* OVERRIDE AGGRESSIVE HIDING */
                            .main-content > * { display: block !important; }
                            .main-content > *:not(.wristband-print-container) { display: block !important; }
                            
                            .game-plan-container, .game-plan-content {
                                display: block !important; /* Kill Flexbox for print */
                                width: 100% !important;
                                height: auto !important;
                                margin: 0 !important;
                                padding: 0 !important;
                                overflow: visible !important;
                                border: none !important;
                            }
                            ${viewMode === 'sheet' ? `
                                .game-plan-content {
                                    zoom: 0.75;
                                }
                            ` : ''}
                        }
                    `}</style>
                    {/* Toolbar */}
                    <div className="app-toolbar no-print" style={{ display: 'flex', justifyContent: 'space-between', gap: '1rem', borderBottom: '1px solid var(--border)', paddingBottom: '1rem', alignItems: 'center' }}>
                        <div style={{ display: 'flex', gap: '1rem', alignItems: 'center' }}>
                            <button
                                className="btn"
                                onClick={handleClearGamePlan}
                                title="Clear Game Plan"
                                style={{ height: '52px', width: '52px', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', textAlign: 'center', background: 'white', border: '1px solid #cbd5e1', color: '#ef4444' }}
                            >
                                <Icon name="Trash" size={16} />
                                <span style={{ fontSize: '0.7rem', marginTop: '4px' }}>CLR</span>
                            </button>
                            <button
                                className="btn"
                                onClick={() => setShowImportModal(true)}
                                style={{ height: '52px', width: '80px', display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', textAlign: 'center', lineHeight: '1.2', background: 'white', border: '1px solid #cbd5e1', color: '#64748b' }}
                            >
                                <Icon name="Download" size={16} />
                                <span style={{ fontSize: '0.7rem', marginTop: '4px' }}>IMPORT</span>
                            </button>
                            <button className={`btn ${viewMode === 'matrix' ? 'btn-primary' : 'btn-secondary'}`} onClick={() => setViewMode('matrix')} style={{ height: '52px', width: '110px', display: 'flex', alignItems: 'center', justifyContent: 'center', textAlign: 'center', lineHeight: '1.2', fontSize: '0.75rem' }}>
                                STRIKE 'EM OUT
                            </button>
                            <button className={`btn ${viewMode === 'sheet' ? 'btn-primary' : 'btn-secondary'}`} onClick={() => setViewMode('sheet')} style={{ height: '52px', width: '110px', display: 'flex', alignItems: 'center', justifyContent: 'center', textAlign: 'center', lineHeight: '1.2', fontSize: '0.75rem' }}>
                                SITUATIONS & SCRIPTS
                            </button>
                            <button className={`btn ${viewMode === 'fzdnd' ? 'btn-primary' : 'btn-secondary'}`} onClick={() => setViewMode('fzdnd')} style={{ height: '52px', width: '80px', display: 'flex', alignItems: 'center', justifyContent: 'center', textAlign: 'center', lineHeight: '1.2', fontSize: '0.75rem' }}>
                                FZDnD
                            </button>
                            <button className={`btn ${viewMode === 'priority' ? 'btn-primary' : 'btn-secondary'}`} onClick={() => setViewMode('priority')} style={{ height: '52px', width: '110px', display: 'flex', alignItems: 'center', justifyContent: 'center', textAlign: 'center', lineHeight: '1.2', fontSize: '0.75rem' }}>
                                PRIORITY PLAYS
                            </button>
                            <button className={`btn ${viewMode === 'staples' ? 'btn-primary' : 'btn-secondary'}`} onClick={() => setViewMode('staples')} style={{ height: '52px', width: '90px', display: 'flex', alignItems: 'center', justifyContent: 'center', textAlign: 'center', lineHeight: '1.2', fontSize: '0.75rem' }}>
                                STAPLES
                            </button>
                            <button className={`btn ${viewMode === 'player-touches' ? 'btn-primary' : 'btn-secondary'}`} onClick={() => setViewMode('player-touches')} style={{ height: '52px', width: '110px', display: 'flex', alignItems: 'center', justifyContent: 'center', textAlign: 'center', lineHeight: '1.2', fontSize: '0.75rem' }}>
                                PLAYER TOUCHES
                            </button>
                            <button className="btn btn-secondary" onClick={() => {
                                // Map current viewMode to print preview tab
                                const tabMap = { 'sheet': 'sheet', 'matrix': 'matrix', 'fzdnd': 'fzdnd', 'priority': 'priority', 'staples': 'staples', 'player-touches': 'player-touches' };
                                setPrintPreviewTab(tabMap[viewMode] || 'sheet');
                                setShowPrintPreview(true);
                            }} style={{ border: '2px solid var(--accent)', height: '52px', width: '110px', display: 'flex', alignItems: 'center', justifyContent: 'center', textAlign: 'center', lineHeight: '1.2', fontSize: '0.75rem' }}>
                                <Icon name="Printer" size={16} style={{ marginBottom: '4px' }} /> PRINT
                            </button>
                        </div>

                        {/* Game Plan Statistics Ticker */}
                        {/* Ticker temporarily removed */}
                    </div>

                    {/* View Content */}
                    <div style={{ flex: 1, display: 'flex', overflow: 'hidden', gap: '1rem' }}>
                        <div className="game-plan-content" style={{ flex: 1, overflow: 'hidden', background: ['priority', 'staples'].includes(viewMode) ? 'transparent' : 'white', padding: ['priority', 'staples'].includes(viewMode) ? '0' : '1rem', borderRadius: '8px', display: 'flex', flexDirection: 'column' }}>
                            {viewMode === 'call-sheet' && renderCallSheet()}
                            {viewMode === 'sheet' && renderSheetView()}
                            {viewMode === 'fzdnd' && renderFZDnDView()}
                            {viewMode === 'matrix' && renderMatrix()}
                            {viewMode === 'player-touches' && renderPlayerTouches()}
                            {viewMode === 'priority' && renderPriorityPlays()}
                            {viewMode === 'staples' && renderStaples()}
                        </div>
                    </div>

                    {/* Play Selector Modal */}
                    {renderPlaySelector()}
                    {renderSectionConfigurationModal()}
                    {renderBoxEditorModal()}
                    {/* Standardized Play Details Modal */}
                    {assignmentModalState && (() => {
                        const { playId } = assignmentModalState;
                        const play = plays.find(p => p.id === playId);
                        if (!play) return null;
                        const assignedSits = getPlaySituations(playId);
                        const assignedIds = new Set(assignedSits.map(s => s.id));
                        return (
                            <PlayDetailsModal
                                playId={playId}
                                plays={plays}
                                gamePlanLayouts={gamePlanLayouts}
                                assignedIds={assignedIds}
                                onUpdatePlay={onUpdatePlay}
                                onAssignSituation={handleAssignPlayToSituation}
                                playBuckets={playBuckets}
                                playCategories={playCategories}
                                currentWeek={currentWeek}
                                onClose={() => setAssignmentModalState(null)}
                            />
                        );
                    })()}

                    {/* Import Modal */}
                    {showImportModal && (
                        <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 10000 }}>
                            <div className="card" style={{ width: '400px', padding: '1.5rem', background: 'white' }}>
                                <h3 style={{ color: '#1e293b', marginBottom: '0.5rem' }}>Import Game Plan</h3>
                                <p style={{ color: '#475569', marginBottom: '1rem' }}>Select a week to copy Game Plan & Call Sheet from. <strong style={{ color: '#dc2626' }}>This will overwrite current data.</strong></p>
                                <select
                                    className="form-select"
                                    value={importSourceWeekId}
                                    onChange={e => setImportSourceWeekId(e.target.value)}
                                    style={{ marginBottom: '1rem', width: '100%' }}
                                >
                                    <option value="">Select Week...</option>
                                    {weeks.filter(w => w.id !== currentWeek.id).map(w => (
                                        <option key={w.id} value={w.id}>{w.name}</option>
                                    ))}
                                </select>
                                <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '8px' }}>
                                    <button className="btn" onClick={() => setShowImportModal(false)}>Cancel</button>
                                    <button className="btn btn-primary" onClick={handleImportGamePlan} disabled={!importSourceWeekId}>Import</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Print Preview Modal */}
                    {showPrintPreview && ReactDOM.createPortal(
                        <div className="print-preview-modal-wrapper print-only-portal" style={{
                            position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
                            background: 'white', zIndex: 9999,
                            display: 'flex', flexDirection: 'column'
                        }}>
                            {/* Header with tab selector and controls */}
                            <div className="print-preview-header" style={{
                                background: '#1e293b', // darker background
                                padding: '1rem',
                                borderBottom: '1px solid #334155',
                                display: 'flex',
                                flexDirection: 'row',
                                justifyContent: 'space-between',
                                alignItems: 'center',
                                gap: '1rem',
                                flexWrap: 'wrap'
                            }}>
                                {/* Left: Navigation Tabs */}
                                <div style={{
                                    display: 'flex',
                                    gap: '0.25rem',
                                    overflowX: 'auto',
                                    paddingBottom: '4px',
                                    flex: 1,
                                    minWidth: 0 // Allow shrinking
                                }}>
                                    {[
                                        { id: 'staples', label: 'STAPLES' },
                                        { id: 'priority', label: 'PRIORITY PLAYS' },
                                        { id: 'sheet', label: 'SITUATIONS & SCRIPTS' },
                                        { id: 'matrix', label: "STRIKE 'EM OUT" },
                                        { id: 'fzdnd', label: 'FZDnD' },
                                        { id: 'player-touches', label: 'PLAYER TOUCHES' }
                                    ].map(tab => (
                                        <button
                                            key={tab.id}
                                            className={`btn`}
                                            onClick={() => setPrintPreviewTab(tab.id)}
                                            style={{
                                                fontSize: '0.85rem',
                                                padding: '0.5rem 1rem',
                                                borderRadius: '6px',
                                                border: '1px solid',
                                                borderColor: printPreviewTab === tab.id ? 'rgba(255,255,255,0.2)' : 'transparent',
                                                background: printPreviewTab === tab.id ? 'var(--primary)' : 'transparent',
                                                color: printPreviewTab === tab.id ? 'white' : '#94a3b8',
                                                fontWeight: printPreviewTab === tab.id ? '600' : '500',
                                                whiteSpace: 'nowrap',
                                                cursor: 'pointer',
                                                transition: 'all 0.2s ease'
                                            }}
                                        >
                                            {tab.label}
                                        </button>
                                    ))}
                                </div>

                                {/* Right: Controls (Scale, Print, Close) */}
                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.75rem', flexShrink: 0 }}>
                                    {/* Scale Dropdown */}
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', background: 'var(--surface)', padding: '0.25rem 0.75rem', borderRadius: '6px' }}>
                                        <label style={{ color: '#94a3b8', fontSize: '0.8rem', fontWeight: 500 }}>Scale:</label>
                                        <select
                                            value={printScale}
                                            onChange={(e) => setPrintScale(Number(e.target.value))}
                                            style={{
                                                background: 'transparent',
                                                color: 'white',
                                                border: 'none',
                                                fontSize: '0.9rem',
                                                cursor: 'pointer',
                                                outline: 'none',
                                                padding: '0.25rem'
                                            }}
                                        >
                                            <option value={0.5}>50%</option>
                                            <option value={0.75}>75%</option>
                                            <option value={0.85}>85%</option>
                                            <option value={1}>100%</option>
                                        </select>
                                    </div>

                                    {/* Orientation Toggle */}
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '0.25rem', background: 'var(--surface)', padding: '0.25rem', borderRadius: '6px' }}>
                                        <button
                                            onClick={() => setPrintOrientation('portrait')}
                                            style={{
                                                background: printOrientation === 'portrait' ? 'var(--primary)' : 'transparent',
                                                color: printOrientation === 'portrait' ? 'white' : '#94a3b8',
                                                border: 'none',
                                                padding: '0.35rem 0.6rem',
                                                borderRadius: '4px',
                                                cursor: 'pointer',
                                                fontSize: '0.75rem',
                                                fontWeight: 600,
                                                display: 'flex',
                                                alignItems: 'center',
                                                gap: '4px'
                                            }}
                                            title="Portrait orientation"
                                        >
                                            <span style={{ transform: 'rotate(0deg)', display: 'inline-block' }}>▯</span> Portrait
                                        </button>
                                        <button
                                            onClick={() => setPrintOrientation('landscape')}
                                            style={{
                                                background: printOrientation === 'landscape' ? 'var(--primary)' : 'transparent',
                                                color: printOrientation === 'landscape' ? 'white' : '#94a3b8',
                                                border: 'none',
                                                padding: '0.35rem 0.6rem',
                                                borderRadius: '4px',
                                                cursor: 'pointer',
                                                fontSize: '0.75rem',
                                                fontWeight: 600,
                                                display: 'flex',
                                                alignItems: 'center',
                                                gap: '4px'
                                            }}
                                            title="Landscape orientation"
                                        >
                                            <span style={{ transform: 'rotate(90deg)', display: 'inline-block' }}>▯</span> Landscape
                                        </button>
                                    </div>

                                    {/* Print Button */}
                                    <button
                                        className="btn btn-primary"
                                        onClick={() => {
                                            // Inject orientation CSS before printing
                                            const styleId = 'print-orientation-style';
                                            let styleEl = document.getElementById(styleId);
                                            if (!styleEl) {
                                                styleEl = document.createElement('style');
                                                styleEl.id = styleId;
                                                document.head.appendChild(styleEl);
                                            }
                                            styleEl.textContent = `@page { size: ${printOrientation === 'landscape' ? 'landscape' : 'portrait'}; margin: 0.4in; } @media print { .print-preview-content > div { width: 100% !important; min-height: auto !important; } }`;
                                            // Small delay to ensure CSS is applied
                                            setTimeout(() => window.print(), 50);
                                        }}
                                        style={{
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '0.5rem',
                                            padding: '0.5rem 1rem',
                                            boxShadow: '0 2px 4px rgba(0,0,0,0.2)'
                                        }}
                                        title={`Print in ${printOrientation} mode (confirm in print dialog)`}
                                    >
                                        <Icon name="Printer" size={16} />
                                        <span>PRINT ({printOrientation.charAt(0).toUpperCase() + printOrientation.slice(1)})</span>
                                    </button>

                                    {/* Close Button */}
                                    <button
                                        className="btn btn-secondary"
                                        onClick={() => setShowPrintPreview(false)}
                                        style={{
                                            width: '32px',
                                            height: '32px',
                                            padding: 0,
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            borderRadius: '50%',
                                            background: 'var(--surface)',
                                            color: 'white',
                                            border: 'none'
                                        }}
                                    >
                                        <Icon name="X" size={18} />
                                    </button>
                                </div>
                            </div>


                            {/* Print content area */}
                            <div className={`print-preview-content ${printOrientation === 'landscape' ? 'print-landscape' : 'print-portrait'}`} style={{
                                flex: 1,
                                overflow: 'auto',
                                background: '#e5e7eb',
                                padding: '1rem',
                                display: 'flex',
                                justifyContent: 'center'
                            }}>
                                <div style={{
                                    zoom: printScale,
                                    transformOrigin: 'top center',
                                    background: 'white',
                                    boxShadow: '0 4px 20px rgba(0,0,0,0.15)',
                                    padding: '0.5in',
                                    width: printOrientation === 'landscape' ? '11in' : '8.5in',
                                    minHeight: printOrientation === 'landscape' ? '8.5in' : '11in'
                                }}>
                                    {printPreviewTab === 'staples' && renderStaples()}
                                    {printPreviewTab === 'priority' && renderPriorityPlays()}
                                    {printPreviewTab === 'sheet' && renderSheetView(true)}
                                    {printPreviewTab === 'matrix' && renderMatrix()}
                                    {printPreviewTab === 'fzdnd' && renderFZDnDView()}
                                    {printPreviewTab === 'player-touches' && renderPlayerTouches()}
                                </div>
                            </div>
                        </div>,
                        document.body
                    )}

                </div >
            );
        };



        // REMOVED FEATURES (available in git history):
        // - JerseyLottery (~267 lines)  
        // - EquipmentManager (~616 lines)
        // To restore: check git history before this commit

        // --- RBAC CONSTANTS & HELPERS ---
        // --- RBAC CONSTANTS & HELPERS ---
        const ROLES = [
            'Head Coach',
            'Assistant',
            'Student Manager',
            'Trainer',
            'Stats',
            'Player'
        ];

        const FEATURES = [
            { id: 'dashboard', label: 'Dashboard', fullLabel: 'Program Dashboard' },
            { id: 'playbook', label: 'Playbook', fullLabel: 'Master Playbook' },
            { id: 'callsheet', label: 'Game Plan', fullLabel: 'Call Sheet & Game Planning' },
            { id: 'install', label: 'Install', fullLabel: 'Install Schedule' },
            { id: 'scripts', label: 'Scripts', fullLabel: 'Practice Scripts' },
            { id: 'depth', label: 'Depth', fullLabel: 'Depth Charts' },
            { id: 'recruiting', label: 'Recruiting', fullLabel: 'Recruiting Board' },
            { id: 'staff', label: 'Staff', fullLabel: 'Staff Management' },
            { id: 'settings', label: 'Settings', fullLabel: 'Settings & Config' }
        ];

        const DEFAULT_PERMISSIONS = {
            'Head Coach': {
                dashboard: { view: true, edit: true },
                playbook: { view: true, edit: true },
                callsheet: { view: true, edit: true },
                install: { view: true, edit: true },
                scripts: { view: true, edit: true },
                depth: { view: true, edit: true },
                recruiting: { view: true, edit: true },
                staff: { view: true, edit: true },
                settings: { view: true, edit: true }
            },
            'Assistant': {
                dashboard: { view: true, edit: true },
                playbook: { view: true, edit: true },
                callsheet: { view: true, edit: true },
                install: { view: true, edit: true },
                scripts: { view: true, edit: true },
                depth: { view: true, edit: true },
                recruiting: { view: true, edit: true },
                staff: { view: true, edit: false },
                settings: { view: false, edit: false }
            },
            'Student Manager': {
                dashboard: { view: true, edit: false },
                playbook: { view: false, edit: false },
                callsheet: { view: false, edit: false },
                install: { view: true, edit: false },
                scripts: { view: true, edit: true }, // Help with logistics
                depth: { view: true, edit: false },
                recruiting: { view: false, edit: false },
                staff: { view: false, edit: false },
                settings: { view: false, edit: false }
            },
            'Trainer': {
                dashboard: { view: true, edit: true }, // Update injuries
                playbook: { view: false, edit: false },
                callsheet: { view: false, edit: false },
                install: { view: false, edit: false },
                scripts: { view: false, edit: false },
                depth: { view: true, edit: false },
                recruiting: { view: false, edit: false },
                staff: { view: true, edit: false }, // View contact info
                settings: { view: false, edit: false }
            },
            'Stats': {
                dashboard: { view: true, edit: false },
                playbook: { view: true, edit: false },
                callsheet: { view: true, edit: false },
                install: { view: false, edit: false },
                scripts: { view: true, edit: false },
                depth: { view: true, edit: false },
                recruiting: { view: false, edit: false },
                staff: { view: false, edit: false },
                settings: { view: false, edit: false }
            },
            'Player': {
                dashboard: { view: true, edit: false },
                playbook: { view: true, edit: false },
                callsheet: { view: false, edit: false },
                install: { view: true, edit: false },
                scripts: { view: false, edit: false },
                depth: { view: true, edit: false },
                recruiting: { view: false, edit: false },
                staff: { view: false, edit: false },
                settings: { view: false, edit: false }
            }
        };

        const SchoolManagement = ({ currentUser, schoolId }) => {
            const [createLoading, setCreateLoading] = useState(false);
            const [joinLoading, setJoinLoading] = useState(false);
            const [joinInput, setJoinInput] = useState('');
            const [createAccessCode, setCreateAccessCode] = useState('');
            const [createMascot, setCreateMascot] = useState(''); // New: Mascot Input
            const [importData, setImportData] = useState(false); // Changed: Opt-in to data copy
            const [error, setError] = useState('');

            const handleCreateSchool = async () => {
                if (!createAccessCode.trim()) {
                    setError("Admin Access Code is required.");
                    return;
                }

                if (!confirm(importData
                    ? "This will copy your current workspace data to the new School Database. Proceed?"
                    : "You are creating a new empty school. Proceed?")) return;
                setCreateLoading(true);
                setError('');

                try {
                    // VERIFY ACCESS CODE
                    // In a real app, use a Cloud Function. Here, we check a secured Firestore doc or a hardcoded fallback.
                    let isValid = false;
                    try {
                        const configDoc = await window.db.collection('config').doc('access').get();
                        if (configDoc.exists && configDoc.data().createSchoolCode === createAccessCode) {
                            isValid = true;
                        } else if (createAccessCode === 'HEADCOACH101') {
                            // Fallback until config is set
                            isValid = true;
                        }
                    } catch (err) {
                        console.warn("Config check failed, checking fallback", err);
                        if (createAccessCode === 'HEADCOACH101') isValid = true;
                    }

                    if (!isValid) {
                        throw new Error("Invalid Admin Access Code.");
                    }

                    const newSchoolId = `SCH_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
                    const joinCode = Math.random().toString(36).substring(2, 8).toUpperCase(); // Consistent with SchoolSetupWizard

                    // 1. Gather all local data keys
                    const keys = [
                        'oc-dashboard-roster', 'oc-dashboard-plays', 'oc-dashboard-staff',
                        'oc-dashboard-depthchart', 'attendance_log',
                        'formationLayouts', 'oc-dashboard-ratings',
                        'athlete_assessments', 'oc-dashboard-formations', 'oc-dashboard-zone-philosophies',
                        'oc-dashboard-custom-focus',
                        'oc-dashboard-position-names', 'staff_role_tasks',
                        'wiz_ol_library', 'oc-dashboard-weeks'
                    ];

                    const schoolData = {
                        createdAt: new Date().toISOString(),
                        createdBy: currentUser.uid,
                        id: newSchoolId,
                        joinCode: joinCode, // Store Join Code
                        name: "My New School", // Default name
                        settings: {
                            schoolName: "My New School",
                            schoolMascot: createMascot || 'Tigers', // Default if empty
                            teamLogo: localStorage.getItem('oc-dashboard-logo') || '',
                            accentColor: localStorage.getItem('oc-dashboard-accent') || '#3b82f6',
                            theme: localStorage.getItem('oc-dashboard-theme') || 'dark',
                            activeYear: localStorage.getItem('hc-active-year') || '2025',
                            visibleFeatures: JSON.parse(localStorage.getItem('hc-visible-features') || '{}')
                        },
                        // Initialize empty arrays if NOT importing data
                        roster: [],
                        staff: [
                            {
                                id: currentUser.uid,
                                name: currentUser.displayName || 'Head Coach',
                                email: currentUser.email,
                                roles: ['Head Coach', 'Team Admin'], // FORCE ADMIN RIGHTS
                                phone: '',
                                bio: 'School Creator'
                            }
                        ],
                        plays: [],
                        billing: { // Initialize with trial
                            plan: 'premium_trial',
                            trialStartDate: new Date().toISOString(),
                            trialEndDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),
                            status: 'active'
                        }
                    };

                    // Populate schoolData only if importing data
                    if (importData) {
                        keys.forEach(k => {
                            const val = localStorage.getItem(k);
                            if (val) {
                                // Map local keys to cloud keys (reverse of loadUserData logic)
                                // This is a bit manual but necessary
                                if (k === 'oc-dashboard-roster') schoolData.roster = JSON.parse(val);
                                if (k === 'oc-dashboard-plays') schoolData.plays = JSON.parse(val);
                                if (k === 'oc-dashboard-staff') schoolData.staff = JSON.parse(val);
                                if (k === 'oc-dashboard-depthchart') schoolData.depthChart = JSON.parse(val);

                                if (k === 'oc-dashboard-weeks') schoolData.weeks = JSON.parse(val);
                                if (k === 'attendance_log') schoolData.attendance = JSON.parse(val);
                                if (k === 'oc-dashboard-valhalla') schoolData.valhalla = JSON.parse(val);
                                if (k === 'formationLayouts') schoolData.formationLayouts = JSON.parse(val);
                                if (k === 'oc-dashboard-ratings') schoolData.ratings = JSON.parse(val);
                                if (k === 'athlete_assessments') schoolData.athleteAssessments = JSON.parse(val);
                                if (k === 'oc-dashboard-formations') schoolData.formations = JSON.parse(val);
                                if (k === 'oc-dashboard-zone-philosophies') schoolData.zonePhilosophies = JSON.parse(val);
                                if (k === 'oc-dashboard-custom-focus') schoolData.customFocus = JSON.parse(val);
                                if (k === 'oc-dashboard-position-names') schoolData.positionNames = JSON.parse(val);
                                if (k === 'staff_role_tasks') schoolData.roleTasks = JSON.parse(val);
                                if (k === 'wiz_ol_library') schoolData.wizLib = JSON.parse(val);
                            }
                        });
                    }

                    // 2. Write School Doc
                    await window.db.collection('schools').doc(newSchoolId).set(schoolData);

                    // 3. Update User Doc
                    await window.db.collection('users').doc(currentUser.uid).update({ schoolId: newSchoolId });

                    alert(`School Created! ID: ${newSchoolId}. The app will now reload.`);
                    window.location.reload();

                } catch (e) {
                    console.error(e);
                    setError("Failed to create school: " + e.message);
                } finally {
                    setCreateLoading(false);
                }
            };

            const handleJoinSchool = async () => {
                const input = joinInput.trim();
                if (!input) return;

                setJoinLoading(true);
                setError('');
                try {
                    // Try to find by Join Code first (if len 6)
                    let targetSchoolId = null;
                    let targetSchoolName = '';

                    if (input.length === 6) {
                        try {
                            const querySnapshot = await window.db.collection('schools')
                                .where('joinCode', '==', input.toUpperCase())
                                .limit(1)
                                .get();

                            if (!querySnapshot.empty) {
                                targetSchoolId = querySnapshot.docs[0].id;
                                targetSchoolName = querySnapshot.docs[0].data().name;
                            }
                        } catch (err) {
                            console.log("Join Code lookup failed", err);
                        }
                    }

                    // Fallback to direct ID if not found by code
                    if (!targetSchoolId) {
                        const schoolDoc = await window.db.collection('schools').doc(input).get();
                        if (schoolDoc.exists) {
                            targetSchoolId = schoolDoc.id;
                            targetSchoolName = schoolDoc.data().name || 'Unknown School';
                        }
                    }

                    if (!targetSchoolId) {
                        throw new Error("School not found. Check the Code or ID.");
                    }

                    if (!confirm(`Join ${targetSchoolName}?`)) return;

                    await window.db.collection('users').doc(currentUser.uid).update({ schoolId: targetSchoolId });

                    // Add to member list (optional but good practice)
                    await window.db.collection('schools').doc(targetSchoolId).update({
                        [`memberList.${currentUser.uid}`]: {
                            email: currentUser.email,
                            role: 'viewer', // Default role
                            joinedAt: new Date().toISOString()
                        }
                    });

                    window.location.reload();
                } catch (e) {
                    setError(e.message);
                } finally {
                    setJoinLoading(false);
                }
            };

            const handleLeaveSchool = async () => {
                if (!confirm("Are you sure you want to leave this school? You will revert to your personal workspace.")) return;
                try {
                    await window.db.collection('users').doc(currentUser.uid).update({ schoolId: firebase.firestore.FieldValue.delete() });

                    // CLEAR LOCAL DATA to avoid ghost data
                    const keys = [
                        'oc-dashboard-roster', 'oc-dashboard-plays', 'oc-dashboard-staff',
                        'oc-dashboard-depthchart', 'attendance_log',
                        'formationLayouts', 'oc-dashboard-ratings', 'oc-dashboard-game-grades',
                        'oc-dashboard-scouting',
                        'athlete_assessments', 'oc-dashboard-formations', 'oc-dashboard-zone-philosophies',
                        'oc-dashboard-custom-focus',
                        'oc-dashboard-position-names', 'staff_role_tasks',
                        'wiz_ol_library', 'oc-dashboard-weeks',
                        'hc_school_id', 'hc_school_name'
                    ];
                    keys.forEach(k => localStorage.removeItem(k));

                    window.location.reload();
                } catch (e) {
                    console.error("Error leaving school:", e);
                    alert("Error leaving school: " + e.message);
                }
            };

            return (
                <div style={{ padding: '2rem', maxWidth: '800px', margin: '0 auto' }}>

                    <div style={{ marginBottom: '2rem' }}>
                        <h1 style={{ fontSize: '2rem', marginBottom: '0.5rem' }}>Welcome, {currentUser.displayName || 'Coach'}</h1>
                        <p style={{ color: 'var(--text-secondary)' }}>
                            You are currently in your <strong>Personal Workspace</strong>. Data is saved locally.
                        </p>
                    </div>

                    {error && (
                        <div className="alert alert-danger" style={{ marginBottom: '1.5rem' }}>
                            {error}
                        </div>
                    )}

                    {schoolId ? (
                        <div className="card">
                            <h2>Current School</h2>
                            <div style={{ background: 'var(--bg-body)', padding: '1rem', borderRadius: '8px', marginBottom: '1.5rem' }}>
                                <p style={{ fontSize: '0.9rem', color: 'var(--text-secondary)', marginBottom: '0.5rem' }}>School ID</p>
                                <div style={{ display: 'flex', gap: '0.5rem' }}>
                                    <code style={{ flex: 1, padding: '0.5rem', background: 'var(--bg-body)', borderRadius: '4px', border: '1px solid var(--border)' }}>
                                        {schoolId}
                                    </code>
                                    <button className="btn btn-secondary" onClick={() => navigator.clipboard.writeText(schoolId)}>Copy</button>
                                </div>
                                <p style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginTop: '0.5rem' }}>
                                    Share this ID with other coaches so they can join this team.
                                </p>
                            </div>
                            <button className="btn btn-danger" onClick={handleLeaveSchool}>Leave School</button>
                        </div>
                    ) : (
                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '2rem' }}>
                            {/* Create School */}
                            <div className="card">
                                <h2>Create New School</h2>
                                <p style={{ color: 'var(--text-secondary)', marginBottom: '1.5rem' }}>
                                    Convert your personal workspace into a shared Team Database. You will become the admin.
                                </p>
                                <div style={{ marginBottom: '1rem' }}>
                                    <label style={{ display: 'block', marginBottom: '0.5rem', fontSize: '0.9rem' }}>School Mascot</label>
                                    <input
                                        type="text"
                                        className="form-input"
                                        placeholder="e.g. Tigers, Eagles..."
                                        value={createMascot}
                                        onChange={e => setCreateMascot(e.target.value)}
                                        style={{ width: '100%', marginBottom: '1rem' }}
                                    />
                                    <label style={{ display: 'block', marginBottom: '0.5rem', fontSize: '0.9rem' }}>Admin Access Code</label>
                                    <input
                                        type="password"
                                        className="form-input"
                                        placeholder="Required to create school..."
                                        value={createAccessCode}
                                        onChange={e => setCreateAccessCode(e.target.value)}
                                        style={{ width: '100%' }}
                                    />
                                    <label style={{ display: 'flex', alignItems: 'center', marginTop: '1rem', cursor: 'pointer' }}>
                                        <input
                                            type="checkbox"
                                            checked={importData}
                                            onChange={e => setImportData(e.target.checked)}
                                            style={{ marginRight: '0.5rem', width: 'auto' }}
                                        />
                                        <span style={{ fontSize: '0.9rem', color: 'var(--text-primary)' }}>Copy my current workspace data (Optional)</span>
                                    </label>
                                </div>
                                <button
                                    className="btn btn-primary"
                                    onClick={handleCreateSchool}
                                    disabled={createLoading}
                                    style={{ width: '100%' }}
                                >
                                    {createLoading ? 'Creating...' : (importData ? 'Create & Import Data' : 'Create New School')}
                                </button>
                            </div>

                            {/* Join School */}
                            <div className="card">
                                <h2>Join Existing School</h2>
                                <p style={{ color: 'var(--text-secondary)', marginBottom: '1.5rem' }}>
                                    Enter a <strong>Join Code</strong> (from your HC) or a legacy School ID to sync with your team.
                                </p>
                                <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '1rem' }}>
                                    <input
                                        type="text"
                                        className="form-input"
                                        placeholder="Enter 6-digit Join Code..."
                                        value={joinInput}
                                        onChange={e => setJoinInput(e.target.value)}
                                    />
                                    <button
                                        className="btn btn-secondary"
                                        onClick={handleJoinSchool}
                                        disabled={joinLoading || !joinInput}
                                    >
                                        {joinLoading ? 'Joining...' : 'Join'}
                                    </button>
                                </div>
                                {error && <div style={{ color: '#ef4444', fontSize: '0.9rem' }}>{error}</div>}
                            </div>
                        </div>
                    )}
                </div>
            );
        };
        const PermissionsView = ({ permissions, onUpdatePermissions, onResetDefaults }) => {
            // Cycle through: none -> view -> edit -> none
            const cyclePermission = (role, featureId) => {
                const newPermissions = JSON.parse(JSON.stringify(permissions));
                if (!newPermissions[role]) newPermissions[role] = {};
                if (!newPermissions[role][featureId]) newPermissions[role][featureId] = { view: false, edit: false };

                const p = newPermissions[role][featureId];
                if (!p.view && !p.edit) {
                    // none -> view
                    p.view = true;
                    p.edit = false;
                } else if (p.view && !p.edit) {
                    // view -> edit
                    p.view = true;
                    p.edit = true;
                } else {
                    // edit -> none
                    p.view = false;
                    p.edit = false;
                }

                onUpdatePermissions(newPermissions);
            };

            const getPermissionState = (p) => {
                if (!p.view && !p.edit) return 'none';
                if (p.view && !p.edit) return 'view';
                return 'edit';
            };

            return (
                <div style={{ padding: '2rem', height: '100%', overflowY: 'auto' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '2rem' }}>
                        <div>
                            <h1 style={{ fontSize: '2rem', marginBottom: '0.5rem' }}>Permissions</h1>
                            <div style={{ color: 'var(--text-secondary)' }}>Click cells to cycle: None → View → Edit</div>
                        </div>
                        <button className="btn btn-outline" onClick={onResetDefaults}>
                            <Icon name="RotateCcw" size={16} /> Reset
                        </button>
                    </div>

                    <div className="card" style={{ overflowX: 'auto' }}>
                        <table style={{ width: '100%', borderCollapse: 'collapse', minWidth: '900px' }}>
                            <thead>
                                <tr style={{ borderBottom: '1px solid var(--border)' }}>
                                    <th style={{ textAlign: 'left', padding: '0.75rem 1rem', minWidth: '140px' }}>Role</th>
                                    {FEATURES.map(feature => (
                                        <th key={feature.id} style={{ textAlign: 'center', padding: '0.75rem 0.5rem', fontSize: '0.8rem', minWidth: '70px' }} title={feature.fullLabel}>
                                            {feature.label}
                                        </th>
                                    ))}
                                </tr>
                            </thead>
                            <tbody>
                                {ROLES.map(role => {
                                    const isHC = role === 'Head Coach';
                                    return (
                                        <tr key={role} style={{ borderBottom: '1px solid var(--border)' }}>
                                            <td style={{ padding: '0.75rem 1rem', fontWeight: 'bold' }}>{role}</td>
                                            {FEATURES.map(feature => {
                                                const rolePerms = permissions[role] || DEFAULT_PERMISSIONS[role] || {};
                                                const p = rolePerms[feature.id] || { view: false, edit: false };
                                                const state = getPermissionState(p);

                                                const stateStyles = {
                                                    none: { bg: 'var(--surface)', border: '1px solid transparent', color: 'var(--text-secondary)', label: '—' },
                                                    view: { bg: 'rgba(59, 130, 246, 0.15)', border: '1px solid #3b82f6', color: '#3b82f6', label: 'View' },
                                                    edit: { bg: 'rgba(34, 197, 94, 0.15)', border: '1px solid #22c55e', color: '#22c55e', label: 'Edit' }
                                                };
                                                const s = stateStyles[state];

                                                return (
                                                    <td key={`${role}-${feature.id}`} style={{ padding: '0.5rem', textAlign: 'center' }}>
                                                        <button
                                                            onClick={() => !isHC && cyclePermission(role, feature.id)}
                                                            style={{
                                                                background: s.bg,
                                                                border: s.border,
                                                                color: s.color,
                                                                padding: '4px 8px',
                                                                borderRadius: '4px',
                                                                cursor: isHC ? 'default' : 'pointer',
                                                                opacity: isHC ? 0.5 : 1,
                                                                fontSize: '0.75rem',
                                                                fontWeight: '600',
                                                                minWidth: '50px'
                                                            }}
                                                            title={isHC ? 'Head Coach has full access' : `Click to change (${feature.fullLabel})`}
                                                        >
                                                            {s.label}
                                                        </button>
                                                    </td>
                                                );
                                            })}
                                        </tr>
                                    );
                                })}
                            </tbody>
                        </table>
                    </div>

                    <div style={{ marginTop: '1rem', display: 'flex', gap: '1.5rem', fontSize: '0.8rem', color: 'var(--text-secondary)' }}>
                        <span><span style={{ color: 'var(--text-secondary)' }}>—</span> No Access</span>
                        <span><span style={{ color: '#3b82f6' }}>View</span> Can view only</span>
                        <span><span style={{ color: '#22c55e' }}>Edit</span> Can view & edit</span>
                    </div>
                </div>
            );
        };


        // PLAYER LOAD MANAGEMENT
        const LOAD_WEIGHTS = [3, 2, 1]; // Slot 1 (3pts), Slot 2 (2pts), Slot 3 (1pt)

        const calculatePlayerLoad = (playerId, depthCharts) => {
            let totalScore = 0;
            const breakdown = [];

            if (!depthCharts || typeof depthCharts !== 'object') return { totalScore, breakdown };

            Object.entries(depthCharts).forEach(([chartKey, positions]) => {
                if (!positions) return;

                // Parse Unit Name from Key (e.g. "OFFENSE" -> "Offense")
                let unitName = chartKey.replace(/_/g, ' ');

                // Capitalize each word
                unitName = unitName.replace(/\w\S*/g, (w) => (w.replace(/^\w/, (c) => c.toUpperCase())));

                Object.entries(positions).forEach(([posId, playerIds]) => {
                    if (Array.isArray(playerIds)) {
                        playerIds.forEach((pId, index) => {
                            if (pId === playerId) {
                                const weight = LOAD_WEIGHTS[index] || 1; // Default to 1 if deep depth
                                totalScore += weight;

                                // Determine Role Name if position structure is standard "UNIT_POS"
                                let roleName = posId;
                                if (posId.includes('_')) {
                                    roleName = posId.split('_').pop();
                                }

                                breakdown.push({
                                    unit: unitName,
                                    role: roleName,
                                    weight: weight,
                                    type: index === 0 ? 'Starter' : (index === 1 ? 'Rotation' : 'Depth')
                                });
                            }
                        });
                    }
                });
            });

            return { totalScore, breakdown };
        };


        // DEFAULT 2025 DATA
        const DEFAULT_ROSTER_2025 = [];

        const DEFAULT_STAFF_2025 = [];

        // Default Formation Presets
        const DEFAULT_FORMATIONS = [
            {
                id: 'blue',
                name: 'Blue',
                description: '2x2 Spread - Balanced receivers',
                positions: [
                    { label: 'LT', x: 35, y: 52 },
                    { label: 'LG', x: 42, y: 52 },
                    { label: 'C', x: 50, y: 52 },
                    { label: 'RG', x: 58, y: 52 },
                    { label: 'RT', x: 65, y: 52 },
                    { label: 'QB', x: 50, y: 58 },
                    { label: 'RB', x: 50, y: 65 },
                    { label: 'X', x: 10, y: 52 },
                    { label: 'Z', x: 90, y: 52 },
                    { label: 'A', x: 70, y: 56 },
                    { label: 'Y', x: 30, y: 56 }
                ]
            },
            {
                id: 'red',
                name: 'Red',
                description: '3x1 Spread - Trips right',
                positions: [
                    { label: 'LT', x: 35, y: 52 },
                    { label: 'LG', x: 42, y: 52 },
                    { label: 'C', x: 50, y: 52 },
                    { label: 'RG', x: 58, y: 52 },
                    { label: 'RT', x: 65, y: 52 },
                    { label: 'QB', x: 50, y: 58 },
                    { label: 'RB', x: 50, y: 65 },
                    { label: 'X', x: 10, y: 52 },
                    { label: 'Z', x: 90, y: 52 },
                    { label: 'A', x: 80, y: 52 },
                    { label: 'Y', x: 85, y: 56 }
                ]
            },
            {
                id: 'green',
                name: 'Green',
                description: '2x2 Spread with tight slot',
                positions: [
                    { label: 'LT', x: 35, y: 52 },
                    { label: 'LG', x: 42, y: 52 },
                    { label: 'C', x: 50, y: 52 },
                    { label: 'RG', x: 58, y: 52 },
                    { label: 'RT', x: 65, y: 52 },
                    { label: 'QB', x: 50, y: 58 },
                    { label: 'RB', x: 50, y: 65 },
                    { label: 'X', x: 10, y: 52 },
                    { label: 'Z', x: 90, y: 52 },
                    { label: 'A', x: 68, y: 53 },
                    { label: 'Y', x: 32, y: 53 }
                ]
            },
            {
                id: 'orange',
                name: 'Orange',
                description: 'Empty backfield 3x2',
                positions: [
                    { label: 'LT', x: 35, y: 52 },
                    { label: 'LG', x: 42, y: 52 },
                    { label: 'C', x: 50, y: 52 },
                    { label: 'RG', x: 58, y: 52 },
                    { label: 'RT', x: 65, y: 52 },
                    { label: 'QB', x: 50, y: 58 },
                    { label: 'X', x: 10, y: 52 },
                    { label: 'Z', x: 90, y: 52 },
                    { label: 'A', x: 80, y: 52 },
                    { label: 'Y', x: 30, y: 56 },
                    { label: 'F', x: 70, y: 60 }
                ]
            },
            {
                id: 'diamond_rt',
                name: 'Diamond Rt',
                description: 'Diamond formation right',
                positions: [
                    { label: 'LT', x: 35, y: 52 },
                    { label: 'LG', x: 42, y: 52 },
                    { label: 'C', x: 50, y: 52 },
                    { label: 'RG', x: 58, y: 52 },
                    { label: 'RT', x: 65, y: 52 },
                    { label: 'QB', x: 50, y: 58 },
                    { label: 'WR', x: 55, y: 45 },
                    { label: 'WR', x: 40, y: 58 },
                    { label: 'WR', x: 70, y: 58 },
                    { label: 'WR', x: 55, y: 72 },
                    { label: 'X', x: 10, y: 52 }
                ]
            },
            {
                id: 'diamond_lt',
                name: 'Diamond Lt',
                description: 'Diamond formation left',
                positions: [
                    { label: 'LT', x: 35, y: 52 },
                    { label: 'LG', x: 42, y: 52 },
                    { label: 'C', x: 50, y: 52 },
                    { label: 'RG', x: 58, y: 52 },
                    { label: 'RT', x: 65, y: 52 },
                    { label: 'QB', x: 50, y: 58 },
                    { label: 'WR', x: 45, y: 45 },
                    { label: 'WR', x: 30, y: 58 },
                    { label: 'WR', x: 60, y: 58 },
                    { label: 'WR', x: 45, y: 72 },
                    { label: 'Z', x: 90, y: 52 }
                ]
            },
            {
                id: 'bunch_rt',
                name: 'Bunch Rt',
                description: 'Bunched receivers right',
                positions: [
                    { label: 'LT', x: 35, y: 52 },
                    { label: 'LG', x: 42, y: 52 },
                    { label: 'C', x: 50, y: 52 },
                    { label: 'RG', x: 58, y: 52 },
                    { label: 'RT', x: 65, y: 52 },
                    { label: 'QB', x: 50, y: 58 },
                    { label: 'RB', x: 50, y: 65 },
                    { label: 'X', x: 10, y: 52 },
                    { label: 'WR', x: 78, y: 52 },
                    { label: 'WR', x: 83, y: 52 },
                    { label: 'WR', x: 88, y: 50 }
                ]
            },
            {
                id: 'bunch_lt',
                name: 'Bunch Lt',
                description: 'Bunched receivers left',
                positions: [
                    { label: 'LT', x: 35, y: 52 },
                    { label: 'LG', x: 42, y: 52 },
                    { label: 'C', x: 50, y: 52 },
                    { label: 'RG', x: 58, y: 52 },
                    { label: 'RT', x: 65, y: 52 },
                    { label: 'QB', x: 50, y: 58 },
                    { label: 'RB', x: 50, y: 65 },
                    { label: 'Z', x: 90, y: 52 },
                    { label: 'WR', x: 22, y: 52 },
                    { label: 'WR', x: 17, y: 52 },
                    { label: 'WR', x: 12, y: 50 }
                ]
            },
            {
                id: 'bright',
                name: 'Bright',
                description: 'Tight formation with TE',
                positions: [
                    { label: 'LT', x: 35, y: 52 },
                    { label: 'LG', x: 42, y: 52 },
                    { label: 'C', x: 50, y: 52 },
                    { label: 'RG', x: 58, y: 52 },
                    { label: 'RT', x: 65, y: 52 },
                    { label: 'QB', x: 50, y: 58 },
                    { label: 'RB', x: 50, y: 65 },
                    { label: 'TE', x: 70, y: 52 },
                    { label: 'X', x: 10, y: 52 },
                    { label: 'Z', x: 90, y: 52 },
                    { label: 'A', x: 80, y: 54 }
                ]
            },
            {
                id: 'rip',
                name: 'Rip',
                description: 'Rip formation',
                positions: [
                    { label: 'LT', x: 35, y: 52 },
                    { label: 'LG', x: 42, y: 52 },
                    { label: 'C', x: 50, y: 52 },
                    { label: 'RG', x: 58, y: 52 },
                    { label: 'RT', x: 65, y: 52 },
                    { label: 'QB', x: 50, y: 58 },
                    { label: 'RB', x: 50, y: 65 },
                    { label: 'X', x: 12, y: 52 },
                    { label: 'Z', x: 88, y: 52 },
                    { label: 'A', x: 72, y: 55 },
                    { label: 'Y', x: 28, y: 55 }
                ]
            },
            {
                id: 'gold',
                name: 'Gold',
                description: 'Gold formation',
                positions: [
                    { label: 'LT', x: 35, y: 52 },
                    { label: 'LG', x: 42, y: 52 },
                    { label: 'C', x: 50, y: 52 },
                    { label: 'RG', x: 58, y: 52 },
                    { label: 'RT', x: 65, y: 52 },
                    { label: 'QB', x: 50, y: 58 },
                    { label: 'RB', x: 50, y: 65 },
                    { label: 'X', x: 10, y: 52 },
                    { label: 'Z', x: 90, y: 52 },
                    { label: 'A', x: 75, y: 56 },
                    { label: 'Y', x: 25, y: 56 }
                ]
            }
        ];


        const GradingModal = ({ cell, currentData, onClose, onSave }) => {
            const [grade, setGrade] = useState(currentData?.grade || 2);
            const [criteria, setCriteria] = useState(currentData?.criteria || {
                alignment: false,
                assignment: false,
                getOff: false,
                finish: false
            });
            const [notes, setNotes] = useState(currentData?.notes || '');

            useEffect(() => {
                if (currentData) {
                    setGrade(currentData.grade);
                    setCriteria(currentData.criteria || {});
                    setNotes(currentData.notes || '');
                } else {
                    setGrade(2);
                    setCriteria({ alignment: false, assignment: false, getOff: false, finish: false });
                    setNotes('');
                }
            }, [currentData]);

            return (
                <div style={{
                    position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
                    background: 'rgba(0,0,0,0.8)', display: 'flex', alignItems: 'center', justifyContent: 'center',
                    zIndex: 1000, backdropFilter: 'blur(5px)'
                }}>
                    <div className="card" style={{ width: '500px', maxWidth: '90%', animation: 'slideIn 0.3s' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '1.5rem', borderBottom: '1px solid var(--border)', paddingBottom: '1rem' }}>
                            <div>
                                <h2>Grade: {cell.player.name}</h2>
                                <div style={{ color: 'var(--text-secondary)', fontSize: '0.9rem' }}>
                                    {cell.play.play.name} • {cell.play.situation.down}&{cell.play.situation.distance}
                                </div>
                            </div>
                            <button onClick={onClose} style={{ background: 'none', border: 'none', color: 'var(--text-secondary)', cursor: 'pointer' }}>
                                <Icon name="X" size={24} />
                            </button>
                        </div>

                        <div style={{ marginBottom: '1.5rem' }}>
                            <label className="form-label" style={{ textAlign: 'center', display: 'block' }}>Performance Grade</label>
                            <div style={{ display: 'flex', gap: '0.5rem' }}>
                                {[0, 1, 2, 3, 4].map(g => (
                                    <button
                                        key={g}
                                        onClick={() => setGrade(g)}
                                        className="btn"
                                        style={{
                                            flex: 1,
                                            background: grade === g ? (g >= 3 ? '#10b981' : g < 2 ? '#ef4444' : '#f59e0b') : 'var(--bg-panel)',
                                            color: grade === g ? 'white' : 'var(--text-primary)',
                                            fontWeight: 'bold',
                                            padding: '1rem',
                                            fontSize: '1.5rem',
                                            border: grade === g ? '2px solid rgba(255,255,255,0.2)' : '1px solid var(--border)'
                                        }}
                                    >
                                        {g}
                                    </button>
                                ))}
                            </div>
                            <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.8rem', marginTop: '0.5rem', color: 'var(--text-secondary)', padding: '0 0.5rem' }}>
                                <span>Critical Error</span>
                                <span>Poor</span>
                                <span>Average</span>
                                <span>Good</span>
                                <span>Dominant</span>
                            </div>
                        </div>

                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginBottom: '1.5rem' }}>
                            {Object.keys(criteria).map(key => (
                                <label key={key} style={{ display: 'flex', alignItems: 'center', gap: '0.75rem', padding: '1rem', background: 'var(--bg-panel)', borderRadius: '6px', cursor: 'pointer', border: criteria[key] ? '1px solid var(--accent)' : '1px solid transparent' }}>
                                    <input
                                        type="checkbox"
                                        checked={criteria[key]}
                                        onChange={(e) => setCriteria({ ...criteria, [key]: e.target.checked })}
                                        style={{ width: '20px', height: '20px', accentColor: 'var(--accent)' }}
                                    />
                                    <span style={{ textTransform: 'capitalize', fontWeight: '500' }}>{key.replace(/([A-Z])/g, ' $1').trim()}</span>
                                </label>
                            ))}
                        </div>

                        <div style={{ marginBottom: '2rem' }}>
                            <label className="form-label">Notes</label>
                            <textarea
                                className="form-input"
                                rows="3"
                                value={notes}
                                onChange={(e) => setNotes(e.target.value)}
                                placeholder="Add specific coaching points..."
                            />
                        </div>

                        <div style={{ display: 'flex', gap: '1rem' }}>
                            <button className="btn" onClick={onClose} style={{ flex: 1, background: 'var(--bg-panel)' }}>Cancel</button>
                            <button
                                className="btn btn-primary"
                                style={{ flex: 2 }}
                                onClick={() => {
                                    onSave({ grade, criteria, notes });
                                    onClose();
                                }}
                            >
                                <Icon name="Save" size={18} style={{ marginRight: '8px' }} />
                                Save Grade
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const ManageWeekModal = ({ isOpen, onClose, currentWeek, weeks, onUpdateWeek }) => {
            console.log('ManageWeekModal Render: isOpen=', isOpen, 'currentWeek=', currentWeek?.id);
            if (!isOpen) return null;
            if (!currentWeek) {
                console.error('ManageWeekModal: currentWeek is missing');
                return null;
            }

            const [mode, setMode] = React.useState('import'); // 'import' | 'clear'
            const [sourceWeekId, setSourceWeekId] = React.useState('');
            const [selections, setSelections] = React.useState({
                practicePlans: true,
                gamePlan: true, // Includes Scripts & Layouts
                wristbands: true,
                installs: true,
                depthChart: true,
                zonePhilosophies: true
            });

            // Filter available weeks (exclude current)
            const availableWeeks = (weeks || []).filter(w => w.id !== currentWeek.id);

            const handleToggle = (key) => {
                setSelections(prev => ({ ...prev, [key]: !prev[key] }));
            };

            const handleImport = () => {
                if (!sourceWeekId) return;
                const sourceWeek = weeks.find(w => w.id === sourceWeekId);
                if (!sourceWeek) return;

                const updates = {};

                if (selections.practicePlans) {
                    const newPlans = {};
                    Object.entries(sourceWeek.practicePlans || {}).forEach(([day, plan]) => {
                        newPlans[day] = {
                            ...JSON.parse(JSON.stringify(plan)),
                            id: Date.now().toString() + Math.random().toString(36).substr(2, 5) + day,
                            date: currentWeek.practicePlans[day]?.date || plan.date
                        };
                    });
                    updates.practicePlans = newPlans;
                }

                if (selections.gamePlan) {
                    updates.offensiveGamePlan = JSON.parse(JSON.stringify(sourceWeek.offensiveGamePlan || { sets: [] }));
                    updates.dumbCallSheetData = JSON.parse(JSON.stringify(sourceWeek.dumbCallSheetData || {}));
                }

                if (selections.wristbands) {
                    updates.wristbands = JSON.parse(JSON.stringify(sourceWeek.wristbands));
                }

                if (selections.installs) {
                    updates.installList = [...(sourceWeek.installList || [])];
                }

                if (selections.depthChart) {
                    updates.depthChart = JSON.parse(JSON.stringify(sourceWeek.depthChart));
                }

                if (selections.zonePhilosophies) {
                    updates.zonePhilosophies = JSON.parse(JSON.stringify(sourceWeek.zonePhilosophies));
                }

                if (Object.keys(updates).length > 0) {
                    onUpdateWeek(currentWeek.id, 'bulk_update', updates);
                }
                onClose();
            };

            const handleClear = () => {
                const updates = {};

                if (selections.practicePlans) {
                    const resetPlans = {};
                    ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'].forEach(day => {
                        resetPlans[day] = {
                            id: Date.now().toString() + Math.random().toString(36).substr(2, 5) + day,
                            date: (currentWeek.practicePlans[day]?.date) || new Date().toISOString().split('T')[0],
                            startTime: '15:40',
                            segments: []
                        };
                    });
                    updates.practicePlans = resetPlans;
                }

                if (selections.gamePlan) {
                    updates.offensiveGamePlan = { sets: [] };
                    updates.dumbCallSheetData = {};
                }

                if (selections.wristbands) {
                    updates.wristbands = {
                        card1: { type: 'standard', opp: '', iter: '1', rows: [] },
                        card2: { type: 'standard', opp: '', iter: '1', rows: [] },
                        card3: { type: 'wiz', opp: '', iter: '1', rows: [] },
                        staples: { type: 'staples', opp: '', iter: '1', rows: [] }
                    };
                }

                if (selections.installs) updates.installList = [];
                if (selections.depthChart) updates.depthChart = {};
                if (selections.zonePhilosophies) updates.zonePhilosophies = {};

                if (Object.keys(updates).length > 0) {
                    onUpdateWeek(currentWeek.id, 'bulk_update', updates);
                }
                onClose();
            };

            return (
                <div style={{
                    position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
                    background: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 10000
                }}>
                    <div className="card" style={{ width: '500px', padding: '1.5rem', background: '#1e293b', color: 'white', maxHeight: '90vh', overflowY: 'auto', border: '1px solid #334155' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                            <h2 style={{ margin: 0 }}>Manage Week</h2>
                            <button onClick={onClose} style={{ background: 'none', border: 'none', cursor: 'pointer' }}><Icon name="X" size={24} /></button>
                        </div>

                        <div style={{ display: 'flex', gap: '1rem', marginBottom: '1.5rem' }}>
                            <button
                                onClick={() => setMode('import')}
                                style={{
                                    flex: 1, padding: '0.75rem', borderRadius: '8px', fontWeight: 'bold',
                                    background: mode === 'import' ? 'var(--primary)' : '#334155',
                                    color: mode === 'import' ? 'white' : '#94a3b8',
                                    border: '1px solid #475569'
                                }}
                            >
                                Import from Previous
                            </button>
                            <button
                                onClick={() => setMode('clear')}
                                style={{
                                    flex: 1, padding: '0.75rem', borderRadius: '8px', fontWeight: 'bold',
                                    background: mode === 'clear' ? '#ef4444' : '#334155',
                                    color: mode === 'clear' ? 'white' : '#94a3b8',
                                    border: '1px solid #475569'
                                }}
                            >
                                Start from Scratch
                            </button>
                        </div>

                        {mode === 'import' && (
                            <div>
                                <div style={{ marginBottom: '1rem' }}>
                                    <label style={{ display: 'block', fontWeight: 'bold', marginBottom: '0.5rem' }}>Select Source Week</label>
                                    <select
                                        className="form-input"
                                        style={{ background: '#334155', color: 'white', border: '1px solid #475569' }}
                                        value={sourceWeekId}
                                        onChange={(e) => setSourceWeekId(e.target.value)}
                                    >
                                        <option value="">-- Select Week --</option>
                                        {availableWeeks.map(w => (
                                            <option key={w.id} value={w.id}>Week {w.weekNum} - {w.name} {w.opponent ? `vs ${w.opponent}` : ''}</option>
                                        ))}
                                    </select>
                                </div>

                                {sourceWeekId && (
                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                                        <label style={{ fontWeight: 'bold' }}>Select Data to Import:</label>
                                        {[
                                            { id: 'practicePlans', label: 'Practice Plans' },
                                            { id: 'gamePlan', label: 'Game Plan & Scripts' },
                                            { id: 'wristbands', label: 'Wristbands' },
                                            { id: 'installs', label: 'Install List' },
                                            { id: 'depthChart', label: 'Depth Charts' },
                                            { id: 'zonePhilosophies', label: 'Zone Philosophies' }
                                        ].map(item => (
                                            <label key={item.id} style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', cursor: 'pointer' }}>
                                                <input
                                                    type="checkbox"
                                                    checked={selections[item.id]}
                                                    onChange={() => handleToggle(item.id)}
                                                    style={{ width: '18px', height: '18px' }}
                                                />
                                                {item.label}
                                            </label>
                                        ))}
                                    </div>
                                )}

                                <div style={{ marginTop: '1.5rem', display: 'flex', justifyContent: 'flex-end' }}>
                                    <button
                                        className="btn btn-primary"
                                        disabled={!sourceWeekId}
                                        onClick={handleImport}
                                    >
                                        Import Selected Data
                                    </button>
                                </div>
                            </div>
                        )}

                        {mode === 'clear' && (
                            <div style={{ padding: '1rem' }}>
                                <div style={{ textAlign: 'center', marginBottom: '1.5rem' }}>
                                    <Icon name="AlertTriangle" size={48} color="#ef4444" style={{ marginBottom: '1rem' }} />
                                    <h3 style={{ color: '#ef4444', marginTop: 0 }}>Clear Selected Data</h3>
                                    <p>Select the items you want to reset. <br /><strong>Warning: This action is irreversible.</strong></p>
                                </div>

                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem', marginBottom: '1.5rem' }}>
                                    <label style={{ fontWeight: 'bold' }}>Select Data to Clear:</label>
                                    {[
                                        { id: 'practicePlans', label: 'Practice Plans' },
                                        { id: 'gamePlan', label: 'Game Plan & Scripts' },
                                        { id: 'wristbands', label: 'Wristbands' },
                                        { id: 'installs', label: 'Install List' },
                                        { id: 'depthChart', label: 'Depth Charts' },
                                        { id: 'zonePhilosophies', label: 'Zone Philosophies' }
                                    ].map(item => (
                                        <label key={item.id} style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', cursor: 'pointer' }}>
                                            <input
                                                type="checkbox"
                                                checked={selections[item.id]}
                                                onChange={() => handleToggle(item.id)}
                                                style={{ width: '18px', height: '18px' }}
                                            />
                                            {item.label}
                                        </label>
                                    ))}
                                </div>

                                <button
                                    className="btn"
                                    onClick={handleClear}
                                    style={{ background: '#ef4444', color: 'white', width: '100%', padding: '1rem', fontWeight: 'bold' }}
                                >
                                    Clear Selected Data
                                </button>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const GameWeekOverview = ({ week, weeks, onUpdateWeek, teamLogo, isLocked }) => {

            const [addEventModal, setAddEventModal] = useState(null); // { day: 'monday' } or null
            const [editingEvent, setEditingEvent] = useState(null); // { day, eventId, event } or null
            const [exportMode, setExportMode] = useState(false);

            const overview = week.overview || {};

            // Ensure structure
            if (!overview.dailySchedule) {
                overview.dailySchedule = {
                    monday: { events: [] },
                    tuesday: { events: [] },
                    wednesday: { events: [] },
                    thursday: { events: [] },
                    friday: { events: [] },
                    saturday: { events: [] }
                };
            }

            // Sync practices from practice plans
            useEffect(() => {
                if (!week.practicePlans) return;

                const DAYS = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
                let hasChanges = false;
                const newDailySchedule = JSON.parse(JSON.stringify(overview.dailySchedule));

                DAYS.forEach(day => {
                    const plan = week.practicePlans[day];
                    const autoId = `auto-practice-${day}`;
                    const existingIndex = newDailySchedule[day].events.findIndex(e => e.id === autoId);

                    if (plan && plan.startTime) {
                        // Calculate end time
                        let endTime = '';
                        try {
                            const [h, m] = plan.startTime.split(':').map(Number);
                            let totalMinutes = (h * 60) + m;
                            totalMinutes += parseInt(plan.warmupDuration || 0);
                            if (plan.segments && Array.isArray(plan.segments)) {
                                plan.segments.forEach(s => totalMinutes += parseInt(s.duration || 0));
                            }
                            const endH = Math.floor(totalMinutes / 60);
                            const endM = totalMinutes % 60;
                            endTime = `${endH.toString().padStart(2, '0')}:${endM.toString().padStart(2, '0')}`;
                        } catch (e) { endTime = 'TBD'; }

                        const practiceEvent = {
                            id: autoId,
                            type: 'practice',
                            level: 'Varsity',
                            start: plan.startTime,
                            end: endTime,
                            notes: plan.focus || '',
                            autoPopulated: true
                        };

                        if (existingIndex >= 0) {
                            const existing = newDailySchedule[day].events[existingIndex];
                            if (existing.start !== practiceEvent.start || existing.end !== practiceEvent.end || existing.notes !== practiceEvent.notes) {
                                newDailySchedule[day].events[existingIndex] = practiceEvent;
                                hasChanges = true;
                            }
                        } else {
                            newDailySchedule[day].events.unshift(practiceEvent);
                            hasChanges = true;
                        }
                    } else if (existingIndex >= 0) {
                        // Remove if plan was cleared
                        newDailySchedule[day].events.splice(existingIndex, 1);
                        hasChanges = true;
                    }
                });

                if (hasChanges) {
                    onUpdateWeek(week.id, 'overview', { ...overview, dailySchedule: newDailySchedule });
                }
            }, [week.practicePlans]);

            const DAYS = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
            const DAY_LABELS = { monday: 'Monday', tuesday: 'Tuesday', wednesday: 'Wednesday', thursday: 'Thursday', friday: 'Friday', saturday: 'Saturday' };

            const handleExport = () => {
                setExportMode(true);
                setTimeout(() => {
                    window.print();
                    setExportMode(false);
                }, 500);
            };

            const getEventColor = (type) => {
                if (type === 'practice') return '#3b82f6';
                if (type === 'game') return '#ef4444';
                return '#10b981';
            };

            return (
                <div style={{ padding: '1rem', maxWidth: '1000px', margin: '0 auto' }}>
                    <div className="no-print" style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                        <h1>Week {week.weekNum} Overview</h1>
                        <div style={{ display: 'flex', gap: '1rem' }}>

                            <button className="btn btn-primary" onClick={handleExport}>
                                <Icon name="Printer" size={18} style={{ marginRight: '8px' }} />
                                Export for SportsYou
                            </button>
                        </div>
                    </div>

                    <div id="game-week-print-area">
                        {/* Header Info */}
                        <div style={{ background: '#1e293b', color: 'white', padding: '1.5rem', borderRadius: '12px', marginBottom: '1.5rem', textAlign: 'center' }}>
                            <div style={{ marginBottom: '1.5rem', display: 'flex', justifyContent: 'center', alignItems: 'center', gap: '1rem' }}>
                                <label style={{ color: 'var(--accent)', fontWeight: 'bold' }}>Game Date:</label>
                                <input
                                    type="date"
                                    className="form-input"
                                    style={{ width: 'auto', background: 'var(--surface)', color: 'white', border: '1px solid var(--accent)' }}
                                    value={week.date || ''}
                                    onChange={(e) => onUpdateWeek(week.id, 'date', e.target.value)}
                                />
                            </div>
                            <div style={{ fontSize: '0.9rem', textTransform: 'uppercase', letterSpacing: '0.1em', color: 'var(--accent)', fontWeight: '800', marginBottom: '0.5rem' }}>
                                Motivational Focus
                            </div>
                            <div className="no-print">
                                <textarea
                                    className="form-input"
                                    style={{ background: 'var(--surface)', color: 'white', border: 'none', textAlign: 'center', fontSize: '1.25rem', fontWeight: 'bold' }}
                                    value={overview.messageOfWeek || ''}
                                    placeholder="Enter Message of the Week..."
                                    onChange={(e) => onUpdateWeek(week.id, 'overview', { ...overview, messageOfWeek: e.target.value })}
                                />
                            </div>
                            <div className="print-only" style={{ fontSize: '1.5rem', fontWeight: 'bold', fontStyle: 'italic' }}>
                                "{overview.messageOfWeek || 'Win The Day'}"
                            </div>
                        </div>

                        {/* Daily Schedule */}
                        <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                            {DAYS.map(day => {
                                const daySchedule = overview.dailySchedule[day];
                                const hasMeal = day === 'thursday' && overview.meal && (overview.meal.host || overview.meal.time);

                                return (
                                    <div key={day} className="card" style={{ padding: '1.25rem', borderLeft: '6px solid var(--accent)' }}>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                            <h2 style={{ margin: 0, fontSize: '1.5rem' }}>{DAY_LABELS[day]}</h2>
                                            <button className="btn no-print" onClick={() => setAddEventModal({ day })} disabled={isLocked}>
                                                <Icon name="Plus" size={16} style={{ marginRight: '6px' }} />
                                                Add Event
                                            </button>
                                        </div>

                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                                            {daySchedule.events.map(event => (
                                                <div key={event.id} style={{
                                                    padding: '1rem',
                                                    background: 'var(--bg-panel)',
                                                    borderRadius: '10px',
                                                    borderLeft: `5px solid ${getEventColor(event.type)}`,
                                                    display: 'flex',
                                                    justifyContent: 'space-between',
                                                    alignItems: 'center'
                                                }}>
                                                    <div>
                                                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '0.25rem' }}>
                                                            <span style={{ fontSize: '0.7rem', fontWeight: '800', textTransform: 'uppercase', background: getEventColor(event.type), color: 'white', padding: '2px 8px', borderRadius: '4px' }}>
                                                                {event.type === 'practice' ? 'Practice' : event.type === 'game' ? `${event.level} Game` : 'Event'}
                                                            </span>
                                                            {event.autoPopulated && <span style={{ fontSize: '0.75em', color: 'var(--text-secondary)', fontStyle: 'italic' }}>(Auto)</span>}
                                                        </div>

                                                        {event.type === 'practice' && (
                                                            <div style={{ fontSize: '1.1rem', fontWeight: '800' }}>
                                                                {event.start} - {event.end} {event.notes && <span style={{ fontWeight: 'normal', color: 'var(--text-secondary)', marginLeft: '0.5rem' }}>| {event.notes}</span>}
                                                            </div>
                                                        )}

                                                        {event.type === 'game' && (
                                                            <div>
                                                                <div style={{ fontSize: '1.1rem', fontWeight: '800' }}>
                                                                    {event.isHome ? '🏠 Home' : '🚌 Away'} vs {event.opponent}
                                                                </div>
                                                                <div style={{ display: 'flex', gap: '1rem', fontSize: '0.9rem', flexWrap: 'wrap', marginTop: '0.25rem' }}>
                                                                    <span>⏱️ Kickoff: <strong>{event.kickoff}</strong></span>
                                                                    {!event.isHome && <span>🚌 Bus: <strong>{event.busTime}</strong></span>}
                                                                    {!event.isHome && event.dismissalTime && <span style={{ color: '#f59e0b', fontWeight: '800' }}>⚠️ Dismiss: {event.dismissalTime}</span>}
                                                                    <span style={{ color: 'var(--text-secondary)' }}>📍 {event.location}</span>
                                                                </div>
                                                                <div style={{ display: 'flex', gap: '0.5rem', marginTop: '0.5rem' }}>
                                                                    <span style={{ fontSize: '0.8rem', background: 'var(--bg-app)', border: '1px solid var(--border)', padding: '2px 8px', borderRadius: '4px' }}>👕 {event.uniforms?.jersey} Jersey</span>
                                                                    <span style={{ fontSize: '0.8rem', background: 'var(--bg-app)', border: '1px solid var(--border)', padding: '2px 8px', borderRadius: '4px' }}>👖 {event.uniforms?.pants} Pants</span>
                                                                </div>
                                                            </div>
                                                        )}

                                                        {event.type === 'custom' && (
                                                            <div>
                                                                <div style={{ fontSize: '1.1rem', fontWeight: '800' }}>{event.title}</div>
                                                                <div style={{ fontSize: '0.9rem', color: 'var(--text-secondary)' }}>
                                                                    ⏰ {event.time} | 📍 {event.location}
                                                                </div>
                                                                {event.notes && <div style={{ fontSize: '0.85rem', marginTop: '0.25rem' }}>{event.notes}</div>}
                                                            </div>
                                                        )}
                                                    </div>

                                                    {!event.autoPopulated && !isLocked && (
                                                        <div className="no-print" style={{ display: 'flex', gap: '0.5rem' }}>
                                                            <button className="btn" onClick={() => setEditingEvent({ day, eventId: event.id, event })} style={{ padding: '4px 8px' }}>
                                                                <Icon name="Edit" size={14} />
                                                            </button>
                                                            <button className="btn" style={{ padding: '4px 8px', color: '#ef4444' }} onClick={() => {
                                                                if (confirm('Delete event?')) {
                                                                    const newSchedule = { ...overview.dailySchedule };
                                                                    newSchedule[day].events = newSchedule[day].events.filter(e => e.id !== event.id);
                                                                    onUpdateWeek(week.id, 'overview', { ...overview, dailySchedule: newSchedule });
                                                                }
                                                            }}>
                                                                <Icon name="Trash2" size={14} />
                                                            </button>
                                                        </div>
                                                    )}
                                                </div>
                                            ))}

                                            {hasMeal && (
                                                <div style={{ padding: '1rem', background: '#fefce8', borderRadius: '10px', borderLeft: '5px solid #eab308' }}>
                                                    <div style={{ fontSize: '0.7rem', fontWeight: '800', textTransform: 'uppercase', background: '#eab308', color: 'white', padding: '2px 8px', borderRadius: '4px', width: 'fit-content', marginBottom: '0.5rem' }}>
                                                        Team Meal
                                                    </div>
                                                    <div style={{ fontSize: '1.1rem', fontWeight: '800' }}>
                                                        🍴 {overview.meal.time} {overview.meal.host && <span style={{ fontWeight: 'normal', color: '#854d0e', marginLeft: '0.5rem' }}>@ {overview.meal.host}</span>}
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>

                    {(addEventModal || editingEvent) && (
                        <EventModal
                            day={addEventModal?.day || editingEvent?.day}
                            event={editingEvent?.event}
                            onClose={() => { setAddEventModal(null); setEditingEvent(null); }}
                            onSave={(data) => {
                                const newSchedule = { ...overview.dailySchedule };
                                if (editingEvent) {
                                    const idx = newSchedule[editingEvent.day].events.findIndex(e => e.id === editingEvent.eventId);
                                    newSchedule[editingEvent.day].events[idx] = { ...data, id: editingEvent.eventId };
                                } else {
                                    newSchedule[addEventModal.day].events.push({ ...data, id: `manual-${Date.now()}` });
                                }
                                onUpdateWeek(week.id, 'overview', { ...overview, dailySchedule: newSchedule });
                                setAddEventModal(null);
                                setEditingEvent(null);
                            }}
                        />
                    )}
                </div>
            );
        };

        const EventModal = ({ day, event, onClose, onSave }) => {
            const [type, setType] = useState(event?.type || 'game');
            const [level, setLevel] = useState(event?.level || 'JV');
            const [isHome, setIsHome] = useState(event?.isHome !== undefined ? event.isHome : true);
            const [opponent, setOpponent] = useState(event?.opponent || '');
            const [kickoff, setKickoff] = useState(event?.kickoff || '');
            const [busTime, setBusTime] = useState(event?.busTime || '');
            const [dismissalTime, setDismissalTime] = useState(event?.dismissalTime || '');
            const [location, setLocation] = useState(event?.location || '');
            const [uniforms, setUniforms] = useState(event?.uniforms || { jersey: 'White', pants: 'Red' });
            const [title, setTitle] = useState(event?.title || '');
            const [time, setTime] = useState(event?.time || '');
            const [notes, setNotes] = useState(event?.notes || '');

            return (
                <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.8)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 2000 }}>
                    <div className="card" style={{ width: '500px', maxWidth: '95%', maxHeight: '90vh', overflowY: 'auto' }}>
                        <h2>{event ? 'Edit' : 'Add'} Event for {day.toUpperCase()}</h2>

                        <div style={{ marginBottom: '1rem' }}>
                            <label className="form-label">Type</label>
                            <div className="btn-group">
                                <button className={`btn ${type === 'game' ? 'btn-primary' : ''}`} onClick={() => setType('game')}>Game</button>
                                <button className={`btn ${type === 'custom' ? 'btn-primary' : ''}`} onClick={() => setType('custom')}>Custom</button>
                            </div>
                        </div>

                        {type === 'game' && (
                            <>
                                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginBottom: '1rem' }}>
                                    <div>
                                        <label className="form-label">Level</label>
                                        <select className="form-select" value={level} onChange={(e) => setLevel(e.target.value)}>
                                            <option>JV</option>
                                            <option>JV2</option>
                                            <option>Varsity</option>
                                            <option>Freshman</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label className="form-label">Location Type</label>
                                        <div className="btn-group">
                                            <button className={`btn ${isHome ? 'btn-primary' : ''}`} onClick={() => setIsHome(true)}>Home</button>
                                            <button className={`btn ${!isHome ? 'btn-primary' : ''}`} onClick={() => setIsHome(false)}>Away</button>
                                        </div>
                                    </div>
                                </div>
                                <div style={{ marginBottom: '1rem' }}>
                                    <label className="form-label">Opponent</label>
                                    <input className="form-input" value={opponent} onChange={(e) => setOpponent(e.target.value)} placeholder="Central High" />
                                </div>
                                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginBottom: '1rem' }}>
                                    <div>
                                        <label className="form-label">Kickoff</label>
                                        <input className="form-input" value={kickoff} onChange={(e) => setKickoff(e.target.value)} placeholder="6:00 PM" />
                                    </div>
                                    <div>
                                        <label className="form-label">Location</label>
                                        <input className="form-input" value={location} onChange={(e) => setLocation(e.target.value)} placeholder="Stadium" />
                                    </div>
                                </div>
                                {!isHome && (
                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginBottom: '1rem' }}>
                                        <div>
                                            <label className="form-label">Bus Departure</label>
                                            <input className="form-input" value={busTime} onChange={(e) => setBusTime(e.target.value)} placeholder="4:30 PM" />
                                        </div>
                                        <div>
                                            <label className="form-label">Dismissal</label>
                                            <input className="form-input" value={dismissalTime} onChange={(e) => setDismissalTime(e.target.value)} placeholder="2:30 PM" />
                                        </div>
                                    </div>
                                )}
                                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginBottom: '1rem' }}>
                                    <div>
                                        <label className="form-label">Jersey</label>
                                        <select className="form-select" value={uniforms.jersey} onChange={(e) => setUniforms({ ...uniforms, jersey: e.target.value })}>
                                            <option>White</option><option>Red</option><option>Black</option><option>Grey</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label className="form-label">Pants</label>
                                        <select className="form-select" value={uniforms.pants} onChange={(e) => setUniforms({ ...uniforms, pants: e.target.value })}>
                                            <option>White</option><option>Red</option><option>Black</option><option>Grey</option>
                                        </select>
                                    </div>
                                </div>
                            </>
                        )}

                        {type === 'custom' && (
                            <>
                                <div style={{ marginBottom: '1rem' }}>
                                    <label className="form-label">Title</label>
                                    <input className="form-input" value={title} onChange={(e) => setTitle(e.target.value)} placeholder="High-Five Friday" />
                                </div>
                                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginBottom: '1rem' }}>
                                    <div>
                                        <label className="form-label">Time</label>
                                        <input className="form-input" value={time} onChange={(e) => setTime(e.target.value)} placeholder="7:30 AM" />
                                    </div>
                                    <div>
                                        <label className="form-label">Location</label>
                                        <input className="form-input" value={location} onChange={(e) => setLocation(e.target.value)} placeholder="Elementary" />
                                    </div>
                                </div>
                                <div style={{ marginBottom: '1rem' }}>
                                    <label className="form-label">Notes</label>
                                    <textarea className="form-input" value={notes} onChange={(e) => setNotes(e.target.value)} />
                                </div>
                            </>
                        )}

                        <div style={{ display: 'flex', gap: '1rem', marginTop: '1rem' }}>
                            <button className="btn" onClick={onClose} style={{ flex: 1 }}>Cancel</button>
                            <button className="btn btn-primary" style={{ flex: 2 }} onClick={() => onSave({ type, level, isHome, opponent, kickoff, busTime, dismissalTime, location, uniforms, title, time, notes })}>Save</button>
                        </div>
                    </div>

                </div>
            );
        };








        const SeasonSetupView = ({ weeks, onUpdateWeek, onAddWeek, onDeleteWeek, mode = 'season' }) => {
            const getWeekNum = (w) => {
                if (w.weekNum !== undefined) return w.weekNum;
                const match = w.name.match(/Week (\d+)/);
                if (match) return parseInt(match[1]);
                if (w.name === "Week 0") return 0;
                return 99;
            };

            const sortedWeeks = weeks.filter(w => {
                if (mode === 'summer') return w.name.includes("Summer");
                if (mode === 'pre-season') return ["Family Week", "Camp Week", "First Week of Practice", "Week 0"].includes(w.name);
                return (w.name.startsWith("Week ") && !w.name.includes("Summer")) || w.name === "First Week with No Game";
            }).sort((a, b) => getWeekNum(a) - getWeekNum(b));

            const handleAutofillDates = () => {
                if (!confirm('This will autofill dates for subsequent weeks based on the first set date (adding 7 days recursively). Existing dates after the start point will be overwritten. Continue?')) return;

                let lastDate = null;
                sortedWeeks.forEach(week => {
                    if (week.date) {
                        const [y, m, d] = week.date.split('-').map(Number);
                        // Note: Month is 0-indexed in Date constructor, but if parsing "2023-08-01",
                        // we want to be careful. Let's use standard Date parsing which works well with YYYY-MM-DD
                        // actually explicit is safer to avoid timezone issues:
                        if (y && m && d) lastDate = new Date(y, m - 1, d);
                    } else if (lastDate) {
                        const nextDate = new Date(lastDate);
                        nextDate.setDate(nextDate.getDate() + 7);
                        lastDate = nextDate; // update reference

                        const y = nextDate.getFullYear();
                        const m = String(nextDate.getMonth() + 1).padStart(2, '0');
                        const d = String(nextDate.getDate()).padStart(2, '0');
                        onUpdateWeek(week.id, 'date', `${y}-${m}-${d}`);
                    }
                });
            };

            const getTitle = () => {
                if (mode === 'summer') return 'Summer Setup';
                if (mode === 'pre-season') return 'Pre-Season Setup';
                return 'Season Setup';
            };

            const getIcon = () => {
                if (mode === 'summer') return 'Sun';
                if (mode === 'pre-season') return 'Zap';
                return 'Calendar';
            };

            return (
                <div style={{ padding: '2rem', maxWidth: '1400px', margin: '0 auto' }}>
                    <div className="card" style={{ padding: '2rem', background: '#1e293b', color: 'white', border: '1px solid #334155' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '2rem', borderBottom: '1px solid #334155', paddingBottom: '1rem' }}>
                            <h2 style={{ display: 'flex', alignItems: 'center', gap: '0.75rem', margin: 0 }}>
                                <Icon name={getIcon()} size={28} color="#60a5fa" />
                                {getTitle()}
                            </h2>
                            <button className="btn btn-secondary" onClick={handleAutofillDates}>
                                <Icon name="RotateCw" size={16} /> Autofill Dates
                            </button>
                        </div>

                        <div style={{ overflowX: 'auto' }}>
                            <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                                <thead>
                                    <tr style={{ background: '#0f172a', textTransform: 'uppercase', fontSize: '0.85rem', letterSpacing: '0.05em' }}>
                                        <th style={{ padding: '1rem', textAlign: 'left', borderBottom: '1px solid #334155' }}>Week</th>
                                        {mode === 'season' && <th style={{ padding: '1rem', textAlign: 'left', borderBottom: '1px solid #334155' }}>Opponent Name</th>}
                                        <th style={{ padding: '1rem', textAlign: 'left', borderBottom: '1px solid #334155' }}>Week of (Monday)</th>
                                        {mode === 'season' && <th style={{ padding: '1rem', textAlign: 'center', borderBottom: '1px solid #334155' }}>Home / Away</th>}
                                        <th style={{ padding: '1rem', textAlign: 'left', borderBottom: '1px solid #334155' }}>Label Preview</th>
                                        <th style={{ padding: '1rem', textAlign: 'center', borderBottom: '1px solid #334155' }}>Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {sortedWeeks.map(week => (
                                        <tr key={week.id} style={{ borderBottom: '1px solid #334155' }}>
                                            <td style={{ padding: '1rem', fontWeight: 'bold', color: '#94a3b8' }}>{week.name}</td>
                                            {mode === 'season' && (
                                                <td style={{ padding: '1rem' }}>
                                                    <input
                                                        type="text"
                                                        className="form-input"
                                                        placeholder="Enter Opponent..."
                                                        value={week.opponent || ''}
                                                        onChange={(e) => onUpdateWeek(week.id, 'opponent', e.target.value)}
                                                        style={{ background: '#334155', color: 'white', border: '1px solid #475569', width: '100%' }}
                                                    />
                                                </td>
                                            )}
                                            <td style={{ padding: '1rem' }}>
                                                <input
                                                    type="date"
                                                    className="form-input"
                                                    value={week.date || ''}
                                                    onChange={(e) => onUpdateWeek(week.id, 'date', e.target.value)}
                                                    style={{ background: '#334155', color: 'white', border: '1px solid #475569', width: '100%' }}
                                                />
                                            </td>
                                            {mode === 'season' && (
                                                <td style={{ padding: '1rem', textAlign: 'center' }}>
                                                    <div style={{ display: 'flex', justifyContent: 'center', gap: '0.5rem' }}>
                                                        <button
                                                            onClick={() => onUpdateWeek(week.id, 'isHome', true)}
                                                            style={{
                                                                padding: '0.5rem 1rem',
                                                                borderRadius: '6px',
                                                                border: '1px solid',
                                                                background: week.isHome ? '#3b82f6' : 'transparent',
                                                                color: week.isHome ? 'white' : '#64748b',
                                                                borderColor: week.isHome ? '#3b82f6' : '#475569',
                                                                cursor: 'pointer', fontWeight: 'bold'
                                                            }}
                                                        >
                                                            Home
                                                        </button>
                                                        <button
                                                            onClick={() => onUpdateWeek(week.id, 'isHome', false)}
                                                            style={{
                                                                padding: '0.5rem 1rem',
                                                                borderRadius: '6px',
                                                                border: '1px solid',
                                                                background: !week.isHome === true && week.isHome !== undefined ? '#ef4444' : (week.isHome === false ? '#ef4444' : 'transparent'),
                                                                color: week.isHome === false ? 'white' : '#64748b',
                                                                borderColor: week.isHome === false ? '#ef4444' : '#475569',
                                                                cursor: 'pointer', fontWeight: 'bold'
                                                            }}
                                                        >
                                                            Away
                                                        </button>
                                                    </div>
                                                </td>
                                            )}
                                            <td style={{ padding: '1rem', color: '#cbd5e1', fontStyle: 'italic' }}>
                                                Week {week.weekNum} {week.opponent ? `- ${week.opponent} (${week.isHome ? 'H' : 'A'})` : ''}
                                            </td>
                                            <td style={{ padding: '1rem', textAlign: 'center' }}>
                                                <button
                                                    onClick={() => onDeleteWeek(week.id)}
                                                    style={{
                                                        background: 'transparent',
                                                        border: 'none',
                                                        color: '#ef4444',
                                                        cursor: 'pointer',
                                                        opacity: 0.7,
                                                        padding: '0.4rem',
                                                        borderRadius: '4px'
                                                    }}
                                                    className="hover-bg-slate-700"
                                                    title="Delete Week"
                                                >
                                                    <Icon name="Trash" size={18} />
                                                </button>
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                        <div style={{ marginTop: '2rem', display: 'flex', justifyContent: 'center' }}>
                            <button className="btn btn-primary" onClick={onAddWeek} style={{ padding: '0.75rem 1.5rem', fontSize: '1rem', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                <Icon name="Plus" size={18} /> Add Next Week
                            </button>
                        </div>
                    </div>
                </div >
            );
        };

        const SchoolSetupWizard = ({ schoolId, onComplete }) => {
            const [localSchoolName, setLocalSchoolName] = useState('');
            const [localMascot, setLocalMascot] = useState('🦅');
            const [primaryColor, setPrimaryColor] = useState('#0ea5e9'); // Default Blue
            const [isInitializing, setIsInitializing] = useState(false);

            const handleInitialize = async () => {
                if (!localSchoolName) return;

                // Silent Wipe (No Confirm)

                setIsInitializing(true);

                try {
                    const userId = window.auth.currentUser.uid;
                    const userRef = window.db.collection('users').doc(userId);

                    // 1. WIPE LOCAL DATA (Clean Slate)
                    const keysToWipe = [
                        'oc-dashboard-roster', 'oc-dashboard-plays', 'oc-dashboard-staff',
                        'oc-dashboard-depthchart', 'attendance_log',
                        'formationLayouts', 'oc-dashboard-ratings', 'oc-dashboard-game-grades',
                        'oc-dashboard-scouting',
                        'athlete_assessments', 'oc-dashboard-formations', 'oc-dashboard-zone-philosophies',
                        'oc-dashboard-custom-focus',
                        'oc-dashboard-position-names', 'staff_role_tasks',
                        'wiz_ol_library', 'oc-dashboard-weeks',
                        'oc-dashboard-game-plans', 'oc-dashboard-scripts',
                        'oc-dashboard-logo', 'oc-dashboard-theme', 'oc-dashboard-accent',
                        'hc_school_billing', 'hc_school_id', 'hc_school_name', 'hc-active-year', 'hc-visible-features'
                    ];

                    keysToWipe.forEach(key => localStorage.removeItem(key));

                    // 2. SET DEFAULTS
                    localStorage.setItem('oc-dashboard-accent', primaryColor);
                    localStorage.setItem('hc_school_id', schoolId); // Bind immediately

                    // 3. UPDATE FIRESTORE (School Doc)
                    const joinCode = Math.random().toString(36).substring(2, 8).toUpperCase();

                    // 4. Create School Document
                    await window.db.collection('schools').doc(schoolId).set({
                        name: localSchoolName,
                        mascot: localMascot,
                        joinCode: joinCode, // NEW: Join Code for onboarding
                        primaryColor: primaryColor,
                        initialized: true,
                        createdAt: new Date().toISOString(),
                        createdBy: window.auth.currentUser.email,
                        roster: [], // Explicit empty
                        staff: [], // Explicit empty
                        plays: [], // Explicit empty
                        billing: {
                            plan: 'trial',
                            status: 'active',
                            trialEndsAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),
                            promoCode: null,
                            subscriptionEndsAt: null,
                            features: {}
                        }
                    });

                    // 4. CRITICAL: UPDATE USER PROFILE & WIPE PERSONAL DATA
                    // This ensures loadUserDataFromFirestore switches to School Mode
                    // and doesn't fall back to old personal data.
                    await userRef.set({
                        schoolId: schoolId, // LINK USER TO SCHOOL
                        // Wipe potential leaky fields from personal doc
                        roster: firebase.firestore.FieldValue.delete(),
                        plays: firebase.firestore.FieldValue.delete(),
                        staff: firebase.firestore.FieldValue.delete(),
                        weeks: firebase.firestore.FieldValue.delete(),
                        inventory: firebase.firestore.FieldValue.delete(),
                        attendance: firebase.firestore.FieldValue.delete(),

                        settings: {
                            activeYear: '2025',
                            theme: 'dark', // Reset theme
                            accentColor: primaryColor
                        }
                    }, { merge: true });

                    // 4b. CREATE MEMBERSHIP (Explicit)
                    await window.db.collection('users').doc(userId).collection('memberships').doc(schoolId).set({
                        role: 'admin',
                        joinedAt: new Date().toISOString(),
                        status: 'active'
                    });

                    // 5. COMPLETE
                    // alert(`Welcome to ${localSchoolName}! Your workspace is ready.`); // Removed explicit alert to be faster
                    onComplete();

                } catch (err) {
                    console.error("Error initializing school:", err);
                    alert("Failed to initialize school: " + err.message);
                    setIsInitializing(false);
                }
            };

            return (
                <div style={{
                    position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
                    background: '#0f172a', color: 'white', zIndex: 9999,
                    display: 'flex', alignItems: 'center', justifyContent: 'center'
                }}>
                    <div style={{
                        background: '#1e293b', padding: '2rem', borderRadius: '12px',
                        maxWidth: '500px', width: '90%', border: '1px solid #334155',
                        boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.5)'
                    }}>
                        <div style={{ textAlign: 'center', marginBottom: '2rem' }}>
                            <div style={{ fontSize: '3rem', marginBottom: '1rem' }}>🎉</div>
                            <h2 style={{ fontSize: '1.8rem', fontWeight: 'bold', marginBottom: '0.5rem' }}>Welcome, Coach!</h2>
                            <p style={{ color: '#94a3b8' }}>Let's set up your new school workspace.</p>
                        </div>

                        <div style={{ display: 'flex', flexDirection: 'column', gap: '1.5rem' }}>
                            <div>
                                <label style={{ display: 'block', fontSize: '0.9rem', marginBottom: '0.5rem', color: '#cbd5e1' }}>School Name</label>
                                <input
                                    type="text"
                                    className="form-input"
                                    placeholder="e.g. Central High School"
                                    value={localSchoolName}
                                    onChange={(e) => setLocalSchoolName(e.target.value)}
                                    style={{ width: '100%', padding: '0.75rem', fontSize: '1.1rem' }}
                                    autoFocus
                                />
                            </div>

                            <div>
                                <label style={{ display: 'block', fontSize: '0.9rem', marginBottom: '0.5rem', color: '#cbd5e1' }}>Primary Color</label>
                                <div style={{ display: 'flex', gap: '0.75rem', flexWrap: 'wrap' }}>
                                    {[
                                        '#0ea5e9', // Sky Blue
                                        '#ef4444', // Red
                                        '#22c55e', // Green
                                        '#eab308', // Yellow
                                        '#f97316', // Orange
                                        '#a855f7', // Purple
                                        '#ec4899', // Pink
                                        '#64748b', // Slate
                                        '#000000', // Black
                                        '#1e1b4b'  // Navy
                                    ].map(color => (
                                        <button
                                            key={color}
                                            onClick={() => setPrimaryColor(color)}
                                            style={{
                                                width: '32px', height: '32px', borderRadius: '50%',
                                                background: color,
                                                border: primaryColor === color ? '3px solid white' : '1px solid rgba(255,255,255,0.2)',
                                                cursor: 'pointer',
                                                transform: primaryColor === color ? 'scale(1.1)' : 'scale(1)',
                                                transition: 'all 0.2s',
                                                boxShadow: primaryColor === color ? `0 0 10px ${color}` : 'none'
                                            }}
                                        />
                                    ))}
                                </div>
                            </div>

                            <button
                                className="btn btn-primary"
                                onClick={handleInitialize}
                                disabled={!localSchoolName || isInitializing}
                                style={{
                                    marginTop: '1rem', padding: '1rem',
                                    fontSize: '1.1rem', justifyContent: 'center',
                                    background: primaryColor,
                                    opacity: (!localSchoolName || isInitializing) ? 0.5 : 1
                                }}
                            >
                                {isInitializing ? 'Setting up...' : 'Create New School'}
                            </button>
                        </div>
                    </div>
                </div>
            );
        };


        const SchoolSwitcher = ({ userId, currentSchoolId }) => {
            const [memberships, setMemberships] = useState([]);
            const [schools, setSchools] = useState({});
            const [loading, setLoading] = useState(true);

            useEffect(() => {
                const fetchMemberships = async () => {
                    if (!userId) return;
                    try {
                        const memSnapshot = await window.db.collection('users').doc(userId).collection('memberships').get();
                        if (memSnapshot.empty) {
                            setLoading(false);
                            return;
                        }

                        const mems = memSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        setMemberships(mems);

                        // Fetch names for these schools
                        const schoolIds = mems.map(m => m.id);
                        // Firestore "in" query limited to 10, split if needed but assuming < 10 for now
                        if (schoolIds.length > 0) {
                            const schoolsMap = {};
                            // Use Promise.all for simplicity over 'in' query limitations if list is small
                            await Promise.all(schoolIds.map(async (sid) => {
                                const doc = await window.db.collection('schools').doc(sid).get();
                                if (doc.exists) schoolsMap[sid] = doc.data().name;
                                else schoolsMap[sid] = "Unknown School";
                            }));
                            setSchools(schoolsMap);
                        }
                    } catch (err) {
                        console.error("Error loading memberships:", err);
                    }
                    setLoading(false);
                };
                fetchMemberships();
            }, [userId]);

            if (loading) return <div style={{ fontSize: '0.8rem', opacity: 0.5 }}>Loading schools...</div>;
            if (memberships.length <= 1) return null; // Only show if multiple schools

            return (
                <div style={{ marginTop: '0.5rem', marginBottom: '1rem' }}>
                    <label style={{ fontSize: '0.7rem', color: 'var(--text-secondary)', textTransform: 'uppercase', letterSpacing: '0.05em' }}>Switch School</label>
                    <select
                        className="form-select"
                        value={currentSchoolId || ''}
                        onChange={(e) => {
                            const newId = e.target.value;
                            if (newId && newId !== currentSchoolId) {
                                if (confirm(`Switch to ${schools[newId]}?`)) {
                                    localStorage.setItem('hc_school_id', newId);
                                    // Ensure clean slate for new context
                                    localStorage.removeItem('oc-dashboard-roster');
                                    localStorage.removeItem('oc-dashboard-plays');
                                    localStorage.removeItem('oc-dashboard-staff');
                                    window.location.reload();
                                }
                            }
                        }}
                        style={{ width: '100%', fontSize: '0.85rem', padding: '0.25rem', marginTop: '0.25rem', background: 'var(--surface)', border: '1px solid var(--border)' }}
                    >
                        {memberships.map(m => (
                            <option key={m.id} value={m.id}>
                                {schools[m.id] || m.id} ({m.role})
                            </option>
                        ))}
                    </select>
                </div>
            );
        };

        const getSchoolPlan = (school, user) => {
            if (!school) return 'FREE';

            // 1. Site Admin Bypass
            // Hardcoded for safety across entire app context
            const SITE_ADMINS = ['matthewfinn14@gmail.com', 'admin@digitaldofo.com'];
            if (user && user.email && SITE_ADMINS.includes(user.email.toLowerCase())) {
                return 'ALL_ACCESS';
            }

            const billing = school.billing || {};

            // Default to 'free' if no plan set, BUT if it is a legacy school without billing,
            // we might want to grandfather them or default to trial? 
            // For now, let's assume default is FREE unless migrated.
            const plan = billing.plan || 'free';
            const now = new Date();

            // 2. Trial Check
            if (plan === 'trial') {
                if (billing.trialEndsAt && new Date(billing.trialEndsAt) > now) {
                    return 'PREMIUM_TRIAL';
                }
                return 'FREE'; // Trial Expired
            }

            // 3. Premium Check
            if (plan === 'premium') {
                // If subscription has an end date (e.g. from promo), check it
                if (billing.subscriptionEndsAt && new Date(billing.subscriptionEndsAt) <= now) {
                    return 'FREE'; // Expired
                }
                return 'PREMIUM';
            }

            // 4. All Access (Configured manually)
            if (plan === 'all_access') return 'ALL_ACCESS';

            return 'FREE';
        };

        const LEGACY_PROGRAM_RECORDS = {
            'Squat': {
                '320+': {
                    'PR': { value: '--', holder: '-', year: '-' }
                },
                '310-319': {
                    '12': { value: '470', holder: 'David Downs', year: '8/20' },
                    'PR': { value: '470', holder: 'David Downs', year: '8/20' }
                },
                '300-309': {
                    '12': { value: '480', holder: 'Tyler Heithoff', year: '7/22' },
                    '11': { value: '465', holder: 'Tyler Heithoff', year: '5/22' },
                    '10': { value: '350', holder: 'Tyler Heithoff', year: '5/21' },
                    '9': { value: '240', holder: 'Patrick Gomez', year: '5/22' },
                    'PR': { value: '480', holder: 'Tyler Heithoff', year: '7/22' }
                },
                '290-299': {
                    '12': { value: '315', holder: 'Colin Hansen', year: '8/21' },
                    '11': { value: '280', holder: 'Colin Hansen', year: '5/21' },
                    '10': { value: '315', holder: 'Tyler Heithoff', year: '2/21' },
                    '9': { value: '220', holder: 'Patrick Gomez', year: '11/21' },
                    'PR': { value: '315', holder: 'C. Hansen / T. Heithoff', year: '2021' }
                },
                '280-289': {
                    '12': { value: '355', holder: 'Carson Barber', year: '7/24' },
                    '11': { value: '455', holder: 'Aaron Peyton', year: '5/23' },
                    '10': { value: '350', holder: 'Carson Barber', year: '5/23' },
                    'PR': { value: '455', holder: 'Aaron Peyton', year: '5/23' }
                },
                '270-279': {
                    '12': { value: '455', holder: 'Aaron Peyton', year: '7/23' },
                    '10': { value: '315', holder: 'Carson Barber', year: '10/22' },
                    '9': { value: '270', holder: 'Carson Barber', year: '5/22' },
                    'PR': { value: '455', holder: 'Aaron Peyton', year: '7/23' }
                },
                '260-269': {
                    '11': { value: '415', holder: 'Aaron Peyton', year: '10/22' },
                    '9': { value: '250', holder: 'Carson Barber', year: '2/22' },
                    'PR': { value: '415', holder: 'Aaron Peyton', year: '10/22' }
                },
                '250-259': {
                    '11': { value: '450', holder: 'Record Holder', year: '5/24' },
                    '10': { value: '365', holder: 'Aaron Peyton', year: '5/22' },
                    '9': { value: '230', holder: 'Carson Barber', year: '11/21' },
                    'PR': { value: '450', holder: 'Record Holder', year: '5/24' }
                },
                '240-249': {
                    '12': { value: '405', holder: 'W. Licht, T. Tjaden, T. Peterson', year: '23/24' },
                    '11': { value: '415', holder: 'Record Holder', year: '7/23' },
                    '10': { value: '380', holder: 'Record Holder', year: '2/23' },
                    '9': { value: '225', holder: 'Jackson Mohr', year: '2/23' },
                    'PR': { value: '415', holder: 'Record Holder', year: '7/23' }
                },
                '230-239': {
                    '12': { value: '400', holder: 'Wes Hansen', year: '7/24' },
                    '11': { value: '425', holder: 'Wes Hansen', year: '5/24' },
                    '10': { value: '335', holder: 'Aaron Peyton', year: '2/22' },
                    'PR': { value: '425', holder: 'Wes Hansen', year: '5/24' }
                },
                '220-229': {
                    '12': { value: '470', holder: 'Zach Twedt', year: '8/20' },
                    '11': { value: '445', holder: 'Charlie Watts', year: '2/24' },
                    '10': { value: '340', holder: 'Wes Hansen', year: '5/23' },
                    '9': { value: '285', holder: 'Blake Nelsen', year: '2/23' },
                    'PR': { value: '470', holder: 'Zach Twedt', year: '8/20' }
                },
                '210-219': {
                    '12': { value: '460', holder: 'Garret Nerem', year: '7/24' },
                    '11': { value: '425', holder: 'Garrett Nerem', year: '5/24' },
                    '10': { value: '335', holder: 'Tristan Peterson', year: '5/23' },
                    '9': { value: '340', holder: 'Jake Rogers', year: '5/23' },
                    'PR': { value: '460', holder: 'Garret Nerem', year: '7/24' }
                },
                '200-209': {
                    '12': { value: '280', holder: 'Parker Watts', year: '8/21' },
                    '11': { value: '415', holder: 'C. Watts / G. Nerem', year: '23/24' },
                    '10': { value: '425', holder: 'Fiston Carlson', year: '7/24' },
                    '9': { value: '335', holder: 'Jake Rogers', year: '2/23' },
                    'PR': { value: '425', holder: 'Fiston Carlson', year: '7/24' }
                },
                '190-199': {
                    '12': { value: '285', holder: 'Logan Schnurr', year: '8/21' },
                    '11': { value: '400', holder: 'Cael Vermeer', year: '7/24' },
                    '10': { value: '350', holder: 'Cael Vermeer', year: '7/23' },
                    '9': { value: '430', holder: 'Fiston Carlson', year: '5/24' },
                    'PR': { value: '430', holder: 'Fiston Carlson', year: '5/24' }
                },
                '180-189': {
                    '12': { value: '380', holder: 'Sam Knoll', year: '7/24' },
                    '11': { value: '440', holder: 'Fiston Carlson', year: '7/25' },
                    '10': { value: '355', holder: 'Ben Licht', year: '7/24' },
                    '9': { value: '360', holder: 'Fiston Carlson', year: '7/23' },
                    'PR': { value: '440', holder: 'Fiston Carlson', year: '7/25' }
                },
                '170-179': {
                    '12': { value: '355', holder: 'D. Lettow / H. Johnson', year: '22/23' },
                    '11': { value: '340', holder: 'Tyler Lambert', year: '7/25' },
                    '10': { value: '350', holder: 'Isaac Miskell', year: '7/24' },
                    '9': { value: '345', holder: 'Isaac Miskell', year: '2/24' },
                    'PR': { value: '355', holder: 'D. Lettow / H. Johnson', year: '22/23' }
                },
                '160-169': {
                    '12': { value: '320', holder: 'Heston McIlrath', year: '7/24' },
                    '11': { value: '350', holder: 'Sam Knoll', year: '7/23' },
                    '10': { value: '335', holder: 'Cooper Triggs', year: '7/24' },
                    '9': { value: '300', holder: 'Ben Licht', year: '10/23' },
                    'PR': { value: '350', holder: 'Sam Knoll', year: '7/23' }
                },
                '150-159': {
                    '12': { value: '315', holder: 'G. Carpenter / C. Long', year: '22/25' },
                    '11': { value: '345', holder: 'Cody Long', year: '7/24' },
                    '10': { value: '330', holder: 'Cody Long', year: '11/23' },
                    '9': { value: '355', holder: 'Ben Mazyck', year: '10/23' },
                    'PR': { value: '355', holder: 'Ben Mazyck', year: '10/23' }
                },
                '140-149': {
                    '12': { value: '290', holder: 'C. Diehl / J. Martin', year: '21/22' },
                    '11': { value: '275', holder: 'Blake Larson', year: '7/24' },
                    '10': { value: '315', holder: 'Cody Long', year: '7/23' },
                    '9': { value: '305', holder: 'Ben Mazyck', year: '7/23' },
                    'PR': { value: '315', holder: 'Cody Long', year: '7/23' }
                },
                '130-139': {
                    '11': { value: '255', holder: 'Jake Knoll', year: '7/25' },
                    '10': { value: '275', holder: 'Jake Knoll', year: '7/24' },
                    '9': { value: '270', holder: 'C. Long / B. Loof', year: '22/23' },
                    'PR': { value: '275', holder: 'Jake Knoll', year: '7/24' }
                },
                '120-129': {
                    '11': { value: '215', holder: 'Noah Healy', year: '7/25' },
                    '9': { value: '260', holder: 'Brady Long', year: '7/24' },
                    'PR': { value: '260', holder: 'Brady Long', year: '7/24' }
                },
                '110-119': {
                    '11': { value: '180', holder: 'Brayden Kilstofte', year: '11/21' },
                    '9': { value: '195', holder: 'B. Larson / M. Dahlsten', year: '23/25' },
                    'PR': { value: '195', holder: 'B. Larson / M. Dahlsten', year: '23/25' }
                },
                '100-109': {
                    '11': { value: '160', holder: 'Brayden Kilstofte', year: '8/21' },
                    '9': { value: '185', holder: 'Blake Larson', year: '10/22' },
                    'PR': { value: '185', holder: 'Blake Larson', year: '10/22' }
                }
            },
            'Bench': {
                '320+': {
                    'PR': { value: '--', holder: '-', year: '-' }
                },
                '310-319': {
                    '12': { value: '295', holder: 'David Downs', year: '8/20' },
                    'PR': { value: '295', holder: 'David Downs', year: '8/20' }
                },
                '300-309': {
                    '12': { value: '250', holder: 'Tyler Heithoff', year: '7/22' },
                    '11': { value: '250', holder: 'Tyler Heithoff', year: '5/22' },
                    '9': { value: '170', holder: 'Patrick Gomez', year: '5/22' },
                    'PR': { value: '250', holder: 'Tyler Heithoff', year: '2022' }
                },
                '290-299': {
                    '12': { value: '175', holder: 'Colin Hansen', year: '8/21' },
                    '11': { value: '165', holder: 'Colin Hansen', year: '5/21' },
                    '10': { value: '185', holder: 'Tyler Heithoff', year: '2/21' },
                    '9': { value: '155', holder: 'Patrick Gomez', year: '11/21' },
                    'PR': { value: '185', holder: 'Tyler Heithoff', year: '2/21' }
                },
                '280-289': {
                    '12': { value: '220', holder: 'Carson Barber', year: '7/24' },
                    '11': { value: '220', holder: 'Carson Barber', year: '7/23' },
                    '10': { value: '215', holder: 'Carson Barber', year: '5/23' },
                    'PR': { value: '220', holder: 'Carson Barber', year: '23/24' }
                },
                '270-279': {
                    '12': { value: '245', holder: 'Aaron Peyton', year: '7/23' },
                    '10': { value: '195', holder: 'Carson Barber', year: '10/22' },
                    '9': { value: '175', holder: 'Carson Barber', year: '5/22' },
                    'PR': { value: '245', holder: 'Aaron Peyton', year: '7/23' }
                },
                '260-269': {
                    '11': { value: '245', holder: 'Aaron Peyton', year: '10/22' },
                    '10': { value: '155', holder: 'Carson Barber', year: '2/22' },
                    'PR': { value: '245', holder: 'Aaron Peyton', year: '10/22' }
                },
                '250-259': {
                    '11': { value: '245', holder: 'Aaron Peyton', year: '7/22' },
                    '10': { value: '245', holder: 'Aaron Peyton', year: '5/22' },
                    '9': { value: '145', holder: 'Carson Barber', year: '11/21' },
                    'PR': { value: '245', holder: 'Aaron Peyton', year: '2022' }
                },
                '240-249': {
                    '12': { value: '280', holder: 'William Licht', year: '7/23' },
                    '11': { value: '255', holder: 'Thomas Tjaden', year: '5/23' },
                    '10': { value: '215', holder: 'Aaron Peyton', year: '11/21' },
                    '9': { value: '170', holder: 'Jackson Mohr', year: '10/22' },
                    'PR': { value: '280', holder: 'William Licht', year: '7/23' }
                },
                '230-239': {
                    '12': { value: '265', holder: 'Blake Nelsen', year: '8/25' },
                    '11': { value: '270', holder: 'William Licht', year: '5/23' },
                    '10': { value: '215', holder: 'Record Holder', year: '10/22' },
                    'PR': { value: '270', holder: 'William Licht', year: '5/23' }
                },
                '220-229': {
                    '12': { value: '315', holder: 'Jimmy Philipsen', year: '8/20' },
                    '11': { value: '280', holder: 'Charlie Watts', year: '2/24' },
                    '10': { value: '190', holder: 'Wes Hansen', year: '5/23' },
                    '9': { value: '185', holder: 'Aaron Peyton', year: '5/21' },
                    'PR': { value: '315', holder: 'Jimmy Philipsen', year: '8/20' }
                },
                '210-219': {
                    '12': { value: '255', holder: 'Garrett Nerem', year: '7/24' },
                    '11': { value: '300', holder: 'Chance Georgius', year: '7/25' },
                    '10': { value: '250', holder: 'William Licht', year: '5/22' },
                    '9': { value: '245', holder: 'Jake Rogers', year: '5/23' },
                    'PR': { value: '300', holder: 'Chance Georgius', year: '7/25' }
                },
                '200-209': {
                    '12': { value: '230', holder: 'Jonovan Wilkinson', year: '7/23' },
                    '11': { value: '270', holder: 'Charlie Watts', year: '7/23' },
                    '10': { value: '235', holder: 'William Licht', year: '2/22' },
                    '9': { value: '225', holder: 'Blake Winecoff', year: '7/25' },
                    'PR': { value: '270', holder: 'Charlie Watts', year: '7/23' }
                },
                '190-199': {
                    '12': { value: '170', holder: 'Logan Schnurr', year: '8/21' },
                    '11': { value: '210', holder: 'Jonovan Wilkinson', year: '10/22' },
                    '10': { value: '270', holder: 'Charlie Watts', year: '5/23' },
                    '9': { value: '305', holder: 'Fiston Carlson', year: '2/24' },
                    'PR': { value: '305', holder: 'Fiston Carlson', year: '2/24' }
                },
                '180-189': {
                    '12': { value: '280', holder: 'Christian Eslick', year: '7/22' },
                    '11': { value: '325', holder: 'Fiston Carlson', year: '7/25' },
                    '10': { value: '215', holder: 'G. Nerem / C. Barber', year: '23/24' },
                    '9': { value: '255', holder: 'Fiston Carlson', year: '7/23' },
                    'PR': { value: '325', holder: 'Fiston Carlson', year: '7/25' }
                },
                '170-179': {
                    '12': { value: '220', holder: 'Jackson Sterle', year: '8/20' },
                    '11': { value: '245', holder: 'Ben Mazyck', year: '7/25' },
                    '10': { value: '215', holder: 'Isaac Miskell', year: '7/24' },
                    '9': { value: '210', holder: 'Ben Licht', year: '2/24' },
                    'PR': { value: '245', holder: 'Ben Mazyck', year: '7/25' }
                },
                '160-169': {
                    '12': { value: '235', holder: 'Heston McIlrath', year: '7/24' },
                    '11': { value: '200', holder: 'Q. Ante / D. Lettow', year: '21/21' },
                    '10': { value: '235', holder: 'Sam Knoll', year: '2/23' },
                    '9': { value: '195', holder: 'S. Knoll / B. Licht', year: '22/23' },
                    'PR': { value: '235', holder: 'H. McIlrath / S. Knoll', year: '23/24' }
                },
                '150-159': {
                    '12': { value: '210', holder: 'Cody Long', year: '7/25' },
                    '11': { value: '205', holder: 'Brady Lettow', year: '7/23' },
                    '10': { value: '235', holder: 'Ben Mazyck', year: '7/24' },
                    '9': { value: '225', holder: 'Ben Mazyck', year: '10/23' },
                    'PR': { value: '235', holder: 'Ben Mazyck', year: '7/24' }
                },
                '140-149': {
                    '12': { value: '185', holder: 'John Martin', year: '7/22' },
                    '11': { value: '190', holder: 'Blake Larson', year: '7/24' },
                    '10': { value: '200', holder: 'Brody Kilstofte', year: '7/25' },
                    '9': { value: '200', holder: 'Ben Mazyck', year: '7/23' },
                    'PR': { value: '200', holder: 'B. Kilstofte / B. Mazyck', year: '23/25' }
                },
                '130-139': {
                    '11': { value: '185', holder: 'Jake Knoll', year: '7/25' },
                    '10': { value: '190', holder: 'Jake Knoll', year: '7/24' },
                    '9': { value: '160', holder: 'Blake Loof', year: '11/23' },
                    'PR': { value: '190', holder: 'Jake Knoll', year: '7/24' }
                },
                '120-129': {
                    '11': { value: '160', holder: 'Noah Healy', year: '7/25' },
                    '10': { value: '185', holder: 'Jake Knoll', year: '7/23' },
                    'PR': { value: '185', holder: 'Jake Knoll', year: '7/23' }
                },
                '110-119': {
                    '11': { value: '120', holder: 'Brayden Kilstofte', year: '11/21' },
                    '10': { value: '160', holder: 'Max Dahlsten', year: '7/25' },
                    'PR': { value: '160', holder: 'Max Dahlsten', year: '7/25' }
                },
                '100-109': {
                    '10': { value: '125', holder: 'Blake Larson', year: '2/23' },
                    'PR': { value: '125', holder: 'Blake Larson', year: '2/23' }
                }
            },
            'Tape Shuttle': {
                '320+': {
                    'PR': { value: '--', holder: '-', year: '-' }
                },
                '310-319': {
                    '12': { value: '59.4', holder: 'David Downs', year: '8/20' },
                    'PR': { value: '59.4', holder: 'David Downs', year: '8/20' }
                },
                '300-309': {
                    '12': { value: '1:05.2', holder: 'Tyler Heithoff', year: '8/22' },
                    '11': { value: '1:08', holder: 'Tyler Heithoff', year: '8/21' },
                    'PR': { value: '1:05.2', holder: 'Tyler Heithoff', year: '8/22' }
                },
                '290-299': {
                    '12': { value: '1:05', holder: 'Colin Hansen', year: '8/21' },
                    '11': { value: '1:05', holder: 'Colin Hansen', year: '8/20' },
                    '10': { value: '68.9', holder: 'Tyler Heithoff', year: '8/20' },
                    'PR': { value: '1:05', holder: 'Colin Hansen', year: '8/21' }
                },
                '280-289': {
                    '12': { value: '59.0', holder: 'Carson Barber', year: '8/24' },
                    'PR': { value: '59.0', holder: 'Carson Barber', year: '8/24' }
                },
                '270-279': {
                    '12': { value: '58.7', holder: 'Jackson Mohr', year: '8/25' },
                    '10': { value: '58.9', holder: 'Carson Barber', year: '8/22' },
                    'PR': { value: '58.7', holder: 'Jackson Mohr', year: '8/25' }
                },
                '260-269': {
                    '11': { value: '59.2', holder: 'Jackson Mohr', year: '8/24' },
                    'PR': { value: '59.2', holder: 'Jackson Mohr', year: '8/24' }
                },
                '250-259': {
                    '11': { value: '51.5', holder: 'Aaron Peyton', year: '8/22' },
                    '10': { value: '1:08', holder: 'Carson Barber', year: '8/21' },
                    'PR': { value: '51.5', holder: 'Aaron Peyton', year: '8/22' }
                },
                '240-249': {
                    '12': { value: '51.6', holder: 'Tristan Peterson', year: '8/24' },
                    '11': { value: '1:00.6', holder: 'Jake Jennings', year: '8/22' },
                    '9': { value: '1:00', holder: 'Jackson Mohr', year: '8/22' },
                    'PR': { value: '51.6', holder: 'Tristan Peterson', year: '8/24' }
                },
                '230-239': {
                    '12': { value: '48.6', holder: 'Blake Nelsen', year: '8/25' },
                    '11': { value: '1:01', holder: 'Nick Stewart', year: '8/21' },
                    '10': { value: '49.4', holder: 'Record Holder', year: '8/22' },
                    'PR': { value: '48.6', holder: 'Blake Nelsen', year: '8/25' }
                },
                '220-229': {
                    '12': { value: '49.3', holder: 'Luke Patton', year: '8/22' },
                    '11': { value: '52.5', holder: 'Blake Nelsen', year: '8/24' },
                    '9': { value: '1:10', holder: 'Aaron Peyton', year: '8/20' },
                    'PR': { value: '49.3', holder: 'Luke Patton', year: '8/22' }
                },
                '210-219': {
                    '11': { value: '49.8', holder: 'Carter Barber', year: '8/25' },
                    '10': { value: '53', holder: 'Luke Patton', year: '8/20' },
                    '9': { value: '1:01', holder: 'B. Nelsen / J. Rogers', year: '8/22' },
                    'PR': { value: '49.8', holder: 'Carter Barber', year: '8/25' }
                },
                '200-209': {
                    '12': { value: '50.1', holder: 'Cael Vermeer', year: '8/25' },
                    '11': { value: '50.8', holder: 'Christian Chelsvig', year: '8/22' },
                    '10': { value: '45.0', holder: 'Fiston Carlson', year: '8/24' },
                    '9': { value: '55.32', holder: 'Blake Winecoff', year: '8/25' },
                    'PR': { value: '45.0', holder: 'Fiston Carlson', year: '8/24' }
                },
                '190-199': {
                    '12': { value: '50.6', holder: 'Logan Schnurr', year: '8/21' },
                    '11': { value: '47.9', holder: 'Cael Vermeer', year: '8/24' },
                    '10': { value: '49.4', holder: 'Nick Butler', year: '8/20' },
                    '9': { value: '1:00.7', holder: 'Jaxson Kadolph', year: '8/20' },
                    'PR': { value: '47.9', holder: 'Cael Vermeer', year: '8/24' }
                },
                '180-189': {
                    '12': { value: '45.4', holder: 'Kale Lande', year: '8/22' },
                    '11': { value: '45.3', holder: 'Cooper Triggs', year: '8/25' },
                    '10': { value: '48.0', holder: 'Carter Barber', year: '8/24' },
                    '9': { value: '52.9', holder: 'Cole Olson', year: '8/20' },
                    'PR': { value: '45.3', holder: 'Cooper Triggs', year: '8/25' }
                },
                '170-179': {
                    '12': { value: '45', holder: 'Will Bunn', year: '8/21' },
                    '11': { value: '44.1', holder: 'Hesston Johnson', year: '8/22' },
                    '10': { value: '46.2', holder: 'Jonovan Wilkinson', year: '8/21' },
                    '9': { value: '47.6', holder: 'Connor Morton', year: '8/21' },
                    'PR': { value: '44.1', holder: 'Hesston Johnson', year: '8/22' }
                },
                '160-169': {
                    '12': { value: '43.8', holder: 'Heston McIlrath', year: '8/24' },
                    '11': { value: '45.9', holder: 'Dillon Lettow', year: '8/21' },
                    '10': { value: '45.5', holder: 'Sam Knoll', year: '8/22' },
                    '9': { value: '51.3', holder: 'Charlie Watts', year: '8/21' },
                    'PR': { value: '43.8', holder: 'Heston McIlrath', year: '8/24' }
                },
                '150-159': {
                    '12': { value: '43.3', holder: 'Cody Long', year: '8/25' },
                    '11': { value: '44.9', holder: 'Gavin Carpenter', year: '8/21' },
                    '10': { value: '44.1', holder: 'Luke Thoreson', year: '8/24' },
                    '9': { value: '46.7', holder: 'Sam Scarrow', year: '8/25' },
                    'PR': { value: '43.3', holder: 'Cody Long', year: '8/25' }
                },
                '140-149': {
                    '12': { value: '45.5', holder: 'Cade Diehl', year: '8/21' },
                    '11': { value: '46.3', holder: 'Blake Larson', year: '8/24' },
                    '10': { value: '46.3', holder: 'Brody Kilstofte', year: '8/25' },
                    '9': { value: '48.1', holder: 'Hesston Johnson', year: '8/20' },
                    'PR': { value: '45.5', holder: 'Cade Diehl', year: '8/21' }
                },
                '130-139': {
                    '11': { value: '45.9', holder: 'Jake Knoll', year: '8/25' },
                    '10': { value: '46.1', holder: 'Brady Long', year: '8/25' },
                    '9': { value: '45.7', holder: 'Myles McIlrath', year: '8/25' },
                    'PR': { value: '45.7', holder: 'Myles McIlrath', year: '8/25' }
                },
                '120-129': {
                    '11': { value: '47.21', holder: 'Noah Healy', year: '8/25' },
                    '10': { value: '45.9', holder: 'Cody Long', year: '8/22' },
                    'PR': { value: '45.9', holder: 'Cody Long', year: '8/22' }
                },
                '110-119': {
                    '10': { value: '50.4', holder: 'Parker Watson', year: '8/25' },
                    'PR': { value: '50.4', holder: 'Parker Watson', year: '8/25' }
                },
                '100-109': {
                    '10': { value: '49.3', holder: 'Brayden Kilstofte', year: '8/21' },
                    '9': { value: '50.2', holder: 'Blake Larson', year: '8/22' },
                    'PR': { value: '49.3', holder: 'Brayden Kilstofte', year: '8/21' }
                }
            },
            '800m': {
                '320+': {
                    'PR': { value: '--', holder: '-', year: '-' }
                },
                '310-319': {
                    '12': { value: '3:53', holder: 'David Downs', year: '8/20' },
                    'PR': { value: '3:53', holder: 'David Downs', year: '8/20' }
                },
                '300-309': {
                    '12': { value: '4:51', holder: 'Tyler Heithoff', year: '8/22' },
                    'PR': { value: '4:51', holder: 'Tyler Heithoff', year: '8/22' }
                },
                '290-299': {
                    '11': { value: '4:18', holder: 'Colin Hansen', year: '8/20' },
                    '10': { value: '4:39', holder: 'Patrick Gomez', year: '8/22' },
                    'PR': { value: '4:18', holder: 'Colin Hansen', year: '8/20' }
                },
                '280-289': {
                    '12': { value: '4:13', holder: 'Ryan Johnson', year: '8/21' },
                    'PR': { value: '4:13', holder: 'Ryan Johnson', year: '8/21' }
                },
                '270-279': {
                    '12': { value: '3:43', holder: 'Jackson Mohr', year: '8/25' },
                    '10': { value: '4:04', holder: 'Carson Barber', year: '8/22' },
                    'PR': { value: '3:43', holder: 'Jackson Mohr', year: '8/25' }
                },
                '260-269': {
                    '11': { value: '4:35', holder: 'Ryan Johnson', year: '8/20' },
                    'PR': { value: '4:35', holder: 'Ryan Johnson', year: '8/20' }
                },
                '250-259': {
                    '11': { value: '3:33', holder: 'Aaron Peyton', year: '8/22' },
                    '10': { value: '3:39', holder: 'Carson Barber', year: '8/21' },
                    'PR': { value: '3:33', holder: 'Aaron Peyton', year: '8/22' }
                },
                '240-249': {
                    '11': { value: '3:40', holder: 'Jake Jennings', year: '8/22' },
                    '10': { value: '4:18', holder: 'Jackson Mohr', year: '8/22' },
                    'PR': { value: '3:40', holder: 'Jake Jennings', year: '8/22' }
                },
                '230-239': {
                    '12': { value: '2:43', holder: 'Blake Nelsen', year: '8/25' },
                    '11': { value: '3:32', holder: 'Nick Stewart', year: '8/21' },
                    '10': { value: '3:27', holder: 'Aaron Peyton', year: '8/21' },
                    'PR': { value: '2:43', holder: 'Blake Nelsen', year: '8/25' }
                },
                '220-229': {
                    '12': { value: '2:25', holder: 'Luke Patton', year: '8/22' },
                    '11': { value: '3:20', holder: 'William Licht', year: '8/22' },
                    '9': { value: '4:36', holder: 'Aaron Peyton', year: '8/20' },
                    'PR': { value: '2:25', holder: 'Luke Patton', year: '8/22' }
                },
                '210-219': {
                    '11': { value: '2:43', holder: 'C. Barber / G. Jeter', year: '8/25' },
                    '10': { value: '2:52', holder: 'Luke Patton', year: '8/20' },
                    '9': { value: '4:05', holder: 'Jake Rogers', year: '8/22' },
                    'PR': { value: '2:43', holder: 'C. Barber / G. Jeter', year: '8/25' }
                },
                '200-209': {
                    '12': { value: '2:34', holder: 'Cael Vermeer', year: '8/25' },
                    '11': { value: '2:54', holder: 'Christian Chelsvig', year: '8/22' },
                    '10': { value: '3:15', holder: 'Nick Stewart', year: '8/21' },
                    '9': { value: '3:35', holder: 'Blake Winecoff', year: '8/25' },
                    'PR': { value: '2:34', holder: 'Cael Vermeer', year: '8/25' }
                },
                '190-199': {
                    '12': { value: '3:08', holder: 'Logan Schnurr', year: '8/21' },
                    '11': { value: '2:40', holder: 'Tucker Hawkins', year: '8/25' },
                    '10': { value: '3:02', holder: 'Nick Butler', year: '8/20' },
                    '9': { value: '3:29', holder: 'Jaxson Kadolph', year: '8/20' },
                    'PR': { value: '2:40', holder: 'Tucker Hawkins', year: '8/25' }
                },
                '180-189': {
                    '12': { value: '2:09', holder: 'Kale Lande', year: '8/22' },
                    '11': { value: '2:31', holder: 'Luke Thoreson', year: '8/25' },
                    '10': { value: '3:02', holder: 'Garrett Nerem', year: '8/22' },
                    '9': { value: '2:52', holder: 'Cael Vermeer', year: '8/22' },
                    'PR': { value: '2:09', holder: 'Kale Lande', year: '8/22' }
                },
                '170-179': {
                    '12': { value: '2:11', holder: 'Dillon Lettow', year: '8/22' },
                    '11': { value: '2:09', holder: 'Kale Lande', year: '8/21' },
                    '10': { value: '2:29', holder: 'Jonovan Wilkinson', year: '8/21' },
                    '9': { value: '2:38', holder: 'Connor Morton', year: '8/21' },
                    'PR': { value: '2:09', holder: 'Kale Lande', year: '8/21' }
                },
                '160-169': {
                    '12': { value: '2:34', holder: 'Matt Phelan', year: '8/21' },
                    '11': { value: '2:19', holder: 'Dillon Lettow', year: '8/21' },
                    '10': { value: '2:15', holder: 'Colin Willis', year: '8/25' },
                    '9': { value: '2:53', holder: 'Garrett Nerem', year: '8/21' },
                    'PR': { value: '2:15', holder: 'Colin Willis', year: '8/25' }
                },
                '150-159': {
                    '12': { value: '2:16', holder: 'Ben Greenfield', year: '8/22' },
                    '11': { value: '2:23', holder: 'Gavin Carpenter', year: '8/21' },
                    '10': { value: '2:20', holder: 'Hesston Johnson', year: '8/21' },
                    '9': { value: '2:45', holder: 'Sam Scarrow', year: '8/25' },
                    'PR': { value: '2:16', holder: 'Ben Greenfield', year: '8/22' }
                },
                '140-149': {
                    '12': { value: '2:15', holder: 'Cade Diehl', year: '8/21' },
                    '11': { value: '2:32', holder: 'Carter Loof', year: '8/20' },
                    '10': { value: '2:30', holder: 'Boaz Clark', year: '8/21' },
                    '9': { value: '2:38', holder: 'Sam Knoll', year: '8/21' },
                    'PR': { value: '2:15', holder: 'Cade Diehl', year: '8/21' }
                },
                '130-139': {
                    '11': { value: '2:26', holder: 'Cade Diehl', year: '8/21' },
                    '10': { value: '2:38', holder: 'Brady Long', year: '8/25' },
                    '9': { value: '2:39', holder: 'Myles McIlrath', year: '8/25' },
                    'PR': { value: '2:26', holder: 'Cade Diehl', year: '8/21' }
                },
                '120-129': {
                    '11': { value: '2:31', holder: 'Noah Healy', year: '8/25' },
                    '10': { value: '2:33', holder: 'Hayden Janssen', year: '8/22' },
                    'PR': { value: '2:31', holder: 'Noah Healy', year: '8/25' }
                },
                '110-119': {
                    '11': { value: '2:43', holder: 'Tristan Anderson', year: '8/21' },
                    '10': { value: '2:42', holder: 'Max Dahlsten', year: '8/25' },
                    'PR': { value: '2:42', holder: 'Max Dahlsten', year: '8/25' }
                },
                '100-109': {
                    '11': { value: '2:28', holder: 'Brayden Kilstofte', year: '8/21' },
                    '9': { value: '2:46', holder: 'Blake Larson', year: '8/22' },
                    'PR': { value: '2:28', holder: 'Brayden Kilstofte', year: '8/21' }
                }
            },
            'Bag Jump': {
                '320+': {
                    'PR': { value: '--', holder: '-', year: '-' }
                },
                '310-319': {
                    '12': { value: '33', holder: 'David Downs', year: '8/20' },
                    'PR': { value: '33', holder: 'David Downs', year: '8/20' }
                },
                '300-309': {
                    '12': { value: '27', holder: 'Tyler Heithoff', year: '8/22' },
                    '11': { value: '27', holder: 'Tyler Heithoff', year: '8/21' },
                    'PR': { value: '27', holder: 'Tyler Heithoff', year: '21/22' }
                },
                '290-299': {
                    '12': { value: '34', holder: 'Colin Hansen', year: '8/21' },
                    '11': { value: '36', holder: 'Colin Hansen', year: '8/20' },
                    '10': { value: '25', holder: 'Tyler Heithoff', year: '8/20' },
                    'PR': { value: '36', holder: 'Colin Hansen', year: '8/20' }
                },
                '280-289': {
                    '12': { value: '43', holder: 'Carson Barber', year: '8/24' },
                    'PR': { value: '43', holder: 'Carson Barber', year: '8/24' }
                },
                '270-279': {
                    '12': { value: '37', holder: 'Jackson Mohr', year: '8/25' },
                    '10': { value: '36', holder: 'Carson Barber', year: '8/22' },
                    'PR': { value: '37', holder: 'Jackson Mohr', year: '8/25' }
                },
                '260-269': {
                    '11': { value: '39', holder: 'Ryan Johnson', year: '8/20' },
                    'PR': { value: '39', holder: 'Ryan Johnson', year: '8/20' }
                },
                '250-259': {
                    '11': { value: '49', holder: 'Aaron Peyton', year: '8/22' },
                    '10': { value: '44', holder: 'Carson Barber', year: '8/21' },
                    'PR': { value: '49', holder: 'Aaron Peyton', year: '8/22' }
                },
                '240-249': {
                    '12': { value: '53', holder: 'Tristan Peterson', year: '8/24' },
                    '11': { value: '44', holder: 'Jake Jennings', year: '8/22' },
                    '9': { value: '38', holder: 'Jackson Mohr', year: '8/22' },
                    'PR': { value: '53', holder: 'Tristan Peterson', year: '8/24' }
                },
                '230-239': {
                    '12': { value: '55', holder: 'Blake Nelsen', year: '8/25' },
                    '11': { value: '44', holder: 'Nick Stewart', year: '8/21' },
                    '10': { value: '50', holder: 'Aaron Peyton', year: '8/21' },
                    'PR': { value: '55', holder: 'Blake Nelsen', year: '8/25' }
                },
                '220-229': {
                    '12': { value: '57', holder: 'Jimmy Philipsen', year: '8/20' },
                    '11': { value: '53', holder: 'Blake Nelsen', year: '8/24' },
                    '9': { value: '43', holder: 'Aaron Peyton', year: '8/20' },
                    'PR': { value: '57', holder: 'Jimmy Philipsen', year: '8/20' }
                },
                '210-219': {
                    '12': { value: '59', holder: 'Garrett Nerem', year: '8/24' },
                    '11': { value: '53', holder: 'C. Barber / C. Georgius', year: '8/25' },
                    '10': { value: '51', holder: 'Luke Patton', year: '8/20' },
                    '9': { value: '52', holder: 'Jake Rogers', year: '8/22' },
                    'PR': { value: '59', holder: 'Garrett Nerem', year: '8/24' }
                },
                '200-209': {
                    '12': { value: '51', holder: 'Parker Watts', year: '8/21' },
                    '11': { value: '55', holder: 'Christian Chelsvig', year: '8/22' },
                    '10': { value: '53', holder: 'Thomas Tjaden', year: '8/21' },
                    '9': { value: '46', holder: 'Blake Winecoff', year: '8/25' },
                    'PR': { value: '55', holder: 'Christian Chelsvig', year: '8/22' }
                },
                '190-199': {
                    '12': { value: '51', holder: 'Logan Schnurr', year: '8/21' },
                    '11': { value: '54', holder: 'Nick Butler', year: '8/21' },
                    '10': { value: '54', holder: 'Charlie Watts', year: '8/22' },
                    '9': { value: '41', holder: 'Jaxson Kadolph', year: '8/20' },
                    'PR': { value: '54', holder: 'N. Butler / C. Watts', year: '21/22' }
                },
                '180-189': {
                    '12': { value: '62', holder: 'Sam Knoll', year: '8/24' },
                    '11': { value: '61', holder: 'Luke Thoreson', year: '8/25' },
                    '10': { value: '56', holder: 'C. Chelsvig / C. Barber', year: '21/24' },
                    '9': { value: '47', holder: 'Cael Vermeer', year: '8/22' },
                    'PR': { value: '62', holder: 'Sam Knoll', year: '8/24' }
                },
                '170-179': {
                    '12': { value: '64', holder: 'Adam McIlrath', year: '8/20' },
                    '11': { value: '63', holder: 'Hesston Johnson', year: '8/22' },
                    '10': { value: '58', holder: 'Jonovan Wilkinson', year: '8/21' },
                    '9': { value: '61', holder: 'Connor Morton', year: '8/21' },
                    'PR': { value: '64', holder: 'Adam McIlrath', year: '8/20' }
                },
                '160-169': {
                    '12': { value: '66', holder: 'Heston McIlrath', year: '8/24' },
                    '11': { value: '64', holder: 'Aiden Frey', year: '8/25' },
                    '10': { value: '56', holder: 'K. Lande / C. Willis', year: '20/25' },
                    '9': { value: '59', holder: 'Charlie Watts', year: '8/21' },
                    'PR': { value: '66', holder: 'Heston McIlrath', year: '8/24' }
                },
                '150-159': {
                    '12': { value: '65', holder: 'Cody Long', year: '8/25' },
                    '11': { value: '62', holder: 'Cody Long', year: '8/24' },
                    '10': { value: '62', holder: 'Hesston Johnson', year: '8/21' },
                    '9': { value: '60', holder: 'Sam Scarrow', year: '8/25' },
                    'PR': { value: '65', holder: 'Cody Long', year: '8/25' }
                },
                '140-149': {
                    '12': { value: '64', holder: 'Cade Diehl', year: '8/22' },
                    '11': { value: '64', holder: 'Riley Larson', year: '8/22' },
                    '10': { value: '62', holder: 'Jake Berggren', year: '8/22' },
                    '9': { value: '60', holder: 'H. McIlrath / H. Johnson', year: '20/21' },
                    'PR': { value: '64', holder: 'C. Diehl / R. Larson', year: '2022' }
                },
                '130-139': {
                    '11': { value: '64', holder: 'Cade Diehl', year: '8/20' },
                    '10': { value: '65', holder: 'Brady Long', year: '8/25' },
                    '9': { value: '61', holder: 'Jake Berggren', year: '8/21' },
                    'PR': { value: '65', holder: 'Brady Long', year: '8/25' }
                },
                '120-129': {
                    '10': { value: '58', holder: 'Riley Larson', year: '8/21' },
                    '9': { value: '66', holder: 'Brady Long', year: '8/24' },
                    'PR': { value: '66', holder: 'Brady Long', year: '8/24' }
                },
                '110-119': {
                    '10': { value: '50', holder: 'Tristan Anderson', year: '8/21' },
                    '9': { value: '54', holder: 'Max Dahlsten', year: '8/25' },
                    'PR': { value: '54', holder: 'Max Dahlsten', year: '8/25' }
                },
                '100-109': {
                    '10': { value: '51', holder: 'Brayden Kilstofte', year: '8/21' },
                    '9': { value: '56', holder: 'Blake Larson', year: '8/22' },
                    'PR': { value: '56', holder: 'Blake Larson', year: '8/22' }
                }
            },
            'Broad Jump': {},
            '10m Fly': {},
            'Pro Agility': {},
            'Deadlift': {}
        };

        // Schedule Modal Component
        const ScheduleModal = ({ scheduleModal, setScheduleModal, updateSchedule }) => {
            const [tempDate, setTempDate] = useState(scheduleModal.item.scheduledDate || new Date().toISOString().split('T')[0]);
            const [tempRecurring, setTempRecurring] = useState(scheduleModal.item.recurring?.enabled || false);
            const [tempPattern, setTempPattern] = useState(scheduleModal.item.recurring?.pattern || 'weekly');
            const [tempDayOfWeek, setTempDayOfWeek] = useState(scheduleModal.item.recurring?.dayOfWeek ?? new Date().getDay());
            const [tempWeekOfMonth, setTempWeekOfMonth] = useState(scheduleModal.item.recurring?.weekOfMonth || 1);
            const [tempMonth, setTempMonth] = useState(scheduleModal.item.recurring?.month || 1);

            return (
                <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000 }} onClick={() => setScheduleModal(null)}>
                    <div className="card" style={{ width: '90%', maxWidth: '500px', padding: '2rem' }} onClick={e => e.stopPropagation()}>
                        <h3 style={{ margin: '0 0 1.5rem 0' }}>Schedule {scheduleModal.type === 'quote' ? 'Quote' : 'Challenge'}</h3>

                        <div style={{ marginBottom: '1.5rem' }}>
                            <label className="form-label">Start Date</label>
                            <input
                                type="date"
                                className="form-input"
                                value={tempDate}
                                onChange={e => setTempDate(e.target.value)}
                            />
                        </div>

                        <div style={{ marginBottom: '1.5rem' }}>
                            <label style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', cursor: 'pointer' }}>
                                <input
                                    type="checkbox"
                                    checked={tempRecurring}
                                    onChange={e => setTempRecurring(e.target.checked)}
                                />
                                <span className="form-label" style={{ margin: 0 }}>Recurring</span>
                            </label>
                        </div>

                        {tempRecurring && (
                            <>
                                <div style={{ marginBottom: '1.5rem' }}>
                                    <label className="form-label">Pattern</label>
                                    <select className="form-input" value={tempPattern} onChange={e => setTempPattern(e.target.value)}>
                                        <option value="weekly">Weekly</option>
                                        <option value="monthly">Monthly</option>
                                        <option value="yearly">Yearly</option>
                                    </select>
                                </div>

                                {tempPattern === 'weekly' && (
                                    <div style={{ marginBottom: '1.5rem' }}>
                                        <label className="form-label">Day of Week</label>
                                        <select className="form-input" value={tempDayOfWeek} onChange={e => setTempDayOfWeek(parseInt(e.target.value))}>
                                            <option value={0}>Sunday</option>
                                            <option value={1}>Monday</option>
                                            <option value={2}>Tuesday</option>
                                            <option value={3}>Wednesday</option>
                                            <option value={4}>Thursday</option>
                                            <option value={5}>Friday</option>
                                            <option value={6}>Saturday</option>
                                        </select>
                                    </div>
                                )}

                                {(tempPattern === 'monthly' || tempPattern === 'yearly') && (
                                    <>
                                        <div style={{ marginBottom: '1.5rem' }}>
                                            <label className="form-label">Week of Month</label>
                                            <select className="form-input" value={tempWeekOfMonth} onChange={e => setTempWeekOfMonth(e.target.value === 'last' ? 'last' : parseInt(e.target.value))}>
                                                <option value={1}>1st</option>
                                                <option value={2}>2nd</option>
                                                <option value={3}>3rd</option>
                                                <option value={4}>4th</option>
                                                <option value="last">Last</option>
                                            </select>
                                        </div>
                                        <div style={{ marginBottom: '1.5rem' }}>
                                            <label className="form-label">Day of Week</label>
                                            <select className="form-input" value={tempDayOfWeek} onChange={e => setTempDayOfWeek(parseInt(e.target.value))}>
                                                <option value={0}>Sunday</option>
                                                <option value={1}>Monday</option>
                                                <option value={2}>Tuesday</option>
                                                <option value={3}>Wednesday</option>
                                                <option value={4}>Thursday</option>
                                                <option value={5}>Friday</option>
                                                <option value={6}>Saturday</option>
                                            </select>
                                        </div>
                                    </>
                                )}

                                {tempPattern === 'yearly' && (
                                    <div style={{ marginBottom: '1.5rem' }}>
                                        <label className="form-label">Month</label>
                                        <select className="form-input" value={tempMonth} onChange={e => setTempMonth(parseInt(e.target.value))}>
                                            <option value={1}>January</option>
                                            <option value={2}>February</option>
                                            <option value={3}>March</option>
                                            <option value={4}>April</option>
                                            <option value={5}>May</option>
                                            <option value={6}>June</option>
                                            <option value={7}>July</option>
                                            <option value={8}>August</option>
                                            <option value={9}>September</option>
                                            <option value={10}>October</option>
                                            <option value={11}>November</option>
                                            <option value={12}>December</option>
                                        </select>
                                    </div>
                                )}
                            </>
                        )}

                        <div style={{ display: 'flex', gap: '1rem', justifyContent: 'flex-end' }}>
                            <button className="btn btn-secondary" onClick={() => setScheduleModal(null)}>Cancel</button>
                            <button
                                className="btn btn-primary"
                                onClick={() => {
                                    updateSchedule(scheduleModal.type, scheduleModal.item.id, {
                                        scheduledDate: tempDate,
                                        recurring: tempRecurring ? {
                                            enabled: true,
                                            pattern: tempPattern,
                                            dayOfWeek: tempDayOfWeek,
                                            weekOfMonth: (tempPattern === 'monthly' || tempPattern === 'yearly') ? tempWeekOfMonth : undefined,
                                            month: tempPattern === 'yearly' ? tempMonth : undefined
                                        } : null
                                    });
                                    setScheduleModal(null);
                                }}
                            >
                                Save Schedule
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // REMOVED: CulturalCalibration component

        // --- INSTALL SLIDESHOW COMPONENT ---
        const RenderInstallSlideshow_PLACEHOLDER = () => null; // Placeholder to help find where to delete
        const CulturalCalibration_REMOVED = ({ culturalCalibration, setCulturalCalibration, currentPermissions, authUser }) => {
            const isAdmin = true; // currentPermissions?.organizationAdmin || currentPermissions?.culturalAdmin;
            const [ccMode, setCCMode] = useState(isAdmin ? 'admin' : 'user');
            const [quoteText, setQuoteText] = useState('');
            const [quoteAuthor, setQuoteAuthor] = useState('');
            const [challengeText, setChallengeText] = useState('');
            const [reflection, setReflection] = useState('');
            const [currentScore, setCurrentScore] = useState(5);
            const [desiredScore, setDesiredScore] = useState(8);
            const [feedback, setFeedback] = useState('');
            const [adminTab, setAdminTab] = useState('content'); // 'content' or 'calendar'
            const [scheduleModal, setScheduleModal] = useState(null); // {type: 'quote'|'challenge', item: object}
            const [calendarDate, setCalendarDate] = useState(new Date());

            // Helper: Check if two dates are the same day
            const isSameDay = (date1, date2) => {
                return date1.getFullYear() === date2.getFullYear() &&
                    date1.getMonth() === date2.getMonth() &&
                    date1.getDate() === date2.getDate();
            };

            // Helper: Get the week of month for a date (1-5)
            const getWeekOfMonth = (date) => {
                const firstDay = new Date(date.getFullYear(), date.getMonth(), 1);
                const dayOfMonth = date.getDate();
                return Math.ceil((dayOfMonth + firstDay.getDay()) / 7);
            };

            // Helper: Check if date matches monthly pattern (e.g., "2nd Tuesday")
            const matchesMonthlyPattern = (date, recurring) => {
                if (date.getDay() !== recurring.dayOfWeek) return false;

                const weekOfMonth = getWeekOfMonth(date);
                if (recurring.weekOfMonth === 'last') {
                    // Check if this is the last occurrence of this weekday in the month
                    const nextWeek = new Date(date);
                    nextWeek.setDate(date.getDate() + 7);
                    return nextWeek.getMonth() !== date.getMonth();
                }
                return weekOfMonth === recurring.weekOfMonth;
            };

            // Helper: Check if item is scheduled for target date
            const isScheduledFor = (item, targetDate) => {
                if (!item.scheduledDate) return false;

                const scheduled = new Date(item.scheduledDate);

                if (!item.recurring?.enabled) {
                    // One-time: exact date match
                    return isSameDay(scheduled, targetDate);
                }

                // Must be on or after start date
                if (targetDate < scheduled) return false;

                // Recurring patterns
                switch (item.recurring.pattern) {
                    case 'weekly':
                        return targetDate.getDay() === item.recurring.dayOfWeek;
                    case 'monthly':
                        return matchesMonthlyPattern(targetDate, item.recurring);
                    case 'yearly':
                        return targetDate.getMonth() === item.recurring.month - 1 &&
                            matchesMonthlyPattern(targetDate, item.recurring);
                    default:
                        return false;
                }
            };

            // Helper: Find active item for today (or most recent)
            const findActiveItem = (items) => {
                const today = new Date();
                today.setHours(0, 0, 0, 0);

                // 1. Find items scheduled for today
                const todayItems = items.filter(item => isScheduledFor(item, today));
                if (todayItems.length) return todayItems[0];

                // 2. Fallback: Most recent scheduled item before today
                const pastItems = items
                    .filter(item => item.scheduledDate && new Date(item.scheduledDate) <= today)
                    .sort((a, b) => new Date(b.scheduledDate) - new Date(a.scheduledDate));
                if (pastItems.length) return pastItems[0];

                // 3. Fallback: Most recently added
                const sortedByDate = items.sort((a, b) => new Date(b.dateAdded) - new Date(a.dateAdded));
                return sortedByDate[0] || null;
            };


            const addQuote = () => {
                if (!quoteText.trim()) return;
                const newQuote = {
                    id: Date.now().toString(),
                    text: quoteText,
                    author: quoteAuthor || 'Unknown',
                    dateAdded: new Date().toISOString(),
                    scheduledDate: null,
                    recurring: null
                };
                setCulturalCalibration({
                    ...culturalCalibration,
                    quotes: [...(culturalCalibration.quotes || []), newQuote]
                });
                setQuoteText('');
                setQuoteAuthor('');
            };

            const updateSchedule = (type, itemId, scheduleData) => {
                const key = type === 'quote' ? 'quotes' : 'challenges';
                const updated = (culturalCalibration[key] || []).map(item =>
                    item.id === itemId ? { ...item, ...scheduleData } : item
                );
                setCulturalCalibration({
                    ...culturalCalibration,
                    [key]: updated
                });
            };


            const addChallenge = () => {
                if (!challengeText.trim()) return;
                const newChallenge = {
                    id: Date.now().toString(),
                    text: challengeText,
                    dateAdded: new Date().toISOString(),
                    scheduledDate: null,
                    recurring: null
                };
                setCulturalCalibration({
                    ...culturalCalibration,
                    challenges: [...(culturalCalibration.challenges || []), newChallenge]
                });
                setChallengeText('');
            };

            const setActiveQuote = (id) => {
                setCulturalCalibration({
                    ...culturalCalibration,
                    activeQuote: id
                });
            };

            const setActiveChallenge = (id) => {
                setCulturalCalibration({
                    ...culturalCalibration,
                    activeChallenge: id
                });
            };

            const deleteQuote = (id) => {
                setCulturalCalibration({
                    ...culturalCalibration,
                    quotes: (culturalCalibration.quotes || []).filter(q => q.id !== id),
                    activeQuote: culturalCalibration.activeQuote === id ? null : culturalCalibration.activeQuote
                });
            };

            const deleteChallenge = (id) => {
                setCulturalCalibration({
                    ...culturalCalibration,
                    challenges: (culturalCalibration.challenges || []).filter(c => c.id !== id),
                    activeChallenge: culturalCalibration.activeChallenge === id ? null : culturalCalibration.activeChallenge
                });
            };

            const submitResponse = () => {
                const newResponse = {
                    id: Date.now().toString(),
                    userId: authUser?.uid,
                    userName: authUser?.displayName || authUser?.email,
                    date: new Date().toISOString(),
                    reflection: reflection,
                    currentCultureScore: currentScore,
                    desiredCultureScore: desiredScore,
                    feedback: feedback
                };
                setCulturalCalibration({
                    ...culturalCalibration,
                    responses: [...(culturalCalibration.responses || []), newResponse]
                });
                setReflection('');
                setCurrentScore(5);
                setDesiredScore(8);
                setFeedback('');
                alert('Response submitted successfully!');
            };

            const activeQuoteObj = findActiveItem(culturalCalibration.quotes || []);
            const activeChallengeObj = findActiveItem(culturalCalibration.challenges || []);

            const responses = culturalCalibration.responses || [];
            const avgCurrent = responses.length > 0 ? (responses.reduce((sum, r) => sum + r.currentCultureScore, 0) / responses.length).toFixed(1) : 'N/A';
            const avgDesired = responses.length > 0 ? (responses.reduce((sum, r) => sum + r.desiredCultureScore, 0) / responses.length).toFixed(1) : 'N/A';

            return (
                <div style={{ height: '100%', display: 'flex', flexDirection: 'column', gap: '1rem', overflow: 'auto', padding: '1rem' }}>
                    <div className="card" style={{ padding: '2rem', background: 'linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%)' }}>
                        <h2 style={{ margin: '0 0 1rem 0', color: 'white', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                            <Icon name="Heart" size={28} />
                            Culture Calibration
                        </h2>
                        <p style={{ margin: 0, opacity: 0.9, color: 'white' }}>
                            Daily quotes, challenges, and culture feedback
                        </p>
                        {isAdmin && (
                            <div style={{ marginTop: '1.5rem', display: 'flex', gap: '1rem' }}>
                                <button className={`btn ${ccMode === 'admin' ? 'btn-primary' : 'btn-secondary'}`} onClick={() => setCCMode('admin')} style={{ borderRadius: '20px' }}>Admin View</button>
                                <button className={`btn ${ccMode === 'user' ? 'btn-primary' : 'btn-secondary'}`} onClick={() => setCCMode('user')} style={{ borderRadius: '20px' }}>User View</button>
                            </div>
                        )}
                    </div>
                    {ccMode === 'admin' ? (
                        <>
                            {/* Tabs for Admin View */}
                            <div className="card" style={{ padding: '1rem' }}>
                                <div style={{ display: 'flex', gap: '0.5rem', borderBottom: '2px solid var(--border)' }}>
                                    <button
                                        className={`btn ${adminTab === 'content' ? 'btn-primary' : 'btn-secondary'}`}
                                        onClick={() => setAdminTab('content')}
                                        style={{ borderRadius: '8px 8px 0 0', borderBottom: adminTab === 'content' ? '2px solid var(--accent)' : 'none' }}
                                    >
                                        Manage Content
                                    </button>
                                    <button
                                        className={`btn ${adminTab === 'calendar' ? 'btn-primary' : 'btn-secondary'}`}
                                        onClick={() => setAdminTab('calendar')}
                                        style={{ borderRadius: '8px 8px 0 0', borderBottom: adminTab === 'calendar' ? '2px solid var(--accent)' : 'none' }}
                                    >
                                        Calendar Schedule
                                    </button>
                                </div>
                            </div>

                            {adminTab === 'content' ? (
                                <>
                                    {/* Response Dashboard */}
                                    <div className="card" style={{ padding: '1.5rem' }}>
                                        <h3 style={{ margin: '0 0 1rem 0' }}>Response Dashboard</h3>
                                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1rem' }}>
                                            <div>
                                                <div style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginBottom: '0.5rem' }}>Total Responses</div>
                                                <div style={{ fontSize: '2rem', fontWeight: 'bold', color: 'var(--accent)' }}>{responses.length}</div>
                                            </div>
                                            <div>
                                                <div style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginBottom: '0.5rem' }}>Avg Current Culture</div>
                                                <div style={{ fontSize: '2rem', fontWeight: 'bold', color: '#f97316' }}>{avgCurrent}</div>
                                            </div>
                                            <div>
                                                <div style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', marginBottom: '0.5rem' }}>Avg Desired Culture</div>
                                                <div style={{ fontSize: '2rem', fontWeight: 'bold', color: '#10b981' }}>{avgDesired}</div>
                                            </div>
                                        </div>
                                    </div>

                                    {/* Daily Quotes */}
                                    <div className="card" style={{ padding: '1.5rem' }}>
                                        <h3 style={{ margin: '0 0 1rem 0' }}>Daily Quotes</h3>
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem', marginBottom: '1.5rem' }}>
                                            <input className="form-input" placeholder="Quote text..." value={quoteText} onChange={e => setQuoteText(e.target.value)} />
                                            <input className="form-input" placeholder="Author (optional)" value={quoteAuthor} onChange={e => setQuoteAuthor(e.target.value)} />
                                            <button className="btn btn-primary" onClick={addQuote} disabled={!quoteText.trim()}>Add Quote</button>
                                        </div>
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                            {(culturalCalibration.quotes || []).map(quote => (
                                                <div key={quote.id} style={{ padding: '1rem', background: 'var(--bg-secondary)', borderRadius: '8px', border: '1px solid var(--border)' }}>
                                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start', marginBottom: '0.5rem' }}>
                                                        <div style={{ flex: 1 }}>
                                                            <div style={{ fontStyle: 'italic', marginBottom: '0.5rem' }}>"{quote.text}"</div>
                                                            <div style={{ fontSize: '0.85rem', color: 'var(--text-secondary)' }}>— {quote.author}</div>
                                                        </div>
                                                        <div style={{ display: 'flex', gap: '0.5rem' }}>
                                                            <button
                                                                className="btn btn-sm btn-secondary"
                                                                onClick={() => setScheduleModal({ type: 'quote', item: quote })}
                                                            >
                                                                <Icon name="Calendar" size={14} /> Schedule
                                                            </button>
                                                            <button className="btn btn-sm btn-danger" onClick={() => deleteQuote(quote.id)}>Delete</button>
                                                        </div>
                                                    </div>
                                                    {quote.scheduledDate && (
                                                        <div style={{ fontSize: '0.75rem', color: 'var(--accent)', marginTop: '0.5rem' }}>
                                                            📅 {quote.recurring?.enabled ? (
                                                                <>Recurring: {
                                                                    quote.recurring.pattern === 'weekly' ? `Every ${['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][quote.recurring.dayOfWeek]}` :
                                                                        quote.recurring.pattern === 'monthly' ? `${['1st', '2nd', '3rd', '4th', 'Last'][quote.recurring.weekOfMonth === 'last' ? 4 : quote.recurring.weekOfMonth - 1]} ${['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][quote.recurring.dayOfWeek]} of month` :
                                                                            quote.recurring.pattern === 'yearly' ? `${['1st', '2nd', '3rd', '4th', 'Last'][quote.recurring.weekOfMonth === 'last' ? 4 : quote.recurring.weekOfMonth - 1]} ${['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][quote.recurring.dayOfWeek]} of ${['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][quote.recurring.month - 1]}` : ''
                                                                }</>
                                                            ) : (
                                                                new Date(quote.scheduledDate).toLocaleDateString()
                                                            )}
                                                        </div>
                                                    )}
                                                </div>
                                            ))}
                                        </div>
                                    </div>

                                    {/* Daily Challenges */}
                                    <div className="card" style={{ padding: '1.5rem' }}>
                                        <h3 style={{ margin: '0 0 1rem 0' }}>Daily Challenges</h3>
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem', marginBottom: '1.5rem' }}>
                                            <textarea className="form-input" rows={3} placeholder="Challenge text..." value={challengeText} onChange={e => setChallengeText(e.target.value)} />
                                            <button className="btn btn-primary" onClick={addChallenge} disabled={!challengeText.trim()}>Add Challenge</button>
                                        </div>
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                            {(culturalCalibration.challenges || []).map(challenge => (
                                                <div key={challenge.id} style={{ padding: '1rem', background: 'var(--bg-secondary)', borderRadius: '8px', border: '1px solid var(--border)' }}>
                                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start', marginBottom: '0.5rem' }}>
                                                        <div style={{ flex: 1 }}>{challenge.text}</div>
                                                        <div style={{ display: 'flex', gap: '0.5rem' }}>
                                                            <button
                                                                className="btn btn-sm btn-secondary"
                                                                onClick={() => setScheduleModal({ type: 'challenge', item: challenge })}
                                                            >
                                                                <Icon name="Calendar" size={14} /> Schedule
                                                            </button>
                                                            <button className="btn btn-sm btn-danger" onClick={() => deleteChallenge(challenge.id)}>Delete</button>
                                                        </div>
                                                    </div>
                                                    {challenge.scheduledDate && (
                                                        <div style={{ fontSize: '0.75rem', color: 'var(--accent)', marginTop: '0.5rem' }}>
                                                            📅 {challenge.recurring?.enabled ? (
                                                                <>Recurring: {
                                                                    challenge.recurring.pattern === 'weekly' ? `Every ${['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][challenge.recurring.dayOfWeek]}` :
                                                                        challenge.recurring.pattern === 'monthly' ? `${['1st', '2nd', '3rd', '4th', 'Last'][challenge.recurring.weekOfMonth === 'last' ? 4 : challenge.recurring.weekOfMonth - 1]} ${['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][challenge.recurring.dayOfWeek]} of month` :
                                                                            challenge.recurring.pattern === 'yearly' ? `${['1st', '2nd', '3rd', '4th', 'Last'][challenge.recurring.weekOfMonth === 'last' ? 4 : challenge.recurring.weekOfMonth - 1]} ${['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][challenge.recurring.dayOfWeek]} of ${['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][challenge.recurring.month - 1]}` : ''
                                                                }</>
                                                            ) : (
                                                                new Date(challenge.scheduledDate).toLocaleDateString()
                                                            )}
                                                        </div>
                                                    )}
                                                </div>
                                            ))}
                                        </div>
                                    </div>

                                    {/* Submitted Responses */}
                                    <div className="card" style={{ padding: '1.5rem' }}>
                                        <h3 style={{ margin: '0 0 1rem 0' }}>Submitted Responses</h3>
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                                            {responses.length === 0 ? (
                                                <div style={{ textAlign: 'center', padding: '2rem', color: 'var(--text-secondary)' }}>No responses yet</div>
                                            ) : (
                                                responses.map(response => (
                                                    <div key={response.id} style={{ padding: '1rem', background: 'var(--bg-secondary)', borderRadius: '8px', border: '1px solid var(--border)' }}>
                                                        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem' }}>
                                                            <div style={{ fontWeight: 'bold' }}>{response.userName}</div>
                                                            <div style={{ fontSize: '0.85rem', color: 'var(--text-secondary)' }}>{new Date(response.date).toLocaleDateString()}</div>
                                                        </div>
                                                        <div style={{ marginBottom: '0.5rem', fontSize: '0.95rem' }}>{response.reflection}</div>
                                                        <div style={{ display: 'flex', gap: '1.5rem', fontSize: '0.85rem' }}>
                                                            <div>Current: <span style={{ fontWeight: 'bold', color: '#f97316' }}>{response.currentCultureScore}/10</span></div>
                                                            <div>Desired: <span style={{ fontWeight: 'bold', color: '#10b981' }}>{response.desiredCultureScore}/10</span></div>
                                                        </div>
                                                        {response.feedback && (
                                                            <div style={{ marginTop: '0.5rem', padding: '0.5rem', background: 'var(--bg-primary)', borderRadius: '4px', fontSize: '0.85rem' }}>
                                                                <strong>Feedback:</strong> {response.feedback}
                                                            </div>
                                                        )}
                                                    </div>
                                                ))
                                            )}
                                        </div>
                                    </div>
                                </>
                            ) : (
                                <div className="card" style={{ padding: '1.5rem' }}>
                                    <h3 style={{ margin: '0 0 1rem 0' }}>Calendar Schedule</h3>
                                    {/* Calendar Controls */}
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                                        <button className="btn btn-secondary" onClick={() => {
                                            const newDate = new Date(calendarDate);
                                            newDate.setMonth(newDate.getMonth() - 1);
                                            setCalendarDate(newDate);
                                        }}>
                                            ← Previous
                                        </button>
                                        <h4 style={{ margin: 0 }}>
                                            {calendarDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}
                                        </h4>
                                        <button className="btn btn-secondary" onClick={() => {
                                            const newDate = new Date(calendarDate);
                                            newDate.setMonth(newDate.getMonth() + 1);
                                            setCalendarDate(newDate);
                                        }}>
                                            Next →
                                        </button>
                                    </div>

                                    {/* Calendar Grid */}
                                    <div style={{
                                        display: 'grid',
                                        gridTemplateColumns: 'repeat(7, 1fr)',
                                        gap: '0.5rem',
                                        marginBottom: '1rem'
                                    }}>
                                        {/* Day Headers */}
                                        {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map(day => (
                                            <div key={day} style={{
                                                padding: '0.5rem',
                                                textAlign: 'center',
                                                fontWeight: 'bold',
                                                color: 'var(--text-secondary)',
                                                fontSize: '0.85rem'
                                            }}>
                                                {day}
                                            </div>
                                        ))}

                                        {(() => {
                                            const year = calendarDate.getFullYear();
                                            const month = calendarDate.getMonth();
                                            const firstDay = new Date(year, month, 1).getDay();
                                            const daysInMonth = new Date(year, month + 1, 0).getDate();
                                            const today = new Date();
                                            today.setHours(0, 0, 0, 0);

                                            const days = [];

                                            // Empty cells for days before month starts
                                            for (let i = 0; i < firstDay; i++) {
                                                days.push(<div key={`empty-${i}`} style={{ padding: '0.5rem' }} />);
                                            }

                                            // Actual days of the month
                                            for (let day = 1; day <= daysInMonth; day++) {
                                                const date = new Date(year, month, day);
                                                const isToday = isSameDay(date, today);

                                                // Find items scheduled for this date
                                                const quotes = (culturalCalibration.quotes || []).filter(q => isScheduledFor(q, date));
                                                const challenges = (culturalCalibration.challenges || []).filter(c => isScheduledFor(c, date));
                                                const hasItems = quotes.length > 0 || challenges.length > 0;

                                                days.push(
                                                    <div
                                                        key={day}
                                                        style={{
                                                            padding: '0.5rem',
                                                            border: '1px solid var(--borde)',
                                                            borderRadius: '4px',
                                                            minHeight: '80px',
                                                            backgroundColor: isToday ? 'rgba(var(--accent-rgb), 0.1)' : 'var(--bg-secondary)',
                                                            borderColor: isToday ? 'var(--accent)' : 'var(--border)',
                                                            cursor: hasItems ? 'pointer' : 'default',
                                                            transition: 'all 0.2s ease'
                                                        }}
                                                        onMouseEnter={(e) => {
                                                            if (hasItems) {
                                                                e.currentTarget.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
                                                                e.currentTarget.style.transform = 'translateY(-2px)';
                                                            }
                                                        }}
                                                        onMouseLeave={(e) => {
                                                            if (hasItems) {
                                                                e.currentTarget.style.boxShadow = 'none';
                                                                e.currentTarget.style.transform = 'translateY(0)';
                                                            }
                                                        }}
                                                    >
                                                        <div style={{
                                                            fontWeight: isToday ? 'bold' : 'normal',
                                                            marginBottom: '0.25rem',
                                                            color: isToday ? 'var(--accent)' : 'var(--text-primary)'
                                                        }}>
                                                            {day}
                                                        </div>

                                                        {/* Display scheduled items */}
                                                        {hasItems && (
                                                            <div style={{ fontSize: '0.75rem', display: 'flex', flexDirection: 'column', gap: '0.25rem' }}>
                                                                {quotes.map((q, idx) => (
                                                                    <div
                                                                        key={`quote-${idx}`}
                                                                        style={{
                                                                            padding: '0.15rem 0.3rem',
                                                                            background: 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)',
                                                                            color: 'white',
                                                                            borderRadius: '3px',
                                                                            overflow: 'hidden',
                                                                            textOverflow: 'ellipsis',
                                                                            whiteSpace: 'nowrap',
                                                                            fontSize: '0.7rem'
                                                                        }}
                                                                        title={`Quote: "${q.text}"`}
                                                                    >
                                                                        💬 {q.recurring?.enabled ? '🔄 ' : ''}Quote
                                                                    </div>
                                                                ))}
                                                                {challenges.map((c, idx) => (
                                                                    <div
                                                                        key={`challenge-${idx}`}
                                                                        style={{
                                                                            padding: '0.15rem 0.3rem',
                                                                            background: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)',
                                                                            color: 'white',
                                                                            borderRadius: '3px',
                                                                            overflow: 'hidden',
                                                                            textOverflow: 'ellipsis',
                                                                            whiteSpace: 'nowrap',
                                                                            fontSize: '0.7rem'
                                                                        }}
                                                                        title={`Challenge: "${c.text}"`}
                                                                    >
                                                                        ⚡ {c.recurring?.enabled ? '🔄 ' : ''}Challenge
                                                                    </div>
                                                                ))}
                                                            </div>
                                                        )}
                                                    </div>
                                                );
                                            }

                                            return days;
                                        })()}
                                    </div>

                                    {/* Legend */}
                                    <div style={{
                                        display: 'flex',
                                        gap: '1.5rem',
                                        justifyContent: 'center',
                                        padding: '1rem',
                                        borderTop: '1px solid var(--border)'
                                    }}>
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', fontSize: '0.85rem' }}>
                                            <div style={{
                                                width: '20px',
                                                height: '20px',
                                                background: 'linear-gradient(135deg, #3b82f6 0%, #2563eb 100%)',
                                                borderRadius: '3px'
                                            }} />
                                            <span>Quote</span>
                                        </div>
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', fontSize: '0.85rem' }}>
                                            <div style={{
                                                width: '20px',
                                                height: '20px',
                                                background: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)',
                                                borderRadius: '3px'
                                            }} />
                                            <span>Challenge</span>
                                        </div>
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', fontSize: '0.85rem' }}>
                                            <span>🔄</span>
                                            <span>Recurring</span>
                                        </div>
                                    </div>
                                </div>
                            )}

                            {/* Schedule Modal */}
                            {scheduleModal && (
                                <ScheduleModal
                                    scheduleModal={scheduleModal}
                                    setScheduleModal={setScheduleModal}
                                    updateSchedule={updateSchedule}
                                />
                            )}
                        </>
                    ) : (
                        <><div className="card" style={{ padding: '1.5rem' }}><h3 style={{ margin: '0 0 1rem 0' }}>Today's Quote</h3>{activeQuoteObj ? (<div style={{ fontSize: '1.1rem' }}><div style={{ fontStyle: 'italic', marginBottom: '0.75rem' }}>"{activeQuoteObj.text}"</div><div style={{ textAlign: 'right', color: 'var(--text-secondary)' }}>— {activeQuoteObj.author}</div></div>) : (<div style={{ color: 'var(--text-secondary)', fontStyle: 'italic' }}>No active quote for today</div>)}</div><div className="card" style={{ padding: '1.5rem' }}><h3 style={{ margin: '0 0 1rem 0' }}>Today's Challenge</h3>{activeChallengeObj ? (<div style={{ fontSize: '1.05rem' }}>{activeChallengeObj.text}</div>) : (<div style={{ color: 'var(--text-secondary)', fontStyle: 'italic' }}>No active challenge for today</div>)}</div><div className="card" style={{ padding: '1.5rem' }}><h3 style={{ margin: '0 0 1rem 0' }}>Your Feedback</h3><div style={{ marginBottom: '1.5rem' }}><label className="form-label">How are you feeling about our program's culture? What's on your mind?</label><textarea className="form-input" rows={4} placeholder="Share your thoughts, reflections, or concerns..." value={reflection} onChange={e => setReflection(e.target.value)} /></div><div style={{ marginBottom: '1.5rem' }}><label className="form-label">Current Culture Score (1-10)</label><div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}><input type="range" min="1" max="10" value={currentScore} onChange={e => setCurrentScore(parseInt(e.target.value))} style={{ flex: 1 }} /><span style={{ fontSize: '1.25rem', fontWeight: 'bold', minWidth: '3ch', color: '#f97316' }}>{currentScore}</span></div></div><div style={{ marginBottom: '1.5rem' }}><label className="form-label">Desired Culture Score (1-10)</label><div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}><input type="range" min="1" max="10" value={desiredScore} onChange={e => setDesiredScore(parseInt(e.target.value))} style={{ flex: 1 }} /><span style={{ fontSize: '1.25rem', fontWeight: 'bold', minWidth: '3ch', color: '#10b981' }}>{desiredScore}</span></div></div><div style={{ marginBottom: '1.5rem' }}><label className="form-label">Additional Feedback (Optional)</label><textarea className="form-input" rows={3} placeholder="Any suggestions or thoughts on how we can improve?" value={feedback} onChange={e => setFeedback(e.target.value)} /></div><button className="btn btn-primary" onClick={submitResponse} disabled={!reflection.trim()} style={{ width: '100%' }}>Submit Response</button></div></>
                    )}
                </div>
            );
        };

        // --- INSTALL SLIDESHOW COMPONENT ---
        const RenderInstallSlideshow = ({ plays, wizLibrary, positionNames, positionColors = {} }) => {
            const [currentIndex, setCurrentIndex] = useState(0);

            // Filter plays that have isInstall: true
            const installPlays = useMemo(() => {
                if (!plays) return [];
                return plays.filter(p => p.isInstall === true);
            }, [plays]);

            if (installPlays.length === 0) {
                return (
                    <div style={{ padding: '2rem', textAlign: 'center', color: '#666' }}>
                        <h3>No plays added to Install Slideshow.</h3>
                        <p>Go to "Edit Play" and check "Add to Install Slideshow" to see plays here.</p>
                    </div>
                );
            }

            const currentPlay = installPlays[currentIndex];

            return (
                <div style={{ height: 'calc(100vh - 100px)', display: 'flex', flexDirection: 'column' }}>
                    <div style={{ padding: '1rem', borderBottom: '1px solid #ccc', display: 'flex', justifyContent: 'space-between', alignItems: 'center', background: 'white' }}>
                        <div>
                            <h2 style={{ margin: 0 }}>Install Slideshow</h2>
                            <p style={{ margin: 0, color: '#666' }}>{currentPlay.name} ({currentIndex + 1} of {installPlays.length})</p>
                        </div>
                        <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center' }}>
                            <button className="btn btn-secondary" onClick={() => setCurrentIndex(prev => Math.max(0, prev - 1))} disabled={currentIndex === 0}>Previous</button>
                            <button className="btn btn-secondary" onClick={() => setCurrentIndex(prev => Math.min(installPlays.length - 1, prev + 1))} disabled={currentIndex === installPlays.length - 1}>Next</button>
                        </div>
                    </div>
                    <div style={{ flex: 1, background: '#f0f0f0', position: 'relative' }}>
                        {/* Key: Force re-mount on play change */}
                        <PlayDiagramEditor
                            key={currentPlay.id}
                            initialData={currentPlay.diagramData || { elements: [] }}
                            onSave={() => { }}
                            onCancel={() => { }}
                            mode="standard"
                            readOnly={true}
                            positionNames={positionNames}
                            positionColors={positionColors}
                            wizLibrary={wizLibrary}
                        />
                    </div>
                </div>
            );
        };

        const PracticeReportView = ({ weeks, plays, playSyntax = [], parsePlayName, currentWeek, playCategories = [], playBuckets = [], onUpdatePlans, onNavigate }) => {
            const [selectedWeekId, setSelectedWeekId] = useState(currentWeek?.id || weeks[0]?.id);
            const [addToScriptModal, setAddToScriptModal] = useState(null); // { playId, playName }
            const [modalDay, setModalDay] = useState('Monday');
            const [modalSegmentId, setModalSegmentId] = useState(null);
            const [expandedCategories, setExpandedCategories] = useState({});

            // Get selected week
            const selectedWeek = weeks.find(w => w.id === selectedWeekId) || currentWeek || weeks[0];

            // Coverage Analysis
            const coverageData = useMemo(() => {
                if (!selectedWeek) return null;

                // 1. Get all game plan play IDs
                const gamePlanPlayIds = new Set();
                const gamePlan = selectedWeek.offensiveGamePlan || {};

                // Handle both array and object formats for sets
                const sets = Array.isArray(gamePlan.sets) ? gamePlan.sets : Object.values(gamePlan.sets || {});
                sets.forEach(set => {
                    (set.playIds || set.assignedPlayIds || []).forEach(id => {
                        const playId = typeof id === 'object' ? id.id : id;
                        if (playId && playId !== 'GAP') gamePlanPlayIds.add(playId);
                    });
                });

                // Also check miniScripts
                const miniScripts = Array.isArray(gamePlan.miniScripts) ? gamePlan.miniScripts : Object.values(gamePlan.miniScripts || {});
                miniScripts.forEach(ms => {
                    (ms.playIds || ms.assignedPlayIds || []).forEach(id => {
                        const playId = typeof id === 'object' ? id.id : id;
                        if (playId && playId !== 'GAP') gamePlanPlayIds.add(playId);
                    });
                });

                // 2. Count reps per play from this week's practice scripts
                const weekReps = {};
                const practicePlans = selectedWeek.practicePlans || {};
                const daysData = Array.isArray(practicePlans) ? practicePlans : Object.values(practicePlans);

                daysData.forEach(day => {
                    (day.segments || []).forEach(seg => {
                        (seg.script || []).forEach(row => {
                            if (row.playId) {
                                weekReps[row.playId] = (weekReps[row.playId] || 0) + 1;
                            } else if (row.play) {
                                // Try to find play by name
                                const matchedPlay = plays.find(p => p.name === row.play);
                                if (matchedPlay) {
                                    weekReps[matchedPlay.id] = (weekReps[matchedPlay.id] || 0) + 1;
                                }
                            }
                        });
                    });
                });

                // 3. Count season-wide reps (historical - all previous weeks)
                const seasonReps = {};
                weeks.filter(w => (w.weekNumber || 0) < (selectedWeek.weekNumber || 999)).forEach(prevWeek => {
                    const prevPlans = prevWeek.practicePlans || {};
                    const prevDays = Array.isArray(prevPlans) ? prevPlans : Object.values(prevPlans);

                    prevDays.forEach(day => {
                        (day.segments || []).forEach(seg => {
                            (seg.script || []).forEach(row => {
                                if (row.playId) {
                                    seasonReps[row.playId] = (seasonReps[row.playId] || 0) + 1;
                                }
                            });
                        });
                    });
                });

                // 4. Categorize plays
                const needsAttention = [];
                const lowReps = [];
                const adequate = [];
                const notOnGamePlan = [];

                gamePlanPlayIds.forEach(playId => {
                    const play = plays.find(p => p.id === playId);
                    if (!play) return;

                    const reps = weekReps[playId] || 0;
                    const historicalReps = seasonReps[playId] || 0;
                    const isNewInstall = (selectedWeek.newInstallIds || []).includes(playId);
                    const category = playCategories.find(c => c.id === play.categoryId);
                    const bucket = playBuckets.find(b => b.id === play.bucketId);

                    const item = { play, reps, historicalReps, isNewInstall, category, bucket };

                    if (reps === 0) needsAttention.push(item);
                    else if (reps < 3) lowReps.push(item);
                    else adequate.push(item);
                });

                // Find plays practiced but not on game plan
                Object.keys(weekReps).forEach(playId => {
                    if (!gamePlanPlayIds.has(playId)) {
                        const play = plays.find(p => p.id === playId);
                        if (play) {
                            const category = playCategories.find(c => c.id === play.categoryId);
                            const bucket = playBuckets.find(b => b.id === play.bucketId);
                            notOnGamePlan.push({
                                play,
                                reps: weekReps[playId],
                                historicalReps: seasonReps[playId] || 0,
                                category,
                                bucket
                            });
                        }
                    }
                });

                // 5. Group by category for breakdown view
                const byCategory = {};
                playCategories.forEach(cat => {
                    byCategory[cat.id] = { ...cat, totalPlays: 0, coveredPlays: 0, totalReps: 0, buckets: {} };
                });
                byCategory['unassigned'] = { id: 'unassigned', label: 'Unassigned', color: '#64748b', totalPlays: 0, coveredPlays: 0, totalReps: 0, buckets: {} };

                gamePlanPlayIds.forEach(playId => {
                    const play = plays.find(p => p.id === playId);
                    if (!play) return;

                    const catId = play.categoryId || 'unassigned';
                    const bucketId = play.bucketId || 'other';
                    const reps = weekReps[playId] || 0;

                    if (!byCategory[catId]) byCategory[catId] = byCategory['unassigned'];
                    if (!byCategory[catId].buckets[bucketId]) {
                        const bucket = playBuckets.find(b => b.id === bucketId);
                        byCategory[catId].buckets[bucketId] = { id: bucketId, label: bucket?.label || 'Other', plays: [], totalReps: 0 };
                    }

                    byCategory[catId].buckets[bucketId].plays.push({ play, reps });
                    byCategory[catId].buckets[bucketId].totalReps += reps;
                    byCategory[catId].totalPlays++;
                    byCategory[catId].totalReps += reps;
                    if (reps > 0) byCategory[catId].coveredPlays++;
                });

                const practicedFromGamePlan = Object.keys(weekReps).filter(id => gamePlanPlayIds.has(id)).length;

                return {
                    gamePlanCount: gamePlanPlayIds.size,
                    practicedCount: practicedFromGamePlan,
                    coveragePercent: gamePlanPlayIds.size > 0 ? Math.round((practicedFromGamePlan / gamePlanPlayIds.size) * 100) : 0,
                    needsAttention,
                    lowReps,
                    adequate,
                    notOnGamePlan,
                    byCategory,
                    totalWeekReps: Object.values(weekReps).reduce((a, b) => a + b, 0)
                };
            }, [selectedWeekId, selectedWeek, weeks, plays, playCategories, playBuckets]);

            // Get available segments for Add to Script modal
            const getAvailableSegments = (day) => {
                const plans = selectedWeek?.practicePlans || {};
                const dayPlan = Array.isArray(plans) ? plans.find(p => p.day === day) : plans[day];
                if (!dayPlan) return [];
                return (dayPlan.segments || []).filter(s => s.hasScript);
            };

            // Handle Add to Script
            const handleAddToScript = () => {
                if (!addToScriptModal || !modalSegmentId || !onUpdatePlans) return;

                const plans = { ...(selectedWeek?.practicePlans || {}) };
                const dayPlan = Array.isArray(plans) ? plans.find(p => p.day === modalDay) : plans[modalDay];
                if (!dayPlan) return;

                const segmentIndex = (dayPlan.segments || []).findIndex(s => s.id === modalSegmentId);
                if (segmentIndex === -1) return;

                const segment = dayPlan.segments[segmentIndex];
                const script = [...(segment.script || [])];

                // Find first empty slot
                const emptyIndex = script.findIndex(row => !row.play && !row.playId);
                if (emptyIndex === -1) {
                    alert('No empty slots available in this segment');
                    return;
                }

                const play = plays.find(p => p.id === addToScriptModal.playId);
                script[emptyIndex] = { ...script[emptyIndex], play: play?.name || '', playId: addToScriptModal.playId };

                const updatedSegments = [...dayPlan.segments];
                updatedSegments[segmentIndex] = { ...segment, script };

                if (Array.isArray(plans)) {
                    const dayIndex = plans.findIndex(p => p.day === modalDay);
                    plans[dayIndex] = { ...dayPlan, segments: updatedSegments };
                } else {
                    plans[modalDay] = { ...dayPlan, segments: updatedSegments };
                }

                onUpdatePlans(plans);
                setAddToScriptModal(null);
            };

            // Play row renderer
            const renderPlayRow = (item, showAddButton = true) => (
                <div key={item.play.id} style={{
                    display: 'flex',
                    alignItems: 'center',
                    padding: '0.5rem 0.75rem',
                    borderBottom: '1px solid var(--border)',
                    gap: '0.5rem'
                }}>
                    <div style={{
                        width: '8px',
                        height: '8px',
                        borderRadius: '50%',
                        background: item.reps === 0 ? '#ef4444' : item.reps < 3 ? '#f59e0b' : '#10b981',
                        flexShrink: 0
                    }} />
                    <div style={{ flex: 1, fontWeight: '500', fontSize: '0.9rem' }}>{item.play.name}</div>
                    <div style={{ fontSize: '0.75rem', color: '#64748b', minWidth: '70px' }}>
                        {item.category?.label || item.bucket?.label || '-'}
                    </div>
                    <div style={{ fontSize: '0.8rem', fontWeight: 'bold', minWidth: '50px', textAlign: 'center', color: item.reps === 0 ? '#ef4444' : item.reps < 3 ? '#f59e0b' : '#10b981' }}>
                        {item.reps} rep{item.reps !== 1 ? 's' : ''}
                    </div>
                    {item.isNewInstall && (
                        <span style={{ fontSize: '0.65rem', background: '#fbbf24', color: '#000', padding: '2px 6px', borderRadius: '4px', fontWeight: 'bold' }}>NEW</span>
                    )}
                    {item.historicalReps > 0 && (
                        <span style={{ fontSize: '0.7rem', color: '#94a3b8' }}>Season: {item.historicalReps}</span>
                    )}
                    {showAddButton && onUpdatePlans && (
                        <button
                            onClick={() => setAddToScriptModal({ playId: item.play.id, playName: item.play.name })}
                            style={{
                                padding: '4px 8px',
                                fontSize: '0.7rem',
                                background: '#3b82f6',
                                color: 'white',
                                border: 'none',
                                borderRadius: '4px',
                                cursor: 'pointer',
                                fontWeight: 'bold'
                            }}
                        >
                            + Add
                        </button>
                    )}
                </div>
            );

            if (!coverageData) return <div style={{ padding: '2rem' }}>Loading...</div>;

            return (
                <div style={{ height: '100%', display: 'flex', flexDirection: 'column', gap: '1rem', padding: '1rem', overflow: 'hidden' }}>
                    {/* Header */}
                    <div className="card" style={{ padding: '1rem 1.5rem' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                            <h2 style={{ margin: 0, display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                <Icon name="ClipboardCheck" size={24} />
                                Practice Coverage Report
                            </h2>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                                <select
                                    className="form-input"
                                    value={selectedWeekId}
                                    onChange={(e) => setSelectedWeekId(e.target.value)}
                                    style={{ minWidth: '180px' }}
                                >
                                    {weeks.map(w => (
                                        <option key={w.id} value={w.id}>
                                            {w.name}{w.opponent ? ` vs. ${w.opponent}` : ''}
                                        </option>
                                    ))}
                                </select>
                            </div>
                        </div>

                        {/* Summary Stats */}
                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '1rem' }}>
                            <div style={{ background: '#3b82f6', padding: '1rem', borderRadius: '8px', color: 'white' }}>
                                <div style={{ fontSize: '0.8rem', opacity: 0.9 }}>Game Plan</div>
                                <div style={{ fontSize: '1.8rem', fontWeight: 'bold' }}>{coverageData.gamePlanCount}</div>
                                <div style={{ fontSize: '0.75rem', opacity: 0.8 }}>plays</div>
                            </div>
                            <div style={{ background: '#10b981', padding: '1rem', borderRadius: '8px', color: 'white' }}>
                                <div style={{ fontSize: '0.8rem', opacity: 0.9 }}>Practiced</div>
                                <div style={{ fontSize: '1.8rem', fontWeight: 'bold' }}>{coverageData.practicedCount}</div>
                                <div style={{ fontSize: '0.75rem', opacity: 0.8 }}>plays covered</div>
                            </div>
                            <div style={{ background: 'var(--surface)', padding: '1rem', borderRadius: '8px', border: '1px solid var(--border)' }}>
                                <div style={{ fontSize: '0.8rem', opacity: 0.8 }}>Coverage</div>
                                <div style={{ fontSize: '1.8rem', fontWeight: 'bold' }}>{coverageData.coveragePercent}%</div>
                                <div style={{ height: '6px', background: '#e2e8f0', borderRadius: '3px', marginTop: '4px' }}>
                                    <div style={{ height: '100%', width: `${coverageData.coveragePercent}%`, background: coverageData.coveragePercent >= 90 ? '#10b981' : coverageData.coveragePercent >= 70 ? '#f59e0b' : '#ef4444', borderRadius: '3px' }} />
                                </div>
                            </div>
                            <div style={{ background: coverageData.needsAttention.length > 0 ? '#fef2f2' : '#f0fdf4', padding: '1rem', borderRadius: '8px', border: `1px solid ${coverageData.needsAttention.length > 0 ? '#fecaca' : '#bbf7d0'}` }}>
                                <div style={{ fontSize: '0.8rem', color: coverageData.needsAttention.length > 0 ? '#dc2626' : '#16a34a' }}>Needs Work</div>
                                <div style={{ fontSize: '1.8rem', fontWeight: 'bold', color: coverageData.needsAttention.length > 0 ? '#dc2626' : '#16a34a' }}>{coverageData.needsAttention.length}</div>
                                <div style={{ fontSize: '0.75rem', color: coverageData.needsAttention.length > 0 ? '#dc2626' : '#16a34a' }}>plays w/ 0 reps</div>
                            </div>
                        </div>
                    </div>

                    {/* Main Content */}
                    <div style={{ flex: 1, display: 'flex', gap: '1rem', overflow: 'hidden' }}>
                        {/* Left Column - Alerts */}
                        <div style={{ width: '50%', display: 'flex', flexDirection: 'column', gap: '1rem', overflow: 'hidden' }}>
                            {/* Needs Attention */}
                            {coverageData.needsAttention.length > 0 && (
                                <div className="card" style={{ flex: coverageData.lowReps.length > 0 ? 1 : 2, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
                                    <div style={{ padding: '0.75rem 1rem', borderBottom: '1px solid var(--border)', background: '#fef2f2', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                        <Icon name="AlertTriangle" size={18} color="#dc2626" />
                                        <span style={{ fontWeight: 'bold', color: '#dc2626' }}>NEEDS ATTENTION</span>
                                        <span style={{ fontSize: '0.8rem', color: '#dc2626' }}>({coverageData.needsAttention.length} plays with 0 reps)</span>
                                    </div>
                                    <div style={{ overflowY: 'auto', flex: 1 }}>
                                        {coverageData.needsAttention.map(item => renderPlayRow(item))}
                                    </div>
                                </div>
                            )}

                            {/* Low Reps */}
                            {coverageData.lowReps.length > 0 && (
                                <div className="card" style={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
                                    <div style={{ padding: '0.75rem 1rem', borderBottom: '1px solid var(--border)', background: '#fffbeb', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                        <Icon name="AlertCircle" size={18} color="#d97706" />
                                        <span style={{ fontWeight: 'bold', color: '#d97706' }}>LOW REPS</span>
                                        <span style={{ fontSize: '0.8rem', color: '#d97706' }}>(1-2 reps, standard is 3)</span>
                                    </div>
                                    <div style={{ overflowY: 'auto', flex: 1 }}>
                                        {coverageData.lowReps.map(item => renderPlayRow(item))}
                                    </div>
                                </div>
                            )}

                            {/* All Good State */}
                            {coverageData.needsAttention.length === 0 && coverageData.lowReps.length === 0 && (
                                <div className="card" style={{ flex: 1, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: '2rem' }}>
                                    <Icon name="CheckCircle" size={48} color="#10b981" />
                                    <div style={{ marginTop: '1rem', fontSize: '1.1rem', fontWeight: 'bold', color: '#10b981' }}>Great Coverage!</div>
                                    <div style={{ color: '#64748b' }}>All game plan plays have adequate reps.</div>
                                </div>
                            )}
                        </div>

                        {/* Right Column - Category Breakdown & Not on Game Plan */}
                        <div style={{ width: '50%', display: 'flex', flexDirection: 'column', gap: '1rem', overflow: 'hidden' }}>
                            {/* Category Breakdown */}
                            <div className="card" style={{ flex: 2, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
                                <div style={{ padding: '0.75rem 1rem', borderBottom: '1px solid var(--border)', fontWeight: 'bold' }}>
                                    By Category
                                </div>
                                <div style={{ overflowY: 'auto', flex: 1, padding: '0.5rem' }}>
                                    {Object.values(coverageData.byCategory).filter(cat => cat.totalPlays > 0).map(cat => (
                                        <div key={cat.id} style={{ marginBottom: '0.5rem', border: '1px solid var(--border)', borderRadius: '6px', overflow: 'hidden' }}>
                                            <div
                                                onClick={() => setExpandedCategories(prev => ({ ...prev, [cat.id]: !prev[cat.id] }))}
                                                style={{
                                                    padding: '0.6rem 0.75rem',
                                                    background: cat.color || '#64748b',
                                                    color: 'white',
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    justifyContent: 'space-between',
                                                    cursor: 'pointer'
                                                }}
                                            >
                                                <span style={{ fontWeight: 'bold', textTransform: 'uppercase', fontSize: '0.8rem' }}>{cat.label}</span>
                                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.75rem' }}>
                                                    <span style={{ fontSize: '0.75rem' }}>{cat.coveredPlays}/{cat.totalPlays} covered</span>
                                                    <span style={{ fontSize: '0.75rem' }}>{cat.totalReps} reps</span>
                                                    <Icon name={expandedCategories[cat.id] ? "ChevronDown" : "ChevronRight"} size={16} color="white" />
                                                </div>
                                            </div>
                                            {expandedCategories[cat.id] && (
                                                <div style={{ background: '#f8fafc' }}>
                                                    {Object.values(cat.buckets).map(bucket => (
                                                        <div key={bucket.id} style={{ padding: '0.4rem 0.75rem', borderBottom: '1px solid #e2e8f0', display: 'flex', alignItems: 'center', fontSize: '0.85rem' }}>
                                                            <span style={{
                                                                width: '8px',
                                                                height: '8px',
                                                                borderRadius: '50%',
                                                                background: bucket.totalReps === 0 ? '#ef4444' : bucket.totalReps < bucket.plays.length * 3 ? '#f59e0b' : '#10b981',
                                                                marginRight: '8px'
                                                            }} />
                                                            <span style={{ flex: 1 }}>{bucket.label}</span>
                                                            <span style={{ color: '#64748b', marginRight: '8px' }}>{bucket.plays.length} play{bucket.plays.length !== 1 ? 's' : ''}</span>
                                                            <span style={{ fontWeight: 'bold', color: bucket.totalReps === 0 ? '#ef4444' : bucket.totalReps < bucket.plays.length * 3 ? '#f59e0b' : '#10b981' }}>
                                                                {bucket.totalReps} reps
                                                            </span>
                                                        </div>
                                                    ))}
                                                </div>
                                            )}
                                        </div>
                                    ))}
                                </div>
                            </div>

                            {/* Not on Game Plan */}
                            {coverageData.notOnGamePlan.length > 0 && (
                                <div className="card" style={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
                                    <div style={{ padding: '0.75rem 1rem', borderBottom: '1px solid var(--border)', background: '#f1f5f9', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                        <Icon name="FileQuestion" size={18} color="#64748b" />
                                        <span style={{ fontWeight: 'bold', color: '#64748b' }}>NOT ON GAME PLAN</span>
                                        <span style={{ fontSize: '0.8rem', color: '#94a3b8' }}>(practiced but not in game plan)</span>
                                    </div>
                                    <div style={{ overflowY: 'auto', flex: 1 }}>
                                        {coverageData.notOnGamePlan.map(item => renderPlayRow(item, false))}
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Add to Script Modal */}
                    {addToScriptModal && (
                        <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000 }}>
                            <div className="card" style={{ width: '400px', padding: '1.5rem' }}>
                                <h3 style={{ margin: '0 0 1rem 0' }}>Add "{addToScriptModal.playName}" to Script</h3>

                                <div style={{ marginBottom: '1rem' }}>
                                    <label style={{ display: 'block', marginBottom: '0.25rem', fontWeight: '500', fontSize: '0.9rem' }}>Day</label>
                                    <select
                                        className="form-input"
                                        value={modalDay}
                                        onChange={(e) => {
                                            setModalDay(e.target.value);
                                            setModalSegmentId(null);
                                        }}
                                        style={{ width: '100%' }}
                                    >
                                        {['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'].map(day => (
                                            <option key={day} value={day}>{day}</option>
                                        ))}
                                    </select>
                                </div>

                                <div style={{ marginBottom: '1rem' }}>
                                    <label style={{ display: 'block', marginBottom: '0.25rem', fontWeight: '500', fontSize: '0.9rem' }}>Segment</label>
                                    <select
                                        className="form-input"
                                        value={modalSegmentId || ''}
                                        onChange={(e) => setModalSegmentId(e.target.value)}
                                        style={{ width: '100%' }}
                                    >
                                        <option value="">Select segment...</option>
                                        {getAvailableSegments(modalDay).map(seg => (
                                            <option key={seg.id} value={seg.id}>{seg.type || seg.name || 'Segment'}</option>
                                        ))}
                                    </select>
                                </div>

                                {modalSegmentId && (() => {
                                    const segments = getAvailableSegments(modalDay);
                                    const seg = segments.find(s => s.id === modalSegmentId);
                                    const emptySlots = (seg?.script || []).filter(r => !r.play && !r.playId).length;
                                    return (
                                        <div style={{ padding: '0.75rem', background: '#f0fdf4', borderRadius: '6px', marginBottom: '1rem', fontSize: '0.85rem', color: '#16a34a' }}>
                                            {emptySlots > 0 ? `${emptySlots} empty slot${emptySlots !== 1 ? 's' : ''} available` : 'No empty slots - play will be added to a new row'}
                                        </div>
                                    );
                                })()}

                                <div style={{ display: 'flex', gap: '0.5rem', justifyContent: 'flex-end' }}>
                                    <button
                                        onClick={() => setAddToScriptModal(null)}
                                        style={{ padding: '0.5rem 1rem', background: '#e2e8f0', border: 'none', borderRadius: '6px', cursor: 'pointer' }}
                                    >
                                        Cancel
                                    </button>
                                    <button
                                        onClick={handleAddToScript}
                                        disabled={!modalSegmentId}
                                        style={{
                                            padding: '0.5rem 1rem',
                                            background: modalSegmentId ? '#3b82f6' : '#94a3b8',
                                            color: 'white',
                                            border: 'none',
                                            borderRadius: '6px',
                                            cursor: modalSegmentId ? 'pointer' : 'not-allowed',
                                            fontWeight: 'bold'
                                        }}
                                    >
                                        Add to Script
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- HIERARCHY EDITOR COMPONENT ---
        const HierarchyEditor = ({ segmentTypes, focusItems, settings, onUpdateSettings, onAddSegment, onAddFocus, onRenameSegment, onRenameFocus, deleteConfirmation, setDeleteConfirmation, onDeleteSegment, onDeleteFocus }) => {
            const [selectedSegment, setSelectedSegment] = useState(null);

            // Filter focus items based on link checkboxes
            const isFocusAllowed = (seg, focus) => {
                const segSettings = settings[seg] || {};
                // If no specific allowed list exists, EVERYTHING is allowed (default behavior)
                if (!segSettings.allowedFocusItems || segSettings.allowedFocusItems.length === 0) return true;
                return segSettings.allowedFocusItems.includes(focus);
            };

            const toggleFocusLink = (seg, focus) => {
                const segSettings = settings[seg] || { showHash: true, showDefense: true };
                let currentAllowed = segSettings.allowedFocusItems || [];

                // If currently "All Allowed" (empty), and we click one, we must first "Exclude All Others". 
                // Wait, if I start checking boxes, it implies "Only these are allowed".
                // So if currentAllowed is empty, and I click 'A', then 'A' is the ONLY one allowed.

                if (!currentAllowed.includes(focus)) {
                    // ADDING
                    // Logic: If I add one, and it was empty, then effectively I just switched from "All" to "One".
                    const newAllowed = [...currentAllowed, focus];
                    onUpdateSettings({
                        ...settings,
                        [seg]: { ...segSettings, allowedFocusItems: newAllowed }
                    });
                } else {
                    // REMOVING
                    const newAllowed = currentAllowed.filter(f => f !== focus);
                    onUpdateSettings({
                        ...settings,
                        [seg]: { ...segSettings, allowedFocusItems: newAllowed }
                    });
                }
            };

            // Helper to check if a segment has ANY restrictions
            const hasRestrictions = (seg) => {
                const segSettings = settings[seg] || {};
                return segSettings.allowedFocusItems && segSettings.allowedFocusItems.length > 0;
            };

            return (
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '2rem', height: '100%', minHeight: 0 }}>
                    {/* LEFT: Segment Types */}
                    <div style={{ background: 'var(--bg-main)', padding: '1rem', borderRadius: '8px', border: '1px solid var(--border)', display: 'flex', flexDirection: 'column' }}>
                        <h4 style={{ marginTop: 0, marginBottom: '1rem', borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem' }}>
                            Segment Types
                        </h4>

                        <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '1rem' }}>
                            <input
                                id="new-segment-type"
                                className="form-input"
                                placeholder="New Segment..."
                            />
                            <button className="btn btn-primary" onClick={() => {
                                const val = document.getElementById('new-segment-type').value.trim();
                                if (val) {
                                    onAddSegment(val);
                                    document.getElementById('new-segment-type').value = '';
                                }
                            }}>Add</button>
                        </div>

                        <div style={{ flex: 1, overflowY: 'auto', display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                            {segmentTypes.map(item => {
                                const segSettings = settings[item] || { showHash: true, showDefense: true };
                                const isSelected = selectedSegment === item;
                                const restrictedCount = segSettings.allowedFocusItems?.length || 0;

                                return (
                                    <div
                                        key={item}
                                        onClick={() => setSelectedSegment(item)}
                                        style={{
                                            display: 'flex', justifyContent: 'space-between', alignItems: 'center',
                                            padding: '0.5rem',
                                            background: isSelected ? 'var(--primary)' : 'var(--bg-panel)',
                                            color: isSelected ? 'white' : 'inherit',
                                            borderRadius: '4px',
                                            cursor: 'pointer',
                                            border: isSelected ? '1px solid var(--primary-dark)' : '1px solid transparent'
                                        }}
                                    >
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '2px' }}>
                                            <input
                                                type="text"
                                                value={item}
                                                onChange={(e) => {
                                                    const newName = e.target.value;
                                                    if (newName && newName !== item && !segmentTypes.includes(newName)) {
                                                        onRenameSegment(item, newName);
                                                    }
                                                }}
                                                onBlur={(e) => {
                                                    const newName = e.target.value.trim();
                                                    if (!newName || newName === item) {
                                                        e.target.value = item;
                                                    } else if (segmentTypes.includes(newName)) {
                                                        e.target.value = item;
                                                    }
                                                }}
                                                onKeyDown={(e) => {
                                                    if (e.key === 'Enter') {
                                                        e.target.blur();
                                                    }
                                                }}
                                                onClick={(e) => e.stopPropagation()}
                                                style={{
                                                    background: 'transparent',
                                                    border: 'none',
                                                    color: 'inherit',
                                                    fontWeight: '600',
                                                    fontSize: 'inherit',
                                                    padding: 0,
                                                    outline: 'none',
                                                    width: '100%',
                                                    cursor: 'text'
                                                }}
                                            />
                                            <div style={{ display: 'flex', gap: '12px', fontSize: '0.75rem', color: isSelected ? 'rgba(255,255,255,0.8)' : 'var(--text-secondary)' }}>
                                                <label onClick={e => e.stopPropagation()} style={{ display: 'flex', alignItems: 'center', gap: '4px', cursor: 'pointer' }}>
                                                    <input
                                                        type="checkbox"
                                                        checked={segSettings.showHash !== false}
                                                        onChange={(e) => {
                                                            onUpdateSettings({
                                                                ...settings,
                                                                [item]: { ...segSettings, showHash: e.target.checked }
                                                            });
                                                        }}
                                                    /> Hash
                                                </label>
                                                <label onClick={e => e.stopPropagation()} style={{ display: 'flex', alignItems: 'center', gap: '4px', cursor: 'pointer' }}>
                                                    <input
                                                        type="checkbox"
                                                        checked={segSettings.showDefense !== false}
                                                        onChange={(e) => {
                                                            onUpdateSettings({
                                                                ...settings,
                                                                [item]: { ...segSettings, showDefense: e.target.checked }
                                                            });
                                                        }}
                                                    /> Def
                                                </label>
                                            </div>
                                            {restrictedCount > 0 && (
                                                <span style={{ fontSize: '0.7rem', fontStyle: 'italic', opacity: 0.8 }}>
                                                    {restrictedCount} focus items allowed
                                                </span>
                                            )}
                                        </div>
                                        {deleteConfirmation?.list === 'segments' && deleteConfirmation?.item === item ? (
                                            <div style={{ display: 'flex', gap: '4px' }}>
                                                <button className="btn btn-icon" style={{ color: 'var(--success)' }} onClick={(e) => { e.stopPropagation(); onDeleteSegment(item); }}>
                                                    <Icon name="Check" size={14} />
                                                </button>
                                                <button className="btn btn-icon" style={{ color: 'var(--text-secondary)' }} onClick={(e) => { e.stopPropagation(); setDeleteConfirmation(null); }}>
                                                    <Icon name="X" size={14} />
                                                </button>
                                            </div>
                                        ) : (
                                            <button className="btn btn-icon" style={{ color: isSelected ? 'white' : 'var(--danger)', opacity: 0.7 }} onClick={(e) => { e.stopPropagation(); setDeleteConfirmation({ list: 'segments', item }); }}>
                                                <Icon name="Trash" size={14} />
                                            </button>
                                        )}
                                    </div>
                                );
                            })}
                        </div>
                    </div>

                    {/* RIGHT: Focus Items */}
                    <div style={{ background: 'var(--bg-main)', padding: '1rem', borderRadius: '8px', border: '1px solid var(--border)', display: 'flex', flexDirection: 'column' }}>
                        <h4 style={{ marginTop: 0, marginBottom: '1rem', borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem' }}>
                            {selectedSegment ? `Allowed Focus for "${selectedSegment}"` : 'Focus Items (Master List)'}
                        </h4>

                        {selectedSegment && (
                            <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', marginBottom: '1rem', background: 'var(--bg-panel)', padding: '0.5rem', borderRadius: '4px' }}>
                                Check items to restrict dropdown options. If <b>none</b> are checked, <b>all</b> items will be available.
                            </div>
                        )}

                        <div style={{ display: 'flex', gap: '0.5rem', marginBottom: '1rem' }}>
                            <input
                                id="new-focus-item"
                                className="form-input"
                                placeholder="New Focus..."
                            />
                            <button className="btn btn-primary" onClick={() => {
                                const val = document.getElementById('new-focus-item').value.trim();
                                if (val) {
                                    onAddFocus(val);
                                    document.getElementById('new-focus-item').value = '';
                                }
                            }}>Add</button>
                        </div>

                        <div style={{ flex: 1, overflowY: 'auto', display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                            {focusItems.map(item => {
                                const isLinked = selectedSegment ? isFocusAllowed(selectedSegment, item) && hasRestrictions(selectedSegment) : false;

                                return (
                                    <div key={item} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '0.5rem', background: 'var(--bg-panel)', borderRadius: '4px' }}>
                                        <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                                            {selectedSegment && (
                                                <input
                                                    type="checkbox"
                                                    checked={isLinked}
                                                    onChange={() => toggleFocusLink(selectedSegment, item)}
                                                />
                                            )}
                                            <input
                                                type="text"
                                                value={item}
                                                onChange={(e) => {
                                                    const newName = e.target.value;
                                                    if (newName && newName !== item && !focusItems.includes(newName)) {
                                                        onRenameFocus(item, newName);
                                                    }
                                                }}
                                                onBlur={(e) => {
                                                    const newName = e.target.value.trim();
                                                    if (!newName || newName === item) {
                                                        e.target.value = item;
                                                    } else if (focusItems.includes(newName)) {
                                                        e.target.value = item;
                                                    }
                                                }}
                                                onKeyDown={(e) => {
                                                    if (e.key === 'Enter') {
                                                        e.target.blur();
                                                    }
                                                }}
                                                style={{
                                                    background: 'transparent',
                                                    border: 'none',
                                                    color: 'inherit',
                                                    fontSize: 'inherit',
                                                    padding: 0,
                                                    outline: 'none',
                                                    flex: 1,
                                                    cursor: 'text'
                                                }}
                                            />
                                        </div>
                                        {deleteConfirmation?.list === 'focus' && deleteConfirmation?.item === item ? (
                                            <div style={{ display: 'flex', gap: '4px' }}>
                                                <button className="btn btn-icon" style={{ color: 'var(--success)' }} onClick={() => onDeleteFocus(item)}>
                                                    <Icon name="Check" size={14} />
                                                </button>
                                                <button className="btn btn-icon" style={{ color: 'var(--text-secondary)' }} onClick={() => setDeleteConfirmation(null)}>
                                                    <Icon name="X" size={14} />
                                                </button>
                                            </div>
                                        ) : (
                                            <button className="btn btn-icon" style={{ color: 'var(--danger)', opacity: 0.7 }} onClick={() => setDeleteConfirmation({ list: 'focus', item })}>
                                                <Icon name="Trash" size={14} />
                                            </button>
                                        )}
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                </div>
            );
        };

        const DEFAULT_PLAY_BUCKETS = [
            { id: 'run', label: 'Run', color: '#10b981', textColor: '#ffffff' },
            { id: 'pass', label: 'Pass', color: '#3b82f6', textColor: '#ffffff' },
            { id: 'screen', label: 'Screen', color: '#8b5cf6', textColor: '#ffffff' }
        ];

        // Personnel Packages Configuration
        const DEFAULT_PERSONNEL_GROUPINGS = [
            { id: 'pers_10', code: '10', name: '10 Personnel', description: '1 RB, 0 TE, 4 WR', positions: ['QB', 'RB', 'X', 'Z', 'Y', 'A'] },
            { id: 'pers_11', code: '11', name: '11 Personnel', description: '1 RB, 1 TE, 3 WR', positions: ['QB', 'RB', 'X', 'Z', 'Y', 'A'] },
            { id: 'pers_12', code: '12', name: '12 Personnel', description: '1 RB, 2 TE, 2 WR', positions: ['QB', 'RB', 'X', 'Z', 'Y', 'H'] },
            { id: 'pers_20', code: '20', name: '20 Personnel', description: '2 RB, 0 TE, 3 WR', positions: ['QB', 'RB', 'F', 'X', 'Z', 'A'] },
            { id: 'pers_21', code: '21', name: '21 Personnel', description: '2 RB, 1 TE, 2 WR', positions: ['QB', 'RB', 'F', 'X', 'Z', 'Y'] },
            { id: 'pers_22', code: '22', name: '22 Personnel', description: '2 RB, 2 TE, 1 WR', positions: ['QB', 'RB', 'F', 'X', 'Y', 'H'] },
        ];



        /* -------------------------------------------------------------------------- */
        /*                                  ANALYTICS                                  */
        /* -------------------------------------------------------------------------- */

        const PLAY_PROTOCOLS = [
            { id: 'REGULAR', color: '#3b82f6', label: 'Regular', code: 'R' },
            { id: 'SCRAMBLE', color: '#eab308', label: 'Scramble', code: 'SC' },
            { id: 'SUGAR', color: '#a855f7', label: 'Sugar Huddle', code: 'SH' },
            { id: 'INDY', color: '#22c55e', label: 'Indy', code: 'IN' },
            { id: 'LOW_RZ', color: '#ef4444', label: 'Low Red Zone', code: 'LR' },
            { id: 'HIGH_RZ', color: '#f97316', label: 'High Red Zone', code: 'HR' },
            { id: 'BACKED_UP', color: '#6366f1', label: 'Backed Up', code: 'BU' },
            { id: 'TWO_MIN', color: '#ec4899', label: 'Two Minute', code: '2M' },
            { id: 'FOUR_MIN', color: '#14b8a6', label: 'Four Minute', code: '4M' },
            { id: 'GOAL_LINE', color: '#8b5cf6', label: 'Goal Line', code: 'GL' },
            { id: 'SHORT_YD', color: '#06b6d4', label: 'Short Yardage', code: 'SY' }
        ];

        const WeeklyAnalytics = ({ currentWeek, plays, practicePlans }) => {
            const [viewMode, setViewMode] = React.useState('overall'); // 'overall', 'daily', 'usage', 'unassigned'
            const printRef = React.useRef();

            const analytics = React.useMemo(() => {
                const results = {
                    totalReps: 0,
                    concepts: { overall: {}, daily: {} },
                    unassigned: [],
                    leaderboard: [],
                    gamePlanUsage: []
                };

                if (!currentWeek || !practicePlans) return results;

                // 1. Build Play Map
                const playMap = new Map((plays || []).map(p => [p.id, p]));
                const playCounts = new Map();
                const practiceScriptPlays = new Set();

                // 2. Process Practice Plans
                Object.values(practicePlans).forEach(plan => {
                    if (plan.weekId !== currentWeek.id) return;

                    plan.periods?.forEach(period => {
                        period.scripts?.forEach(script => {
                            results.totalReps++;

                            // Track PLAYS
                            const playId = script.playId; // Assuming script has playId, or matched by name? 
                            // Based on previous code, script might be the play object itself or have a reference.
                            // Let's assume script has playId or is the play. 
                            // Wait, previous code used script.playId if it existed, or looked up by name?
                            // Let's look at how it counts.
                            // "const pid = s.playId || s.id;"

                            const pid = script.playId || script.id;
                            if (pid) {
                                practiceScriptPlays.add(pid);
                                playCounts.set(pid, (playCounts.get(pid) || 0) + 1);

                                const play = playMap.get(pid);
                                if (play) {
                                    // Count Concept
                                    const family = play.conceptFamily || 'Unclassified';
                                    results.concepts.overall[family] = (results.concepts.overall[family] || 0) + 1;

                                    // Daily
                                    const day = plan.date ? new Date(plan.date).toLocaleDateString('en-US', { weekday: 'long' }) : 'Unknown';
                                    if (!results.concepts.daily[day]) results.concepts.daily[day] = {};
                                    results.concepts.daily[day][family] = (results.concepts.daily[day][family] || 0) + 1;
                                }
                            }
                        });
                    });
                });

                // 3. Unassigned Game Plan Plays (Plays in InstallList but NOT in any script)
                if (currentWeek.installList) {
                    currentWeek.installList.forEach(item => {
                        // item is { id: playId, ... } or just playId?
                        // usually installList is array of play IDs or objects with id.
                        // let's assume objects { id: ... } based on usage.
                        const pid = item.id || item;
                        if (!practiceScriptPlays.has(pid)) {
                            const play = playMap.get(pid);
                            if (play) results.unassigned.push(play);
                        }
                    });
                }

                // 4. Game Plan Usage
                if (currentWeek.installList) {
                    results.gamePlanUsage = currentWeek.installList.map(item => {
                        const pid = item.id || item;
                        const play = playMap.get(pid);
                        return {
                            id: pid,
                            play: play,
                            count: playCounts.get(pid) || 0
                        };
                    }).sort((a, b) => b.count - a.count);
                }

                // 5. Leaderboard (Top 50)
                results.leaderboard = Array.from(playCounts.entries())
                    .map(([id, count]) => ({ play: playMap.get(id), count }))
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 50);

                return results;
            }, [currentWeek, plays, practicePlans]);

            const cardStyle = {
                background: 'var(--surface)',
                border: '1px solid var(--border)',
                borderRadius: '8px',
                padding: '1.5rem',
                marginBottom: '1.5rem',
                boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
            };

            return (
                <div className="analytics-dashboard">
                    {/* Header / Tabs */}
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                        <h3 style={{ margin: 0, display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                            <Icon name="BarChart2" /> Practice Analytics
                        </h3>
                        <div style={{ display: 'flex', gap: '0.5rem', background: 'var(--bg-input)', padding: '0.25rem', borderRadius: '6px' }}>
                            {['overall', 'daily', 'usage', 'unassigned'].map(mode => (
                                <button
                                    key={mode}
                                    onClick={() => setViewMode(mode)}
                                    style={{
                                        padding: '0.5rem 1rem',
                                        borderRadius: '4px',
                                        border: 'none',
                                        background: viewMode === mode ? 'var(--surface)' : 'transparent',
                                        color: viewMode === mode ? 'var(--text-primary)' : 'var(--text-tertiary)',
                                        fontWeight: viewMode === mode ? 600 : 400,
                                        cursor: 'pointer',
                                        textTransform: 'capitalize',
                                        boxShadow: viewMode === mode ? '0 1px 2px rgba(0,0,0,0.1)' : 'none'
                                    }}
                                >
                                    {mode === 'usage' ? 'Game Plan Usage' : mode}
                                </button>
                            ))}
                        </div>
                    </div>

                    {/* Content Area */}
                    <div ref={printRef}>
                        {viewMode === 'overall' && (
                            <div style={cardStyle}>
                                <h4 style={{ marginTop: 0 }}>Concept Breakdown (Overall)</h4>
                                <table style={{ width: '100%', borderCollapse: 'collapse', marginTop: '1rem' }}>
                                    <thead>
                                        <tr style={{ borderBottom: '1px solid var(--border)' }}>
                                            <th style={{ textAlign: 'left', padding: '0.5rem' }}>Concept Family</th>
                                            <th style={{ textAlign: 'right', padding: '0.5rem' }}>Reps</th>
                                            <th style={{ textAlign: 'right', padding: '0.5rem' }}>% Total</th>
                                            <th style={{ width: '100px', padding: '0.5rem' }}></th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {Object.entries(analytics.concepts.overall)
                                            .sort(([, a], [, b]) => b - a)
                                            .map(([concept, count]) => (
                                                <tr key={concept} style={{ borderBottom: '1px solid var(--border-light)' }}>
                                                    <td style={{ padding: '0.5rem' }}>{concept}</td>
                                                    <td style={{ textAlign: 'right', padding: '0.5rem' }}>{count}</td>
                                                    <td style={{ textAlign: 'right', padding: '0.5rem' }}>
                                                        {Math.round((count / analytics.totalReps) * 100)}%
                                                    </td>
                                                    <td style={{ padding: '0.5rem' }}>
                                                        <div style={{ height: '8px', background: 'var(--bg-input)', borderRadius: '4px', overflow: 'hidden' }}>
                                                            <div style={{ height: '100%', width: `${(count / analytics.totalReps) * 100}%`, background: 'var(--primary)' }}></div>
                                                        </div>
                                                    </td>
                                                </tr>
                                            ))}
                                    </tbody>
                                </table>
                            </div>
                        )}

                        {viewMode === 'daily' && (
                            <div style={cardStyle}>
                                <h4 style={{ marginTop: 0 }}>Daily Concept Breakdown</h4>
                                <table style={{ width: '100%', borderCollapse: 'collapse', marginTop: '1rem' }}>
                                    <thead>
                                        <tr style={{ borderBottom: '1px solid var(--border)' }}>
                                            <th style={{ textAlign: 'left', padding: '0.5rem' }}>Concept Family</th>
                                            {['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'].map(d => (
                                                <th key={d} style={{ textAlign: 'center', padding: '0.5rem' }}>{d.substr(0, 3)}</th>
                                            ))}
                                            <th style={{ textAlign: 'right', padding: '0.5rem' }}>Total</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {Object.keys(analytics.concepts.overall).map(concept => (
                                            <tr key={concept} style={{ borderBottom: '1px solid var(--border-light)' }}>
                                                <td style={{ padding: '0.5rem', fontWeight: 'bold' }}>{concept}</td>
                                                {['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'].map(day => (
                                                    <td key={day} style={{ textAlign: 'center', padding: '0.5rem', color: analytics.concepts.daily[day]?.[concept] > 0 ? 'inherit' : 'var(--text-tertiary)' }}>
                                                        {analytics.concepts.daily[day]?.[concept] || 0}
                                                    </td>
                                                ))}
                                                <td style={{ textAlign: 'right', padding: '0.5rem', fontWeight: 'bold' }}>{analytics.concepts.overall[concept]}</td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        )}

                        {viewMode === 'usage' && (
                            <div style={cardStyle}>
                                <h3 style={{ marginBottom: '1rem' }}>Game Plan Usage</h3>
                                <table style={{ width: '100%', borderCollapse: 'collapse', marginTop: '1rem' }}>
                                    <thead>
                                        <tr style={{ borderBottom: '1px solid var(--border)' }}>
                                            <th style={{ textAlign: 'left', padding: '0.5rem' }}>Play</th>
                                            <th style={{ textAlign: 'center', padding: '0.5rem' }}>Reps</th>
                                            <th style={{ textAlign: 'left', padding: '0.5rem' }}>Status</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {analytics.gamePlanUsage.map((item, idx) => (
                                            <tr key={item.playId || idx} style={{
                                                borderBottom: '1px solid var(--border-light)',
                                                background: item.count === 0 ? 'rgba(239, 68, 68, 0.05)' : 'transparent'
                                            }}>
                                                <td style={{ padding: '0.5rem' }}>
                                                    <div style={{ fontWeight: 'bold' }}>{item.play?.name || 'Unknown Play'}</div>
                                                    <div style={{ fontSize: '0.8rem', color: 'var(--text-tertiary)' }}>{item.play?.conceptFamily || 'No Concept'}</div>
                                                </td>
                                                <td style={{ textAlign: 'center', padding: '0.5rem', fontWeight: 'bold', color: item.count === 0 ? 'var(--danger)' : 'inherit' }}>
                                                    {item.count}
                                                </td>
                                                <td style={{ padding: '0.5rem' }}>
                                                    {item.count === 0 ? (
                                                        <span style={{ color: 'var(--danger)', fontSize: '0.8rem', display: 'flex', alignItems: 'center', gap: '4px' }}>
                                                            <Icon name="AlertCircle" size={14} />
                                                            Not Practiced
                                                        </span>
                                                    ) : (
                                                        <span style={{ color: 'var(--success)', fontSize: '0.8rem', display: 'flex', alignItems: 'center', gap: '4px' }}>
                                                            <Icon name="CheckCircle" size={14} />
                                                            In Practice
                                                        </span>
                                                    )}
                                                </td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        )}

                        {
                            viewMode === 'unassigned' && (
                                <div style={cardStyle}>
                                    <h3 style={{ marginBottom: '1rem' }}>Unassigned Game Plan Plays</h3>
                                    <p style={{ color: 'var(--text-secondary)', marginBottom: '1.5rem' }}>
                                        The following plays are in the Weekly Install List but have not been assigned to any practice script.
                                    </p>

                                    {analytics.unassigned.length === 0 ? (
                                        <div style={{
                                            padding: '2rem', textAlign: 'center', color: 'var(--success)',
                                            background: 'rgba(34, 197, 94, 0.1)', borderRadius: '8px',
                                            border: '1px solid rgba(34, 197, 94, 0.3)'
                                        }}>
                                            <Icon name="CheckCircle" size={24} style={{ marginBottom: '0.5rem' }} />
                                            <div style={{ fontWeight: 'bold' }}>All installed plays have been assigned!</div>
                                        </div>
                                    ) : (
                                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))', gap: '1rem' }}>
                                            {analytics.unassigned.map(play => (
                                                <div key={play?.id} style={{ padding: '0.75rem', background: 'var(--bg-panel)', border: '1px solid var(--border)', borderRadius: '6px', boxShadow: '0 1px 2px rgba(0, 0, 0, 0.1)' }}>
                                                    <div style={{ fontWeight: 'bold', marginBottom: '0.25rem' }}>{play?.name || 'Unknown Play'}</div>
                                                    <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>
                                                        {play?.formation} • {play?.conceptFamily || 'No Concept'}
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            )
                        }
                    </div>

                    {/* Leaderboard Section - Always Visible or part of Overall? */}
                    {/* Let's put Leaderboard at bottom if ViewMode is matching or just always. 
                Previous design seemed to have it separate. Let's include it in 'overall' or separate.
                The previous code had it in 'overall' I think? Or separate? 
                Let's make it a separate card below content area, visible in 'overall' mode */}

                    {
                        viewMode === 'overall' && (
                            <div style={cardStyle}>
                                <h3 style={{ marginBottom: '1rem' }}>Most Practiced Plays (Top 50)</h3>
                                <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                                    <thead>
                                        <tr style={{ borderBottom: '1px solid var(--border)' }}>
                                            <th style={{ textAlign: 'left', padding: '0.5rem' }}>Play Name</th>
                                            <th style={{ textAlign: 'left', padding: '0.5rem' }}>Concept</th>
                                            <th style={{ textAlign: 'right', padding: '0.5rem' }}>Reps</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {analytics.leaderboard.map(({ play, count }, idx) => (
                                            <tr key={idx} style={{ borderBottom: '1px solid var(--border-light)', background: idx < 3 ? 'rgba(234, 179, 8, 0.05)' : 'transparent' }}>
                                                <td style={{ padding: '0.5rem' }}>
                                                    <div style={{ fontWeight: 'bold' }}>{play?.name || 'Unknown'}</div>
                                                </td>
                                                <td style={{ padding: '0.5rem', color: 'var(--text-secondary)' }}>{play?.conceptFamily}</td>
                                                <td style={{ textAlign: 'right', padding: '0.5rem', fontWeight: 'bold' }}>{count}</td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        )
                    }
                </div >
            );
        };


        const DEPTH_CHART_TYPES = [
            { id: 'OFFENSE', label: 'Offense' },
            { id: 'DEFENSE', label: 'Defense' },
            { id: 'KICKOFF', label: 'Kickoff' },
            { id: 'KICK_RETURN', label: 'Kick Return' },
            { id: 'PUNT', label: 'Punt' },
            { id: 'PUNT_RETURN', label: 'Punt Return' },
            { id: 'PAT_BLOCK', label: 'PAT/FG Block' }
        ];

        const App = () => {
            // Custom Hook for Auto-Sync to prevent initial-load overwrites
            const useAutoSync = (authUser, key, data, debounceMs = 2000, isEnabled = true) => {
                const isFirstRun = useRef(true);
                useEffect(() => {
                    // Always skip the very first run (mount)
                    if (isFirstRun.current) {
                        isFirstRun.current = false;
                        return;
                    }

                    // Only run if:
                    // 1. User is logged in
                    // 2. Global "isLoaded" flag is true (prevents overwriting cloud data with initial empty state)
                    if (authUser && window.db && isEnabled) {
                        const timer = setTimeout(() => {
                            syncToFirestore(authUser.uid, key, data);
                        }, debounceMs);
                        return () => clearTimeout(timer);
                    }
                }, [data, authUser, key, debounceMs, isEnabled]);
            };
            const { currentUser: authUser, logout } = useAuth();
            // Auth check moved to end of component to prevent hook mismatch errors


            const [showLogoutConfirm, setShowLogoutConfirm] = useState(false);
            const [view, setView] = useState('practice-report'); // Default to Practice Report
            const [showManageWeekModal, setShowManageWeekModal] = useState(false);
            const [sidebarCollapsed, setSidebarCollapsed] = useLocalStorage('hc-sidebar-collapsed', false);
            const closeSideMenuRef = useRef(null); // Ref for child components to register side menu close callback
            const [editingPlay, setEditingPlay] = useState(null);
            const [quickEditModalState, setQuickEditModalState] = useState(null);

            // -- PLAY DETAILS MODAL (Root-Level for PlayChip context) --
            const [playDetailsModalState, setPlayDetailsModalState] = useState({ isOpen: false, playId: null });
            const openPlayDetails = (playId) => setPlayDetailsModalState({ isOpen: true, playId });
            const closePlayDetails = () => setPlayDetailsModalState({ isOpen: false, playId: null });

            // -- SCHOOL INITIALIZATION CHECK --
            const [schoolSetupData, setSchoolSetupData] = useState({ showWizard: false, schoolId: null });
            const [inviteData, setInviteData] = useState(null); // NEW: Invite State
            const [accessRequestStatus, setAccessRequestStatus] = useState({ checked: false, status: null, data: null }); // 'pending' | 'approved' | 'rejected' | null

            // Auto-clear wizard if school is already set up (prevents wizard showing over existing school)
            useEffect(() => {
                if (schoolSetupData.showWizard && schoolName) {
                    console.log("DEBUG: School already set up, clearing wizard state");
                    setSchoolSetupData({ showWizard: false, schoolId: null });
                }
            }, [schoolSetupData.showWizard, schoolName]);
            const [pendingAccessRequests, setPendingAccessRequests] = useState(0); // Count of pending requests for admin badge
            const [isViewingAll, setIsViewingAll] = useState(false);
            const [selectedCharts, setSelectedCharts] = useState(DEPTH_CHART_TYPES.map(t => t.id));

            // -- PROGRAM RECORDS MIGRATION --
            const [programRecords, setProgramRecords] = useLocalStorage('hc-program-records', {});

            // Sync Program Records to Firestore
            useAutoSync(authUser, 'program_records', programRecords);

            // -- DEPTH CHART STATE --
            const [depthCharts, setDepthCharts] = useLocalStorage('hc-depth-charts', {});
            const [depthChartLayouts, setDepthChartLayouts] = useLocalStorage('hc-depth-chart-layouts', {});

            const handleUpdateDepthLayout = (chartType, id, x, y) => {
                setDepthChartLayouts(prev => ({
                    ...prev,
                    [chartType]: {
                        ...(prev[chartType] || {}),
                        [id]: { x, y }
                    }
                }));
            };

            const handleResetDepthLayout = (chartType) => {
                if (window.confirm('Reset layout positions for ' + chartType + '?')) {
                    const newLayouts = { ...depthChartLayouts };
                    delete newLayouts[chartType];
                    setDepthChartLayouts(newLayouts);
                }
            };
            // Sync Depth Charts to Firestore
            useAutoSync(authUser, 'depth_charts', depthCharts);

            // Migration Effect
            useEffect(() => {
                const checkSchoolInit = async () => {
                    if (!authUser) return;

                    // ADMIN BYPASS: admin@digitaldofo.com skips ALL school setup (admin-only mode)
                    // This must be at the very top before any other checks
                    if (authUser.email.toLowerCase() === 'admin@digitaldofo.com') {
                        console.log("DEBUG: admin@digitaldofo.com detected. Bypassing ALL school setup - admin-only mode.");
                        setAccessRequestStatus({ checked: true, status: 'admin', data: { isAdmin: true } });
                        setSchoolSetupData({ showWizard: false, schoolId: null });
                        return;
                    }

                    // LOCAL TESTING BYPASS: Skip access request AND wizard for @test.com emails or localhost
                    const isLocalhost = window.location.hostname === 'localhost' || window.location.protocol === 'file:';
                    const isTestEmail = authUser.email.toLowerCase().endsWith('@test.com');
                    if (isLocalhost || isTestEmail) {
                        console.log("DEBUG: Local testing detected. Bypassing access request and wizard.");
                        const newSchoolId = 'test_school_' + Date.now();
                        setSchoolSetupData({ showWizard: false, schoolId: newSchoolId });
                        return;
                    }

                    try {
                        // 1. CHECK FOR PENDING INVITES
                        console.log("Checking for invites for:", authUser.email);
                        const inviteQuery = await window.db.collection('invites')
                            .where('email', '==', authUser.email.toLowerCase())
                            .where('status', '==', 'pending')
                            .get();

                        if (!inviteQuery.empty) {
                            const inviteDoc = inviteQuery.docs[0];
                            console.log("Found invite:", inviteDoc.id);
                            setInviteData({ id: inviteDoc.id, ...inviteDoc.data() });
                            return; // Stop processing to show invite modal
                        }

                        // 1b. CHECK FOR CLAIMED DOMAINS (Auto-Join)
                        // Skip public email domains - only match custom/school domains
                        const PUBLIC_EMAIL_DOMAINS = ['gmail.com', 'yahoo.com', 'hotmail.com', 'outlook.com', 'icloud.com', 'aol.com', 'mail.com', 'protonmail.com'];
                        const emailDomain = authUser.email.split('@')[1]?.toLowerCase();
                        if (emailDomain && !PUBLIC_EMAIL_DOMAINS.includes(emailDomain)) {
                            console.log("DEBUG: Checking domain match for:", emailDomain);
                            const domainQuery = await window.db.collection('schools')
                                .where('domains', 'array-contains', emailDomain)
                                .limit(1)
                                .get();

                            if (!domainQuery.empty) {
                                const sDoc = domainQuery.docs[0];
                                const sData = sDoc.data();
                                console.log("DEBUG: Found domain match for school:", sData.name);
                                // Check if already a member
                                const memCheck = await window.db.collection('users').doc(authUser.uid).collection('memberships').doc(sDoc.id).get();
                                if (!memCheck.exists) {
                                    setInviteData({
                                        schoolId: sDoc.id,
                                        schoolName: sData.name,
                                        role: 'viewer', // Default to viewer for safety
                                        type: 'domain_match'
                                    });
                                    return;
                                }
                            }
                        } else {
                            console.log("DEBUG: Skipping domain match for public email domain:", emailDomain);
                        }

                        // 1c. PRIMARY SETUP CHECK: DO I HAVE A MEMBERSHIP?
                        // If user has ANY membership, they are setup. We skip legacy/creation wizard.
                        // FIX: Ensure User Document actually exists! (Subcollections persist after parent deletion)
                        const userDocCall = await window.db.collection('users').doc(authUser.uid).get();

                        console.log("DEBUG: Checking memberships for user:", authUser.uid);
                        const memberships = await window.db.collection('users').doc(authUser.uid).collection('memberships').get();
                        console.log("DEBUG: Membership count:", memberships.size);

                        // Only respect memberships if the user profile is intact
                        if (!memberships.empty && userDocCall.exists) {
                            console.log("User has active memberships. Skipping wizard.");
                            return;
                        }

                        // 2. CHECK LEGACY / EXISTING ACCESS
                        // Force Server Fetch to avoid stale cache loop (Wrapped in Try/Catch for robustness)
                        let accessDoc;
                        try {
                            accessDoc = await window.db.collection('config').doc('access').get({ source: 'server' });
                        } catch (e) {
                            console.warn("Access config server fetch failed, fallback to cache", e);
                            accessDoc = await window.db.collection('config').doc('access').get();
                        }

                        const accessData = accessDoc.exists ? accessDoc.data() : {};
                        const userValues = Object.values(accessData.userSchools || {});

                        const isPaying = accessData.payingAdmins && accessData.payingAdmins.includes(authUser.email.toLowerCase());

                        // Check if user has a school ID assigned in config OR on their profile
                        let schoolId = accessData.userSchools ? accessData.userSchools[authUser.email.toLowerCase()] : null;

                        if (!schoolId) {
                            const userDoc = await window.db.collection('users').doc(authUser.uid).get();
                            if (userDoc.exists && userDoc.data().schoolId) {
                                schoolId = userDoc.data().schoolId;
                            }
                        }

                        // 3. CHECK FOR ZERO MEMBERSHIPS (Orphaned User -> Check Access Request)
                        // If no invites, no domain match, and no legacy school ID, check access request status
                        console.log("DEBUG: inviteData=", inviteData, "schoolId=", schoolId);

                        // 3a. FALLBACK: Check if user email is in any school's memberList (covers edge cases)
                        if (!inviteData && !schoolId) {
                            console.log("DEBUG: Checking if user email is in any school memberList...");
                            try {
                                const memberQuery = await window.db.collection('schools')
                                    .where('memberList', 'array-contains', { email: authUser.email.toLowerCase(), role: 'admin' })
                                    .limit(1)
                                    .get();

                                if (!memberQuery.empty) {
                                    schoolId = memberQuery.docs[0].id;
                                    console.log("DEBUG: Found school via memberList query:", schoolId);
                                } else {
                                    // Try alternative memberList format (just email string)
                                    const memberQuery2 = await window.db.collection('schools').get();
                                    for (const doc of memberQuery2.docs) {
                                        const members = doc.data().memberList || [];
                                        const found = members.some(m =>
                                            (typeof m === 'string' && m.toLowerCase() === authUser.email.toLowerCase()) ||
                                            (m && m.email && m.email.toLowerCase() === authUser.email.toLowerCase())
                                        );
                                        if (found) {
                                            schoolId = doc.id;
                                            console.log("DEBUG: Found school via full scan:", schoolId);
                                            break;
                                        }
                                    }
                                }
                            } catch (err) {
                                console.warn("DEBUG: memberList query failed:", err);
                            }
                        }

                        // matthewfinn14@gmail.com gets wizard to create template schools (admin bypass handled earlier)
                        if (authUser.email.toLowerCase() === 'matthewfinn14@gmail.com' && !inviteData && !schoolId) {
                            console.log("DEBUG: matthewfinn14@gmail.com detected. Showing school wizard for template creation.");
                            const newSchoolId = 'school_' + Date.now();
                            setSchoolSetupData({ showWizard: true, schoolId: newSchoolId });
                            return;
                        }

                        if (!inviteData && !schoolId) {
                            console.log("DEBUG: User has no memberships. Checking access request status...");

                            // Check for existing access request (force server fetch to avoid stale cache)
                            try {
                                let requestDoc;
                                try {
                                    requestDoc = await window.db.collection('access_requests').doc(authUser.email.toLowerCase()).get({ source: 'server' });
                                } catch (serverErr) {
                                    console.warn("Access request server fetch failed, fallback to cache:", serverErr);
                                    requestDoc = await window.db.collection('access_requests').doc(authUser.email.toLowerCase()).get();
                                }
                                console.log("DEBUG: Access request doc exists:", requestDoc.exists, "data:", requestDoc.data());

                                if (requestDoc.exists) {
                                    const requestData = requestDoc.data();

                                    if (requestData.status === 'approved') {
                                        // Check if access has expired
                                        if (requestData.accessExpiresAt && new Date(requestData.accessExpiresAt) < new Date()) {
                                            console.log("Access has expired.");
                                            setAccessRequestStatus({ checked: true, status: 'expired', data: requestData });
                                            return;
                                        }
                                        // Approved and not expired - show wizard to create school
                                        console.log("Access approved. Showing school creation wizard.");
                                        // Store trial info for banner display
                                        if (requestData.accessExpiresAt) {
                                            localStorage.setItem('dofo_trial_expires', requestData.accessExpiresAt);
                                            localStorage.setItem('dofo_trial_days', requestData.trialDays || '7');
                                        }
                                        const newSchoolId = 'school_' + Date.now();
                                        setSchoolSetupData({ showWizard: true, schoolId: newSchoolId });
                                        return;
                                    } else if (requestData.status === 'pending') {
                                        console.log("Access request pending.");
                                        setAccessRequestStatus({ checked: true, status: 'pending', data: requestData });
                                        return;
                                    } else if (requestData.status === 'rejected') {
                                        console.log("Access request rejected.");
                                        setAccessRequestStatus({ checked: true, status: 'rejected', data: requestData });
                                        return;
                                    } else {
                                        // Unknown status - log it and treat as pending for safety
                                        console.log("Access request has unknown status:", requestData.status);
                                        setAccessRequestStatus({ checked: true, status: requestData.status || 'pending', data: requestData });
                                        return;
                                    }
                                } else {
                                    // No request exists - show the request form
                                    console.log("No access request found. Showing request form.");
                                    setAccessRequestStatus({ checked: true, status: null, data: null });
                                    return;
                                }

                            } catch (err) {
                                console.error("Error checking access request:", err);
                                // On error, show the request form
                                setAccessRequestStatus({ checked: true, status: null, data: null });
                                return;
                            }
                        }

                        // If user has a school ID, check if the school exists and load it
                        if (schoolId) {
                            let schoolDoc;
                            try {
                                schoolDoc = await window.db.collection('schools').doc(schoolId).get({ source: 'server' });
                            } catch (e) {
                                console.warn("School doc server fetch failed, using cache", e);
                                schoolDoc = await window.db.collection('schools').doc(schoolId).get();
                            }

                            if (schoolDoc.exists) {
                                const schoolData = schoolDoc.data();
                                if (!schoolData.initialized) {
                                    console.log("School not initialized, showing wizard.");
                                    setSchoolSetupData({ showWizard: true, schoolId: schoolId });
                                    return;
                                }
                                // School exists and is initialized - user should be able to access it
                                // Ensure user has proper membership record (repair if missing)
                                console.log("DEBUG: Found valid school for user:", schoolId, schoolData.name);
                                const membershipRef = window.db.collection('users').doc(authUser.uid).collection('memberships').doc(schoolId);
                                const membershipDoc = await membershipRef.get();
                                if (!membershipDoc.exists) {
                                    console.log("DEBUG: Repairing missing membership record...");
                                    // Find user's role from school memberList
                                    const members = schoolData.memberList || [];
                                    const userEntry = members.find(m =>
                                        (m && m.email && m.email.toLowerCase() === authUser.email.toLowerCase())
                                    );
                                    const userRole = userEntry?.role || 'viewer';
                                    // Create membership
                                    await window.db.collection('users').doc(authUser.uid).set({
                                        email: authUser.email,
                                        updatedAt: new Date().toISOString()
                                    }, { merge: true });
                                    await membershipRef.set({
                                        schoolId: schoolId,
                                        role: userRole,
                                        joinedAt: new Date().toISOString()
                                    });
                                    console.log("DEBUG: Membership repaired. Reloading...");
                                }
                                // School is valid - let normal app loading continue
                                return;
                            } else {
                                console.log("DEBUG: School", schoolId, "doesn't exist. User may need new school.");
                            }
                        }

                        // Mark as checked even if nothing matched (should rarely happen)
                        console.log("DEBUG: No setup conditions matched. Marking as checked.");
                        setAccessRequestStatus({ checked: true, status: null, data: null });

                    } catch (err) {
                        console.error("Error checking school init:", err);
                        // On error, show access request form as fallback
                        setAccessRequestStatus({ checked: true, status: null, data: null });
                    }
                };
                checkSchoolInit();
            }, [authUser]);

            // INVITE ACCEPTANCE HANDLER
            const handleAcceptInvite = async () => {
                if (!inviteData) return;
                try {
                    // 1. Create Membership
                    await window.db.collection('users').doc(authUser.uid).collection('memberships').doc(inviteData.schoolId).set({
                        role: inviteData.role,
                        joinedAt: new Date().toISOString(),
                        status: 'active'
                    });

                    // 2. Add to School Member List
                    const newMember = {
                        uid: authUser.uid,
                        email: authUser.email,
                        role: inviteData.role,
                        joinedAt: new Date().toISOString()
                    };
                    await window.db.collection('schools').doc(inviteData.schoolId).update({
                        memberList: firebase.firestore.FieldValue.arrayUnion(newMember)
                    });

                    // 3. Mark Invite Accepted (If valid invite)
                    if (inviteData.id && inviteData.type !== 'domain_match') {
                        await window.db.collection('invites').doc(inviteData.id).update({
                            status: 'accepted',
                            acceptedAt: new Date().toISOString(),
                            acceptedBy: authUser.uid
                        });
                    }

                    // 4. Set Local Context & Reload
                    localStorage.setItem('hc_school_id', inviteData.schoolId);
                    localStorage.setItem('hc_school_name', inviteData.schoolName);

                    // Force clean slate for new school
                    localStorage.removeItem('oc-dashboard-roster');
                    localStorage.removeItem('oc-dashboard-plays');
                    localStorage.removeItem('oc-dashboard-staff');

                    alert("Welcome to the team!");
                    window.location.reload();

                } catch (err) {
                    console.error("Error accepting invite:", err);
                    alert("Failed to join. Please try again.");
                }
            };




            // Settings State
            const [searchTerm, setSearchTerm] = useState('');


            const [activeYear, setActiveYear] = useState(() => {
                return localStorage.getItem('hc-active-year') || '2025';
            });

            useEffect(() => {
                localStorage.setItem('hc-active-year', activeYear);
                // Cloud Sync
                if (currentUser && window.db) {
                    syncToFirestore(currentUser.uid, 'settings', { activeYear });
                }
            }, [activeYear, currentUser]);

            // Football 101 Data
            const [football101Data, setFootball101Data] = useLocalStorage('hc-football-101', {
                rules: [],
                offense: { terms: [], fundamentals: [] },
                defense: { terms: [], fundamentals: [] },
                specialTeams: { terms: [], fundamentals: [] }
            });

            const [visibleFeatures, setVisibleFeatures] = useState(() => {
                const saved = localStorage.getItem('hc-visible-features-v2');
                const DEFAULT_FEATURES = {
                    staffMeeting: {
                        enabled: true,
                        items: {
                            meetingHome: true,
                            scouting: true,
                            weekOverview: true,
                            practice: true,
                            pregame: true,
                            grading: true
                        }
                    },
                    gameWeek: { // Now "Offense, Defense & Special Teams"
                        enabled: true,
                        items: {
                            schemeSetup: true,
                            depthCharts: true,
                            playbook: true,
                            gamePlan: true,
                            addPlay: true,
                            wristband: true,
                            practiceScripts: true,
                            dumbCallsheet: true,

                        }
                    },
                    program: {
                        enabled: true,
                        items: {
                            roster: true,
                            calendar: true
                        }
                    }
                };

                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);

                        // MIGRATION LOGIC:
                        // 1. If 'scheme' exists, migrate its items to 'gameWeek' if not already there
                        // 2. Ensure ALL keys from DEFAULT_FEATURES exist in the result (deep merge)

                        const merged = { ...DEFAULT_FEATURES };
                        // Force enable ratings per user request
                        if (parsed.development && parsed.development.items) {
                            parsed.development.items.ratings = true;
                        }

                        // Helper to safely merge category
                        const mergeCategory = (catName, legacySource = null) => {
                            const parsedCat = parsed[catName] || {};
                            const defaultCat = DEFAULT_FEATURES[catName];

                            // If user explicitly disabled the category in parsed, keep it disabled.
                            // However, if it was undefined (new category), default to enabled (true).
                            const isEnabled = parsedCat.enabled !== undefined ? parsedCat.enabled : defaultCat.enabled;

                            const mergedItems = { ...defaultCat.items };

                            // Merge existing items from parsed
                            if (parsedCat.items) {
                                Object.keys(parsedCat.items).forEach(key => {
                                    mergedItems[key] = parsedCat.items[key];
                                });
                            }

                            // Migrate legacy items if applicable
                            if (legacySource && parsed[legacySource] && parsed[legacySource].items) {
                                // Specific migration for scheme -> gameWeek
                                if (catName === 'gameWeek') {
                                    // Map scheme items to new keys if needed, or just copy if names match
                                    if (parsed[legacySource].items.playbook !== undefined) mergedItems.playbook = parsed[legacySource].items.playbook;
                                    if (parsed[legacySource].items.formations !== undefined) mergedItems.formations = parsed[legacySource].items.formations;
                                    // Glossary was not tracked in scheme permissions previously? If so, default true is fine.
                                }
                            }

                            return {
                                enabled: isEnabled,
                                items: mergedItems
                            };
                        };

                        return {
                            staffMeeting: mergeCategory('staffMeeting'), // New category
                            gameWeek: mergeCategory('gameWeek', 'scheme'), // Merge scheme into gameWeek
                            program: mergeCategory('program'),
                            apps: mergeCategory('apps'),
                            development: mergeCategory('development')
                        };

                    } catch (e) {
                        console.error("Error parsing visible features, resetting to default", e);
                        return DEFAULT_FEATURES;
                    }
                }

                return DEFAULT_FEATURES;
            });

            useEffect(() => {
                localStorage.setItem('hc-visible-features', JSON.stringify(visibleFeatures));
            }, [visibleFeatures]);

            // Initialize Wiz Library from LocalStorage (with legacy fallback)
            const [wizLibrary, setWizLibrary] = useState(() => {
                const saved = localStorage.getItem('wiz_ol_library') || localStorage.getItem('rooski_ol_library'); // Legacy fallback
                return saved ? JSON.parse(saved) : [];
            });

            // Multi-Card Wristband Settings
            const [wbSettings, setWbSettings] = useState(() => {
                const defaultSettings = {
                    card1: { type: 'standard', opp: '', iter: '1', rows: [] },
                    card2: { type: 'standard', opp: '', iter: '1', rows: [] },
                    card3: { type: 'wiz', opp: '', iter: '1', rows: [] },
                    staples: { type: 'staples', opp: '', iter: '1', rows: [] }
                };
                const saved = localStorage.getItem('hc_wb_settings_v3');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Ensure staples exists and fill other defaults
                    return { ...defaultSettings, ...parsed };
                }

                // Migration from legacy flat keys
                return {
                    card1: {
                        type: 'standard',
                        opp: localStorage.getItem('hc_wb1_opponent') || '',
                        iter: localStorage.getItem('hc_wb1_iteration') || '',
                        rows: []
                    },
                    card2: {
                        type: 'standard',
                        opp: localStorage.getItem('hc_wb2_opponent') || '',
                        iter: localStorage.getItem('hc_wb2_iteration') || '',
                        rows: []
                    },
                    card3: {
                        type: 'wiz',
                        opp: '',
                        iter: '',
                        rows: []
                    },
                    staples: {
                        type: 'staples',
                        opp: localStorage.getItem('hc_staples_opponent') || '',
                        iter: localStorage.getItem('hc_staples_iteration') || '',
                        rows: []
                    }
                };
            });

            // Sync WB Settings changes
            useEffect(() => {
                localStorage.setItem('hc_wb_settings_v3', JSON.stringify(wbSettings));

                // Maintain legacy keys for external consumption if any
                localStorage.setItem('hc_wb1_opponent', wbSettings.card1.opp);
                localStorage.setItem('hc_wb1_iteration', wbSettings.card1.iter);
                localStorage.setItem('hc_wb2_opponent', wbSettings.card2.opp);
                localStorage.setItem('hc_wb2_iteration', wbSettings.card2.iter);
                if (wbSettings.staples) {
                    localStorage.setItem('hc_staples_opponent', wbSettings.staples.opp);
                    localStorage.setItem('hc_staples_iteration', wbSettings.staples.iter);
                }

                if (authUser) {
                    syncToFirestore(authUser.uid, 'wbSettingsV3', {
                        ...wbSettings,
                        sheetUrl: localStorage.getItem('hc_wristband_sheet_url')
                    });
                }
            }, [wbSettings, authUser]);
            const [plays, setPlays] = useState(() => {
                try {
                    const saved = localStorage.getItem('oc-dashboard-plays');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        return Array.isArray(parsed) ? parsed : INITIAL_PLAYS;
                    }
                    return INITIAL_PLAYS;
                } catch (error) {
                    console.error('Error loading plays from localStorage:', error);
                    return INITIAL_PLAYS;
                }
            });

            // --- CRITICAL DATA SYNC (FINAL AUDIT) ---
            useEffect(() => {
                localStorage.setItem('oc-dashboard-position-names', JSON.stringify(positionNames));
                if (authUser) syncToFirestore(authUser.uid, 'positionNames', positionNames);
            }, [positionNames]);

            useEffect(() => {
                localStorage.setItem('wiz_ol_library', JSON.stringify(wizLibrary));
                if (authUser) syncToFirestore(authUser.uid, 'wizLib', wizLibrary);
            }, [wizLibrary]);


            useEffect(() => {
                localStorage.setItem('oc-dashboard-plays', JSON.stringify(plays));

                // Auto-sync to Firestore (debounced)
                const timer = setTimeout(() => {
                    if (authUser && window.db) { // Check for authUser and db here
                        if (authUser) syncToFirestore(authUser.uid, 'plays', plays);
                    }
                }, 2000); // Debounce playbook sync
                return () => clearTimeout(timer);
            }, [plays, authUser]); // Changed currentUser to authUser to match existing context

            // Sync Weeks (Practice Plans) to Firestore
            useEffect(() => {
                const timer = setTimeout(() => {
                    if (authUser) syncToFirestore(authUser.uid, 'weeks', weeks); // Changed currentUser to authUser
                }, 3000); // 3s debounce for large plan objects
                return () => clearTimeout(timer);
            }, [weeks, authUser]); // Changed currentUser to authUser

            // Sync Attendance to Firestore
            useEffect(() => {
                const timer = setTimeout(() => {
                    if (authUser) syncToFirestore(authUser.uid, 'attendance', attendance); // Changed currentUser to authUser
                }, 1500);
                return () => clearTimeout(timer);
            }, [attendance, authUser]); // Changed currentUser to authUser


            // --- LOADING STATE & SAFETY LOCK ---
            // 'dataLoaded' prevents the app from auto-syncing "empty" initial state back to the cloud.
            // It remains false until loadUserDataFromFirestore is finished or fails.
            const [dataLoaded, setDataLoaded] = useState(false);

            useEffect(() => {
                const initUser = async () => {
                    if (authUser) {
                        try {
                            const result = await loadUserDataFromFirestore(authUser.uid);
                            if (result && result.wiped) {
                                console.log("User data wiped (New/Deleted User). Forcing School Setup.");
                                // Force Wizard to appear
                                setSchoolSetupData({ showWizard: true, schoolId: null });
                                // Clear Invite Data just in case
                                setInviteData(null);
                                // Optional: You could reset other states here if needed, but Wizard hides them.
                            }
                        } catch (e) {
                            console.error("Critical Load Error", e);
                        } finally {
                            // Unlock the sync mechanism now that we have attempted to load content
                            setDataLoaded(true);
                        }
                    }
                };
                initUser();
            }, [authUser]);

            // --- AUTO SYNC HOOK IMPLEMENTATION ---
            // Replaces individual useEffects to prevent "Race Condition" where stale local data overwrites cloud on boot.
            // Now gated by 'dataLoaded' so we NEVER sync before we have loaded.
            useAutoSync(authUser, 'formationLayouts', formationLayouts, 2000, dataLoaded);
            useAutoSync(authUser, 'ratings', ratings, 2000, dataLoaded);


            useAutoSync(authUser, 'roster', roster, 2000, dataLoaded);
            useAutoSync(authUser, 'weeks', weeks, 3000, dataLoaded);
            useAutoSync(authUser, 'plays', plays, 2000, dataLoaded);
            useAutoSync(authUser, 'staff', staff, 2000, dataLoaded);

            // Formation Database
            const [formations, setFormations] = useState(() => {
                const saved = localStorage.getItem('oc-dashboard-formations');
                return saved ? JSON.parse(saved) : DEFAULT_FORMATIONS;
            });

            useEffect(() => {
                localStorage.setItem('oc-dashboard-formations', JSON.stringify(formations));
            }, [formations]);

            // Zone Philosophies
            const [zonePhilosophies, setZonePhilosophies] = useState(() => {
                const saved = localStorage.getItem('oc-dashboard-zone-philosophies');
                return saved ? JSON.parse(saved) : {
                    backed_up: '',
                    coming_out: '',
                    open_field: '',
                    fringe: 'Take one shot, be ready to convert on 4th',
                    high_red: '',
                    low_red: '',
                    goal_line: ''
                };
            });

            useEffect(() => {
                localStorage.setItem('oc-dashboard-zone-philosophies', JSON.stringify(zonePhilosophies));
            }, [zonePhilosophies]);

            const handleUpdateFormations = (newFormations) => {
                setFormations(newFormations);
            };

            const handleAddFormation = (formation) => {
                setFormations([...formations, { ...formation, id: formation.id || Date.now().toString() }]);
            };

            const handleDeleteFormation = (formationId) => {
                // Use functional update to handle batch deletes correctly
                setFormations(prev => prev.filter(f => f.id !== formationId));
            };

            const handleUpdateFormation = (formationId, updatedFormation) => {
                setFormations(formations.map(f => f.id === formationId ? updatedFormation : f));
            };

            // Quick add play from game plan (creates incomplete play)
            const handleQuickAddPlay = (playNameOrObj) => {
                let newPlay;
                if (typeof playNameOrObj === 'object' && playNameOrObj !== null) {
                    newPlay = { ...playNameOrObj };
                    if (newPlay.name) newPlay.name = newPlay.name.toUpperCase();
                } else {
                    const rawName = typeof playNameOrObj === 'string' ? playNameOrObj.trim() : (playNameOrObj || '');
                    newPlay = {
                        id: `play_${Date.now()}`,
                        name: rawName.toUpperCase(),
                        wristbandSlot: '',
                        staplesSlot: '', // [NEW] Staples Wristband Slot (10-89)
                        formation: '',
                        tags: [],
                        incomplete: true, // Mark as incomplete
                        type: '' // No default type (goes to Uncategorized)
                    };
                }
                setPlays(prev => [...prev, newPlay]);
                return newPlay;
            };

            // Determine current season based on month
            const getCurrentSeason = () => {
                const month = new Date().getMonth() + 1; // 1-12
                if (month >= 8 && month <= 11) return 'in-season'; // A === 12 || month === 1) return 'postseason'; // Dec-Jan
                if (month >= 2 && month <= 4) return 'offseason'; // Feb-Apr
                if (month >= 5 && month <= 7) return 'summer'; // May-Jul
                return 'offseason';
            };

            const renderWeeklyTools = (weekId) => {
                const isActive = currentWeekId === weekId;
                const currentSeason = getCurrentSeason();
                const isOffseason = currentSeason === 'offseason';

                return (
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '0.15rem', padding: '0.25rem 0 0.5rem 0' }}>



                        <button className={`nav-item ${isActive && view === 'practice' ? 'active' : ''}`}
                            onClick={() => { setCurrentWeekId(weekId); setView('practice'); }}
                            style={{ paddingLeft: '2.5rem', width: '100%', textAlign: 'left', border: 'none', background: 'none', fontSize: '0.75rem', display: 'flex', alignItems: 'center', gap: '0.5rem', opacity: 0.85 }}>
                            <Icon name="Megaphone" size={12} /> Practice Plans
                        </button>
                        <button className={`nav-item ${isActive && view === 'install-manager' ? 'active' : ''}`}
                            onClick={() => { setCurrentWeekId(weekId); setView('install-manager'); }}
                            style={{ paddingLeft: '2.5rem', width: '100%', textAlign: 'left', border: 'none', background: 'none', fontSize: '0.75rem', display: 'flex', alignItems: 'center', gap: '0.5rem', opacity: 0.85 }}>
                            <Icon name="Layers" size={12} /> Install
                        </button>
                        {/* Expanded Depth Charts */}
                        <button className={`nav-item ${isActive && view === 'depth' ? 'active' : ''}`}
                            onClick={() => { setCurrentWeekId(weekId); setView('depth'); setDepthChartType('OFFENSE'); }}
                            style={{ paddingLeft: '2.5rem', width: '100%', textAlign: 'left', border: 'none', background: 'none', fontSize: '0.75rem', display: 'flex', alignItems: 'center', gap: '0.5rem', opacity: 0.85 }}>
                            <Icon name="Users" size={12} /> Depth Charts
                        </button>
                        <button className={`nav-item ${isActive && view === 'game-plan' ? 'active' : ''}`}
                            onClick={() => { setCurrentWeekId(weekId); setView('game-plan'); }}
                            style={{ paddingLeft: '2.5rem', width: '100%', textAlign: 'left', border: 'none', background: 'none', fontSize: '0.75rem', display: 'flex', alignItems: 'center', gap: '0.5rem', opacity: 0.85 }}>
                            <Icon name="Clipboard" size={12} /> Game Planner
                        </button>
                        <button className={`nav-item ${isActive && view === 'wristband' ? 'active' : ''}`}
                            onClick={() => { setCurrentWeekId(weekId); setView('wristband'); }}
                            style={{ paddingLeft: '2.5rem', width: '100%', textAlign: 'left', border: 'none', background: 'none', fontSize: '0.75rem', display: 'flex', alignItems: 'center', gap: '0.5rem', opacity: 0.85 }}>
                            <Icon name="Watch" size={12} /> Wristband Builder
                        </button>
                        <button className={`nav-item ${isActive && view === 'practice-scripts' ? 'active' : ''}`}
                            onClick={() => { setCurrentWeekId(weekId); setView('practice-scripts'); }}
                            style={{ paddingLeft: '2.5rem', width: '100%', textAlign: 'left', border: 'none', background: 'none', fontSize: '0.75rem', display: 'flex', alignItems: 'center', gap: '0.5rem', opacity: 0.85 }}>
                            <Icon name="FileText" size={12} /> Practice Scripts
                        </button>


                        <button className={`nav-item ${isActive && view === 'pregame' ? 'active' : ''}`}
                            onClick={() => { setCurrentWeekId(weekId); setView('pregame'); }}
                            style={{ paddingLeft: '2.5rem', width: '100%', textAlign: 'left', border: 'none', background: 'none', fontSize: '0.75rem', display: 'flex', alignItems: 'center', gap: '0.5rem', opacity: 0.85 }}>
                            <Icon name="Clock" size={12} /> Pre-Game Timeline
                        </button>
                    </div>
                );
            };

            const checkWristbandConflict = (slot) => {
                const numSlot = parseInt(slot, 10);
                if (isNaN(numSlot)) return false;

                let collision = false;
                Object.keys(wbSettings || {}).forEach(cardId => {
                    if (collision) return;
                    const card = wbSettings[cardId];
                    if (card.type === 'mini-scripts') {
                        const startMap = { card1: 101, card2: 201, card3: 301, card4: 401, card5: 501, card6: 601 };
                        let current = startMap[cardId] || 101;
                        (card.rows || []).forEach(row => {
                            if (row.type !== 'header') {
                                if (current === numSlot) collision = true;
                                current++;
                            }
                        });
                    }
                });
                return collision;
            };

            const handlePatchPlay = (arg1, arg2) => {
                if (Array.isArray(arg1)) {
                    // Bulk Update (Array of objects)
                    const updatesMap = new Map();
                    arg1.forEach(p => {
                        if (p && p.id) updatesMap.set(p.id, p);
                    });
                    setPlays(prev => prev.map(p => updatesMap.has(p.id) ? { ...p, ...updatesMap.get(p.id) } : p));
                } else if (typeof arg1 === 'object' && arg1 !== null && arg1.id) {
                    // Single Object (Update or Create)
                    const updatedPlay = arg1;
                    if (updatedPlay.wristbandSlot && checkWristbandConflict(updatedPlay.wristbandSlot)) {
                        alert(`Wristband slot ${updatedPlay.wristbandSlot} is already assigned to a Mini-Script position. Please choose another number.`);
                        return;
                    }
                    setPlays(prev => {
                        const exists = prev.some(p => p.id === updatedPlay.id);
                        if (exists) {
                            return prev.map(p => p.id === updatedPlay.id ? { ...p, ...updatedPlay } : p);
                        } else {
                            // Verify it's not a zombie play (has name)
                            if (!updatedPlay.name) return prev;
                            return [...prev, updatedPlay];
                        }
                    });
                } else {
                    // Standard (id, updates)
                    if (arg2 && arg2.wristbandSlot && checkWristbandConflict(arg2.wristbandSlot)) {
                        alert(`Wristband slot ${arg2.wristbandSlot} is already assigned to a Mini-Script position. Please choose another number.`);
                        return;
                    }
                    setPlays(prev => prev.map(p => p.id === arg1 ? { ...p, ...arg2 } : p));
                }
            };

            // RBAC State
            // Refactored to be User-Centric
            // We default to the first user (Matt Finn) or finding 's1'
            const [currentUserId, setCurrentUserId] = useState('s1');
            const [permissions, setPermissions] = useLocalStorage('oc-dashboard-permissions', DEFAULT_PERMISSIONS);



            // --- SITE ADMIN LOGIC ---
            // Hardcoded Safety Fallback - these emails always have admin access
            const SUPER_ADMIN_EMAILS = ['matthewfinn14@gmail.com', 'admin@digitaldofo.com'];

            const [siteAdmins, setSiteAdmins] = useState([]);
            const [isSiteAdmin, setIsSiteAdmin] = useState(false);

            // Fetch Site Admins from Firestore
            useEffect(() => {
                let unsubscribe = () => { };
                if (window.db && authUser) {
                    try {
                        unsubscribe = window.db.collection('config').doc('access')
                            .onSnapshot((doc) => {
                                if (doc.exists) {
                                    const data = doc.data();
                                    const admins = data.siteAdmins || [];
                                    setSiteAdmins(admins);

                                    // Determine if current user is Site Admin
                                    const email = authUser.email.toLowerCase();
                                    const isSuper = SUPER_ADMIN_EMAILS.includes(email);
                                    const isListed = admins.includes(email);
                                    setIsSiteAdmin(isSuper || isListed);
                                } else {
                                    // Fallback if doc doesn't exist yet
                                    setIsSiteAdmin(SUPER_ADMIN_EMAILS.includes(authUser.email.toLowerCase()));
                                }
                            }, (error) => {
                                console.error("Error fetching admin config:", error);
                            });
                    } catch (err) {
                        console.error("Setup admin listener failed:", err);
                    }
                }
                return () => unsubscribe();
            }, [authUser]);

            // Fetch pending access requests count for admin notification badge
            useEffect(() => {
                if (!isSiteAdmin || !window.db) return;

                const unsubscribe = window.db.collection('access_requests')
                    .where('status', '==', 'pending')
                    .onSnapshot((snapshot) => {
                        setPendingAccessRequests(snapshot.size);
                    }, (error) => {
                        console.error("Error fetching pending requests:", error);
                    });

                return () => unsubscribe();
            }, [isSiteAdmin]);

            // Ensure permissions structure integrity on load (if new roles added later)
            useEffect(() => {
                const newPerms = { ...permissions };
                let changed = false;
                ROLES.forEach(role => {
                    if (!newPerms[role]) {
                        newPerms[role] = DEFAULT_PERMISSIONS[role];
                        changed = true;
                    }
                });
                if (changed) setPermissions(newPerms);
            }, []);

            // helper to get current staff member
            // We need to access 'staff' state, but it is defined below. 
            // So we will move the staff state definition UP above RBAC or access it inside derived logic.
            // Let's defer currentPermissions calculation until after staff is defined.

            // --- Weeks & Season Management ---

            // Helper to create default plans
            const createDefaultPracticePlans = () => {
                const defaults = {};
                ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'].forEach(day => {
                    defaults[day] = {
                        id: Date.now().toString() + Math.random().toString(36).substr(2, 9) + day,
                        date: new Date().toISOString().split('T')[0],
                        startTime: '15:40',
                        segments: []
                    };
                });
                return defaults;
            };

            // --- SCOPING MIGRATION HELPERS ---
            // 1. Wristband Defaults
            const getGlobalWbSettings = () => {
                const defaultSettings = {
                    card1: { type: 'standard', opp: '', iter: '1', rows: [] },
                    card2: { type: 'standard', opp: '', iter: '1', rows: [] },
                    card3: { type: 'wiz', opp: '', iter: '1', rows: [] },
                    staples: { type: 'staples', opp: '', iter: '1', rows: [] }
                };
                try {
                    const saved = localStorage.getItem('hc_wb_settings_v3');
                    return saved ? { ...defaultSettings, ...JSON.parse(saved) } : defaultSettings;
                } catch (e) { return defaultSettings; }
            };

            // 2. Depth Chart Defaults
            const getGlobalDepthCharts = () => {
                try {
                    const saved = localStorage.getItem('hc-depth-charts');
                    return saved ? JSON.parse(saved) : {};
                } catch (e) { return {}; }
            };

            // 3. Zone Philosophies Defaults
            const getGlobalZonePhilosophies = () => {
                const defaultPhilosophies = {
                    backed_up: '',
                    coming_out: '',
                    open_field: '',
                    fringe: 'Take one shot, be ready to convert on 4th',
                    high_red: '',
                    low_red: '',
                    goal_line: ''
                };
                try {
                    const saved = localStorage.getItem('oc-dashboard-zone-philosophies');
                    return saved ? { ...defaultPhilosophies, ...JSON.parse(saved) } : defaultPhilosophies;
                } catch (e) { return defaultPhilosophies; }
            };

            const [weeks, setWeeks] = useState(() => {
                const saved = localStorage.getItem('oc-dashboard-weeks');
                let existingWeeks = [];
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        existingWeeks = Array.isArray(parsed) ? parsed : [parsed];
                    } catch (e) {
                        console.error("Error parsing saved weeks", e);
                    }
                }



                const currentGlobalWb = getGlobalWbSettings();
                const currentGlobalDepth = getGlobalDepthCharts();
                const currentGlobalZone = getGlobalZonePhilosophies();
                // ---------------------------------

                // Migrate/Populate from OPS_CALENDAR
                const mergedWeeks = OPS_CALENDAR.map((phase, index) => {
                    const existing = existingWeeks.find(w => w.name === phase || w.id === phase);

                    // Scoping Migration: Ensure existing weeks have the new scoped properties
                    if (existing) {
                        // Backfill weekNum if missing (Migration Fix)
                        let finalWeekNum = existing.weekNum;
                        if (finalWeekNum === undefined || finalWeekNum === null) {
                            const match = (existing.name || phase).match(/Week (\d+)$/);
                            if (match) {
                                finalWeekNum = parseInt(match[1]);
                            }
                        }

                        return {
                            ...existing,
                            weekNum: finalWeekNum,
                            wristbands: existing.wristbands || JSON.parse(JSON.stringify(currentGlobalWb)),
                            depthChart: existing.depthChart || JSON.parse(JSON.stringify(currentGlobalDepth)),
                            zonePhilosophies: existing.zonePhilosophies || JSON.parse(JSON.stringify(currentGlobalZone)),
                            gamePlanLayouts: existing.gamePlanLayouts || JSON.parse(JSON.stringify(GAME_PLAN_LAYOUTS))
                        };
                    }

                    // New Week (Default) if not found
                    return {
                        id: phase,
                        name: phase,
                        date: '',
                        opponent: '',
                        isLocked: false,
                        practicePlans: createDefaultPracticePlans(),
                        offensiveGamePlan: { sets: [], miniScripts: [] },
                        dumbCallSheetData: {},
                        pregamePlan: {
                            // Default pregame plan
                        },
                        wristbands: JSON.parse(JSON.stringify(currentGlobalWb)),
                        depthChart: JSON.parse(JSON.stringify(currentGlobalDepth)),
                        zonePhilosophies: JSON.parse(JSON.stringify(currentGlobalZone)),
                        gamePlanLayouts: JSON.parse(JSON.stringify(GAME_PLAN_LAYOUTS))
                    };
                });

                // Also migrate custom weeks (those not in OPS_CALENDAR)
                const phaseSet = new Set(OPS_CALENDAR);
                const customWeeks = existingWeeks.filter(w => !phaseSet.has(w.name));
                const migratedCustomWeeks = customWeeks.map(w => ({
                    ...w,
                    wristbands: w.wristbands || JSON.parse(JSON.stringify(currentGlobalWb)),
                    depthChart: w.depthChart || JSON.parse(JSON.stringify(currentGlobalDepth)),
                    zonePhilosophies: w.zonePhilosophies || JSON.parse(JSON.stringify(currentGlobalZone)),
                    gamePlanLayouts: w.gamePlanLayouts || JSON.parse(JSON.stringify(GAME_PLAN_LAYOUTS))
                }));

                return [...mergedWeeks, ...migratedCustomWeeks];
            });

            const [currentWeekId, setCurrentWeekId] = useState(() => {
                // Determine current month phase
                const currentMonth = new Date().toLocaleString('default', { month: 'long' });
                const currentMonthIndex = OPS_CALENDAR.indexOf(currentMonth);
                const currentMonthPhaseId = currentMonthIndex !== -1 ? `phase-${currentMonthIndex}` : null;

                // Priority: Saved selection (most recently used) -> Current Month -> Last Week -> Week 1
                const savedWeeks = localStorage.getItem('oc-dashboard-weeks');
                // Note: We are deliberating NOT using 'oc-dashboard-weeks' to persist 'last selected', 
                // but rather if we want to default to "today", we should probably prioritize the current date match on initial load if no specific "last selected week" was saved.
                // However, the existing code looked at the LAST item in the weeks array.

                // Let's check for a specific "last viewed week" pref if we had one (we don't currently save one separately).
                // Or we can just default to the current month if available.

                if (currentMonthPhaseId) {
                    return currentMonthPhaseId;
                }

                if (savedWeeks) {
                    const parsed = JSON.parse(savedWeeks);
                    return parsed[parsed.length - 1].id;
                }
                return 'week-1';
            });

            // Custom Focus Items State
            // Custom Focus Items State - MIGRATED TO FULL LISTS
            // We'll keep the storage key to migrate old data if needed, but primarily use practiceFocusItems

            const [deleteConfirmation, setDeleteConfirmation] = useState(null); // {list: 'segments'|'focus', item: 'name' }


            const [practiceSegmentTypes, setPracticeSegmentTypes] = useState(() => {
                const saved = localStorage.getItem('oc-dashboard-segment-types');
                const defaultList = ['Competition', 'Take-Off', 'Fundi', '7-on-7', 'Inside Run', 'Team', 'Team Stationary', 'Circuit', 'Specials', 'Conditioning', 'Ghost Script', 'One-on-Ones', 'Goal Line', 'Short Yardage', 'O FUNDI', 'Team O'];

                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        if (Array.isArray(parsed)) {
                            // Migration: Return object with legacy array for all phases
                            return { OFFENSE: parsed, DEFENSE: parsed, SPECIAL_TEAMS: parsed };
                        }
                        return parsed;
                    } catch (e) { console.error("Error parsing segment types", e); }
                }

                // Default List (Phase Specific Defaults could be added here later, for now sharing global default)
                return { OFFENSE: defaultList, DEFENSE: defaultList, SPECIAL_TEAMS: defaultList };
            });

            const [practiceSegmentSettings, setPracticeSegmentSettings] = useState(() => {
                const saved = localStorage.getItem('oc-dashboard-segment-settings');
                if (saved) return JSON.parse(saved);
                return CALENDAR_CONSTANTS.SEGMENT_TYPE_SETTINGS || {};
            });

            const [practiceTemplates, setPracticeTemplates] = useLocalStorage('oc-dashboard-practice-templates', []);

            useEffect(() => {
                localStorage.setItem('oc-dashboard-segment-settings', JSON.stringify(practiceSegmentSettings));
            }, [practiceSegmentSettings]);

            const [practiceFocusItems, setPracticeFocusItems] = useState(() => {
                const saved = localStorage.getItem('oc-dashboard-focus-items');

                // Migrate legacy custom items if found and not yet saved to new list
                let initialList = ['Base Downs', 'Convert Downs', 'Red Zone', 'Gold Zone', 'Fringe', 'Goalline/Short YDG', 'Play Action', 'Motion', 'Tackling', 'Turnover', 'Pursuit', 'Board drill', 'Joust', 'Kickoff', 'Kick Return', 'Punt', 'Punt Return', 'Field Goal', 'Onside', 'Hands Team'];

                let legacyData = null;
                if (saved) {
                    try {
                        legacyData = JSON.parse(saved);
                    } catch (e) { }
                } else {
                    // One-time migration for very old "custom-focus" key
                    const legacyCustom = localStorage.getItem('oc-dashboard-custom-focus');
                    if (legacyCustom) {
                        try {
                            const parsedLegacy = JSON.parse(legacyCustom);
                            if (Array.isArray(parsedLegacy) && parsedLegacy.length > 0) {
                                // Add unique deprecated items
                                parsedLegacy.forEach(item => {
                                    if (!initialList.includes(item)) initialList.push(item);
                                });
                            }
                        } catch (e) { }
                    }
                    legacyData = initialList;
                }

                if (Array.isArray(legacyData)) {
                    return { OFFENSE: legacyData, DEFENSE: legacyData, SPECIAL_TEAMS: legacyData };
                }
                return legacyData || { OFFENSE: initialList, DEFENSE: initialList, SPECIAL_TEAMS: initialList };
            });

            // Helpers to get merged lists for dropdowns (maintaining backward compatibility for scripts)
            const getAllSegments = () => {
                const all = new Set([
                    ...(practiceSegmentTypes.OFFENSE || []),
                    ...(practiceSegmentTypes.DEFENSE || []),
                    ...(practiceSegmentTypes.SPECIAL_TEAMS || [])
                ]);
                return Array.from(all).sort();
            };

            const getAllFocusItems = () => {
                const all = new Set([
                    ...(practiceFocusItems.OFFENSE || []),
                    ...(practiceFocusItems.DEFENSE || []),
                    ...(practiceFocusItems.SPECIAL_TEAMS || [])
                ]);
                return Array.from(all).sort();
            };

            useEffect(() => {
                localStorage.setItem('oc-dashboard-segment-types', JSON.stringify(practiceSegmentTypes));
            }, [practiceSegmentTypes]);

            useEffect(() => {
                localStorage.setItem('oc-dashboard-focus-items', JSON.stringify(practiceFocusItems));
            }, [practiceFocusItems]);

            // Kept for backward compat in signature but unused
            const addCustomFocusItem = (item) => {
                const targetPhase = 'OFFENSE';
                const allItems = getAllFocusItems();
                if (item && !allItems.includes(item)) {
                    const currentList = practiceFocusItems[targetPhase] || [];
                    setPracticeFocusItems({ ...practiceFocusItems, [targetPhase]: [...currentList, item] });
                }
            };


            // Helper to get current week data
            const currentWeek = weeks.find(w => w.id === currentWeekId) || weeks[0];

            // In-Game State
            const [activePlay, setActivePlay] = useState(null); // The play currently selected by OC



            // Situation State (Derived/Managed via Week)
            const situation = currentWeek.situation || { down: 1, distance: 10, yardLine: 25, driveNumber: 1, hash: 'M' };

            const setSituation = (newSituation) => {
                if (currentWeek.isLocked) return;
                setWeeks(weeks.map(w => w.id === currentWeekId ? { ...w, situation: newSituation } : w));
            };

            // Derived state setters for compatibility with existing components
            const setPracticePlans = (newPlans) => {
                if (currentWeek.isLocked) return;
                setWeeks(weeks.map(w => w.id === currentWeekId ? { ...w, practicePlans: newPlans } : w));
            };

            const setPregamePlan = (newPlan) => {
                if (currentWeek.isLocked) return;
                setWeeks(weeks.map(w => w.id === currentWeekId ? { ...w, pregamePlan: newPlan } : w));
            };

            const setGameLog = (newLog) => {
                if (currentWeek.isLocked) return;
                setWeeks(weeks.map(w => w.id === currentWeekId ? { ...w, gameLog: newLog } : w));
            };

            const setGamePlan = (newPlan) => {
                if (currentWeek.isLocked) return;
                setWeeks(weeks.map(w => w.id === currentWeekId ? { ...w, offensiveGamePlan: newPlan } : w));
            };

            const handleAddWeek = () => {
                // Find highest week number
                let maxWeek = 0;
                weeks.forEach(w => {
                    const match = w.name.match(/Week (\d+)$/); // Strict end match to avoid "Week 1 of Summer"
                    if (match) {
                        const num = parseInt(match[1]);
                        if (num > maxWeek) maxWeek = num;
                    }
                });

                const nextNum = maxWeek + 1;
                const newWeekId = `week-${nextNum}`; // helper ID
                const prevWeek = weeks[weeks.length - 1]; // Use last week for data cloning

                // Carryover Logic
                const newWeek = {
                    id: `custom-week-${Date.now()}`, // Unique ID to avoid any potential collision
                    name: `Week ${nextNum}`,
                    weekNum: nextNum, // Explicitly set weekNum
                    date: '',
                    opponent: '',
                    scoutingReport: '',
                    isLocked: false,
                    // Independent Week Initialization (Blank Slate)
                    practicePlans: createDefaultPracticePlans(),
                    pregamePlan: { script: [] },
                    offensiveGamePlan: { sets: [] },
                    dumbCallSheetData: {},
                    newInstallIds: [], // Start with no installs

                    // Scoped Data Defaults (Global Fallbacks)
                    wristbands: JSON.parse(JSON.stringify(getGlobalWbSettings())),
                    depthChart: JSON.parse(JSON.stringify(getGlobalDepthCharts())),
                    zonePhilosophies: JSON.parse(JSON.stringify(getGlobalZonePhilosophies())),
                    gamePlanLayouts: JSON.parse(JSON.stringify(GAME_PLAN_LAYOUTS)),

                    gameLog: []
                };

                setWeeks([...weeks, newWeek]);
                setCurrentWeekId(newWeek.id);
            };

            const handleDeleteWeek = (weekId) => {
                if (!window.confirm("Are you sure you want to permanently delete this week?")) return;

                const newWeeks = weeks.filter(w => w.id !== weekId);
                setWeeks(newWeeks);

                if (currentWeekId === weekId) {
                    const fallback = newWeeks.length > 0 ? newWeeks[0].id : null;
                    if (fallback) setCurrentWeekId(fallback); // fixed implicit check
                }
            };

            const toggleWeekLock = () => {
                setWeeks(weeks.map(w => w.id === currentWeekId ? { ...w, isLocked: !w.isLocked } : w));
            };

            const handleUpdateWeek = (id, field, value) => {
                setWeeks(prevWeeks => {
                    if (field === 'bulk_update' && typeof value === 'object') {
                        return prevWeeks.map(w => w.id === id ? { ...w, ...value } : w);
                    } else {
                        return prevWeeks.map(w => w.id === id ? { ...w, [field]: value } : w);
                    }
                });
            };

            const handleUpdateGameLog = (newLog) => {
                if (currentWeek.isLocked) return;
                setWeeks(weeks.map(w => w.id === currentWeekId ? { ...w, gameLog: newLog } : w));
            };

            const handleUpdateGamePlan = (newPlan) => {
                handleUpdateWeek(currentWeekId, 'offensiveGamePlan', newPlan);
            };

            // --- SCOPED UPDATE HANDLERS ---
            const handleUpdateWristbands = (newSettings) => {
                if (currentWeek.isLocked) return;
                // Support functional updates like standard setState
                const resolvedSettings = typeof newSettings === 'function'
                    ? newSettings(currentWeek.wristbands)
                    : newSettings;

                setWeeks(weeks.map(w => w.id === currentWeekId ? { ...w, wristbands: resolvedSettings } : w));
            };

            const handleUpdateDepthChart = (newChart) => {
                if (currentWeek.isLocked) return;
                const resolvedChart = typeof newChart === 'function' ? newChart(currentWeek.depthChart) : newChart;
                setWeeks(weeks.map(w => w.id === currentWeekId ? { ...w, depthChart: resolvedChart } : w));
            };

            const handleUpdateZonePhilosophies = (newPhilosophies) => {
                if (currentWeek.isLocked) return;
                const resolvedPhils = typeof newPhilosophies === 'function' ? newPhilosophies(currentWeek.zonePhilosophies) : newPhilosophies;
                setWeeks(weeks.map(w => w.id === currentWeekId ? { ...w, zonePhilosophies: resolvedPhils } : w));
            };
            // ------------------------------

            const [globalWeekTemplates, setGlobalWeekTemplates] = useState([]);

            // Fetch Week Templates from Firestore
            useEffect(() => {
                if (window.db && authUser) {
                    const fetchTemplates = async () => {
                        try {
                            const snapshot = await window.db.collection('global_week_templates').get();
                            const templates = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                            setGlobalWeekTemplates(templates);
                        } catch (err) {
                            console.error("Error fetching week templates:", err);
                        }
                    };
                    fetchTemplates();
                }
            }, [authUser]);

            const handleSaveWeekToTemplates = async (name) => {
                if (!name.trim()) return;
                const templateData = {
                    name: name.trim(),
                    practicePlans: JSON.parse(JSON.stringify(currentWeek.practicePlans)),
                    offensiveGamePlan: JSON.parse(JSON.stringify(currentWeek.offensiveGamePlan)),
                    dumbCallSheetData: JSON.parse(JSON.stringify(currentWeek.dumbCallSheetData || {})),
                    pregamePlan: currentWeek.pregamePlan ? JSON.parse(JSON.stringify(currentWeek.pregamePlan)) : null,

                    // Add new scoped data to templates
                    wristbands: currentWeek.wristbands ? JSON.parse(JSON.stringify(currentWeek.wristbands)) : null,
                    depthChart: currentWeek.depthChart ? JSON.parse(JSON.stringify(currentWeek.depthChart)) : null,
                    zonePhilosophies: currentWeek.zonePhilosophies ? JSON.parse(JSON.stringify(currentWeek.zonePhilosophies)) : null,

                    createdAt: new Date().toISOString(),
                    createdBy: authUser.uid
                };

                try {
                    const docRef = await window.db.collection('global_week_templates').add(templateData);
                    setGlobalWeekTemplates([...globalWeekTemplates, { id: docRef.id, ...templateData }]);
                    alert("Week saved as template!");
                } catch (err) {
                    console.error("Error saving week template:", err);
                    alert("Failed to save template.");
                }
            };

            const handleLoadWeekFromTemplate = (templateId) => {
                if (currentWeek.isLocked) {
                    alert("Current week is locked. Unlock it to apply a template.");
                    return;
                }
                const template = globalWeekTemplates.find(t => t.id === templateId);
                if (!template) return;

                if (confirm(`Apply template "${template.name}" to the current week? This will overwrite your current plans.`)) {
                    setWeeks(weeks.map(w => w.id === currentWeekId ? {
                        ...w,
                        practicePlans: JSON.parse(JSON.stringify(template.practicePlans)),
                        offensiveGamePlan: JSON.parse(JSON.stringify(template.offensiveGamePlan)),
                        dumbCallSheetData: JSON.parse(JSON.stringify(template.dumbCallSheetData || {})),
                        pregamePlan: template.pregamePlan ? JSON.parse(JSON.stringify(template.pregamePlan)) : w.pregamePlan
                    } : w));
                }
            };

            // Persistence for Weeks
            useEffect(() => {
                localStorage.setItem('oc-dashboard-weeks', JSON.stringify(weeks));
            }, [weeks]);

            // --- End Weeks Management ---

            const [roster, setRoster] = useState(() => {
                try {
                    const saved = localStorage.getItem('oc-dashboard-roster');
                    let loadedRoster = [];

                    if (!saved || saved === "null" || saved === "[]") {
                        loadedRoster = DEFAULT_ROSTER_2025;
                    } else {
                        loadedRoster = JSON.parse(saved);
                    }

                    // Migration / Initialization
                    return loadedRoster.map(p => {
                        let updated = { ...p };

                        // Ensure Position Split
                        if (!updated.offPosition || !updated.defPosition) {
                            const parts = (updated.position || '').split('/');
                            updated.offPosition = updated.offPosition || parts[0] || 'NA';
                            updated.defPosition = updated.defPosition || parts[1] || 'NA';
                        }

                        // Ensure Profile Structure
                        if (!updated.profile) {
                            updated.profile = {
                                favorites: { nfl: '', nba: '', mlb: '', musicians: '', food: '', movie: '', hobbies: '' },
                                family: '',
                                goals: { postHS: '', job: '', colleges: '' }
                            };
                        }

                        // Ensure Metrics Structure
                        if (!updated.metrics) {
                            updated.metrics = {
                                attendanceStreak: 0,
                                longestStreak: 0,
                                awards: [],
                                warriorDialLogs: []
                            };
                        } else if (!updated.metrics.warriorDialLogs) {
                            updated.metrics.warriorDialLogs = [];
                        }

                        // DATA NORMALIZATION: Ensure 'number' and 'name' are primary
                        if (!updated.number && updated.jersey) updated.number = updated.jersey;
                        if (!updated.name) {
                            if (updated.firstName && updated.lastName) {
                                updated.name = `${updated.firstName} ${updated.lastName}`;
                            } else if (updated.firstName) {
                                updated.name = updated.firstName;
                            }
                        }

                        // Ensure 'archived' flag exists
                        if (updated.archived === undefined) updated.archived = false;

                        return updated;
                    });

                } catch (e) { return DEFAULT_ROSTER_2025; }
            });
            const [depthChart, setDepthChart] = useState(() => {
                try {
                    const saved = localStorage.getItem('oc-dashboard-depthchart');
                    return (saved && saved !== "null") ? JSON.parse(saved) : {};
                } catch (e) { return {}; }
            });
            const [staff, setStaff] = useState(() => {
                try {
                    const saved = localStorage.getItem('oc-dashboard-staff');
                    if (!saved || saved === "null" || saved === "[]") return DEFAULT_STAFF_2025;

                    const loaded = JSON.parse(saved);
                    // Migration: Ensure 'roles' array exists.
                    // If old 'role' string exists, convert to array.
                    return loaded.map(s => {
                        if (s.role && !s.roles) {
                            // Map legacy string roles to new array. 
                            // 'Assistant Coach' -> 'Position Coach' mapping if needed, 
                            // but explicit mapping is safer.
                            let mappedRole = s.role;
                            if (s.role === 'Assistant Coach') mappedRole = 'Position Coach';
                            return { ...s, roles: [mappedRole], role: undefined };
                        }
                        if (!s.roles) {
                            return { ...s, roles: ['Position Coach'] };
                        }
                        return s;
                    });
                } catch (e) { return DEFAULT_STAFF_2025; }
            });

            // Calculate Permissions based on Current User's Roles
            const currentUser = staff.find(s => s.id === currentUserId) || staff[0] || DEFAULT_STAFF_2025[0];

            const currentPermissions = useMemo(() => {
                const userRoles = currentUser?.roles || [];

                // SUPER OVERRIDE: Admin Flag or Head Coach Role
                if (currentUser?.isAdmin || userRoles.includes('Head Coach')) {
                    // Start with 'Head Coach' permissions (Full Access)
                    return JSON.parse(JSON.stringify(DEFAULT_PERMISSIONS['Head Coach']));
                }

                // Default to first role or generic
                if (userRoles.length === 0) return DEFAULT_PERMISSIONS['Assistant'];

                // Merge Permissions: If ANY role has 'true', specific permission is true.
                const merged = JSON.parse(JSON.stringify(DEFAULT_PERMISSIONS['Assistant'])); // Start with base restricted

                userRoles.forEach(role => {
                    const rolePerms = permissions[role] || DEFAULT_PERMISSIONS[role];
                    if (!rolePerms) return;

                    Object.keys(rolePerms).forEach(feature => {
                        if (!merged[feature]) merged[feature] = { view: false, edit: false };
                        if (rolePerms[feature].view) merged[feature].view = true;
                        if (rolePerms[feature].edit) merged[feature].edit = true;
                    });
                });
                return merged;
            }, [currentUser, permissions]);

            const [teamLogo, setTeamLogo] = useState(() => {
                return localStorage.getItem('oc-dashboard-logo') || null; // Default null for new users
            });
            const [schoolName, setSchoolName] = useState(() => {
                return localStorage.getItem('hc_school_name') || '';
            });

            // Access Config for Permissions (Paying Admin Check)
            const [appAccessConfig, setAppAccessConfig] = useState({});
            useEffect(() => {
                const fetchAccess = async () => {
                    try {
                        if (!window.db) return;
                        const doc = await window.db.collection('config').doc('access').get();
                        if (doc.exists) {
                            setAppAccessConfig(doc.data());
                        }
                    } catch (e) { console.error("Error fetching access config", e); }
                };
                fetchAccess();
            }, []); // Run once on mount
            const [accentColor, setAccentColor] = useState(() => {
                return localStorage.getItem('oc-dashboard-accent') || '#38bdf8';
            });
            const handleUpdateAccentColor = setAccentColor;

            // UI Theme State
            const [theme, setTheme] = useState(() => {
                return localStorage.getItem('oc-dashboard-theme') || 'navy';
            });

            useEffect(() => {
                localStorage.setItem('oc-dashboard-theme', theme);
                document.body.className = `theme-${theme}`;
                // Cloud Sync
                if (currentUser && window.db) {
                    syncToFirestore(currentUser.uid, 'settings', { theme });
                }
            }, [theme, currentUser]);

            const [positionNames, setPositionNames] = useState(() => {
                const saved = localStorage.getItem('oc-dashboard-position-names');
                return saved ? JSON.parse(saved) : {
                    X: 'X', Z: 'Z', A: 'A', Y: 'Y',
                    QB: 'QB', RB: 'RB',
                    LT: 'LT', LG: 'LG', C: 'C', RG: 'RG', RT: 'RT'
                };
            });

            // Position Colors - follows positions through formations and diagrams
            const DEFAULT_POSITION_COLORS = {
                // Skill Positions
                QB: '#1e3a5f',    // Dark blue (quarterback)
                RB: '#3b82f6',    // Blue
                F: '#f97316',     // Orange (fullback)
                H: '#06b6d4',     // Cyan (H-back/slot)
                X: '#a855f7',     // Purple (split end)
                Z: '#22c55e',     // Green (flanker)
                Y: '#eab308',     // Yellow (tight end)
                A: '#ef4444',     // Red (slot)
                B: '#ec4899',     // Pink (extra receiver)
                // O-Line
                LT: '#64748b',    // Slate
                LG: '#64748b',
                C: '#64748b',
                RG: '#64748b',
                RT: '#64748b',
            };
            const [positionColors, setPositionColors] = useLocalStorage('oc-dashboard-position-colors', DEFAULT_POSITION_COLORS);

            const [depthChartType, setDepthChartType] = useState('OFFENSE');

            // Offense Setup State
            const [customPositions, setCustomPositions] = useLocalStorage('oc-dashboard-custom-positions', { OFFENSE: [], DEFENSE: [], SPECIAL_TEAMS: [] });
            const [hiddenPositions, setHiddenPositions] = useLocalStorage('oc-dashboard-hidden-positions', { OFFENSE: [], DEFENSE: [], SPECIAL_TEAMS: [] });
            const [personnelGroupings, setPersonnelGroupings] = useLocalStorage('oc-dashboard-personnel-groupings', DEFAULT_PERSONNEL_GROUPINGS);
            const [positionDescriptions, setPositionDescriptions] = useLocalStorage('oc-dashboard-position-descriptions', {});
            const [playSyntax, setPlaySyntax] = useLocalStorage('oc-dashboard-play-syntax', [
                { id: 'pres_form', label: 'Formation', type: 'text' },
                { id: 'pres_conc', label: 'Concept', type: 'text' }
            ]);
            const [defensePlaySyntax, setDefensePlaySyntax] = useLocalStorage('oc-dashboard-play-syntax-defense', []);
            const [stPlaySyntax, setStPlaySyntax] = useLocalStorage('oc-dashboard-play-syntax-st', []);
            const [termLibrary, setTermLibrary] = useLocalStorage('oc-dashboard-term-library', {});

            const [defenseTermLibrary, setDefenseTermLibrary] = useLocalStorage('oc-dashboard-term-library-defense', {});
            const [stTermLibrary, setStTermLibrary] = useLocalStorage('oc-dashboard-term-library-st', {});

            // O-Line Schemes State (Pass Protections and Run Blocking)
            const [passProtections, setPassProtections] = useLocalStorage('oc-dashboard-pass-protections', [
                { id: 'brown', name: 'BROWN', slideDirection: 'right', manSide: 'left', callText: 'Slide R – Man L', notes: '' },
                { id: 'gold', name: 'GOLD', slideDirection: 'left', manSide: 'right', callText: 'Slide L – Man R', notes: '' }
            ]);
            const [runBlocking, setRunBlocking] = useLocalStorage('oc-dashboard-run-blocking', [
                { id: 'zone', name: 'ZONE', type: 'zone', callText: 'Zone blocking scheme', notes: '' },
                { id: 'gap', name: 'GAP', type: 'gap', callText: 'Gap/Power blocking scheme', notes: '' }
            ]);

            const [setupTab, setSetupTab] = useState('positions');
            const [editingOlineScheme, setEditingOlineScheme] = useState(null); // { id, type: 'protection' | 'blocking' }
            const [setupCategory, setSetupCategory] = useState(null);
            const [selectedBucketCategory, setSelectedBucketCategory] = useState(null);
            // Legacy: Keep playCategories for backward compatibility during transition
            const [playCategories, setPlayCategories] = useLocalStorage('oc-dashboard-play-categories', []);
            const [playBuckets, setPlayBuckets] = useLocalStorage('oc-dashboard-play-buckets', DEFAULT_PLAY_BUCKETS);

            // Custom Tag Categories - users can define their own tag groups for play analysis
            const [customTagCategories, setCustomTagCategories] = useLocalStorage('oc-dashboard-custom-tag-categories', [
                // Example structure: { id: 'cat_123', name: 'My Category', tags: ['Tag 1', 'Tag 2'] }
            ]);

            // Ensure default buckets exist (Run, Pass, Screen)
            useEffect(() => {
                if (!playBuckets || playBuckets.length === 0) {
                    setPlayBuckets(DEFAULT_PLAY_BUCKETS);
                }
            }, [playBuckets, setPlayBuckets]);

            // AUTO-MIGRATION: Assign bucketId to plays based on their type
            useEffect(() => {
                const needsMigration = plays.some(p => p.type && !p.bucketId && p.type !== 'GAP' && p.type !== 'note');

                if (needsMigration) {
                    console.log('Migrating plays from categories to buckets...');

                    // Map old category types to new bucket IDs
                    const typeToBucketMap = {
                        'Run': 'run',
                        'RPO': 'run',
                        'Pass': 'pass',
                        'Play Action': 'pass',
                        'Screen': 'screen',
                        'GADGET': 'screen',
                        'Gadget': 'screen'
                    };

                    plays.forEach(play => {
                        if (play.type && !play.bucketId && play.type !== 'GAP' && play.type !== 'note') {
                            const bucketId = typeToBucketMap[play.type] || 'run';
                            handlePatchPlay(play.id, { bucketId });
                        }
                    });

                    console.log('Migration complete!');
                }
            }, [plays]);


            // Script Presets (Dynamic Script Templates)
            const [scriptPresets, setScriptPresets] = useLocalStorage('oc-dashboard-script-presets', [
                {
                    id: 'preset_takeoff',
                    name: 'Take-Off',
                    useYardLine: true,
                    items: [
                        { yardLine: '-30', hash: 'L' },
                        { yardLine: '-40', hash: 'M' },
                        { yardLine: '50', hash: 'R' },
                        { yardLine: '40', hash: 'L' },
                        { yardLine: '30', hash: 'M' },
                        { yardLine: '20', hash: 'R' },
                        { yardLine: '10', hash: 'L' },
                        { yardLine: '5', hash: 'M' }
                    ]
                }
            ]);





            // Layout Persistence

            const [gamePlanLayouts, setGamePlanLayouts] = useLocalStorage('gamePlanLayouts', GAME_PLAN_LAYOUTS);
            const [layoutVersions, setLayoutVersions] = useLocalStorage('gamePlanLayoutVersions', {});

            // Global Playbook Sidebar State (persistent across all views)
            const [globalSidebarOpen, setGlobalSidebarOpen] = useLocalStorage('oc-global-sidebar-open', false);

            // Ref for "add to next slot" callback - views can register their handler
            const addToNextSlotRef = React.useRef(null);

            // Setup Page Tab State (Offense/Defense/Special Teams)
            const [setupPhase, setSetupPhase] = useLocalStorage('oc-setup-phase', 'OFFENSE');
            const [setupSection, setSetupSection] = useState('positions'); // positions, formations, glossary

            const saveLayoutVersion = (name) => {
                if (!name) return;
                const newVersions = { ...layoutVersions, [name]: gamePlanLayouts };
                setLayoutVersions(newVersions);
                alert(`Layout version "${name}" saved!`);
            };

            const deleteLayoutVersion = (name) => {
                const newVersions = { ...layoutVersions };
                delete newVersions[name];
                setLayoutVersions(newVersions);
            };

            const loadLayoutVersion = (name) => {
                const version = layoutVersions[name];
                if (!version) return;
                setGamePlanLayouts(version);
            };

            // Force update layout cols if they don't match constant (Migration for 4-col change)
            useEffect(() => {
                if (gamePlanLayouts?.CALL_SHEET) {
                    let changed = false;
                    const sections = gamePlanLayouts.CALL_SHEET.sections;
                    if (!sections || !Array.isArray(sections)) return;
                    // Check Scripts (index 0)
                    if (sections[0] && sections[0].cols !== 4) {
                        const newSections = [...sections];
                        newSections[0] = { ...newSections[0], cols: 4 };
                        // Also check D&D (index 1) which should be 4
                        if (newSections[1] && newSections[1].cols !== 4) {
                            newSections[1] = { ...newSections[1], cols: 4 };
                        }
                        setGamePlanLayouts({ ...gamePlanLayouts, CALL_SHEET: { ...gamePlanLayouts.CALL_SHEET, sections: newSections } });
                        changed = true;
                    }
                    else if (sections[1] && sections[1].cols !== 4) {
                        // Just D&D needs update
                        const newSections = [...sections];
                        newSections[1] = { ...newSections[1], cols: 4 };
                        setGamePlanLayouts({ ...gamePlanLayouts, CALL_SHEET: { ...gamePlanLayouts.CALL_SHEET, sections: newSections } });
                        changed = true;
                    }
                }
            }, []);
            const [formationLayouts, setFormationLayouts] = useLocalStorage('formationLayouts', {});

            const updateFormationLayout = (chartType, posId, x, y) => {
                setFormationLayouts(prev => ({
                    ...prev,
                    [chartType]: {
                        ...(prev[chartType] || {}),
                        [posId]: { x, y }
                    }
                }));
            };

            const resetFormationLayout = (chartType) => {
                setFormationLayouts(prev => {
                    const next = { ...prev };
                    delete next[chartType];
                    return next;
                });
            };

            const [ratings, setRatings] = useLocalStorage('oc-dashboard-ratings', {});
            const [attendance, setAttendance] = useLocalStorage('oc-dashboard-attendance', []);




            // Save plays to localStorage whenever it changes
            useEffect(() => {
                localStorage.setItem('oc-dashboard-plays', JSON.stringify(plays));
            }, [plays]);

            // Save roster to localStorage whenever it changes
            useEffect(() => {
                localStorage.setItem('oc-dashboard-roster', JSON.stringify(roster));
                // Cloud Sync
                if (currentUser && window.db) {
                    syncToFirestore(currentUser.uid, 'roster', roster);
                }
            }, [roster, currentUser]);

            // Save depth chart to localStorage whenever it changes
            useEffect(() => {
                localStorage.setItem('oc-dashboard-depthchart', JSON.stringify(depthChart));
                // Cloud Sync
                if (currentUser && window.db) {
                    syncToFirestore(currentUser.uid, 'depthChart', depthChart);
                }
            }, [depthChart, currentUser]);

            // Save staff to localStorage whenever it changes
            useEffect(() => {
                localStorage.setItem('oc-dashboard-staff', JSON.stringify(staff));
                // Cloud Sync
                if (currentUser && window.db) {
                    syncToFirestore(currentUser.uid, 'staff', staff);
                }
            }, [staff, currentUser]);

            // Save team logo to localStorage whenever it changes
            useEffect(() => {
                if (teamLogo) {
                    localStorage.setItem('oc-dashboard-logo', teamLogo);
                } else {
                    localStorage.removeItem('oc-dashboard-logo');
                }
                // Cloud Sync
                if (currentUser && window.db) {
                    syncToFirestore(currentUser.uid, 'settings', { teamLogo });
                }
            }, [teamLogo, currentUser]);

            // Apply and Save Accent Color
            useEffect(() => {
                if (accentColor) {
                    document.documentElement.style.setProperty('--accent', accentColor);
                    localStorage.setItem('oc-dashboard-accent', accentColor);

                    // Persist to School Data (Cloud) if possible
                    const currentSchoolId = localStorage.getItem('hc_school_id');
                    if (currentSchoolId && window.db) {
                        try {
                            const schoolRef = window.db.collection('schools').doc(currentSchoolId);
                            // Only update if specifically changed (debounce could be added but this is simple)
                            schoolRef.set({
                                settings: { accentColor: accentColor }
                            }, { merge: true }).catch(err => console.error("Error saving color to cloud:", err));
                        } catch (e) {
                            console.warn("Could not save color to cloud:", e);
                        }
                    }
                }
            }, [accentColor]);

            // Save position names to localStorage
            useEffect(() => {
                localStorage.setItem('oc-dashboard-position-names', JSON.stringify(positionNames));
                // Cloud Sync
                if (currentUser && window.db) {
                    syncToFirestore(currentUser.uid, 'settings', { positionNames });
                }
            }, [positionNames, currentUser]);

            // Save ratings to localStorage whenever they change
            useEffect(() => {
                localStorage.setItem('oc-dashboard-ratings', JSON.stringify(ratings));
            }, [ratings]);

            const toggleTag = (tag) => {
                // ... (logic handled in PlayInput)
            };

            const handleSavePlay = (playData) => {
                const { assignedScriptIds, ...savedPlayData } = playData;
                if (savedPlayData.name) savedPlayData.name = savedPlayData.name.toUpperCase();

                // Sync Mini Script Assignments
                if (assignedScriptIds !== undefined) {
                    const currentGamePlan = currentWeek.offensiveGamePlan || { sets: [], miniScripts: [] };
                    const newMiniScripts = (currentGamePlan.miniScripts || []).map(script => {
                        const isAssigned = assignedScriptIds.includes(script.id);
                        const hasPlay = script.playIds.includes(savedPlayData.id);

                        if (isAssigned && !hasPlay) {
                            return { ...script, playIds: [...script.playIds, savedPlayData.id] };
                        } else if (!isAssigned && hasPlay) {
                            return { ...script, playIds: script.playIds.filter(id => id !== savedPlayData.id) };
                        }
                        return script;
                    });

                    // Only update gamePlan if changes occured
                    if (JSON.stringify(newMiniScripts) !== JSON.stringify(currentGamePlan.miniScripts)) {
                        setGamePlan({ ...currentGamePlan, miniScripts: newMiniScripts });
                    }
                }

                // Sync Bucket Assignment (Play Family)
                if (savedPlayData.bucketId !== undefined) {
                    const oldBucketId = editingPlay?.bucketId;
                    const newBucketId = savedPlayData.bucketId;

                    // Only update if bucket assignment changed
                    if (oldBucketId !== newBucketId) {
                        const updatedBuckets = playBuckets.map(bucket => {
                            const currentPlays = bucket.plays || [];

                            // Remove from old bucket
                            if (bucket.id === oldBucketId && currentPlays.includes(savedPlayData.id)) {
                                return { ...bucket, plays: currentPlays.filter(id => id !== savedPlayData.id) };
                            }

                            // Add to new bucket
                            if (bucket.id === newBucketId && !currentPlays.includes(savedPlayData.id)) {
                                return { ...bucket, plays: [...currentPlays, savedPlayData.id] };
                            }

                            return bucket;
                        });

                        // Only update if changes occurred
                        if (JSON.stringify(updatedBuckets) !== JSON.stringify(playBuckets)) {
                            setPlayBuckets(updatedBuckets);
                        }
                    }
                }

                if (editingPlay) {
                    setPlays(plays.map(p => p.id === savedPlayData.id ? savedPlayData : p));
                    setEditingPlay(null);
                } else {
                    setPlays([savedPlayData, ...plays]);
                }
                setView('playbook');
            };

            // ...

            // RENDER LOGIC UPDATE
            {
                view === 'new-play' && (
                    <PlayInput
                        onSave={handleSavePlay}
                        onCancel={() => { setEditingPlay(null); setView('playbook'); }}
                        onDelete={handleDeletePlay}
                        initialData={editingPlay}
                        availableMiniScripts={currentWeek.offensiveGamePlan?.miniScripts || []}
                        initialAssignedScriptIds={editingPlay ? (currentWeek.offensiveGamePlan?.miniScripts || []).filter(s => s.playIds.includes(editingPlay.id)).map(s => s.id) : []}
                        formations={formations}
                        wizLibrary={wizLibrary}
                        setWizLibrary={setWizLibrary}
                        positionNames={positionNames}
                        positionColors={positionColors}
                        playBuckets={playBuckets}
                        playCategories={playCategories}
                        onAddFormation={handleAddFormation}
                        passProtections={passProtections}
                        setPassProtections={setPassProtections}
                        runBlocking={runBlocking}
                        setRunBlocking={setRunBlocking}
                        customTagCategories={customTagCategories}
                        setCustomTagCategories={setCustomTagCategories}
                    />
                )
            }

            const handleEditPlay = (play) => {
                setEditingPlay(play);
                setView('new-play');
            };

            const handleUpdatePlay = (arg1, arg2) => {
                if (typeof arg1 === 'string' || typeof arg1 === 'number') {
                    // (id, updates) signature - used by InstallSortableColumn checkboxes
                    const id = arg1;
                    const updates = { ...arg2 };
                    if (updates.name) updates.name = updates.name.toUpperCase();
                    setPlays(prev => prev.map(p => p.id === id ? { ...p, ...updates } : p));
                } else {
                    // (updatedPlay) signature - full object replacement
                    const updatedPlay = arg1;
                    if (Array.isArray(updatedPlay)) {
                        // Batch update
                        const uppercased = updatedPlay.map(p => p.name ? { ...p, name: p.name.toUpperCase() } : p);
                        const updateMap = new Map(uppercased.map(p => [p.id, p]));
                        setPlays(prev => prev.map(p => updateMap.has(p.id) ? updateMap.get(p.id) : p));
                    } else {
                        // Single update
                        const finalPlay = { ...updatedPlay };
                        if (finalPlay.name) finalPlay.name = finalPlay.name.toUpperCase();
                        setPlays(prev => prev.map(p => p.id === finalPlay.id ? finalPlay : p));
                    }
                }
            };

            const handleDeletePlay = (playId) => {
                setPlays(plays.filter(p => p.id !== playId));
                setEditingPlay(null);
                setView('playbook');
            };

            // Filter Logic for Playbook View
            const [playbookFilters, setPlaybookFilters] = useState({
                formation: '',
                playCategory: '', // Bucket
                bucketId: '', // Family
                tag: '',
                situation: ''
            });

            // Batch Delete State
            const [selectedPlays, setSelectedPlays] = useState([]);
            const [lastSelectedPlayId, setLastSelectedPlayId] = useState(null);

            // Batch Import State
            const [isBatchImportOpen, setIsBatchImportOpen] = useState(false);
            const [importData, setImportData] = useState('');
            const [parsedImport, setParsedImport] = useState([]);
            const [columnMapping, setColumnMapping] = useState({});

            const handleProgressSeason = () => {
                const gradeProgression = {
                    'Freshman': 'Sophomore',
                    'Sophomore': 'Junior',
                    'Junior': 'Senior',
                    'Senior': 'Graduated'
                };

                const updatedRoster = roster
                    .map(player => ({
                        ...player,
                        year: gradeProgression[player.year] || player.year
                    }))
                    .filter(player => player.year !== 'Graduated'); // Remove graduated seniors

                const graduatedCount = roster.filter(p => p.year === 'Senior').length;

                setRoster(updatedRoster);
                alert(`✅ Season Advanced!\n\n${updatedRoster.length} players progressed to next grade.\n${graduatedCount} seniors graduated and removed from roster.`);
            };

            const handleRegressSeason = () => {
                const gradeRegression = {
                    'Senior': 'Junior',
                    'Junior': 'Sophomore',
                    'Sophomore': 'Freshman',
                    'Freshman': 'Freshman' // Can't go lower
                };

                const updatedRoster = roster.map(player => ({
                    ...player,
                    year: gradeRegression[player.year] || player.year
                }));

                setRoster(updatedRoster);
                alert(`✅ Season Regressed!\n\n${updatedRoster.length} players moved back one grade.\n\nNote: Graduated seniors were NOT restored.`);
            };

            const togglePlaySelection = (playId, isShift) => {
                const currentFiltered = getFilteredPlaybook();
                setLastSelectedPlayId(playId);

                if (isShift && lastSelectedPlayId) {
                    const currentIndex = currentFiltered.findIndex(p => p.id === playId);
                    const lastIndex = currentFiltered.findIndex(p => p.id === lastSelectedPlayId);

                    if (currentIndex !== -1 && lastIndex !== -1) {
                        const start = Math.min(currentIndex, lastIndex);
                        const end = Math.max(currentIndex, lastIndex);
                        const idsInRange = currentFiltered.slice(start, end + 1).map(p => p.id);

                        setSelectedPlays(prev => {
                            const newSet = new Set([...prev, ...idsInRange]);
                            return Array.from(newSet);
                        });
                        return;
                    }
                }

                setSelectedPlays(prev =>
                    prev.includes(playId)
                        ? prev.filter(id => id !== playId)
                        : [...prev, playId]
                );
            };

            const handleToggleSelect = (playId) => {
                setSelectedPlays(prev =>
                    prev.includes(playId)
                        ? prev.filter(id => id !== playId)
                        : [...prev, playId]
                );
            };

            const handleDeleteSelected = (e) => {
                // Prevent event bubbling and default action to avoid conflicts with other handlers
                if (e) {
                    e.preventDefault();
                    e.stopPropagation();
                }

                // Small timeout to allow the UI to stabilize/event loop to clear before showing the blocking alert
                setTimeout(() => {
                    if (window.confirm(`Are you sure you want to delete ${selectedPlays.length} plays? This cannot be undone.`)) {
                        setPlays(prevPlays => prevPlays.filter(p => !selectedPlays.includes(p.id)));
                        setSelectedPlays([]);
                    }
                }, 50);
            };

            // Batch Import Handlers
            const handleParseImport = () => {
                if (!importData.trim()) return;
                const rows = importData.split('\n').filter(r => r.trim());
                if (rows.length === 0) return;

                const firstRow = rows[0];
                const delimiter = firstRow.includes('\t') ? '\t' : (firstRow.includes(',') ? ',' : ' ');

                const parsed = rows.map(row => {
                    return row.split(delimiter).map(cell => cell.trim());
                });

                setParsedImport(parsed);
                setColumnMapping({});
            };

            const handleBatchCreate = (addToInstall = false) => {
                const newPlays = parsedImport.map(row => {
                    let playNameParts = [];
                    let formation = '';
                    let type = '';

                    Object.entries(columnMapping).forEach(([colIdx, fieldId]) => {
                        const value = row[parseInt(colIdx)];
                        if (!value) return;

                        if (fieldId === 'name_override') {
                            playNameParts = [value];
                        } else if (fieldId === 'formation') {
                            formation = value;
                        } else if (fieldId === 'type') {
                            type = value;
                        } else {
                            const field = playSyntax.find(f => f.id === fieldId);
                            if (field) {
                                playNameParts.push(value);
                            }
                        }
                    });

                    const finalName = playNameParts.join(' ').trim() || row[0];
                    return { name: finalName, formation, type: type || '' };
                });

                newPlays.forEach(playData => {
                    const newPlay = handleQuickAddPlay(playData.name);
                    if (newPlay && playData.formation) {
                        handleUpdatePlay(newPlay.id, { formation: playData.formation, type: playData.type });
                    }
                    if (addToInstall && newPlay && currentWeek) {
                        const installList = currentWeek.installList || [];
                        if (!installList.includes(newPlay.id)) {
                            handleUpdateWeek(currentWeek.id, 'installList', [...installList, newPlay.id]);
                        }
                    }
                });

                setIsBatchImportOpen(false);
                setParsedImport([]);
                setImportData('');
                setColumnMapping({});
            };

            const getFilteredPlaybook = () => {
                if (!Array.isArray(plays)) {
                    console.error('plays is not an array:', plays);
                    return [];
                }
                return plays.filter(play => {
                    // Search term filter (name or formation)
                    const search = (searchTerm || '').toLowerCase().trim();
                    const matchSearch = !search ||
                        (play.name && play.name.toLowerCase().includes(search)) ||
                        (play.formation && play.formation.toLowerCase().includes(search));

                    const matchFormation = !playbookFilters.formation || play.formation === playbookFilters.formation;
                    const matchPlayCategory = !playbookFilters.playCategory || play.playCategory === playbookFilters.playCategory;
                    const matchBucketId = !playbookFilters.bucketId || play.bucketId === playbookFilters.bucketId;
                    const matchTag = !playbookFilters.tag || (play.tags || []).includes(playbookFilters.tag) || play.tag1 === playbookFilters.tag || play.tag2 === playbookFilters.tag;

                    // Situation filter checks against specific categories
                    const matchSituation = !playbookFilters.situation || (play.tags || []).includes(playbookFilters.situation) ||
                        (TAG_CATEGORIES["Situation"] && TAG_CATEGORIES["Situation"].includes(playbookFilters.situation) && (play.tags || []).includes(playbookFilters.situation)) ||
                        (TAG_CATEGORIES["Field Position"] && TAG_CATEGORIES["Field Position"].includes(playbookFilters.situation) && (play.tags || []).includes(playbookFilters.situation)) ||
                        (TAG_CATEGORIES["Down & Distance"] && TAG_CATEGORIES["Down & Distance"].includes(playbookFilters.situation) && (play.tags || []).includes(playbookFilters.situation));

                    return matchSearch && matchFormation && matchPlayCategory && matchBucketId && matchTag && matchSituation;
                });
            };

            const filteredPlaybook = getFilteredPlaybook();

            // Extract unique values for Playbook filters
            const uniqueFormations = [...new Set(plays.map(p => p.formation).filter(Boolean))].sort();
            const uniqueConcepts = [...new Set(plays.map(p => p.concept).filter(Boolean))].sort();
            const allTags = [...new Set(plays.flatMap(p => [p.tag1, p.tag2, ...(p.tags || [])]))].filter(Boolean).sort();
            const situationTags = [...(TAG_CATEGORIES["Field Position"] || []), ...(TAG_CATEGORIES["Down & Distance"] || [])];


            // Sync status state


            const renderDataSyncManager = () => {
                const getLocal = (key, defaultVal = null) => {
                    const saved = localStorage.getItem(key);
                    return saved ? JSON.parse(saved) : defaultVal;
                };

                const dataTypes = [
                    { id: 'roster', label: 'Roster', data: getLocal('oc-dashboard-roster', []) },
                    { id: 'plays', label: 'Playbook', data: getLocal('oc-dashboard-plays', []) },
                    { id: 'staff', label: 'Staff', data: getLocal('oc-dashboard-staff', []) },
                    { id: 'weeks', label: 'Game Planner & Scripts', data: getLocal('oc-dashboard-weeks', []) },

                    { id: 'attendance', label: 'Attendance', data: getLocal('attendance_log', []) },
                    { id: 'formationLayouts', label: 'Formation Maps', data: getLocal('formationLayouts', {}) },
                    { id: 'ratings', label: 'Player Ratings', data: getLocal('oc-dashboard-ratings', {}) },
                    { id: 'athleteAssessments', label: 'Athlete Assessments', data: getLocal('athlete_assessments', {}) },
                    { id: 'formations', label: 'Formations', data: getLocal('oc-dashboard-formations', {}) },
                    { id: 'zonePhilosophies', label: 'Zone Philosophies', data: getLocal('oc-dashboard-zone-philosophies', {}) },
                    { id: 'customFocus', label: 'Custom Focus Areas', data: getLocal('oc-dashboard-custom-focus', []) },
                    { id: 'positionNames', label: 'Position Names', data: getLocal('oc-dashboard-position-names', {}) },
                    { id: 'roleTasks', label: 'Role Specific Tasks', data: getLocal('staff_role_tasks', []) },
                    { id: 'wizLib', label: 'Wiz Library', data: getLocal('wiz_ol_library', {}) },
                    {
                        id: 'wbSettings', label: 'Wristband Settings', data: {
                            wb1Opp: localStorage.getItem('hc_wb1_opponent'),
                            wb1Iter: localStorage.getItem('hc_wb1_iteration'),
                            wb2Opp: localStorage.getItem('hc_wb2_opponent'),
                            wb2Iter: localStorage.getItem('hc_wb2_iteration'),
                            sheetUrl: localStorage.getItem('hc_wristband_sheet_url')
                        }
                    }
                ];

                const handleSyncOne = (typeId, data) => {
                    if (!authUser) return alert("You must be logged in to sync.");
                    if (confirm(`Force PUSH '${typeId}' to cloud? This will overwrite cloud data.`)) {
                        syncToFirestore(authUser.uid, typeId, data)
                            .then(res => {
                                if (res.success) alert(`Successfully pushed ${typeId}!`);
                                else alert(`Error syncing ${typeId}: ${res.error}`);
                            });
                    }
                };

                const handlePullOne = (typeId) => {
                    if (!authUser) return alert("You must be logged in to sync.");
                    if (confirm(`Force PULL '${typeId}' from cloud? This will overwrite local data.`)) {
                        // We use loadUserDataFromFirestore but it loads ALL data.
                        // Ideally we want to load just ONE item, but our function is monolithic.
                        // However, loadUserDataFromFirestore is safe to run.
                        // But to be precise, let's just use the doc ref directly here for speed/clarity?
                        // No, let's allow a full refresh or just reuse the logic.
                        // Actually, let's just call loadUserDataFromFirestore and alert the user.
                        // Wait, loadUserDataFromFirestore replaces LOCAL STORAGE. It does NOT update React State immediately unless we reload.
                        // So we must Reload after pulling.

                        loadUserDataFromFirestore(authUser.uid).then(result => {
                            if (result.success) {
                                alert(`Successfully pulled latest data! The page will now reload.`);
                                window.location.reload();
                            } else {
                                alert("Failed to pull data.");
                            }
                        });
                    }
                };

                const handleSyncAll = () => {
                    if (!authUser) return alert("You must be logged in to sync.");
                    if (confirm("WARNING: This will overwrite ALL cloud data with the data from THIS computer. Are you sure?")) {
                        let successCount = 0;
                        let failCount = 0;

                        Promise.all(dataTypes.map(item => {
                            return syncToFirestore(authUser.uid, item.id, item.data)
                                .then(res => res.success ? successCount++ : failCount++);
                        })).then(() => {
                            alert(`Sync Complete!\nSuccess: ${successCount}\nFailed: ${failCount}`);
                        });
                    }
                };

                return (
                    <div className="card" style={{ maxWidth: '800px', margin: '2rem auto' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem', borderBottom: '1px solid var(--border)', paddingBottom: '1rem' }}>
                            <div>
                                <h1>Master Cloud Sync</h1>
                                <p style={{ opacity: 0.7 }}>Push local data to cloud or reset local data from cloud.</p>
                            </div>
                            <div style={{ display: 'flex', gap: '1rem' }}>
                                <button
                                    className="btn btn-danger"
                                    onClick={() => {
                                        if (window.confirm("NUCLEAR OPTION: This will DELETE all data on THIS computer and force a re-download from the Cloud.\n\nKey Safety Rules:\n1. Only do this if the Cloud data is GOOD.\n2. Do not do this if you have unsaved work on this computer.\n\nAre you sure?")) {
                                            localStorage.clear();
                                            window.location.reload();
                                        }
                                    }}
                                    style={{ border: '2px solid #ef4444', backgroundColor: '#7f1d1d' }}
                                >
                                    ⚠️ Hard Reset
                                </button>
                                <button className="btn btn-primary" onClick={handleSyncAll}>
                                    Push ALL to Cloud
                                </button>
                            </div>

                        </div>

                        <div style={{ display: 'grid', gridTemplateColumns: '1fr', gap: '0.5rem' }}>
                            {dataTypes.map((item, idx) => (
                                <div key={item.id} style={{
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center',
                                    padding: '1rem',
                                    background: idx % 2 === 0 ? 'var(--bg-main)' : 'var(--bg-panel)',
                                    borderRadius: '4px',
                                    border: '1px solid var(--border)'
                                }}>
                                    <div>
                                        <div style={{ fontWeight: 'bold' }}>{item.label}</div>
                                        <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)', fontFamily: 'monospace' }}>
                                            {Array.isArray(item.data)
                                                ? `${item.data.length} items`
                                                : item.data && typeof item.data === 'object'
                                                    ? `${Object.keys(item.data).length} keys`
                                                    : 'Data Object'
                                            } • Key: {item.id}
                                        </div>
                                    </div>
                                    <div style={{ display: 'flex', gap: '0.5rem' }}>
                                        <button className="btn btn-sm"
                                            style={{ backgroundColor: '#10b981', color: 'white', border: 'none' }}
                                            onClick={() => handlePullOne(item.id)}>
                                            Pull (Get)
                                        </button>
                                        <button className="btn btn-secondary btn-sm" onClick={() => handleSyncOne(item.id, item.data)}>
                                            Push
                                        </button>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                );
            };

            const GlossaryView = ({ phase = 'OFFENSE' }) => {
                const isOffense = phase === 'OFFENSE';
                const isDefense = phase === 'DEFENSE';
                const isST = phase === 'SPECIAL_TEAMS';

                let currentSyntax, currentTermLibrary;

                if (isDefense) {
                    currentSyntax = defensePlaySyntax;
                    currentTermLibrary = defenseTermLibrary;
                } else if (isST) {
                    currentSyntax = stPlaySyntax;
                    currentTermLibrary = stTermLibrary;
                } else {
                    currentSyntax = playSyntax;
                    currentTermLibrary = termLibrary;
                }

                return (
                    <div className="animate-fade-in" style={{ padding: '2rem', height: '100%', overflowY: 'auto' }}>
                        <div style={{ marginBottom: '2rem', borderBottom: '1px solid var(--border)', paddingBottom: '1rem' }}>
                            <h1 style={{ margin: 0 }}>
                                {isOffense ? 'Offense' : isDefense ? 'Defense' : 'Special Teams'} <span style={{ color: 'var(--accent)' }}>Glossary</span>
                            </h1>
                            <p style={{ marginTop: '0.5rem', opacity: 0.7 }}>
                                Master terminology for {phase === 'SPECIAL_TEAMS' ? 'Special Teams' : phase.toLowerCase()}.
                            </p>
                        </div>

                        {currentSyntax.length === 0 ? (
                            <div className="alert alert-info">
                                <Icon name="Info" size={18} />
                                No play syntax defined yet. Go to <button className="btn-link" onClick={() => setView('setup-' + (isOffense ? 'offense' : isDefense ? 'defense' : 'st'))}>Setup</button> to configure your language.
                            </div>
                        ) : (
                            <div style={{ display: 'masonry', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '2rem' }}>
                                {/* Note: Masonry isn't standard CSS Grid yet (except Firefox), fallback to columns or grid */}
                                <div style={{ columnCount: 3, columnGap: '2rem' }}>
                                    {currentSyntax.map(cat => (
                                        <div key={cat.id} style={{ breakInside: 'avoid', marginBottom: '2rem', background: 'var(--bg-panel)', borderRadius: '12px', padding: '1.5rem', border: '1px solid var(--border)' }}>
                                            <h3 style={{ marginTop: 0, marginBottom: '1rem', color: 'var(--accent)', borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem', fontSize: '1.1rem' }}>
                                                {cat.label}
                                            </h3>
                                            <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.5rem' }}>
                                                {(currentTermLibrary[cat.id] || []).length > 0 ? (
                                                    (currentTermLibrary[cat.id] || []).map(term => (
                                                        <span key={term.id} style={{ background: 'var(--bg-main)', padding: '4px 10px', borderRadius: '4px', fontSize: '0.9rem', border: '1px solid var(--border)' }}>
                                                            {term.label}
                                                        </span>
                                                    ))
                                                ) : (
                                                    <span style={{ fontStyle: 'italic', opacity: 0.5, fontSize: '0.9rem' }}>No terms added.</span>
                                                )}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div >
                        )}
                    </div >
                );
            };

            const ScriptPresetsManager = () => {
                const [editingPreset, setEditingPreset] = useState(null);

                const handleSave = () => {
                    if (!editingPreset.name) return alert('Name is required');
                    setScriptPresets(prev => {
                        const exists = prev.find(p => p.id === editingPreset.id);
                        if (exists) {
                            return prev.map(p => p.id === editingPreset.id ? editingPreset : p);
                        } else {
                            return [...prev, editingPreset];
                        }
                    });
                    setEditingPreset(null);
                };

                const handleDelete = (id) => {
                    if (confirm('Delete this preset?')) {
                        setScriptPresets(prev => prev.filter(p => p.id !== id));
                    }
                };

                const handleItemChange = (idx, field, val) => {
                    const newItems = [...editingPreset.items];
                    newItems[idx] = { ...newItems[idx], [field]: val };
                    setEditingPreset({ ...editingPreset, items: newItems });
                };

                if (editingPreset) {
                    return (
                        <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                            <div style={{ display: 'flex', alignItems: 'center', marginBottom: '1rem', borderBottom: '1px solid var(--border)', paddingBottom: '1rem' }}>
                                <button className="btn-ghost" onClick={() => setEditingPreset(null)} style={{ marginRight: '1rem' }}>
                                    <Icon name="ArrowLeft" size={16} /> Back
                                </button>
                                <h3 style={{ margin: 0 }}>{editingPreset.id ? 'Edit Preset' : 'New Preset'}</h3>
                                <div style={{ flex: 1 }}></div>
                                <button className="btn-primary" onClick={handleSave}>
                                    <Icon name="Save" size={16} /> Save Preset
                                </button>
                            </div>

                            <div style={{ display: 'grid', gridTemplateColumns: 'minmax(200px, 1fr) 2fr', gap: '2rem', flex: 1, minHeight: 0 }}>
                                <div style={{ background: 'var(--bg-panel)', padding: '1.5rem', borderRadius: '8px', border: '1px solid var(--border)', height: 'fit-content' }}>
                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginBottom: '1.5rem' }}>
                                        <div>
                                            <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: 'bold' }}>Segment Type</label>
                                            <select
                                                className="form-input"
                                                value={editingPreset.type || ''}
                                                onChange={e => setEditingPreset({ ...editingPreset, type: e.target.value })}
                                                style={{ width: '100%' }}
                                            >
                                                <option value="">- Generic / None -</option>
                                                {Object.values(practiceSegmentTypes).flat().map(t => <option key={t} value={t}>{t}</option>)}
                                            </select>
                                        </div>
                                        <div>
                                            <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: 'bold' }}>Focus / Situation</label>
                                            <select
                                                className="form-input"
                                                value={editingPreset.focus || ''}
                                                onChange={e => setEditingPreset({ ...editingPreset, focus: e.target.value })}
                                                style={{ width: '100%' }}
                                            >
                                                <option value="">- Any / None -</option>
                                                {practiceFocusItems.map(f => <option key={f} value={f}>{f}</option>)}
                                            </select>
                                        </div>
                                    </div>
                                    <div style={{ marginBottom: '1.5rem' }}>
                                        <label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: 'bold' }}>Preset Name</label>
                                        <input
                                            className="form-input"
                                            value={editingPreset.name}
                                            onChange={e => setEditingPreset({ ...editingPreset, name: e.target.value })}
                                            placeholder="e.g. Take-Off, Red Zone"
                                        />
                                    </div>
                                    <div style={{ marginBottom: '1.5rem' }}>
                                        <label style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', cursor: 'pointer' }}>
                                            <input
                                                type="checkbox"
                                                checked={editingPreset.useYardLine}
                                                onChange={e => setEditingPreset({ ...editingPreset, useYardLine: e.target.checked })}
                                            />
                                            <span style={{ fontWeight: 'bold' }}>Use Yard Line & Dn/Dist</span>
                                        </label>
                                        <p style={{ fontSize: '0.8rem', opacity: 0.7, marginLeft: '1.5rem', marginTop: '0.25rem' }}>
                                            If unchecked, uses "Situation" text field instead.
                                        </p>
                                    </div>
                                </div>

                                <div style={{ display: 'flex', flexDirection: 'column', background: 'var(--bg-panel)', padding: '1.5rem', borderRadius: '8px', border: '1px solid var(--border)' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                        <h4 style={{ margin: 0 }}>Script Sequence</h4>
                                        <button className="btn-secondary btn-sm" onClick={() => setEditingPreset({ ...editingPreset, items: [...editingPreset.items, {}] })}>
                                            <Icon name="Plus" size={14} /> Add Row
                                        </button>
                                    </div>
                                    <div style={{ flex: 1, overflowY: 'auto' }}>
                                        <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                                            <thead>
                                                <tr style={{ borderBottom: '2px solid var(--border)', textAlign: 'left' }}>
                                                    <th style={{ padding: '0.5rem', width: '40px' }}>#</th>
                                                    {editingPreset.useYardLine ? (
                                                        <>
                                                            <th style={{ padding: '0.5rem' }}>Yard Line</th>
                                                            <th style={{ padding: '0.5rem' }}>Hash</th>
                                                            <th style={{ padding: '0.5rem' }}>Dn/Dist</th>
                                                        </>
                                                    ) : (
                                                        <th style={{ padding: '0.5rem' }}>Situation</th>
                                                    )}
                                                    <th style={{ padding: '0.5rem', width: '40px' }}></th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {editingPreset.items.map((item, idx) => (
                                                    <tr key={idx} style={{ borderBottom: '1px solid var(--border)' }}>
                                                        <td style={{ padding: '0.5rem', opacity: 0.5 }}>{idx + 1}</td>
                                                        {editingPreset.useYardLine ? (
                                                            <>
                                                                <td style={{ padding: '0.5rem' }}>
                                                                    <input className="form-input" style={{ padding: '4px 8px' }} value={item.yardLine || ''} onChange={e => handleItemChange(idx, 'yardLine', e.target.value)} placeholder="-30" />
                                                                </td>
                                                                <td style={{ padding: '0.5rem' }}>
                                                                    <select className="form-input" style={{ padding: '4px 8px' }} value={item.hash || ''} onChange={e => handleItemChange(idx, 'hash', e.target.value)}>
                                                                        <option value="">-</option>
                                                                        <option value="L">L</option>
                                                                        <option value="M">M</option>
                                                                        <option value="R">R</option>
                                                                    </select>
                                                                </td>
                                                                <td style={{ padding: '0.5rem' }}>
                                                                    <input className="form-input" style={{ padding: '4px 8px' }} value={item.down || ''} onChange={e => handleItemChange(idx, 'down', e.target.value)} placeholder="1st & 10" />
                                                                </td>
                                                            </>
                                                        ) : (
                                                            <td style={{ padding: '0.5rem' }}>
                                                                <input className="form-input" style={{ padding: '4px 8px', width: '100%' }} value={item.situation || ''} onChange={e => handleItemChange(idx, 'situation', e.target.value)} placeholder="Goal Line..." />
                                                            </td>
                                                        )}
                                                        <td style={{ padding: '0.5rem' }}>
                                                            <button className="btn-icon" style={{ color: 'var(--danger)', opacity: 0.7 }} onClick={() => {
                                                                const newItems = editingPreset.items.filter((_, i) => i !== idx);
                                                                setEditingPreset({ ...editingPreset, items: newItems });
                                                            }}>
                                                                <Icon name="Trash" size={14} />
                                                            </button>
                                                        </td>
                                                    </tr>
                                                ))}
                                                {editingPreset.items.length === 0 && (
                                                    <tr>
                                                        <td colSpan={editingPreset.useYardLine ? 5 : 3} style={{ padding: '2rem', textAlign: 'center', opacity: 0.5 }}>
                                                            No items. Click "Add Row" to start.
                                                        </td>
                                                    </tr>
                                                )}
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            </div>
                        </div >
                    );
                }

                return (
                    <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                        <div style={{ marginBottom: '1.5rem', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <div>
                                <h3 style={{ margin: 0 }}>Script Presets</h3>
                                <p style={{ margin: '0.25rem 0 0 0', opacity: 0.7 }}>Manage standard script templates for different practice periods.</p>
                            </div>
                            <button className="btn-primary" onClick={() => setEditingPreset({ id: Date.now().toString(), name: 'New Preset', type: '', focus: '', useYardLine: true, items: [] })}>
                                <Icon name="Plus" size={16} /> New Preset
                            </button>
                        </div>

                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '1rem', alignContent: 'start' }}>
                            {scriptPresets.map(preset => (
                                <div key={preset.id} className="card" style={{ padding: '1.5rem', display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                                        <h4 style={{ margin: 0, fontSize: '1.1rem' }}>{preset.name}</h4>
                                        <div style={{ display: 'flex', gap: '0.5rem' }}>
                                            <button className="btn-icon" onClick={() => setEditingPreset({ ...preset, items: [...preset.items] })} title="Edit">
                                                <Icon name="Edit" size={16} />
                                            </button>
                                            <button className="btn-icon" style={{ color: 'var(--danger)' }} onClick={() => handleDelete(preset.id)} title="Delete">
                                                <Icon name="Trash" size={16} />
                                            </button>
                                        </div>
                                    </div>
                                    <div style={{ fontSize: '0.9rem', opacity: 0.7 }}>
                                        {preset.items.length} items • {preset.useYardLine ? 'Yard/Hash' : 'Situation'}
                                    </div>
                                    {(preset.type || preset.focus) && (
                                        <div style={{ marginTop: '0.25rem', fontSize: '0.8rem', color: 'var(--accent)', fontWeight: '500' }}>
                                            {preset.type && <span style={{ marginRight: '0.5rem' }}>[{preset.type}]</span>}
                                            {preset.focus && <span>({preset.focus})</span>}
                                        </div>
                                    )}
                                    <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginTop: 'auto' }}>
                                        {preset.items.slice(0, 3).map((item, i) => (
                                            <span key={i} style={{ background: 'var(--bg-main)', padding: '2px 6px', borderRadius: '4px', fontSize: '0.8rem', border: '1px solid var(--border)' }}>
                                                {preset.useYardLine ? (item.yardLine || '-') + (item.hash ? ` ${item.hash}` : '') : (item.situation || 'Item')}
                                            </span>
                                        ))}
                                        {preset.items.length > 3 && (
                                            <span style={{ fontSize: '0.8rem', opacity: 0.5, alignSelf: 'center' }}>+{preset.items.length - 3} more</span>
                                        )}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                );
            };

            const renderSetup = (phase) => {
                const isOffense = phase === 'OFFENSE';
                const isDefense = phase === 'DEFENSE';
                const isST = phase === 'SPECIAL_TEAMS';
                const isPractice = phase === 'PRACTICE';

                let currentSyntax, setSyntax, defaultPositions;

                if (isDefense) {
                    currentSyntax = defensePlaySyntax;
                    setSyntax = setDefensePlaySyntax;
                    defaultPositions = [
                        { key: 'DE', default: 'DE', description: 'Defensive End' },
                        { key: 'DT', default: 'DT', description: 'Defensive Tackle' },
                        { key: 'NT', default: 'NT', description: 'Nose Tackle' },
                        { key: 'LB', default: 'LB', description: 'Linebacker' },
                        { key: 'CB', default: 'CB', description: 'Cornerback' },
                        { key: 'S', default: 'S', description: 'Safety' },
                        { key: 'NB', default: 'NB', description: 'Nickelback' },
                        { key: 'DL', default: 'DL', description: 'Defensive Line' },
                        { key: 'DB', default: 'DB', description: 'Defensive Back' }
                    ];
                } else if (isST) {
                    currentSyntax = stPlaySyntax;
                    setSyntax = setStPlaySyntax;
                    defaultPositions = [
                        { key: 'K', default: 'K', description: 'Kicker' },
                        { key: 'P', default: 'P', description: 'Punter' },
                        { key: 'LS', default: 'LS', description: 'Long Snapper' },
                        { key: 'H', default: 'H', description: 'Holder' },
                        { key: 'KR', default: 'KR', description: 'Kick Returner' },
                        { key: 'PR', default: 'PR', description: 'Punt Returner' },
                        { key: 'G', default: 'G', description: 'Gunner' },
                        { key: 'W', default: 'W', description: 'Wing' },
                        { key: 'PP', default: 'PP', description: 'Personal Protector' },
                        { key: 'L1', default: 'L1', description: 'KO Left 1' },
                        { key: 'R1', default: 'R1', description: 'KO Right 1' }
                    ];
                } else {
                    currentSyntax = playSyntax;
                    setSyntax = setPlaySyntax;
                    defaultPositions = [
                        { key: 'X', default: 'X', description: 'Left WR' },
                        { key: 'Z', default: 'Z', description: 'Right WR' },
                        { key: 'A', default: 'A', description: 'Slot WR' },
                        { key: 'Y', default: 'Y', description: 'Tight End' },
                        { key: 'QB', default: 'QB', description: 'Quarterback' },
                        { key: 'RB', default: 'RB', description: 'Running Back' },
                        { key: 'LT', default: 'LT', description: 'Left Tackle' },
                        { key: 'LG', default: 'LG', description: 'Left Guard' },
                        { key: 'C', default: 'C', description: 'Center' },
                        { key: 'RG', default: 'RG', description: 'Right Guard' },
                        { key: 'RT', default: 'RT', description: 'Right Tackle' },
                    ];
                }

                let currentTermLibrary, setCurrentTermLibrary;
                if (isDefense) {
                    currentTermLibrary = defenseTermLibrary;
                    setCurrentTermLibrary = setDefenseTermLibrary;
                } else if (isST) {
                    currentTermLibrary = stTermLibrary;
                    setCurrentTermLibrary = setStTermLibrary;
                } else {
                    currentTermLibrary = termLibrary;
                    setCurrentTermLibrary = setTermLibrary;
                }

                const getTerms = (catId) => currentTermLibrary[catId] || [];
                const addTerm = (catId) => {
                    const term = prompt("Enter new term:");
                    if (term) {
                        const newTerms = [...getTerms(catId), { id: Date.now().toString(), label: term }];
                        setCurrentTermLibrary({ ...currentTermLibrary, [catId]: newTerms });
                    }
                };
                const deleteTerm = (catId, termId) => {
                    if (confirm("Delete this term?")) {
                        const newTerms = getTerms(catId).filter(t => t.id !== termId);
                        setCurrentTermLibrary({ ...currentTermLibrary, [catId]: newTerms });
                    }
                };

                const phaseTitle = isPractice ? 'Practice' : isDefense ? 'Defense' : isST ? 'Special Teams' : 'Offense';

                return (
                    <div className="card" style={{ maxWidth: '1200px', margin: '2rem auto', padding: '0', minHeight: '600px', display: 'flex', flexDirection: 'column' }}>
                        <div style={{ padding: '1.5rem', borderBottom: '1px solid var(--border)' }}>
                            <h1 style={{ margin: 0 }}>{phaseTitle} Setup</h1>
                            <p style={{ opacity: 0.7, margin: '0.5rem 0 0 0' }}>Configure your {phaseTitle.toLowerCase()} language, positions, and terminology.</p>
                        </div>

                        <div style={{ display: 'flex', borderBottom: '1px solid var(--border)', background: '#1e293b', flexWrap: 'wrap' }}>
                            {isPractice ? (
                                <>
                                    {/* Practice Tab - Practice Lists */}
                                    <button
                                        className={`btn-ghost`}
                                        style={{
                                            borderRadius: 0,
                                            padding: '1rem 1.5rem',
                                            borderBottom: setupTab === 'practice-lists' ? '3px solid var(--accent)' : '3px solid transparent',
                                            fontWeight: setupTab === 'practice-lists' ? 'bold' : 'normal',
                                            color: setupTab === 'practice-lists' ? 'var(--text-primary)' : 'var(--text-secondary)',
                                            background: 'transparent',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '0.5rem'
                                        }}
                                        onClick={() => setSetupTab('practice-lists')}
                                    >
                                        <Icon name="List" size={16} /> Practice Lists
                                    </button>
                                    {/* Practice Tab - Script Presets */}
                                    <button
                                        className={`btn-ghost`}
                                        style={{
                                            borderRadius: 0,
                                            padding: '1rem 1.5rem',
                                            borderBottom: setupTab === 'script-presets' ? '3px solid var(--accent)' : '3px solid transparent',
                                            fontWeight: setupTab === 'script-presets' ? 'bold' : 'normal',
                                            color: setupTab === 'script-presets' ? 'var(--text-primary)' : 'var(--text-secondary)',
                                            background: 'transparent',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '0.5rem'
                                        }}
                                        onClick={() => setSetupTab('script-presets')}
                                    >
                                        <Icon name="FileText" size={16} /> Script Presets
                                    </button>
                                    {/* Practice Tab - Practice Templates */}
                                    <button
                                        className={`btn-ghost`}
                                        style={{
                                            borderRadius: 0,
                                            padding: '1rem 1.5rem',
                                            borderBottom: setupTab === 'practice-templates' ? '3px solid var(--accent)' : '3px solid transparent',
                                            fontWeight: setupTab === 'practice-templates' ? 'bold' : 'normal',
                                            color: setupTab === 'practice-templates' ? 'var(--text-primary)' : 'var(--text-secondary)',
                                            background: 'transparent',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '0.5rem'
                                        }}
                                        onClick={() => setSetupTab('practice-templates')}
                                    >
                                        <Icon name="Calendar" size={16} /> Practice Templates
                                    </button>
                                </>
                            ) : (
                                <>
                                    {/* 1. Positions */}
                                    <button
                                        className={`btn-ghost`}
                                        style={{
                                            borderRadius: 0,
                                            padding: '1rem 1.5rem',
                                            borderBottom: setupTab === 'positions' ? '3px solid var(--accent)' : '3px solid transparent',
                                            fontWeight: setupTab === 'positions' ? 'bold' : 'normal',
                                            color: setupTab === 'positions' ? 'var(--text-primary)' : 'var(--text-secondary)',
                                            background: 'transparent',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '0.5rem'
                                        }}
                                        onClick={() => setSetupTab('positions')}
                                    >
                                        <Icon name="Users" size={16} /> Positions
                                    </button>
                                    {/* 2. Personnel (Offense only) */}
                                    {isOffense && (
                                        <button
                                            className={`btn-ghost`}
                                            style={{
                                                borderRadius: 0,
                                                padding: '1rem 1.5rem',
                                                borderBottom: setupTab === 'personnel' ? '3px solid var(--accent)' : '3px solid transparent',
                                                fontWeight: setupTab === 'personnel' ? 'bold' : 'normal',
                                                color: setupTab === 'personnel' ? 'var(--text-primary)' : 'var(--text-secondary)',
                                                background: 'transparent',
                                                display: 'flex',
                                                alignItems: 'center',
                                                gap: '0.5rem'
                                            }}
                                            onClick={() => setSetupTab('personnel')}
                                        >
                                            <Icon name="UserCheck" size={16} /> Personnel
                                        </button>
                                    )}
                                    {/* 3. Formations */}
                                    <button
                                        className={`btn-ghost`}
                                        style={{
                                            borderRadius: 0,
                                            padding: '1rem 1.5rem',
                                            borderBottom: setupTab === 'formations' ? '3px solid var(--accent)' : '3px solid transparent',
                                            fontWeight: setupTab === 'formations' ? 'bold' : 'normal',
                                            color: setupTab === 'formations' ? 'var(--text-primary)' : 'var(--text-secondary)',
                                            background: 'transparent',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '0.5rem'
                                        }}
                                        onClick={() => setSetupTab('formations')}
                                    >
                                        <Icon name="LayoutGrid" size={16} /> Formations
                                    </button>
                                    {/* 4. Play Buckets */}
                                    <button
                                        className={`btn-ghost`}
                                        style={{
                                            borderRadius: 0,
                                            padding: '1rem 1.5rem',
                                            borderBottom: setupTab === 'categories' ? '3px solid var(--accent)' : '3px solid transparent',
                                            fontWeight: setupTab === 'categories' ? 'bold' : 'normal',
                                            color: setupTab === 'categories' ? 'var(--text-primary)' : 'var(--text-secondary)',
                                            background: 'transparent',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '0.5rem'
                                        }}
                                        onClick={() => setSetupTab('categories')}
                                    >
                                        <Icon name="Tag" size={16} /> Play Buckets
                                    </button>
                                    {/* 5. Concept Families */}
                                    <button
                                        className={`btn-ghost`}
                                        style={{
                                            borderRadius: 0,
                                            padding: '1rem 1.5rem',
                                            borderBottom: setupTab === 'buckets' ? '3px solid var(--accent)' : '3px solid transparent',
                                            fontWeight: setupTab === 'buckets' ? 'bold' : 'normal',
                                            color: setupTab === 'buckets' ? 'var(--text-primary)' : 'var(--text-secondary)',
                                            background: 'transparent',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '0.5rem'
                                        }}
                                        onClick={() => setSetupTab('buckets')}
                                    >
                                        <Icon name="Grid" size={16} /> Concept Families
                                    </button>
                                    {/* 6. Glossary */}
                                    <button
                                        className={`btn-ghost`}
                                        style={{
                                            borderRadius: 0,
                                            padding: '1rem 1.5rem',
                                            borderBottom: setupTab === 'terms' ? '3px solid var(--accent)' : '3px solid transparent',
                                            fontWeight: setupTab === 'terms' ? 'bold' : 'normal',
                                            color: setupTab === 'terms' ? 'var(--text-primary)' : 'var(--text-secondary)',
                                            background: 'transparent',
                                            display: 'flex',
                                            alignItems: 'center',
                                            gap: '0.5rem'
                                        }}
                                        onClick={() => setSetupTab('terms')}
                                    >
                                        <Icon name="BookOpen" size={16} /> Glossary
                                    </button>
                                </>
                            )}
                        </div>

                        <div style={{ padding: '1.5rem', flex: 1 }}>
                            {setupTab === 'categories' && (
                                <div>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                        <h3 style={{ margin: 0 }}>Play Buckets</h3>
                                        <button className="btn btn-primary" onClick={() => {
                                            const label = prompt("New Category Label:");
                                            if (label) {
                                                const id = label.toLowerCase().replace(/[^a-z0-9]/g, '');
                                                if (playCategories.some(c => c.id === id)) {
                                                    alert("Bucket ID already exists.");
                                                    return;
                                                }
                                                setPlayCategories([...playCategories, { id, label, color: 'gray' }]);
                                            }
                                        }}>
                                            <Icon name="Plus" size={16} /> Add Bucket
                                        </button>
                                    </div>
                                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '1rem' }}>
                                        {playCategories.map((cat, idx) => (
                                            <div key={cat.id} className="card" style={{ padding: '1rem' }}>
                                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.75rem' }}>
                                                    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', flex: 1 }}>
                                                        <div style={{ width: 16, height: 16, borderRadius: '50%', background: cat.color === 'gray' ? '#94a3b8' : cat.color, flexShrink: 0 }}></div>
                                                        <input
                                                            type="text"
                                                            value={cat.label}
                                                            onChange={(e) => {
                                                                const newCategories = [...playCategories];
                                                                newCategories[idx] = { ...cat, label: e.target.value };
                                                                setPlayCategories(newCategories);
                                                            }}
                                                            style={{
                                                                fontWeight: 'bold',
                                                                fontSize: '1rem',
                                                                padding: '0.25rem 0.5rem',
                                                                border: '1px solid var(--border)',
                                                                borderRadius: '4px',
                                                                background: 'var(--bg-main)',
                                                                color: 'var(--text-main)',
                                                                flex: 1
                                                            }}
                                                        />
                                                        <span style={{ fontSize: '0.8rem', opacity: 0.5, flexShrink: 0 }}>({cat.id})</span>
                                                    </div>
                                                    <button className="btn-icon" style={{ color: '#ef4444' }} onClick={() => {
                                                        if (confirm(`Delete bucket "${cat.label}"?`)) {
                                                            setPlayCategories(playCategories.filter(c => c.id !== cat.id));
                                                        }
                                                    }}>
                                                        <Icon name="Trash" size={16} />
                                                    </button>
                                                </div>
                                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                    <label style={{ fontSize: '0.85rem', color: 'var(--text-secondary)', minWidth: '40px' }}>Color:</label>
                                                    <input
                                                        type="color"
                                                        value={cat.color === 'gray' ? '#94a3b8' : cat.color}
                                                        onChange={(e) => {
                                                            const newCategories = [...playCategories];
                                                            newCategories[idx] = { ...cat, color: e.target.value };
                                                            setPlayCategories(newCategories);
                                                        }}
                                                        style={{
                                                            width: '50px',
                                                            height: '32px',
                                                            border: '1px solid var(--border)',
                                                            borderRadius: '4px',
                                                            cursor: 'pointer'
                                                        }}
                                                    />
                                                    <span style={{ fontSize: '0.8rem', opacity: 0.6, fontFamily: 'monospace' }}>{cat.color === 'gray' ? '#94a3b8' : cat.color}</span>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                    <div style={{ marginTop: '2rem', padding: '1rem', background: '#f8fafc', borderRadius: '8px', fontSize: '0.9rem', color: '#64748b' }}>
                                        <p style={{ margin: 0 }}><strong>Note:</strong> These buckets define the high-level organization (e.g. Run, Pass, RPO).</p>
                                    </div>
                                </div>
                            )}

                            {setupTab === 'buckets' && (
                                <div style={{ padding: '2rem' }}>
                                    <div style={{ marginBottom: '2rem' }}>
                                        <h3 style={{ margin: 0 }}>Concept Families</h3>
                                        <p style={{ color: 'var(--text-secondary)', marginTop: '0.5rem' }}>
                                            Manage your concept families within each bucket.
                                        </p>
                                    </div>

                                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '1rem' }}>
                                        {playCategories.map(bucket => {
                                            // Derive families from plays in this bucket
                                            // Ensure we match using bucketId OR categoryId, preferring bucketId if it matches the bucket's ID
                                            const bucketPlays = plays.filter(p => p.bucketId === bucket.id);
                                            const derivedFamilies = [...new Set(bucketPlays.map(p => p.conceptFamily).filter(Boolean))];    // Also include any explicitly defined families (if we decide to store them on the bucket object later)
                                            // For now, we'll just use the derived ones + any purely "custom" ones if we added that feature.
                                            // But since we can't persist custom ones without a backend change or state change, we'll stick to derived + "add via dummy" or just "manage derived".
                                            // Wait, user wants to ADD. If I add a family, I can't just leave it floating.
                                            // I'll add a 'families' array to playCategories in state to persist "unused" families.
                                            const explicitFamilies = bucket.families || [];
                                            const allFamilies = [...new Set([...derivedFamilies, ...explicitFamilies])].sort();

                                            return (
                                                <div key={bucket.id} className="card" style={{ padding: '1.5rem', display: 'flex', flexDirection: 'column' }}>
                                                    <div style={{ borderBottom: '1px solid var(--border)', paddingBottom: '0.5rem', marginBottom: '1rem', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                                                        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                            <div style={{ width: 12, height: 12, borderRadius: '50%', background: bucket.color === 'gray' ? '#94a3b8' : bucket.color }}></div>
                                                            <h4 style={{ margin: 0 }}>{bucket.label}</h4>
                                                        </div>
                                                        <button
                                                            className="btn-icon"
                                                            title="Add Family"
                                                            onClick={() => {
                                                                const name = prompt("New Concept Family Name:");
                                                                if (name) {
                                                                    // Add to bucket's explicit families list
                                                                    const newCategories = playCategories.map(c => {
                                                                        if (c.id === bucket.id) {
                                                                            return { ...c, families: [...(c.families || []), name] };
                                                                        }
                                                                        return c;
                                                                    });
                                                                    setPlayCategories(newCategories);
                                                                }
                                                            }}
                                                        >
                                                            <Icon name="Plus" size={16} />
                                                        </button>
                                                    </div>

                                                    {allFamilies.length === 0 ? (
                                                        <div style={{ fontSize: '0.875rem', color: 'var(--text-secondary)', fontStyle: 'italic', padding: '1rem', textAlign: 'center', border: '1px dashed var(--border)', borderRadius: '4px' }}>
                                                            No families defined.
                                                        </div>
                                                    ) : (
                                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                                            {allFamilies.map(family => (
                                                                <div key={family} style={{
                                                                    display: 'flex',
                                                                    justifyContent: 'space-between',
                                                                    alignItems: 'center',
                                                                    padding: '0.5rem 0.75rem',
                                                                    background: 'var(--bg-main)',
                                                                    borderRadius: '4px',
                                                                    border: '1px solid var(--border)'
                                                                }}>
                                                                    <span style={{ fontSize: '0.9rem', fontWeight: '500' }}>{family}</span>
                                                                    <div style={{ display: 'flex', gap: '0.25rem' }}>
                                                                        <button
                                                                            className="btn-icon" title="Rename Family" onClick={() => {
                                                                                const newName = prompt("Rename Concept Family:", family);
                                                                                if (newName && newName !== family) {
                                                                                    // 1. Update plays
                                                                                    const playsToUpdate = bucketPlays.filter(p => p.conceptFamily === family);
                                                                                    if (playsToUpdate.length > 0) {
                                                                                        const updates = playsToUpdate.map(p => ({ id: p.id, conceptFamily: newName }));
                                                                                        handlePatchPlay(updates);
                                                                                    }

                                                                                    // 2. Update explicit families
                                                                                    if ((bucket.families || []).includes(family)) {
                                                                                        const newCategories = playCategories.map(c => {
                                                                                            if (c.id === bucket.id) {
                                                                                                const newFamilies = c.families.map(f => f === family ? newName : f);
                                                                                                return { ...c, families: newFamilies };
                                                                                            }
                                                                                            return c;
                                                                                        });
                                                                                        setPlayCategories(newCategories);
                                                                                    }
                                                                                }
                                                                            }}
                                                                        >
                                                                            <Icon name="Edit" size={14} />
                                                                        </button>
                                                                        <button
                                                                            className="btn-icon"
                                                                            style={{ color: '#ef4444' }}
                                                                            title="Delete Family"
                                                                            onClick={() => {
                                                                                if (confirm(`Delete family "${family}"? This will remove it from all plays in this bucket.`)) {
                                                                                    // 1. Unassign from plays
                                                                                    const playsToUpdate = bucketPlays.filter(p => p.conceptFamily === family);
                                                                                    if (playsToUpdate.length > 0) {
                                                                                        const updates = playsToUpdate.map(p => ({ id: p.id, conceptFamily: null }));
                                                                                        handlePatchPlay(updates);
                                                                                    }

                                                                                    // 2. Remove from explicit list
                                                                                    if ((bucket.families || []).includes(family)) {
                                                                                        const newCategories = playCategories.map(c => {
                                                                                            if (c.id === bucket.id) {
                                                                                                return { ...c, families: c.families.filter(f => f !== family) };
                                                                                            }
                                                                                            return c;
                                                                                        });
                                                                                        setPlayCategories(newCategories);
                                                                                    }
                                                                                }
                                                                            }}
                                                                        >
                                                                            <Icon name="Trash" size={14} />
                                                                        </button>
                                                                    </div>
                                                                </div>
                                                            ))}
                                                        </div>
                                                    )}
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            )}

                            {setupTab === 'positions' && (
                                <div>
                                    <h3 style={{ marginBottom: '1rem' }}>Position Names</h3>

                                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(180px, 1fr))', gap: '1rem' }}>
                                        {[...defaultPositions.filter(p => !(hiddenPositions[phase] || []).includes(p.key)), ...(customPositions[phase] || [])].map(pos => (
                                            <div key={pos.key} style={{ background: 'var(--bg-main)', padding: '1rem', borderRadius: '8px', border: '1px solid var(--border)', position: 'relative' }}>
                                                {pos.isCustom && (
                                                    <button
                                                        onClick={() => {
                                                            if (confirm(`Permanently delete custom position ${pos.default}?`)) {
                                                                const newCustom = (customPositions[phase] || []).filter(p => p.key !== pos.key);
                                                                setCustomPositions({ ...customPositions, [phase]: newCustom });
                                                            }
                                                        }}
                                                        style={{
                                                            position: 'absolute',
                                                            top: '4px',
                                                            right: '4px',
                                                            background: 'none',
                                                            border: 'none',
                                                            color: '#ef4444',
                                                            cursor: 'pointer',
                                                            opacity: 0.6,
                                                            padding: '4px'
                                                        }}
                                                        onMouseOver={e => e.currentTarget.style.opacity = '1'}
                                                        onMouseOut={e => e.currentTarget.style.opacity = '0.6'}
                                                        title="Delete Position"
                                                    >
                                                        <Icon name="X" size={14} />
                                                    </button>
                                                )}
                                                <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem', paddingRight: pos.isCustom ? '1rem' : '0', alignItems: 'center' }}>
                                                    <label className="form-label" style={{ fontSize: '0.75rem', fontWeight: 'bold' }}>{positionNames[pos.key] || pos.default}</label>
                                                    <input
                                                        type="text"
                                                        value={positionDescriptions[pos.key] !== undefined ? positionDescriptions[pos.key] : pos.description}
                                                        onChange={(e) => setPositionDescriptions({ ...positionDescriptions, [pos.key]: e.target.value })}
                                                        placeholder={pos.description}
                                                        style={{
                                                            fontSize: '0.8rem',
                                                            color: 'var(--text-primary)',
                                                            borderBottom: '1px dashed var(--accent)',
                                                            background: 'transparent',
                                                            textAlign: 'right',
                                                            width: '140px',
                                                            outline: 'none',
                                                            cursor: 'text',
                                                            paddingRight: '2px',
                                                            fontWeight: '500'
                                                        }}
                                                        onFocus={(e) => {
                                                            e.target.style.background = 'var(--bg-panel)';
                                                            e.target.style.borderBottom = '1px solid var(--accent)';
                                                        }}
                                                        onBlur={(e) => {
                                                            e.target.style.background = 'transparent';
                                                            e.target.style.borderBottom = '1px dashed var(--accent)';
                                                        }}
                                                    />
                                                </div>
                                                {/* Position Label Input with Color Picker */}
                                                <div style={{ display: 'flex', gap: '8px', alignItems: 'stretch', marginTop: '0.5rem' }}>
                                                    <div style={{ position: 'relative' }}>
                                                        <input
                                                            type="color"
                                                            value={positionColors[pos.key] || DEFAULT_POSITION_COLORS[pos.key] || '#64748b'}
                                                            onChange={(e) => setPositionColors({ ...positionColors, [pos.key]: e.target.value })}
                                                            style={{
                                                                position: 'absolute',
                                                                width: '100%',
                                                                height: '100%',
                                                                opacity: 0,
                                                                cursor: 'pointer'
                                                            }}
                                                            title="Choose position color"
                                                        />
                                                        <div style={{
                                                            width: '44px',
                                                            height: '100%',
                                                            minHeight: '44px',
                                                            background: positionColors[pos.key] || DEFAULT_POSITION_COLORS[pos.key] || '#64748b',
                                                            borderRadius: '6px',
                                                            border: '2px solid rgba(255,255,255,0.2)',
                                                            display: 'flex',
                                                            alignItems: 'center',
                                                            justifyContent: 'center',
                                                            boxShadow: 'inset 0 2px 4px rgba(0,0,0,0.2)'
                                                        }}>
                                                            <Icon name="Palette" size={16} style={{ color: 'rgba(255,255,255,0.7)' }} />
                                                        </div>
                                                    </div>
                                                    <input
                                                        type="text"
                                                        className="form-input"
                                                        value={positionNames[pos.key] || pos.default}
                                                        onChange={(e) => setPositionNames({ ...positionNames, [pos.key]: e.target.value.toUpperCase().slice(0, 3) })}
                                                        placeholder={pos.default}
                                                        maxLength="3"
                                                        style={{
                                                            padding: '0.5rem',
                                                            fontSize: '1rem',
                                                            fontWeight: 'bold',
                                                            textAlign: 'center',
                                                            border: '1px solid var(--border)',
                                                            borderRadius: '4px',
                                                            flex: 1,
                                                            background: positionColors[pos.key] || DEFAULT_POSITION_COLORS[pos.key] || '#64748b',
                                                            color: '#fff',
                                                            textShadow: '0 1px 2px rgba(0,0,0,0.3)'
                                                        }}
                                                        title={`Customize ${pos.description} label`}
                                                    />
                                                </div>
                                            </div>
                                        ))}

                                        {/* Add Position Button */}
                                        <button
                                            onClick={() => {
                                                const key = prompt("Enter Position Key (1-3 letters, e.g., 'F' or 'S2'):");
                                                if (!key) return;

                                                const cleanKey = key.toUpperCase().trim().slice(0, 3);
                                                if (!cleanKey) return;

                                                // Check for duplicates
                                                const allKeys = [...defaultPositions, ...(customPositions[phase] || [])].map(p => p.key);
                                                if (allKeys.includes(cleanKey)) {
                                                    alert("That position key already exists!");
                                                    return;
                                                }

                                                const desc = prompt("Enter Description (e.g., 'Flex Tight End'):") || cleanKey;

                                                const newPos = {
                                                    key: cleanKey,
                                                    default: cleanKey,
                                                    description: desc,
                                                    isCustom: true
                                                };

                                                setCustomPositions({
                                                    ...customPositions,
                                                    [phase]: [...(customPositions[phase] || []), newPos]
                                                });
                                            }}
                                            style={{
                                                background: 'var(--surface)',
                                                border: '2px dashed var(--border)',
                                                borderRadius: '8px',
                                                display: 'flex',
                                                flexDirection: 'column',
                                                alignItems: 'center',
                                                justifyContent: 'center',
                                                cursor: 'pointer',
                                                padding: '1rem',
                                                minHeight: '100px',
                                                color: 'var(--text-secondary)',
                                                transition: 'all 0.2s'
                                            }}
                                            onMouseOver={e => { e.currentTarget.style.borderColor = 'var(--accent)'; e.currentTarget.style.color = 'var(--accent)'; }}
                                            onMouseOut={e => { e.currentTarget.style.borderColor = 'var(--border)'; e.currentTarget.style.color = 'var(--text-secondary)'; }}
                                        >
                                            <Icon name="Plus" size={24} style={{ marginBottom: '0.5rem' }} />
                                            <span style={{ fontWeight: '600' }}>Add Position</span>
                                        </button>
                                    </div>

                                    {(hiddenPositions[phase] || []).length > 0 && (
                                        <div style={{ marginTop: '2rem', padding: '1rem', border: '1px dashed var(--border)', borderRadius: '8px', opacity: 0.8 }}>
                                            <h4 style={{ margin: '0 0 1rem 0', fontSize: '0.9rem', color: 'var(--text-secondary)' }}>Hidden Default Positions</h4>
                                            <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                                                {(hiddenPositions[phase] || []).map(hiddenKey => {
                                                    const original = defaultPositions.find(p => p.key === hiddenKey);
                                                    if (!original) return null;
                                                    return (
                                                        <div key={hiddenKey} style={{
                                                            display: 'flex',
                                                            alignItems: 'center',
                                                            gap: '0.5rem',
                                                            padding: '0.5rem 1rem',
                                                            background: 'var(--bg-panel)',
                                                            borderRadius: '4px',
                                                            border: '1px solid var(--border)',
                                                            fontSize: '0.85rem'
                                                        }}>
                                                            <span>{original.default} <span style={{ opacity: 0.5 }}>({original.description})</span></span>
                                                            <button
                                                                onClick={() => {
                                                                    const newHidden = (hiddenPositions[phase] || []).filter(h => h !== hiddenKey);
                                                                    setHiddenPositions({ ...hiddenPositions, [phase]: newHidden });
                                                                }}
                                                                className="btn-sm"
                                                                style={{ color: 'var(--accent)', border: 'none', background: 'none', padding: '0', marginLeft: '4px', fontWeight: 'bold', cursor: 'pointer' }}
                                                            >
                                                                Restore
                                                            </button>
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            )}

                            {setupTab === 'syntax' && (
                                <div style={{ maxWidth: '800px' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '1.5rem', alignItems: 'center' }}>
                                        <div>
                                            <h3 style={{ margin: 0 }}>Play Call Structure</h3>
                                            <p style={{ margin: '0.25rem 0 0 0', opacity: 0.7 }}>Define the order and components of a play call.</p>
                                        </div>
                                        <button className="btn btn-primary" onClick={() => {
                                            const newId = Date.now().toString();
                                            setSyntax([...currentSyntax, { id: newId, label: 'New Component', type: 'text' }]);
                                        }}>
                                            <Icon name="Plus" size={16} style={{ marginRight: '6px' }} /> Add Component
                                        </button>
                                    </div>

                                    <div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem' }}>
                                        {currentSyntax.map((item, idx) => (
                                            <div key={item.id} style={{ display: 'flex', gap: '1rem', alignItems: 'center', padding: '1rem', border: '1px solid var(--border)', borderRadius: '8px', background: 'var(--bg-main)' }}>
                                                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', width: '32px', height: '32px', background: 'var(--bg-panel)', borderRadius: '50%', fontWeight: 'bold', color: 'var(--text-secondary)' }}>
                                                    {idx + 1}
                                                </div>
                                                <div style={{ flex: 1, display: 'grid', gridTemplateColumns: '1fr 80px 80px', gap: '1rem' }}>
                                                    <div>
                                                        <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', display: 'block', marginBottom: '0.25rem' }}>Component Name</label>
                                                        <input
                                                            type="text"
                                                            className="form-input"
                                                            value={item.label}
                                                            onChange={(e) => {
                                                                const newSyntax = [...currentSyntax];
                                                                newSyntax[idx].label = e.target.value;
                                                                setSyntax(newSyntax);
                                                            }}
                                                            placeholder="e.g. Formation"
                                                        />
                                                    </div>
                                                    <div>
                                                        <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', display: 'block', marginBottom: '0.25rem' }}>Prefix</label>
                                                        <input
                                                            type="text"
                                                            className="form-input"
                                                            value={item.prefix || ''}
                                                            onChange={(e) => {
                                                                const newSyntax = [...currentSyntax];
                                                                newSyntax[idx].prefix = e.target.value;
                                                                setSyntax(newSyntax);
                                                            }}
                                                            placeholder='"'
                                                            style={{ textAlign: 'center' }}
                                                        />
                                                    </div>
                                                    <div>
                                                        <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', display: 'block', marginBottom: '0.25rem' }}>Suffix</label>
                                                        <input
                                                            type="text"
                                                            className="form-input"
                                                            value={item.suffix || ''}
                                                            onChange={(e) => {
                                                                const newSyntax = [...currentSyntax];
                                                                newSyntax[idx].suffix = e.target.value;
                                                                setSyntax(newSyntax);
                                                            }}
                                                            placeholder='"'
                                                            style={{ textAlign: 'center' }}
                                                        />
                                                    </div>
                                                </div>
                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '2px' }}>
                                                    <button className="btn btn-ghost btn-sm" onClick={() => {
                                                        if (idx === 0) return;
                                                        const newSyntax = [...currentSyntax];
                                                        [newSyntax[idx - 1], newSyntax[idx]] = [newSyntax[idx], newSyntax[idx - 1]];
                                                        setSyntax(newSyntax);
                                                    }} disabled={idx === 0} style={{ padding: '2px' }}><Icon name="ChevronUp" size={16} /></button>
                                                    <button className="btn btn-ghost btn-sm" onClick={() => {
                                                        if (idx === currentSyntax.length - 1) return;
                                                        const newSyntax = [...currentSyntax];
                                                        [newSyntax[idx + 1], newSyntax[idx]] = [newSyntax[idx], newSyntax[idx + 1]];
                                                        setSyntax(newSyntax);
                                                    }} disabled={idx === currentSyntax.length - 1} style={{ padding: '2px' }}><Icon name="ChevronDown" size={16} /></button>
                                                </div>
                                                <button className="btn btn-ghost" style={{ color: 'var(--danger)' }} onClick={() => {
                                                    if (confirm('Delete this syntax component? All associated terms will be hidden.')) {
                                                        const newSyntax = currentSyntax.filter((_, i) => i !== idx);
                                                        setSyntax(newSyntax);
                                                    }
                                                }}>
                                                    <Icon name="Trash" size={18} />
                                                </button>
                                            </div>
                                        ))}
                                        {currentSyntax.length === 0 && (
                                            <div style={{ textAlign: 'center', padding: '3rem', border: '2px dashed var(--border)', borderRadius: '8px', opacity: 0.6 }}>
                                                <Icon name="Code" size={48} style={{ marginBottom: '1rem' }} />
                                                <p>No play components defined.</p>
                                                <p>Click "Add Component" to start building your play call structure.</p>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            )}

                            {setupTab === 'terms' && (
                                <div style={{ height: '100%', display: 'flex', flexDirection: 'column', overflowY: 'auto' }}>
                                    <div style={{ marginBottom: '1.5rem' }}>
                                        <h3 style={{ margin: 0 }}>Glossary</h3>
                                        <p style={{ margin: '0.25rem 0 0 0', opacity: 0.7 }}>Manage vocabulary for your play components.</p>
                                    </div>

                                    {currentSyntax.length === 0 ? (
                                        <div className="alert alert-warning">
                                            <Icon name="AlertTriangle" size={18} />
                                            Please define your Play Call Structure in the Syntax tab first.
                                        </div>
                                    ) : (
                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '1.25rem', paddingBottom: '2rem' }}>
                                            {/* Term Categories as Cards */}
                                            {currentSyntax.map(cat => {
                                                const terms = getTerms(cat.id);
                                                return (
                                                    <div key={cat.id} style={{
                                                        background: 'var(--bg-card)',
                                                        border: '1px solid var(--border)',
                                                        borderRadius: '8px',
                                                        overflow: 'hidden'
                                                    }}>
                                                        {/* Section Header */}
                                                        <div style={{
                                                            padding: '12px 16px',
                                                            borderBottom: '1px solid var(--border)',
                                                            display: 'flex',
                                                            justifyContent: 'space-between',
                                                            alignItems: 'center',
                                                            background: 'var(--bg-main)'
                                                        }}>
                                                            <div style={{
                                                                fontSize: '0.7rem',
                                                                fontWeight: '700',
                                                                color: 'var(--text-secondary)',
                                                                textTransform: 'uppercase',
                                                                letterSpacing: '0.05em'
                                                            }}>
                                                                {cat.label}
                                                            </div>
                                                            <button
                                                                onClick={() => addTerm(cat.id)}
                                                                style={{
                                                                    padding: '4px 10px',
                                                                    borderRadius: '4px',
                                                                    fontSize: '0.75rem',
                                                                    fontWeight: 600,
                                                                    cursor: 'pointer',
                                                                    border: '1px solid var(--border)',
                                                                    background: 'white',
                                                                    color: 'var(--text-secondary)',
                                                                    display: 'flex',
                                                                    alignItems: 'center',
                                                                    gap: '4px'
                                                                }}
                                                            >
                                                                <Icon name="Plus" size={12} /> Add
                                                            </button>
                                                        </div>
                                                        {/* Terms as Pills */}
                                                        <div style={{ padding: '12px 16px' }}>
                                                            {terms.length === 0 ? (
                                                                <div style={{
                                                                    padding: '1rem',
                                                                    textAlign: 'center',
                                                                    opacity: 0.5,
                                                                    fontSize: '0.85rem',
                                                                    border: '1px dashed var(--border)',
                                                                    borderRadius: '6px'
                                                                }}>
                                                                    No terms added yet
                                                                </div>
                                                            ) : (
                                                                <div style={{ display: 'flex', flexWrap: 'wrap', gap: '8px' }}>
                                                                    {terms.map(term => (
                                                                        <div
                                                                            key={term.id}
                                                                            style={{
                                                                                padding: '6px 10px',
                                                                                borderRadius: '6px',
                                                                                fontSize: '0.8rem',
                                                                                fontWeight: 500,
                                                                                border: '1px solid var(--border)',
                                                                                background: 'white',
                                                                                color: 'var(--text-primary)',
                                                                                display: 'flex',
                                                                                alignItems: 'center',
                                                                                gap: '6px'
                                                                            }}
                                                                        >
                                                                            {term.label}
                                                                            <button
                                                                                onClick={() => deleteTerm(cat.id, term.id)}
                                                                                style={{
                                                                                    background: 'none',
                                                                                    border: 'none',
                                                                                    padding: '2px',
                                                                                    cursor: 'pointer',
                                                                                    color: 'var(--text-secondary)',
                                                                                    display: 'flex',
                                                                                    alignItems: 'center',
                                                                                    opacity: 0.6
                                                                                }}
                                                                            >
                                                                                <Icon name="X" size={12} />
                                                                            </button>
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            )}
                                                        </div>
                                                    </div>
                                                );
                                            })}

                                            {/* Additional Built-in Categories */}
                                            {/* Formations Section */}
                                            <div style={{
                                                background: 'var(--bg-card)',
                                                border: '1px solid var(--border)',
                                                borderRadius: '8px',
                                                overflow: 'hidden'
                                            }}>
                                                <div style={{
                                                    padding: '12px 16px',
                                                    borderBottom: '1px solid var(--border)',
                                                    display: 'flex',
                                                    justifyContent: 'space-between',
                                                    alignItems: 'center',
                                                    background: 'var(--bg-main)'
                                                }}>
                                                    <div style={{
                                                        fontSize: '0.7rem',
                                                        fontWeight: '700',
                                                        color: 'var(--text-secondary)',
                                                        textTransform: 'uppercase',
                                                        letterSpacing: '0.05em'
                                                    }}>
                                                        Formations
                                                    </div>
                                                    <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)' }}>
                                                        {formations.length} defined
                                                    </span>
                                                </div>
                                                <div style={{ padding: '12px 16px' }}>
                                                    {formations.length === 0 ? (
                                                        <div style={{
                                                            padding: '1rem',
                                                            textAlign: 'center',
                                                            opacity: 0.5,
                                                            fontSize: '0.85rem',
                                                            border: '1px dashed var(--border)',
                                                            borderRadius: '6px'
                                                        }}>
                                                            No formations defined. Add them in the Formations tab.
                                                        </div>
                                                    ) : (
                                                        <div style={{ display: 'flex', flexWrap: 'wrap', gap: '8px' }}>
                                                            {formations.slice(0, 20).map(f => {
                                                                const personnel = personnelGroupings.find(p => p.code === f.personnel);
                                                                return (
                                                                    <div
                                                                        key={f.id}
                                                                        style={{
                                                                            padding: '6px 10px',
                                                                            borderRadius: '6px',
                                                                            fontSize: '0.8rem',
                                                                            fontWeight: 500,
                                                                            border: '1px solid var(--border)',
                                                                            background: 'white',
                                                                            color: 'var(--text-primary)',
                                                                            display: 'flex',
                                                                            alignItems: 'center',
                                                                            gap: '6px'
                                                                        }}
                                                                    >
                                                                        {f.name}
                                                                        {personnel && (
                                                                            <span style={{
                                                                                fontSize: '0.65rem',
                                                                                padding: '2px 4px',
                                                                                borderRadius: '3px',
                                                                                background: '#e0f2fe',
                                                                                color: '#0369a1',
                                                                                fontWeight: 600
                                                                            }}>
                                                                                {personnel.code}P
                                                                            </span>
                                                                        )}
                                                                    </div>
                                                                );
                                                            })}
                                                            {formations.length > 20 && (
                                                                <div style={{
                                                                    padding: '6px 10px',
                                                                    borderRadius: '6px',
                                                                    fontSize: '0.8rem',
                                                                    fontWeight: 500,
                                                                    background: 'var(--bg-main)',
                                                                    color: 'var(--text-secondary)'
                                                                }}>
                                                                    +{formations.length - 20} more
                                                                </div>
                                                            )}
                                                        </div>
                                                    )}
                                                </div>
                                            </div>

                                            {/* Personnel Groupings Section */}
                                            <div style={{
                                                background: 'var(--bg-card)',
                                                border: '1px solid var(--border)',
                                                borderRadius: '8px',
                                                overflow: 'hidden'
                                            }}>
                                                <div style={{
                                                    padding: '12px 16px',
                                                    borderBottom: '1px solid var(--border)',
                                                    display: 'flex',
                                                    justifyContent: 'space-between',
                                                    alignItems: 'center',
                                                    background: 'var(--bg-main)'
                                                }}>
                                                    <div style={{
                                                        fontSize: '0.7rem',
                                                        fontWeight: '700',
                                                        color: 'var(--text-secondary)',
                                                        textTransform: 'uppercase',
                                                        letterSpacing: '0.05em'
                                                    }}>
                                                        Personnel Groupings
                                                    </div>
                                                    <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)' }}>
                                                        {personnelGroupings.length} packages
                                                    </span>
                                                </div>
                                                <div style={{ padding: '12px 16px' }}>
                                                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: '8px' }}>
                                                        {personnelGroupings.map(pkg => (
                                                            <div
                                                                key={pkg.id}
                                                                style={{
                                                                    padding: '6px 10px',
                                                                    borderRadius: '6px',
                                                                    fontSize: '0.8rem',
                                                                    fontWeight: 500,
                                                                    border: '1px solid var(--border)',
                                                                    background: 'white',
                                                                    color: 'var(--text-primary)'
                                                                }}
                                                            >
                                                                <span style={{ fontWeight: 600 }}>{pkg.code}P</span>
                                                                <span style={{ color: 'var(--text-secondary)', marginLeft: '6px' }}>
                                                                    {pkg.description}
                                                                </span>
                                                            </div>
                                                        ))}
                                                    </div>
                                                </div>
                                            </div>

                                            {/* Play Buckets Section */}
                                            {playCategories.length > 0 && (
                                                <div style={{
                                                    background: 'var(--bg-card)',
                                                    border: '1px solid var(--border)',
                                                    borderRadius: '8px',
                                                    overflow: 'hidden'
                                                }}>
                                                    <div style={{
                                                        padding: '12px 16px',
                                                        borderBottom: '1px solid var(--border)',
                                                        display: 'flex',
                                                        justifyContent: 'space-between',
                                                        alignItems: 'center',
                                                        background: 'var(--bg-main)'
                                                    }}>
                                                        <div style={{
                                                            fontSize: '0.7rem',
                                                            fontWeight: '700',
                                                            color: 'var(--text-secondary)',
                                                            textTransform: 'uppercase',
                                                            letterSpacing: '0.05em'
                                                        }}>
                                                            Play Buckets
                                                        </div>
                                                    </div>
                                                    <div style={{ padding: '12px 16px' }}>
                                                        <div style={{ display: 'flex', flexWrap: 'wrap', gap: '8px' }}>
                                                            {playCategories.map(cat => (
                                                                <div
                                                                    key={cat.id}
                                                                    style={{
                                                                        padding: '5px 10px',
                                                                        borderRadius: '6px',
                                                                        fontSize: '0.8rem',
                                                                        fontWeight: 600,
                                                                        background: cat.color || '#64748b',
                                                                        color: cat.textColor || '#fff'
                                                                    }}
                                                                >
                                                                    {cat.label}
                                                                </div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                </div>
                                            )}

                                            {/* Concept Families Section */}
                                            {playBuckets.length > 0 && (
                                                <div style={{
                                                    background: 'var(--bg-card)',
                                                    border: '1px solid var(--border)',
                                                    borderRadius: '8px',
                                                    overflow: 'hidden'
                                                }}>
                                                    <div style={{
                                                        padding: '12px 16px',
                                                        borderBottom: '1px solid var(--border)',
                                                        display: 'flex',
                                                        justifyContent: 'space-between',
                                                        alignItems: 'center',
                                                        background: 'var(--bg-main)'
                                                    }}>
                                                        <div style={{
                                                            fontSize: '0.7rem',
                                                            fontWeight: '700',
                                                            color: 'var(--text-secondary)',
                                                            textTransform: 'uppercase',
                                                            letterSpacing: '0.05em'
                                                        }}>
                                                            Concept Families
                                                        </div>
                                                    </div>
                                                    <div style={{ padding: '12px 16px' }}>
                                                        <div style={{ display: 'flex', flexWrap: 'wrap', gap: '8px' }}>
                                                            {playBuckets.map(family => (
                                                                <div
                                                                    key={family.id}
                                                                    style={{
                                                                        padding: '5px 10px',
                                                                        borderRadius: '6px',
                                                                        fontSize: '0.8rem',
                                                                        fontWeight: 600,
                                                                        background: family.color || '#94a3b8',
                                                                        color: family.textColor || '#fff'
                                                                    }}
                                                                >
                                                                    {family.label}
                                                                </div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                </div>
                                            )}

                                            {/* Play History Section */}
                                            <div style={{
                                                background: 'var(--bg-card)',
                                                border: '1px solid var(--border)',
                                                borderRadius: '8px',
                                                overflow: 'hidden'
                                            }}>
                                                <div style={{
                                                    padding: '12px 16px',
                                                    borderBottom: '1px solid var(--border)',
                                                    background: 'var(--bg-main)'
                                                }}>
                                                    <div style={{
                                                        fontSize: '0.7rem',
                                                        fontWeight: '700',
                                                        color: 'var(--text-secondary)',
                                                        textTransform: 'uppercase',
                                                        letterSpacing: '0.05em'
                                                    }}>
                                                        Play History
                                                    </div>
                                                    <p style={{ margin: '4px 0 0 0', fontSize: '0.8rem', color: 'var(--text-secondary)' }}>
                                                        Track when plays are scripted in practice plans
                                                    </p>
                                                </div>
                                                <div style={{ padding: '16px' }}>
                                                    {(() => {
                                                        // Build play history from practice plans
                                                        const playHistory = {};
                                                        weeks.forEach(week => {
                                                            if (!week.practicePlans) return;
                                                            Object.entries(week.practicePlans).forEach(([day, plan]) => {
                                                                if (!plan || !plan.segments) return;
                                                                const planDate = plan.date || `${week.weekLabel} - ${day}`;
                                                                plan.segments.forEach(seg => {
                                                                    if (!seg.script) return;
                                                                    seg.script.forEach(row => {
                                                                        const playId = row.playId;
                                                                        if (!playId) return;
                                                                        if (!playHistory[playId]) {
                                                                            playHistory[playId] = [];
                                                                        }
                                                                        const existingDate = playHistory[playId].find(h => h.date === planDate);
                                                                        if (existingDate) {
                                                                            existingDate.count++;
                                                                        } else {
                                                                            playHistory[playId].push({ date: planDate, count: 1, weekId: week.id });
                                                                        }
                                                                    });
                                                                });
                                                            });
                                                        });

                                                        const playsWithHistory = plays.filter(p => playHistory[p.id] && playHistory[p.id].length > 0);

                                                        if (playsWithHistory.length === 0) {
                                                            return (
                                                                <div style={{
                                                                    padding: '2rem',
                                                                    textAlign: 'center',
                                                                    opacity: 0.5,
                                                                    border: '1px dashed var(--border)',
                                                                    borderRadius: '6px'
                                                                }}>
                                                                    <Icon name="Clock" size={24} style={{ marginBottom: '0.5rem', opacity: 0.5 }} />
                                                                    <p style={{ margin: 0, fontSize: '0.85rem' }}>No play history yet.</p>
                                                                    <p style={{ margin: '0.25rem 0 0 0', fontSize: '0.8rem' }}>
                                                                        Add plays to practice scripts to see their history here.
                                                                    </p>
                                                                </div>
                                                            );
                                                        }

                                                        // Sort by most recently used / most scripted
                                                        const sortedPlays = playsWithHistory.sort((a, b) => {
                                                            const aTotal = playHistory[a.id].reduce((sum, h) => sum + h.count, 0);
                                                            const bTotal = playHistory[b.id].reduce((sum, h) => sum + h.count, 0);
                                                            return bTotal - aTotal;
                                                        }).slice(0, 10);

                                                        return (
                                                            <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                                                                {sortedPlays.map(play => {
                                                                    const history = playHistory[play.id];
                                                                    const totalReps = history.reduce((sum, h) => sum + h.count, 0);
                                                                    return (
                                                                        <div key={play.id} style={{
                                                                            padding: '12px',
                                                                            background: 'var(--bg-main)',
                                                                            borderRadius: '6px',
                                                                            border: '1px solid var(--border)'
                                                                        }}>
                                                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '8px' }}>
                                                                                <div>
                                                                                    <span style={{ fontWeight: 600, fontSize: '0.9rem' }}>{play.name}</span>
                                                                                    {play.formation && (
                                                                                        <span style={{ marginLeft: '8px', fontSize: '0.8rem', color: 'var(--text-secondary)' }}>
                                                                                            {play.formation}
                                                                                        </span>
                                                                                    )}
                                                                                </div>
                                                                                <span style={{
                                                                                    padding: '2px 8px',
                                                                                    borderRadius: '10px',
                                                                                    fontSize: '0.75rem',
                                                                                    fontWeight: 600,
                                                                                    background: '#dbeafe',
                                                                                    color: '#1d4ed8'
                                                                                }}>
                                                                                    {totalReps} rep{totalReps !== 1 ? 's' : ''}
                                                                                </span>
                                                                            </div>
                                                                            <div style={{ display: 'flex', flexWrap: 'wrap', gap: '6px' }}>
                                                                                {history.map((h, idx) => (
                                                                                    <span key={idx} style={{
                                                                                        fontSize: '0.7rem',
                                                                                        padding: '3px 6px',
                                                                                        borderRadius: '4px',
                                                                                        background: '#f1f5f9',
                                                                                        color: '#475569'
                                                                                    }}>
                                                                                        {h.date} ({h.count}x)
                                                                                    </span>
                                                                                ))}
                                                                            </div>
                                                                        </div>
                                                                    );
                                                                })}
                                                                {playsWithHistory.length > 10 && (
                                                                    <div style={{
                                                                        textAlign: 'center',
                                                                        fontSize: '0.8rem',
                                                                        color: 'var(--text-secondary)',
                                                                        padding: '8px'
                                                                    }}>
                                                                        Showing top 10 of {playsWithHistory.length} plays with history
                                                                    </div>
                                                                )}
                                                            </div>
                                                        );
                                                    })()}
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            )}

                            {setupTab === 'practice-lists' && (
                                <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                                    <div style={{ marginBottom: '1.5rem' }}>
                                        <h3 style={{ margin: 0 }}>Practice Lists</h3>
                                        <p style={{ margin: '0.25rem 0 0 0', opacity: 0.7 }}>Customize standard dropdown options for practice plans.</p>
                                    </div>

                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '2rem' }}>
                                        <HierarchyEditor
                                            segmentTypes={practiceSegmentTypes[phase] || []}
                                            focusItems={practiceFocusItems[phase] || []}
                                            settings={practiceSegmentSettings}
                                            onUpdateSettings={setPracticeSegmentSettings}
                                            onAddSegment={(val) => {
                                                const currentList = practiceSegmentTypes[phase] || [];
                                                if (!currentList.includes(val)) {
                                                    setPracticeSegmentTypes({ ...practiceSegmentTypes, [phase]: [...currentList, val] });
                                                }
                                            }}
                                            onAddFocus={(val) => {
                                                const currentList = practiceFocusItems[phase] || [];
                                                if (!currentList.includes(val)) {
                                                    setPracticeFocusItems({ ...practiceFocusItems, [phase]: [...currentList, val] });
                                                }
                                            }}
                                            onRenameSegment={(oldName, newName) => {
                                                const currentList = practiceSegmentTypes[phase] || [];
                                                const updatedList = currentList.map(item => item === oldName ? newName : item);
                                                setPracticeSegmentTypes({ ...practiceSegmentTypes, [phase]: updatedList });

                                                // Update settings to use new name as key
                                                if (practiceSegmentSettings[oldName]) {
                                                    const updatedSettings = { ...practiceSegmentSettings };
                                                    updatedSettings[newName] = updatedSettings[oldName];
                                                    delete updatedSettings[oldName];
                                                    setPracticeSegmentSettings(updatedSettings);
                                                }
                                            }}
                                            onRenameFocus={(oldName, newName) => {
                                                const currentList = practiceFocusItems[phase] || [];
                                                const updatedList = currentList.map(item => item === oldName ? newName : item);
                                                setPracticeFocusItems({ ...practiceFocusItems, [phase]: updatedList });

                                                // Update any allowedFocusItems arrays that reference the old name
                                                const updatedSettings = { ...practiceSegmentSettings };
                                                Object.keys(updatedSettings).forEach(segKey => {
                                                    if (updatedSettings[segKey].allowedFocusItems) {
                                                        updatedSettings[segKey] = {
                                                            ...updatedSettings[segKey],
                                                            allowedFocusItems: updatedSettings[segKey].allowedFocusItems.map(
                                                                item => item === oldName ? newName : item
                                                            )
                                                        };
                                                    }
                                                });
                                                setPracticeSegmentSettings(updatedSettings);
                                            }}
                                            deleteConfirmation={deleteConfirmation}
                                            setDeleteConfirmation={setDeleteConfirmation}
                                            onDeleteSegment={(item) => {
                                                const currentList = practiceSegmentTypes[phase] || [];
                                                setPracticeSegmentTypes({ ...practiceSegmentTypes, [phase]: currentList.filter(t => t !== item) });
                                                setDeleteConfirmation(null);
                                            }}
                                            onDeleteFocus={(item) => {
                                                const currentList = practiceFocusItems[phase] || [];
                                                setPracticeFocusItems({ ...practiceFocusItems, [phase]: currentList.filter(t => t !== item) });
                                                setDeleteConfirmation(null);
                                            }}
                                        />
                                    </div>
                                </div>
                            )}


                            {
                                setupTab === 'script-presets' && (
                                    <ScriptPresetsManager />
                                )
                            }

                            {setupTab === 'practice-templates' && (
                                <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                                        <div>
                                            <h3 style={{ margin: 0 }}>Practice Templates</h3>
                                            <p style={{ margin: '0.25rem 0 0 0', opacity: 0.7 }}>Save and reuse practice plan templates for your team.</p>
                                        </div>
                                        <button
                                            className="btn btn-primary"
                                            onClick={() => {
                                                const name = prompt("Template Name:");
                                                if (name) {
                                                    const newTemplate = {
                                                        id: Date.now().toString(),
                                                        name,
                                                        createdAt: new Date().toISOString(),
                                                        segments: []
                                                    };
                                                    setPracticeTemplates([...practiceTemplates, newTemplate]);
                                                }
                                            }}
                                        >
                                            <Icon name="Plus" size={16} /> New Template
                                        </button>
                                    </div>

                                    {practiceTemplates.length === 0 ? (
                                        <div style={{ textAlign: 'center', padding: '3rem', color: 'var(--text-secondary)' }}>
                                            <Icon name="Calendar" size={48} style={{ opacity: 0.3, marginBottom: '1rem' }} />
                                            <p>No practice templates yet.</p>
                                            <p style={{ fontSize: '0.9rem' }}>Create templates to quickly set up practice plans.</p>
                                        </div>
                                    ) : (
                                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '1rem' }}>
                                            {practiceTemplates.map((template, idx) => (
                                                <div key={template.id} className="card" style={{ padding: '1rem' }}>
                                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '0.75rem' }}>
                                                        <div>
                                                            <input
                                                                type="text"
                                                                value={template.name}
                                                                onChange={(e) => {
                                                                    const updated = [...practiceTemplates];
                                                                    updated[idx] = { ...template, name: e.target.value };
                                                                    setPracticeTemplates(updated);
                                                                }}
                                                                style={{
                                                                    fontWeight: 'bold',
                                                                    fontSize: '1rem',
                                                                    background: 'transparent',
                                                                    border: 'none',
                                                                    color: 'var(--text-primary)',
                                                                    padding: 0
                                                                }}
                                                            />
                                                            <p style={{ margin: '0.25rem 0 0 0', fontSize: '0.8rem', color: 'var(--text-secondary)' }}>
                                                                {template.segments?.length || 0} segments
                                                            </p>
                                                        </div>
                                                        <button
                                                            className="btn-icon"
                                                            onClick={() => {
                                                                if (confirm(`Delete "${template.name}"?`)) {
                                                                    setPracticeTemplates(practiceTemplates.filter(t => t.id !== template.id));
                                                                }
                                                            }}
                                                            style={{ color: '#ef4444' }}
                                                        >
                                                            <Icon name="Trash2" size={16} />
                                                        </button>
                                                    </div>
                                                    <div style={{ fontSize: '0.8rem', color: 'var(--text-muted)' }}>
                                                        Created {new Date(template.createdAt).toLocaleDateString()}
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                </div>
                            )}

                            {setupTab === 'oline-schemes' && (
                                <div>
                                    <h3 style={{ marginBottom: '1.5rem' }}>OL WIZ Library</h3>

                                    {/* Pass Protections Section */}
                                    <div style={{ marginBottom: '2rem' }}>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                            <div>
                                                <h4 style={{ margin: 0 }}>Pass Protections</h4>
                                                <p style={{ margin: '0.25rem 0 0 0', opacity: 0.7, fontSize: '0.85rem' }}>Define your pass protection calls (e.g., BROWN, GOLD)</p>
                                            </div>
                                            <button className="btn btn-primary" onClick={() => {
                                                const name = prompt("Protection Name (e.g., BROWN):");
                                                if (name) {
                                                    setPassProtections([...passProtections, {
                                                        id: Date.now().toString(),
                                                        name: name.toUpperCase(),
                                                        slideDirection: 'right',
                                                        manSide: 'left',
                                                        callText: '',
                                                        notes: ''
                                                    }]);
                                                }
                                            }}>
                                                <Icon name="Plus" size={16} style={{ marginRight: '6px' }} /> Add Protection
                                            </button>
                                        </div>
                                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(350px, 1fr))', gap: '1rem' }}>
                                            {passProtections.map((prot, idx) => (
                                                <div key={prot.id} className="card" style={{ padding: '1rem' }}>
                                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.75rem' }}>
                                                        <input
                                                            type="text"
                                                            value={prot.name}
                                                            onChange={(e) => {
                                                                const updated = [...passProtections];
                                                                updated[idx] = { ...prot, name: e.target.value.toUpperCase() };
                                                                setPassProtections(updated);
                                                            }}
                                                            style={{ fontWeight: 'bold', fontSize: '1.1rem', background: 'transparent', border: 'none', color: 'var(--text-primary)', width: '120px' }}
                                                        />
                                                        <button
                                                            className="btn btn-ghost btn-sm"
                                                            onClick={() => {
                                                                if (confirm(`Delete ${prot.name}?`)) {
                                                                    setPassProtections(passProtections.filter(p => p.id !== prot.id));
                                                                }
                                                            }}
                                                            style={{ color: '#ef4444' }}
                                                        >
                                                            <Icon name="Trash2" size={14} />
                                                        </button>
                                                    </div>
                                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '0.75rem', marginBottom: '0.75rem' }}>
                                                        <div>
                                                            <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', display: 'block', marginBottom: '0.25rem' }}>Slide Direction</label>
                                                            <select
                                                                className="form-input"
                                                                value={prot.slideDirection}
                                                                onChange={(e) => {
                                                                    const updated = [...passProtections];
                                                                    updated[idx] = { ...prot, slideDirection: e.target.value };
                                                                    setPassProtections(updated);
                                                                }}
                                                            >
                                                                <option value="left">← Slide Left</option>
                                                                <option value="right">Slide Right →</option>
                                                                <option value="none">No Slide</option>
                                                            </select>
                                                        </div>
                                                        <div>
                                                            <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', display: 'block', marginBottom: '0.25rem' }}>Man Side</label>
                                                            <select
                                                                className="form-input"
                                                                value={prot.manSide}
                                                                onChange={(e) => {
                                                                    const updated = [...passProtections];
                                                                    updated[idx] = { ...prot, manSide: e.target.value };
                                                                    setPassProtections(updated);
                                                                }}
                                                            >
                                                                <option value="left">Man Left</option>
                                                                <option value="right">Man Right</option>
                                                                <option value="none">N/A</option>
                                                            </select>
                                                        </div>
                                                    </div>
                                                    <div style={{ marginBottom: '0.5rem' }}>
                                                        <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', display: 'block', marginBottom: '0.25rem' }}>Call Text (shown on WIZ card)</label>
                                                        <input
                                                            type="text"
                                                            className="form-input"
                                                            value={prot.callText}
                                                            onChange={(e) => {
                                                                const updated = [...passProtections];
                                                                updated[idx] = { ...prot, callText: e.target.value };
                                                                setPassProtections(updated);
                                                            }}
                                                            placeholder="e.g., Slide R – Man L"
                                                        />
                                                    </div>
                                                    <div>
                                                        <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', display: 'block', marginBottom: '0.25rem' }}>Notes</label>
                                                        <textarea
                                                            className="form-input"
                                                            value={prot.notes}
                                                            onChange={(e) => {
                                                                const updated = [...passProtections];
                                                                updated[idx] = { ...prot, notes: e.target.value };
                                                                setPassProtections(updated);
                                                            }}
                                                            placeholder="Optional notes..."
                                                            rows={2}
                                                            style={{ resize: 'vertical' }}
                                                        />
                                                    </div>
                                                    {/* Diagram Preview & Edit */}
                                                    <div style={{ marginTop: '0.75rem', paddingTop: '0.75rem', borderTop: '1px solid var(--border)' }}>
                                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.5rem' }}>
                                                            <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)' }}>Diagram</label>
                                                            <button
                                                                className="btn btn-secondary btn-sm"
                                                                onClick={() => setEditingOlineScheme({ id: prot.id, type: 'protection' })}
                                                                style={{ fontSize: '0.75rem', padding: '0.25rem 0.5rem' }}
                                                            >
                                                                <Icon name="Edit3" size={12} style={{ marginRight: '4px' }} />
                                                                {prot.diagramData ? 'Edit' : 'Create'} Diagram
                                                            </button>
                                                        </div>
                                                        {prot.diagramData && prot.diagramData.length > 0 ? (
                                                            <div style={{ background: 'white', borderRadius: '4px', height: '80px', overflow: 'hidden' }}>
                                                                <svg viewBox="0 0 900 600" width="100%" height="100%" preserveAspectRatio="xMidYMid meet">
                                                                    {prot.diagramData.map((el, i) => {
                                                                        if (el.type === 'player') {
                                                                            const { x, y } = el.points[0];
                                                                            return (
                                                                                <text key={i} x={x} y={y} fontSize={el.fontSize || 40} fill={el.color || '#000'} textAnchor="middle" dominantBaseline="middle" fontWeight="bold">{el.label}</text>
                                                                            );
                                                                        }
                                                                        return null;
                                                                    })}
                                                                </svg>
                                                            </div>
                                                        ) : (
                                                            <div style={{ background: 'var(--bg-input)', borderRadius: '4px', height: '60px', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'var(--text-secondary)', fontSize: '0.75rem' }}>
                                                                No diagram yet
                                                            </div>
                                                        )}
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>

                                    {/* Run Blocking Section */}
                                    <div>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                            <div>
                                                <h4 style={{ margin: 0 }}>Run Blocking Schemes</h4>
                                                <p style={{ margin: '0.25rem 0 0 0', opacity: 0.7, fontSize: '0.85rem' }}>Define your run blocking schemes (e.g., Zone, Gap, Power)</p>
                                            </div>
                                            <button className="btn btn-primary" onClick={() => {
                                                const name = prompt("Blocking Scheme Name (e.g., ZONE, POWER):");
                                                if (name) {
                                                    setRunBlocking([...runBlocking, {
                                                        id: Date.now().toString(),
                                                        name: name.toUpperCase(),
                                                        type: 'zone',
                                                        callText: '',
                                                        notes: ''
                                                    }]);
                                                }
                                            }}>
                                                <Icon name="Plus" size={16} style={{ marginRight: '6px' }} /> Add Scheme
                                            </button>
                                        </div>
                                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(350px, 1fr))', gap: '1rem' }}>
                                            {runBlocking.map((scheme, idx) => (
                                                <div key={scheme.id} className="card" style={{ padding: '1rem' }}>
                                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.75rem' }}>
                                                        <input
                                                            type="text"
                                                            value={scheme.name}
                                                            onChange={(e) => {
                                                                const updated = [...runBlocking];
                                                                updated[idx] = { ...scheme, name: e.target.value.toUpperCase() };
                                                                setRunBlocking(updated);
                                                            }}
                                                            style={{ fontWeight: 'bold', fontSize: '1.1rem', background: 'transparent', border: 'none', color: 'var(--text-primary)', width: '120px' }}
                                                        />
                                                        <button
                                                            className="btn btn-ghost btn-sm"
                                                            onClick={() => {
                                                                if (confirm(`Delete ${scheme.name}?`)) {
                                                                    setRunBlocking(runBlocking.filter(s => s.id !== scheme.id));
                                                                }
                                                            }}
                                                            style={{ color: '#ef4444' }}
                                                        >
                                                            <Icon name="Trash2" size={14} />
                                                        </button>
                                                    </div>
                                                    <div style={{ marginBottom: '0.75rem' }}>
                                                        <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', display: 'block', marginBottom: '0.25rem' }}>Scheme Type</label>
                                                        <select
                                                            className="form-input"
                                                            value={scheme.type}
                                                            onChange={(e) => {
                                                                const updated = [...runBlocking];
                                                                updated[idx] = { ...scheme, type: e.target.value };
                                                                setRunBlocking(updated);
                                                            }}
                                                        >
                                                            <option value="zone">Zone</option>
                                                            <option value="gap">Gap / Man</option>
                                                            <option value="power">Power</option>
                                                            <option value="counter">Counter</option>
                                                            <option value="trap">Trap</option>
                                                            <option value="iso">Iso</option>
                                                            <option value="other">Other</option>
                                                        </select>
                                                    </div>
                                                    <div style={{ marginBottom: '0.5rem' }}>
                                                        <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', display: 'block', marginBottom: '0.25rem' }}>Call Text (shown on WIZ card)</label>
                                                        <input
                                                            type="text"
                                                            className="form-input"
                                                            value={scheme.callText}
                                                            onChange={(e) => {
                                                                const updated = [...runBlocking];
                                                                updated[idx] = { ...scheme, callText: e.target.value };
                                                                setRunBlocking(updated);
                                                            }}
                                                            placeholder="e.g., Inside Zone Left"
                                                        />
                                                    </div>
                                                    <div>
                                                        <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', display: 'block', marginBottom: '0.25rem' }}>Notes</label>
                                                        <textarea
                                                            className="form-input"
                                                            value={scheme.notes}
                                                            onChange={(e) => {
                                                                const updated = [...runBlocking];
                                                                updated[idx] = { ...scheme, notes: e.target.value };
                                                                setRunBlocking(updated);
                                                            }}
                                                            placeholder="Optional notes..."
                                                            rows={2}
                                                            style={{ resize: 'vertical' }}
                                                        />
                                                    </div>
                                                    {/* Diagram Preview & Edit */}
                                                    <div style={{ marginTop: '0.75rem', paddingTop: '0.75rem', borderTop: '1px solid var(--border)' }}>
                                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.5rem' }}>
                                                            <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)' }}>Diagram</label>
                                                            <button
                                                                className="btn btn-secondary btn-sm"
                                                                onClick={() => setEditingOlineScheme({ id: scheme.id, type: 'blocking' })}
                                                                style={{ fontSize: '0.75rem', padding: '0.25rem 0.5rem' }}
                                                            >
                                                                <Icon name="Edit3" size={12} style={{ marginRight: '4px' }} />
                                                                {scheme.diagramData ? 'Edit' : 'Create'} Diagram
                                                            </button>
                                                        </div>
                                                        {scheme.diagramData && scheme.diagramData.length > 0 ? (
                                                            <div style={{ background: 'white', borderRadius: '4px', height: '80px', overflow: 'hidden' }}>
                                                                <svg viewBox="0 0 900 600" width="100%" height="100%" preserveAspectRatio="xMidYMid meet">
                                                                    {scheme.diagramData.map((el, i) => {
                                                                        if (el.type === 'player') {
                                                                            const { x, y } = el.points[0];
                                                                            return (
                                                                                <text key={i} x={x} y={y} fontSize={el.fontSize || 40} fill={el.color || '#000'} textAnchor="middle" dominantBaseline="middle" fontWeight="bold">{el.label}</text>
                                                                            );
                                                                        }
                                                                        return null;
                                                                    })}
                                                                </svg>
                                                            </div>
                                                        ) : (
                                                            <div style={{ background: 'var(--bg-input)', borderRadius: '4px', height: '60px', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'var(--text-secondary)', fontSize: '0.75rem' }}>
                                                                No diagram yet
                                                            </div>
                                                        )}
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>

                                    {/* Diagram Editor Modal */}
                                    {editingOlineScheme && (
                                        <PlayDiagramEditor
                                            initialData={(() => {
                                                const scheme = editingOlineScheme.type === 'protection'
                                                    ? passProtections.find(p => p.id === editingOlineScheme.id)
                                                    : runBlocking.find(b => b.id === editingOlineScheme.id);
                                                return scheme?.diagramData ? { elements: scheme.diagramData } : null;
                                            })()}
                                            mode="wiz-oline"
                                            onSave={(data) => {
                                                if (editingOlineScheme.type === 'protection') {
                                                    setPassProtections(passProtections.map(p =>
                                                        p.id === editingOlineScheme.id ? { ...p, diagramData: data.elements } : p
                                                    ));
                                                } else {
                                                    setRunBlocking(runBlocking.map(b =>
                                                        b.id === editingOlineScheme.id ? { ...b, diagramData: data.elements } : b
                                                    ));
                                                }
                                                setEditingOlineScheme(null);
                                            }}
                                            onCancel={() => setEditingOlineScheme(null)}
                                            positionNames={positionNames}
                                            positionColors={positionColors}
                                        />
                                    )}
                                </div>
                            )}

                            {setupTab === 'personnel' && isOffense && (
                                <div>
                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                                        <div>
                                            <h3 style={{ margin: 0 }}>Personnel Groupings</h3>
                                            <p style={{ margin: '0.25rem 0 0 0', opacity: 0.7, fontSize: '0.85rem' }}>
                                                Define which skill positions are on the field for each personnel package.
                                            </p>
                                        </div>
                                        <button
                                            className="btn btn-primary"
                                            onClick={() => {
                                                const newId = `pers_${Date.now()}`;
                                                setPersonnelGroupings([
                                                    ...personnelGroupings,
                                                    { id: newId, code: '', name: 'New Personnel', description: '', positions: [] }
                                                ]);
                                            }}
                                        >
                                            <Icon name="Plus" size={16} /> Add Personnel
                                        </button>
                                    </div>

                                    {(() => {
                                        // Get all available skill positions from Positions tab
                                        const oLinePositions = ['LT', 'LG', 'C', 'RG', 'RT'];
                                        const customOffensePositions = (customPositions['OFFENSE'] || []).map(p => p.key);
                                        const hiddenOffensePositions = hiddenPositions['OFFENSE'] || [];

                                        // Available positions = (defaults + custom) - hidden - OL
                                        const availablePositions = [
                                            ...defaultPositions.map(p => p.key).filter(p => !hiddenOffensePositions.includes(p) && !oLinePositions.includes(p)),
                                            ...customOffensePositions.filter(p => !oLinePositions.includes(p))
                                        ];

                                        // positionColors comes from state (useLocalStorage)
                                        const defaultPosColorsFallback = {
                                            'QB': '#1e3a5f', 'RB': '#3b82f6', 'F': '#f97316', 'H': '#06b6d4',
                                            'X': '#a855f7', 'Z': '#22c55e', 'Y': '#eab308', 'A': '#ef4444', 'B': '#ec4899'
                                        };
                                        const getPosColor = (pos) => positionColors[pos] || defaultPosColorsFallback[pos] || '#64748b';

                                        return (
                                            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(350px, 1fr))', gap: '1.5rem' }}>
                                                {personnelGroupings.map((grouping, idx) => {
                                                    const activePositions = grouping.positions || [];

                                                    return (
                                                        <div key={grouping.id} style={{
                                                            background: 'var(--surface)',
                                                            border: '1px solid var(--border)',
                                                            borderRadius: '8px',
                                                            padding: '1rem'
                                                        }}>
                                                            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '0.75rem', gap: '0.5rem' }}>
                                                                <div style={{ flex: 1 }}>
                                                                    <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center', marginBottom: '0.5rem' }}>
                                                                        <input
                                                                            type="text"
                                                                            value={grouping.code || ''}
                                                                            onChange={(e) => {
                                                                                const updated = [...personnelGroupings];
                                                                                updated[idx] = { ...grouping, code: e.target.value };
                                                                                setPersonnelGroupings(updated);
                                                                            }}
                                                                            placeholder="Code"
                                                                            style={{
                                                                                width: '50px',
                                                                                padding: '4px 8px',
                                                                                fontSize: '1rem',
                                                                                fontWeight: 'bold',
                                                                                color: 'var(--primary)',
                                                                                background: 'var(--bg-card)',
                                                                                border: '1px solid var(--border)',
                                                                                borderRadius: '4px',
                                                                                textAlign: 'center'
                                                                            }}
                                                                        />
                                                                        <input
                                                                            type="text"
                                                                            value={grouping.name || ''}
                                                                            onChange={(e) => {
                                                                                const updated = [...personnelGroupings];
                                                                                updated[idx] = { ...grouping, name: e.target.value };
                                                                                setPersonnelGroupings(updated);
                                                                            }}
                                                                            placeholder="Name"
                                                                            style={{
                                                                                flex: 1,
                                                                                padding: '4px 8px',
                                                                                fontSize: '0.9rem',
                                                                                background: 'var(--bg-card)',
                                                                                border: '1px solid var(--border)',
                                                                                borderRadius: '4px',
                                                                                color: 'var(--text-primary)'
                                                                            }}
                                                                        />
                                                                    </div>
                                                                    <input
                                                                        type="text"
                                                                        value={grouping.description || ''}
                                                                        onChange={(e) => {
                                                                            const updated = [...personnelGroupings];
                                                                            updated[idx] = { ...grouping, description: e.target.value };
                                                                            setPersonnelGroupings(updated);
                                                                        }}
                                                                        placeholder="Description (e.g., 2 RB, 1 TE)"
                                                                        style={{
                                                                            width: '100%',
                                                                            padding: '4px 8px',
                                                                            fontSize: '0.8rem',
                                                                            color: 'var(--text-secondary)',
                                                                            background: 'var(--bg-card)',
                                                                            border: '1px solid var(--border)',
                                                                            borderRadius: '4px'
                                                                        }}
                                                                    />
                                                                </div>
                                                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                                    <span style={{ fontSize: '0.8rem', color: 'var(--text-muted)' }}>
                                                                        {activePositions.length}
                                                                    </span>
                                                                    <button
                                                                        className="btn-icon"
                                                                        onClick={() => {
                                                                            if (confirm(`Delete "${grouping.name || grouping.code}"?`)) {
                                                                                setPersonnelGroupings(personnelGroupings.filter(g => g.id !== grouping.id));
                                                                            }
                                                                        }}
                                                                        style={{ color: '#ef4444', padding: '4px' }}
                                                                    >
                                                                        <Icon name="Trash2" size={16} />
                                                                    </button>
                                                                </div>
                                                            </div>
                                                            <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.5rem' }}>
                                                                {availablePositions.map(pos => {
                                                                    const isActive = activePositions.includes(pos);
                                                                    const color = getPosColor(pos);

                                                                    return (
                                                                        <label
                                                                            key={pos}
                                                                            style={{
                                                                                display: 'flex',
                                                                                alignItems: 'center',
                                                                                gap: '0.35rem',
                                                                                padding: '0.4rem 0.6rem',
                                                                                background: isActive ? color : 'var(--bg-card)',
                                                                                border: `1px solid ${isActive ? color : 'var(--border)'}`,
                                                                                borderRadius: '6px',
                                                                                cursor: 'pointer',
                                                                                transition: 'all 0.15s',
                                                                                opacity: isActive ? 1 : 0.6
                                                                            }}
                                                                        >
                                                                            <input
                                                                                type="checkbox"
                                                                                checked={isActive}
                                                                                onChange={(e) => {
                                                                                    const newPositions = e.target.checked
                                                                                        ? [...activePositions, pos]
                                                                                        : activePositions.filter(p => p !== pos);
                                                                                    const updated = [...personnelGroupings];
                                                                                    updated[idx] = { ...grouping, positions: newPositions };
                                                                                    setPersonnelGroupings(updated);
                                                                                }}
                                                                                style={{ display: 'none' }}
                                                                            />
                                                                            <span style={{
                                                                                fontWeight: '600',
                                                                                fontSize: '0.85rem',
                                                                                color: isActive ? 'white' : 'var(--text-primary)'
                                                                            }}>
                                                                                {positionNames[pos] || pos}
                                                                            </span>
                                                                        </label>
                                                                    );
                                                                })}
                                                            </div>
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        );
                                    })()}

                                    <div style={{ marginTop: '2rem', padding: '1rem', background: 'var(--surface)', borderRadius: '8px', fontSize: '0.9rem', color: 'var(--text-secondary)' }}>
                                        <p style={{ margin: 0 }}>
                                            <strong>Tip:</strong> Positions shown here come from your Positions tab. Add custom positions there to include them in personnel groupings.
                                        </p>
                                    </div>
                                </div>
                            )}

                            {setupTab === 'formations' && (
                                <FormationManager
                                    formations={formations}
                                    onAddFormation={handleAddFormation}
                                    onUpdateFormation={handleUpdateFormation}
                                    onDeleteFormation={handleDeleteFormation}
                                    positionNames={positionNames}
                                    positionColors={positionColors}
                                    phase={isST ? 'SPECIAL TEAMS' : isDefense ? 'DEFENSE' : 'OFFENSE'}
                                    personnelGroupings={personnelGroupings}
                                />
                            )}
                        </div >
                    </div >
                );
            };



            if (!authUser) return <LoginScreen />;

            // LOADING STATE: Wait for access check to complete before showing anything
            // This prevents users from seeing the main app before access is verified
            // Check if localStorage data belongs to current user (prevents cross-account data leakage)
            const storedUserId = localStorage.getItem('hc_user_id');
            const hasExistingSchool = localStorage.getItem('hc_school_id');
            const isCurrentUserData = storedUserId === authUser.uid;

            // If localStorage belongs to a different user, clear it
            if (hasExistingSchool && !isCurrentUserData) {
                console.log("DEBUG: Clearing stale localStorage from different user");
                localStorage.removeItem('hc_school_id');
                localStorage.removeItem('hc_school_name');
                localStorage.removeItem('hc_user_id');
                localStorage.removeItem('dofo_trial_expires');
                localStorage.removeItem('dofo_trial_days');
            }

            // Store current user ID for future checks
            if (!storedUserId || storedUserId !== authUser.uid) {
                localStorage.setItem('hc_user_id', authUser.uid);
            }

            if (!accessRequestStatus.checked && !schoolSetupData.showWizard && !isCurrentUserData) {
                return (
                    <div style={{
                        height: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center',
                        background: 'linear-gradient(135deg, #0f172a 0%, #1e293b 100%)', color: 'white'
                    }}>
                        <div style={{ textAlign: 'center' }}>
                            <div style={{ fontSize: '2rem', marginBottom: '1rem' }}>Loading...</div>
                            <div style={{ color: '#94a3b8' }}>Verifying access...</div>
                        </div>
                    </div>
                );
            }

            // ACCESS REQUEST GATE: Show appropriate screen based on request status
            if (accessRequestStatus.checked && !schoolSetupData.showWizard) {
                // No request yet - show form
                if (accessRequestStatus.status === null) {
                    return (
                        <AccessRequestForm
                            user={authUser}
                            onSubmit={(status) => setAccessRequestStatus({ checked: true, status, data: { email: authUser.email } })}
                        />
                    );
                }
                // Request approved - check if they already have a school, otherwise show wizard
                if (accessRequestStatus.status === 'approved') {
                    // If school already in localStorage, skip this handler - let app render normally
                    const existingSchoolId = localStorage.getItem('hc_school_id');
                    if (existingSchoolId) {
                        console.log("DEBUG: School already in localStorage, skipping approved handler");
                        // Don't return anything - fall through to normal app rendering
                    } else {
                        // Check if user already has a school before showing wizard
                        const checkExistingSchool = async () => {
                            try {
                                const schoolsSnapshot = await window.db.collection('schools').get();
                                for (const doc of schoolsSnapshot.docs) {
                                    const members = doc.data().memberList || [];
                                    const found = members.some(m =>
                                        (typeof m === 'string' && m.toLowerCase() === authUser.email.toLowerCase()) ||
                                        (m && m.email && m.email.toLowerCase() === authUser.email.toLowerCase())
                                    );
                                    if (found) {
                                        console.log("User already has school:", doc.id, "- saving to localStorage");
                                        // Save to localStorage so next render skips this
                                        const schoolData = doc.data();
                                        localStorage.setItem('hc_school_id', doc.id);
                                        localStorage.setItem('hc_school_name', schoolData.name || 'My School');
                                        window.location.reload();
                                        return;
                                    }
                                }
                                // No existing school found - show wizard
                                const newSchoolId = 'school_' + Date.now();
                                setSchoolSetupData({ showWizard: true, schoolId: newSchoolId });
                            } catch (err) {
                                console.error("Error checking for existing school:", err);
                                // On error, show wizard anyway
                                const newSchoolId = 'school_' + Date.now();
                                setSchoolSetupData({ showWizard: true, schoolId: newSchoolId });
                            }
                        };
                        if (!schoolSetupData.showWizard) {
                            checkExistingSchool();
                        }
                        return (
                            <div style={{
                                height: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center',
                                background: 'linear-gradient(135deg, #0f172a 0%, #1e293b 100%)', color: 'white'
                            }}>
                                <div style={{ textAlign: 'center' }}>
                                    <div style={{ fontSize: '2rem', marginBottom: '1rem' }}>Access Approved!</div>
                                    <div style={{ color: '#94a3b8' }}>Setting up your account...</div>
                                </div>
                            </div>
                        );
                    }
                }
                // Request pending - show waiting screen
                if (accessRequestStatus.status === 'pending') {
                    return <PendingApprovalScreen user={authUser} requestData={accessRequestStatus.data} />;
                }
                // Request rejected
                if (accessRequestStatus.status === 'rejected') {
                    return (
                        <div style={{
                            height: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center',
                            background: 'linear-gradient(135deg, #0f172a 0%, #1e293b 100%)', color: 'white'
                        }}>
                            <div style={{ background: '#1e293b', padding: '2rem', borderRadius: '12px', width: '100%', maxWidth: '500px', textAlign: 'center' }}>
                                <div style={{ fontSize: '4rem', marginBottom: '1rem' }}>❌</div>
                                <h1 style={{ fontSize: '1.5rem', fontWeight: 'bold', marginBottom: '0.5rem', color: '#ef4444' }}>
                                    Request Not Approved
                                </h1>
                                <p style={{ color: '#94a3b8', marginBottom: '1.5rem' }}>
                                    Unfortunately, we weren't able to approve your access request at this time.
                                    {accessRequestStatus.data?.notes && (
                                        <span style={{ display: 'block', marginTop: '1rem', color: '#f59e0b' }}>
                                            Note: {accessRequestStatus.data.notes}
                                        </span>
                                    )}
                                </p>
                                <button
                                    onClick={() => window.auth.signOut()}
                                    style={{ background: '#334155', border: 'none', color: 'white', padding: '0.75rem 1.5rem', borderRadius: '6px', cursor: 'pointer' }}
                                >
                                    Sign Out
                                </button>
                            </div>
                        </div>
                    );
                }
                // Access expired
                if (accessRequestStatus.status === 'expired') {
                    return (
                        <div style={{
                            height: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center',
                            background: 'linear-gradient(135deg, #0f172a 0%, #1e293b 100%)', color: 'white'
                        }}>
                            <div style={{ background: '#1e293b', padding: '2rem', borderRadius: '12px', width: '100%', maxWidth: '500px', textAlign: 'center' }}>
                                <div style={{ fontSize: '4rem', marginBottom: '1rem' }}>⏰</div>
                                <h1 style={{ fontSize: '1.5rem', fontWeight: 'bold', marginBottom: '0.5rem', color: '#f59e0b' }}>
                                    Access Expired
                                </h1>
                                <p style={{ color: '#94a3b8', marginBottom: '1.5rem' }}>
                                    Your trial period has ended. Contact us to continue using DoFO!
                                </p>
                                <p style={{ color: '#64748b', fontSize: '0.85rem', marginBottom: '1rem' }}>
                                    Expired: {accessRequestStatus.data?.accessExpiresAt ? new Date(accessRequestStatus.data.accessExpiresAt).toLocaleDateString() : 'Unknown'}
                                </p>
                                <button
                                    onClick={() => window.auth.signOut()}
                                    style={{ background: '#334155', border: 'none', color: 'white', padding: '0.75rem 1.5rem', borderRadius: '6px', cursor: 'pointer' }}
                                >
                                    Sign Out
                                </button>
                            </div>
                        </div>
                    );
                }
                // Account archived (school was deleted)
                if (accessRequestStatus.status === 'archived') {
                    return (
                        <div style={{
                            height: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center',
                            background: 'linear-gradient(135deg, #0f172a 0%, #1e293b 100%)', color: 'white'
                        }}>
                            <div style={{ background: '#1e293b', padding: '2rem', borderRadius: '12px', width: '100%', maxWidth: '500px', textAlign: 'center' }}>
                                <div style={{ fontSize: '4rem', marginBottom: '1rem' }}>📦</div>
                                <h1 style={{ fontSize: '1.5rem', fontWeight: 'bold', marginBottom: '0.5rem', color: '#6b7280' }}>
                                    Account Archived
                                </h1>
                                <p style={{ color: '#94a3b8', marginBottom: '1.5rem' }}>
                                    Your school account has been deleted by an administrator.
                                    {accessRequestStatus.data?.previousSchoolName && (
                                        <span style={{ display: 'block', marginTop: '0.5rem', color: '#64748b' }}>
                                            Previous school: {accessRequestStatus.data.previousSchoolName}
                                        </span>
                                    )}
                                </p>
                                <p style={{ color: '#64748b', fontSize: '0.85rem', marginBottom: '1.5rem' }}>
                                    Contact an administrator if you believe this was a mistake.
                                </p>
                                <button
                                    onClick={() => window.auth.signOut()}
                                    style={{ background: '#334155', border: 'none', color: 'white', padding: '0.75rem 1.5rem', borderRadius: '6px', cursor: 'pointer' }}
                                >
                                    Sign Out
                                </button>
                            </div>
                        </div>
                    );
                }
            }

            return (
                <PlayDetailsModalContext.Provider value={{ openPlayDetails }}>
                    <div className="app-container">
                        {schoolSetupData.showWizard && !schoolName && (
                            <div className="onboarding-wizard-wrapper">
                                <SchoolOnboardingWizard
                                    user={authUser}
                                    onComplete={async (schoolId) => {
                                        console.log("Onboarding Complete. Fetching new data...");
                                        setSchoolSetupData({ showWizard: false, schoolId: null });
                                        // Fetch fresh data immediately to populate Dashboard without reload
                                        await loadUserDataFromFirestore(authUser.uid);
                                        // Ensure School ID is set in local state (in case loader didn't catch it yet)
                                        localStorage.setItem('hc_school_id', schoolId);
                                    }}
                                />
                            </div>
                        )}

                        {/* Trial Banner */}
                        {(() => {
                            const trialExpires = localStorage.getItem('dofo_trial_expires');
                            if (!trialExpires) return null;
                            const expiresDate = new Date(trialExpires);
                            const now = new Date();
                            if (expiresDate <= now) return null; // Trial expired, don't show banner
                            const daysLeft = Math.ceil((expiresDate - now) / (1000 * 60 * 60 * 24));
                            const trialDays = localStorage.getItem('dofo_trial_days') || '7';
                            return (
                                <div style={{
                                    position: 'fixed',
                                    top: 0,
                                    left: 0,
                                    right: 0,
                                    background: 'linear-gradient(90deg, #0ea5e9, #10b981)',
                                    color: 'white',
                                    padding: '0.5rem 1rem',
                                    textAlign: 'center',
                                    fontSize: '0.9rem',
                                    fontWeight: '500',
                                    zIndex: 9999,
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    gap: '1rem'
                                }}>
                                    <span>
                                        🎉 Welcome! You're on a {trialDays}-day free trial.
                                        {daysLeft === 1 ? ' Expires tomorrow!' : ` ${daysLeft} days remaining.`}
                                    </span>
                                    <span style={{ opacity: 0.9, fontSize: '0.8rem' }}>
                                        Expires: {expiresDate.toLocaleDateString()}
                                    </span>
                                </div>
                            );
                        })()}


                        <div className="sidebar" style={{
                            width: sidebarCollapsed ? '60px' : '280px',
                            transition: 'width 0.3s ease',
                            overflow: 'hidden',
                            zIndex: 100, // Normal sidebar z-index
                            position: 'relative'
                        }}>
                            {/* Collapse button - absolutely positioned */}
                            <button
                                onClick={() => {
                                    const willExpand = sidebarCollapsed;
                                    setSidebarCollapsed(!sidebarCollapsed);
                                    // When expanding sidebar, close any open side menus
                                    if (willExpand && closeSideMenuRef.current) {
                                        closeSideMenuRef.current();
                                    }
                                }}
                                style={{
                                    position: 'absolute',
                                    top: '0.5rem',
                                    right: '0.5rem',
                                    background: 'rgba(56, 189, 248, 0.1)',
                                    border: '1px solid rgba(56, 189, 248, 0.3)',
                                    borderRadius: '4px',
                                    padding: '0.5rem',
                                    cursor: 'pointer',
                                    color: 'var(--accent)',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    zIndex: 10
                                }}
                                title={sidebarCollapsed ? 'Expand sidebar' : 'Collapse sidebar'}
                            >
                                {sidebarCollapsed ? '→' : '←'}
                            </button>
                            {/* Logo - use dark version for light theme */}
                            {!sidebarCollapsed && (
                                <div style={{ marginTop: '-0.25rem', marginBottom: '0.5rem' }}>
                                    <img src={theme === 'light' ? 'DoFO%20dark,%20transparent.png' : 'DoFO%20-%20White%20logo%20transparent%20bckgrnd.png'} alt="DoFO" style={{ width: '90%', maxWidth: '240px', marginLeft: '0px' }} />
                                </div>
                            )}

                            <div style={{ padding: sidebarCollapsed ? '0 0.25rem' : '0 0.5rem', display: 'flex', flexDirection: 'column', gap: '0.25rem', marginBottom: '1rem' }}>
                                {!sidebarCollapsed && (
                                    <>
                                        {schoolName && (
                                            <div style={{ animation: 'fadeIn 0.5s ease', marginBottom: '1rem', display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                                <h2 style={{ fontSize: '1.2rem', fontWeight: '700', lineHeight: '1.2', color: 'var(--text-primary)', marginBottom: '0' }}>
                                                    {schoolName}
                                                </h2>
                                                {teamLogo && (
                                                    <img
                                                        src={teamLogo}
                                                        alt="School Logo"
                                                        style={{ maxHeight: '60px', maxWidth: '100%', objectFit: 'contain', borderRadius: '4px', alignSelf: 'flex-start' }}
                                                    />
                                                )}
                                            </div>
                                        )}

                                        {/* School Switcher */}
                                        <SchoolSwitcher userId={authUser.uid} currentSchoolId={localStorage.getItem('hc_school_id')} />

                                        {/* Active Season Display (Moved to Top/Sticky) */}
                                        <div style={{ marginTop: '1rem' }}>
                                            <label style={{ fontSize: '0.65rem', color: 'var(--text-secondary)', textTransform: 'uppercase', letterSpacing: '0.05em', marginBottom: '0rem', display: 'block' }}>
                                                Active Season
                                            </label>
                                            <div style={{ fontSize: '1.1rem', fontWeight: 'bold', color: 'var(--text-primary)', letterSpacing: '0.05em' }}>
                                                {activeYear || '2024'}
                                            </div>
                                        </div>

                                        {/* Week Template Actions (Moved to Top/Sticky) */}
                                        <div style={{ marginBottom: '1rem', display: 'flex', flexDirection: 'column', gap: '0.25rem' }}>
                                            {globalWeekTemplates.length > 0 && (
                                                <select
                                                    className="form-select"
                                                    style={{ width: '100%', padding: '0.25rem 0.5rem', fontSize: '0.8rem', backgroundColor: 'rgba(0,0,0,0.1)', border: '1px dashed rgba(255,255,255,0.2)' }}
                                                    onChange={(e) => {
                                                        if (e.target.value) {
                                                            handleLoadWeekFromTemplate(e.target.value);
                                                            e.target.value = '';
                                                        }
                                                    }}
                                                    value=""
                                                >
                                                    <option value="" disabled>Apply Week Template...</option>
                                                    {globalWeekTemplates.map(t => (
                                                        <option key={t.id} value={t.id}>📋 {t.name}</option>
                                                    ))}
                                                </select>
                                            )}
                                        </div>
                                    </>
                                )}

                                {/* Core Navigation Buttons (Dashboard/Reports - Moved to Top/Sticky) */}



                                {currentPermissions.dashboard.view && (
                                    <button
                                        className={`nav-item ${view === 'practice-report' ? 'active' : ''}`}
                                        onClick={() => setView('practice-report')}
                                        style={{
                                            width: '100%',
                                            textAlign: 'left',
                                            border: 'none',
                                            background: 'none',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: sidebarCollapsed ? 'center' : 'flex-start',
                                            gap: '0.5rem',
                                            padding: sidebarCollapsed ? '0.75rem 0' : '0.5rem 0.75rem',
                                            marginBottom: '0.25rem'
                                        }}
                                    >
                                        <Icon name="Activity" size={18} color="var(--accent)" />
                                        {!sidebarCollapsed && <span style={{ fontWeight: '600' }}>PRACTICE REPORT</span>}
                                    </button>
                                )}

                                {!sidebarCollapsed && isSiteAdmin && (
                                    <div style={{ marginTop: '0.25rem' }}>
                                        <select
                                            className="form-select"
                                            value={currentUserId}
                                            onChange={(e) => {
                                                setCurrentUserId(e.target.value);
                                                setView('landing');
                                            }}
                                            style={{
                                                width: '100%',
                                                fontSize: '0.8rem',
                                                padding: '0.4rem',
                                                background: 'var(--surface)',
                                                border: '1px solid var(--border)',
                                                color: 'var(--accent)'
                                            }}
                                        >
                                            {staff.map(s => (
                                                <option key={s.id} value={s.id}>View as: {s.name}</option>
                                            ))}
                                        </select>
                                    </div>
                                )}

                                {!sidebarCollapsed && <div style={{ borderBottom: '1px solid var(--border)', marginTop: '0.5rem', marginBottom: '0.5rem' }}></div>}
                            </div>
                            <nav style={{ flex: 1, overflowY: 'auto' }}>

                                {/* Week Selector Section (Phase Breakdown) */}
                                {!sidebarCollapsed && (
                                    <>
                                        <div style={{ padding: '0 0.5rem 1.5rem 0.5rem', borderBottom: '1px solid var(--border)', marginBottom: '1rem' }}>
                                            <div style={{ marginBottom: '1rem' }}>
                                                <label style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', textTransform: 'uppercase', letterSpacing: '0.05em', marginBottom: '0.5rem', display: 'block' }}>
                                                    Phases / Weeks
                                                </label>
                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.25rem' }}>
                                                    {/* Offseason Phase */}
                                                    {weeks.filter(w => w.name === "Offseason").map(w => (
                                                        <CollapsibleCategory
                                                            key={w.id}
                                                            title="OFFSEASON"
                                                            icon={w.isLocked ? "Lock" : "Calendar"}
                                                            defaultOpen={currentWeekId === w.id}
                                                            onTitleClick={() => { setCurrentWeekId(w.id); setView('staff-meeting'); setShowManageWeekModal(false); }}
                                                        >
                                                            {renderWeeklyTools(w.id)}
                                                        </CollapsibleCategory>
                                                    ))}

                                                    {/* Summer Phase */}
                                                    <CollapsibleCategory title="SUMMER" icon="Sun" defaultOpen={false} onTitleClick={() => setView('summer-setup')}>
                                                        {weeks.filter(w => w.name.includes("Summer")).map(w => (
                                                            <CollapsibleCategory
                                                                key={w.id}
                                                                title={w.name}
                                                                icon={w.isLocked ? "Lock" : "Sun"}
                                                                defaultOpen={currentWeekId === w.id}
                                                                nested={true}
                                                                onTitleClick={() => { setCurrentWeekId(w.id); setView('staff-meeting'); setShowManageWeekModal(false); }}
                                                            >
                                                                {renderWeeklyTools(w.id)}
                                                            </CollapsibleCategory>
                                                        ))}
                                                    </CollapsibleCategory>

                                                    {/* Pre-Season Phase */}
                                                    <CollapsibleCategory title="PRE-SEASON" icon="Zap" defaultOpen={false} onTitleClick={() => setView('pre-season-setup')}>
                                                        {weeks.filter(w => ["Family Week", "Camp Week", "First Week of Practice", "Week 0"].includes(w.name)).map(w => (
                                                            <CollapsibleCategory
                                                                key={w.id}
                                                                title={`${w.name}${w.opponent ? ` - ${w.opponent}` : ''}${w.opponent && w.isHome !== undefined ? (w.isHome ? ' (H)' : ' (A)') : ''}`}
                                                                icon={w.isLocked ? "Lock" : "Zap"}
                                                                defaultOpen={currentWeekId === w.id}
                                                                nested={true}
                                                                onTitleClick={() => { setCurrentWeekId(w.id); setView('staff-meeting'); setShowManageWeekModal(false); }}
                                                            >
                                                                {renderWeeklyTools(w.id)}
                                                            </CollapsibleCategory>
                                                        ))}
                                                    </CollapsibleCategory>

                                                    {/* Season Setup */}
                                                    {/* Regular Season Phase */}
                                                    <CollapsibleCategory title="SEASON" icon="Trophy" defaultOpen={false} onTitleClick={() => setView('season-setup')}>
                                                        {weeks.filter(w => (w.name.startsWith("Week ") && !w.name.includes("Summer") && w.name !== "Week 0") || w.name === "First Week with No Game")
                                                            .sort((a, b) => {
                                                                const getNum = (item) => {
                                                                    if (item.weekNum !== undefined) return item.weekNum;
                                                                    const match = item.name.match(/Week (\d+)/);
                                                                    return match ? parseInt(match[1]) : 99;
                                                                };
                                                                return getNum(a) - getNum(b);
                                                            })
                                                            .map(w => (
                                                                <CollapsibleCategory
                                                                    key={w.id}
                                                                    title={`${w.name}${w.opponent ? ` - ${w.opponent}` : ''}${w.opponent && w.isHome !== undefined ? (w.isHome ? ' (H)' : ' (A)') : ''}`}
                                                                    icon={w.isLocked ? "Lock" : "Trophy"}
                                                                    defaultOpen={currentWeekId === w.id}
                                                                    nested={true}
                                                                    onTitleClick={() => { setCurrentWeekId(w.id); setView('staff-meeting'); setShowManageWeekModal(false); }}
                                                                >
                                                                    {renderWeeklyTools(w.id)}
                                                                </CollapsibleCategory>
                                                            ))}
                                                    </CollapsibleCategory>
                                                </div>
                                            </div>



                                            {/* SCHEME SETUP - Combined Offense/Defense/Special Teams */}
                                            {visibleFeatures.gameWeek?.enabled && visibleFeatures.gameWeek?.items?.schemeSetup && (
                                                <div style={{ marginBottom: '0.5rem' }}>
                                                    <div
                                                        onClick={() => setView('setup')}
                                                        className="nav-category-header"
                                                        style={{
                                                            display: 'flex',
                                                            alignItems: 'center',
                                                            padding: '0.75rem 0.5rem',
                                                            cursor: 'pointer',
                                                            color: view === 'setup' ? 'var(--primary)' : 'var(--text-secondary)',
                                                            fontWeight: 'bold',
                                                            fontSize: '0.9rem',
                                                            borderRadius: '6px',
                                                            transition: 'background 0.2s',
                                                            userSelect: 'none',
                                                            background: view === 'setup' ? 'var(--surface)' : 'transparent'
                                                        }}
                                                        onMouseEnter={e => e.currentTarget.style.background = 'var(--surface)'}
                                                        onMouseLeave={e => { if (view !== 'setup') e.currentTarget.style.background = 'transparent'; }}
                                                    >
                                                        <Icon name="Settings" size={18} style={{ marginRight: '0.5rem' }} />
                                                        <span style={{ textTransform: 'uppercase', letterSpacing: '0.05em', fontSize: '0.8rem' }}>Scheme Setup</span>
                                                    </div>
                                                </div>
                                            )}

                                            {/* MASTER PLAYBOOK */}
                                            {visibleFeatures.gameWeek?.enabled && visibleFeatures.gameWeek?.items?.playbook && (
                                                <div style={{ marginBottom: '0.5rem' }}>
                                                    <div
                                                        onClick={() => setView('playbook')}
                                                        className="nav-category-header"
                                                        style={{
                                                            display: 'flex',
                                                            alignItems: 'center',
                                                            padding: '0.75rem 0.5rem',
                                                            cursor: 'pointer',
                                                            color: view === 'playbook' ? 'var(--primary)' : 'var(--text-secondary)',
                                                            fontWeight: 'bold',
                                                            fontSize: '0.9rem',
                                                            borderRadius: '6px',
                                                            transition: 'background 0.2s',
                                                            userSelect: 'none',
                                                            background: view === 'playbook' ? 'var(--surface)' : 'transparent'
                                                        }}
                                                        onMouseEnter={e => e.currentTarget.style.background = 'var(--surface)'}
                                                        onMouseLeave={e => { if (view !== 'playbook') e.currentTarget.style.background = 'transparent'; }}
                                                    >
                                                        <Icon name="Book" size={18} style={{ marginRight: '0.5rem' }} />
                                                        <span style={{ textTransform: 'uppercase', letterSpacing: '0.05em', fontSize: '0.8rem' }}>Master Playbook</span>
                                                    </div>
                                                </div>
                                            )}



                                            {/* PERSONNEL CATEGORY (Moved from top) */}
                                            {currentPermissions.staff.view && (
                                                <CollapsibleCategory title="Personnel" icon="Users" defaultOpen={false}>
                                                    <button className={`nav-item ${view === 'staff-roster' ? 'active' : ''}`} onClick={() => setView('staff-roster')} style={{ paddingLeft: '2rem', width: '100%', textAlign: 'left', border: 'none', background: 'none' }}>
                                                        <Icon name="UserCog" size={16} style={{ marginRight: '8px' }} /> Staff & Roles
                                                    </button>
                                                    {/* Player Profiles moved to top level */}
                                                    <button className={`nav-item ${view === 'roster' ? 'active' : ''}`} onClick={() => setView('roster')} style={{ paddingLeft: '2rem', width: '100%', textAlign: 'left', border: 'none', background: 'none' }}>
                                                        <Icon name="Users" size={16} style={{ marginRight: '8px' }} /> Manage Roster
                                                    </button>
                                                    <button className={`nav-item ${view === 'archive' ? 'active' : ''}`} onClick={() => setView('archive')} style={{ paddingLeft: '2rem', width: '100%', textAlign: 'left', border: 'none', background: 'none' }}>
                                                        <Icon name="Archive" size={16} style={{ marginRight: '8px' }} /> Archive
                                                    </button>

                                                </CollapsibleCategory>
                                            )}





                                            {currentPermissions.dashboard.view && (
                                                <button
                                                    className={`nav-item ${view === 'print-hub' ? 'active' : ''}`}
                                                    onClick={() => setView('print-hub')}
                                                    style={{
                                                        width: '100%',
                                                        textAlign: 'left',
                                                        border: 'none',
                                                        background: 'none',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        justifyContent: sidebarCollapsed ? 'center' : 'flex-start',
                                                        gap: '0.75rem',
                                                        padding: sidebarCollapsed ? '0.75rem 0' : '0.75rem 1rem',
                                                        marginBottom: '0.5rem'
                                                    }}
                                                >
                                                    <Icon name="Printer" size={18} color="var(--accent)" />
                                                    {!sidebarCollapsed && <span style={{ fontWeight: '600' }}>PRINT CENTER</span>}
                                                </button>
                                            )}

                                        </div>
                                    </>
                                )}

                                {/* EQUIPMENT CATEGORY */}


                                <div style={{ marginTop: 'auto', paddingTop: '1rem', borderTop: '1px solid var(--border)', display: 'flex', flexDirection: 'column', gap: '0.25rem' }}>
                                    {(currentUser?.roles?.includes('Head Coach') || currentUser?.roles?.includes('Team Admin')) && (
                                        <button
                                            className={`nav-item ${view === 'settings' ? 'active' : ''}`}
                                            onClick={() => setView('settings')}
                                            style={{ width: '100%', textAlign: 'left', border: 'none', background: 'none', display: 'flex', alignItems: 'center', justifyContent: sidebarCollapsed ? 'center' : 'flex-start', padding: sidebarCollapsed ? '0.75rem 0' : '0.5rem 1rem' }}
                                        >
                                            <Icon name="Settings" size={16} />
                                            {!sidebarCollapsed && <span style={{ marginLeft: '8px' }}>Settings</span>}
                                        </button>
                                    )}
                                    {/* Site Admin - only visible to site admins */}
                                    {isSiteAdmin && (
                                        <button
                                            className={`nav-item ${view === 'admin' ? 'active' : ''}`}
                                            onClick={() => setView('admin')}
                                            style={{ width: '100%', textAlign: 'left', border: 'none', background: 'none', display: 'flex', alignItems: 'center', justifyContent: sidebarCollapsed ? 'center' : 'flex-start', padding: sidebarCollapsed ? '0.75rem 0' : '0.5rem 1rem', position: 'relative' }}
                                        >
                                            <Icon name="Shield" size={16} />
                                            {!sidebarCollapsed && <span style={{ marginLeft: '8px' }}>Site Admin</span>}
                                            {/* Notification badge for pending access requests */}
                                            {pendingAccessRequests > 0 && (
                                                <span style={{
                                                    position: 'absolute',
                                                    top: sidebarCollapsed ? '2px' : '50%',
                                                    right: sidebarCollapsed ? '2px' : '8px',
                                                    transform: sidebarCollapsed ? 'none' : 'translateY(-50%)',
                                                    background: '#ef4444',
                                                    color: 'white',
                                                    fontSize: '0.7rem',
                                                    fontWeight: 'bold',
                                                    minWidth: '18px',
                                                    height: '18px',
                                                    borderRadius: '9px',
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    justifyContent: 'center',
                                                    padding: '0 4px'
                                                }}>
                                                    {pendingAccessRequests}
                                                </span>
                                            )}
                                        </button>
                                    )}
                                    {currentUser && currentUser.roles && currentUser.roles.includes('Head Coach') && (
                                        <button
                                            className={`nav-item ${view === 'permissions' ? 'active' : ''}`}
                                            onClick={() => setView('permissions')}
                                            style={{ width: '100%', textAlign: 'left', border: 'none', background: 'none', display: 'flex', alignItems: 'center', justifyContent: sidebarCollapsed ? 'center' : 'flex-start', padding: sidebarCollapsed ? '0.75rem 0' : '0.5rem 1rem', color: 'var(--text-secondary)' }}
                                        >
                                            <Icon name="Lock" size={16} />
                                            {!sidebarCollapsed && <span style={{ marginLeft: '8px' }}>Permissions</span>}
                                        </button>
                                    )}
                                    <button
                                        className={`nav-item ${view === 'help' ? 'active' : ''}`}
                                        onClick={() => setView('help')}
                                        style={{ width: '100%', textAlign: 'left', border: 'none', background: 'none', display: 'flex', alignItems: 'center', justifyContent: sidebarCollapsed ? 'center' : 'flex-start', padding: sidebarCollapsed ? '0.75rem 0' : '0.5rem 1rem' }}
                                    >
                                        <Icon name="HelpCircle" size={16} />
                                        {!sidebarCollapsed && <span style={{ marginLeft: '8px' }}>How to Use</span>}
                                    </button>
                                    <button
                                        className="nav-item"
                                        onClick={() => setShowLogoutConfirm(true)}
                                        style={{
                                            width: '100%',
                                            textAlign: 'left',
                                            border: 'none',
                                            background: 'none',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: sidebarCollapsed ? 'center' : 'flex-start',
                                            padding: sidebarCollapsed ? '0.75rem 0' : '0.5rem 1rem',
                                            color: 'var(--danger)',
                                            opacity: 0.8
                                        }}
                                        onMouseOver={(e) => e.currentTarget.style.opacity = '1'}
                                        onMouseOut={(e) => e.currentTarget.style.opacity = '0.8'}
                                    >
                                        <Icon name="LogOut" size={16} />
                                        {!sidebarCollapsed && <span style={{ marginLeft: '8px' }}>Log Out</span>}
                                    </button>
                                </div>
                            </nav>
                        </div >

                        <main className="main-content" style={{ marginRight: globalSidebarOpen ? '384px' : '24px', transition: 'margin-right 0.3s ease-in-out' }}>
                            {view === 'staff-meeting' && (
                                <div style={{ height: '100%', display: 'flex', flexDirection: 'column', gap: '1rem', overflow: 'auto', padding: '1rem' }}>
                                    {/* Header */}
                                    <div className="card" style={{ padding: '2rem', background: 'linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%)', color: 'white' }}>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                                            <h2 style={{ margin: 0, display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                <Icon name="LayoutDashboard" size={28} />
                                                {currentWeek.name} Dashboard
                                            </h2>
                                            <button
                                                className="btn"
                                                onClick={() => setShowManageWeekModal(true)}
                                                style={{ background: 'rgba(255,255,255,0.2)', color: 'white', border: '1px solid rgba(255,255,255,0.4)', display: 'flex', alignItems: 'center', gap: '8px' }}
                                            >
                                                <Icon name="Settings" size={18} />
                                                Manage Week
                                            </button>
                                        </div>
                                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1.5rem' }}>
                                            <div>
                                                <div style={{ fontSize: '0.9rem', opacity: 0.9, marginBottom: '0.5rem' }}>Week</div>
                                                <div style={{ fontSize: '2rem', fontWeight: 'bold' }}>{currentWeek.name}</div>
                                            </div>
                                            {currentWeek.opponent && (
                                                <div>
                                                    <div style={{ fontSize: '0.9rem', opacity: 0.9, marginBottom: '0.5rem' }}>Opponent</div>
                                                    <div style={{ fontSize: '2rem', fontWeight: 'bold' }}>{currentWeek.opponent}</div>
                                                </div>
                                            )}
                                            <div>
                                                <div style={{ fontSize: '0.9rem', opacity: 0.9, marginBottom: '0.5rem' }}>Practice Plans</div>
                                                <div style={{ fontSize: '2rem', fontWeight: 'bold' }}>{currentWeek.practicePlans?.length || 0}</div>
                                            </div>
                                            <div>
                                                <div style={{ fontSize: '0.9rem', opacity: 0.9, marginBottom: '0.5rem' }}>Active Players</div>
                                                <div style={{ fontSize: '2rem', fontWeight: 'bold' }}>{roster.filter(p => p.status === 'Active').length}</div>
                                            </div>
                                        </div>
                                    </div>


                                    {/* Weekly Analytics Dashboard */}
                                    {view === 'staff-meeting' && (
                                        <WeeklyAnalytics
                                            currentWeek={currentWeek}
                                            plays={plays}
                                            practicePlans={currentWeek.practicePlans || {}}
                                        />
                                    )}


                                    {/* Quick Links */}
                                    <div className="card" style={{ padding: '1.5rem' }}>
                                        <h3 style={{ margin: '0 0 1rem 0', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                            <Icon name="Zap" size={20} />
                                            Quick Links
                                        </h3>
                                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '1rem' }}>
                                            <button onClick={() => setView('practice')} className="card" style={{ padding: '1rem', background: 'var(--surface)', border: '1px solid var(--border)', borderRadius: '8px', cursor: 'pointer', textAlign: 'left', transition: 'transform 0.2s' }}>
                                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '0.5rem' }}>
                                                    <Icon name="Megaphone" size={18} style={{ color: 'var(--text-primary)' }} />
                                                    <span style={{ fontWeight: 'bold', color: 'var(--text-primary)', lineHeight: '1' }}>Practice Plans</span>
                                                </div>
                                                <div style={{ fontSize: '0.85rem', color: 'var(--text-secondary)' }}>View and edit practice schedules</div>
                                            </button>
                                            <button onClick={() => setView('install-manager')} className="card" style={{ padding: '1rem', background: 'var(--surface)', border: '1px solid var(--border)', borderRadius: '8px', cursor: 'pointer', textAlign: 'left', transition: 'transform 0.2s' }}>
                                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '0.5rem' }}>
                                                    <Icon name="Layers" size={18} style={{ color: 'var(--text-primary)' }} />
                                                    <span style={{ fontWeight: 'bold', color: 'var(--text-primary)', lineHeight: '1' }}>Install Manager</span>
                                                </div>
                                                <div style={{ fontSize: '0.85rem', color: 'var(--text-secondary)' }}>Manage weekly installations</div>
                                            </button>
                                            <button onClick={() => setView('scouting')} className="card" style={{ padding: '1rem', background: 'var(--surface)', border: '1px solid var(--border)', borderRadius: '8px', cursor: 'pointer', textAlign: 'left', transition: 'transform 0.2s' }}>
                                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '0.5rem' }}>
                                                    <Icon name="Search" size={18} style={{ color: 'var(--text-primary)' }} />
                                                    <span style={{ fontWeight: 'bold', color: 'var(--text-primary)', lineHeight: '1' }}>Scouting</span>
                                                </div>
                                                <div style={{ fontSize: '0.85rem', color: 'var(--text-secondary)' }}>Scout opponent tendencies</div>
                                            </button>
                                            <button onClick={() => { setView('depth'); setDepthChartType('OFFENSE'); }} className="card" style={{ padding: '1rem', background: 'var(--surface)', border: '1px solid var(--border)', borderRadius: '8px', cursor: 'pointer', textAlign: 'left', transition: 'transform 0.2s' }}>
                                                <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '0.5rem' }}>
                                                    <Icon name="Users" size={18} style={{ color: 'var(--text-primary)' }} />
                                                    <span style={{ fontWeight: 'bold', color: 'var(--text-primary)', lineHeight: '1' }}>Depth Charts</span>
                                                </div>
                                                <div style={{ fontSize: '0.85rem', color: 'var(--text-secondary)' }}>Manage player positions</div>
                                            </button>
                                        </div>
                                    </div>

                                </div>
                            )}
                            
                            {view === 'print-hub' && <PrintHubView roster={roster} staff={staff} gamePlans={currentWeek.offensiveGamePlan} depthChart={currentWeek.depthChart || depthChart} practicePlans={currentWeek.practicePlans} attendance={attendance} wbSettings={currentWeek.wristbands || wbSettings} setWbSettings={handleUpdateWristbands} plays={plays} personnelGroupings={personnelGroupings} />}

                            {view === 'permissions' && <PermissionsView permissions={permissions} onUpdatePermissions={setPermissions} onResetDefaults={() => setPermissions(DEFAULT_PERMISSIONS)} />}

                            {view === 'dashboard' && <GamedayDashboard plays={plays} />}

                            {view === 'season-setup' && <SeasonSetupView weeks={weeks} onUpdateWeek={handleUpdateWeek} onAddWeek={handleAddWeek} onDeleteWeek={handleDeleteWeek} mode="season" />}
                            {view === 'pre-season-setup' && <SeasonSetupView weeks={weeks} onUpdateWeek={handleUpdateWeek} onAddWeek={handleAddWeek} onDeleteWeek={handleDeleteWeek} mode="pre-season" />}
                            {view === 'summer-setup' && <SeasonSetupView weeks={weeks} onUpdateWeek={handleUpdateWeek} onAddWeek={handleAddWeek} onDeleteWeek={handleDeleteWeek} mode="summer" />}
                            {/* REMOVED: Budget view (~182 lines) - check git history */}

                            {/* REMOVED: culturalCalibration and onboarding views */}
                            {false && (
                                    <div style={{ height: '100%', display: 'flex', flexDirection: 'column', gap: '1rem', overflow: 'auto', padding: '1rem' }}>
                                        {/* Header */}
                                        <div className="card" style={{ padding: '2rem', background: 'linear-gradient(135deg, var(--primary) 0%, var(--accent) 100%)', color: 'white' }}>
                                            <h2 style={{ margin: '0 0 1.5rem 0', display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                <Icon name="UserPlus" size={28} />
                                                Onboarding Dashboard
                                            </h2>
                                            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))', gap: '1.5rem' }}>
                                                <div>
                                                    <div style={{ fontSize: '0.9rem', opacity: 0.9, marginBottom: '0.5rem' }}>Total People</div>
                                                    <div style={{ fontSize: '2rem', fontWeight: 'bold' }}>{totalPeople}</div>
                                                </div>
                                                <div>
                                                    <div style={{ fontSize: '0.9rem', opacity: 0.9, marginBottom: '0.5rem' }}>Fully Complete</div>
                                                    <div style={{ fontSize: '2rem', fontWeight: 'bold', color: '#86efac' }}>{fullyCompleted}</div>
                                                </div>
                                                <div>
                                                    <div style={{ fontSize: '0.9rem', opacity: 0.9, marginBottom: '0.5rem' }}>In Progress</div>
                                                    <div style={{ fontSize: '2rem', fontWeight: 'bold', color: '#fcd34d' }}>{inProgress}</div>
                                                </div>
                                                <div>
                                                    <div style={{ fontSize: '0.9rem', opacity: 0.9, marginBottom: '0.5rem' }}>Not Started</div>
                                                    <div style={{ fontSize: '2rem', fontWeight: 'bold', color: '#fca5a5' }}>{notStarted}</div>
                                                </div>
                                            </div>
                                        </div>

                                        {/* Filter */}
                                        <div style={{ display: 'flex', gap: '0.5rem', padding: '0.5rem 0' }}>
                                            <span style={{ fontWeight: 'bold', marginRight: '0.5rem' }}>Filter:</span>
                                            {['All', 'Player', 'Coach', 'Manager'].map(role => (
                                                <button key={role} onClick={() => setOnboardingRoleFilter(role)} style={{ padding: '0.5rem 1rem', border: 'none', background: onboardingRoleFilter === role ? 'var(--primary)' : 'var(--surface)', color: onboardingRoleFilter === role ? 'white' : 'var(--text)', borderRadius: '6px', cursor: 'pointer', fontWeight: onboardingRoleFilter === role ? 'bold' : 'normal' }}>
                                                    {role}
                                                </button>
                                            ))}
                                        </div>

                                        {/* People List */}
                                        <div className="card" style={{ padding: '1.5rem' }}>
                                            <h3 style={{ margin: '0 0 1rem 0' }}>People ({filteredPeople.length})</h3>
                                            {filteredPeople.length === 0 ? (
                                                <div style={{ padding: '2rem', textAlign: 'center', color: 'var(--text-secondary)', fontStyle: 'italic' }}>
                                                    No people found. Add players to your roster or staff members to see them here.
                                                </div>
                                            ) : (
                                                <div style={{ display: 'grid', gap: '1rem' }}>
                                                    {filteredPeople.map(person => {
                                                        const stats = getCompletionStats(person);
                                                        const statusColor = stats.percentage === 100 ? '#10b981' : stats.percentage > 0 ? '#f59e0b' : '#6b7280';
                                                        return (
                                                            <div key={person.id} className="card" style={{ padding: '1rem', background: 'var(--surface)', cursor: 'pointer', transition: 'transform 0.2s' }} onClick={() => setOnboardingSelectedPerson(person)}>
                                                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '0.75rem' }}>
                                                                    <div>
                                                                        <div style={{ fontWeight: 'bold', fontSize: '1.1rem' }}>{person.name}</div>
                                                                        <div style={{ fontSize: '0.9rem', color: 'var(--text-secondary)' }}>{person.role}</div>
                                                                    </div>
                                                                    <div style={{ textAlign: 'right' }}>
                                                                        <div style={{ fontSize: '1.5rem', fontWeight: 'bold', color: statusColor }}>{stats.percentage}%</div>
                                                                        <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>{stats.completed}/{stats.total} complete</div>
                                                                    </div>
                                                                </div>
                                                                <div style={{ background: 'var(--background)', borderRadius: '999px', height: '8px', overflow: 'hidden' }}>
                                                                    <div style={{ width: `${stats.percentage}%`, height: '100%', background: statusColor, transition: 'width 0.3s' }}></div>
                                                                </div>
                                                            </div>
                                                        );
                                                    })}
                                                </div>
                                            )}
                                        </div>

                                        {/* Detail Modal */}
                                        {onboardingSelectedPerson && (() => {
                                            const personData = getPersonOnboardingData(onboardingSelectedPerson.id, onboardingSelectedPerson.role);
                                            return (
                                                <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.5)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000 }} onClick={() => setOnboardingSelectedPerson(null)}>
                                                    <div className="card" style={{ width: '90%', maxWidth: '600px', maxHeight: '80vh', overflow: 'auto', padding: '2rem', background: 'var(--background)' }} onClick={(e) => e.stopPropagation()}>
                                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem' }}>
                                                            <div>
                                                                <h2 style={{ margin: 0 }}>{onboardingSelectedPerson.name}</h2>
                                                                <div style={{ color: 'var(--text-secondary)' }}>{onboardingSelectedPerson.role}</div>
                                                            </div>
                                                            <button onClick={() => setOnboardingSelectedPerson(null)} style={{ padding: '0.5rem', background: 'var(--surface)', border: 'none', borderRadius: '6px', cursor: 'pointer' }}>
                                                                <Icon name="X" size={20} />
                                                            </button>
                                                        </div>

                                                        <div style={{ marginBottom: '1.5rem' }}>
                                                            <div style={{ fontSize: '2rem', fontWeight: 'bold', color: getCompletionStats(onboardingSelectedPerson).percentage === 100 ? '#10b981' : '#f59e0b' }}>
                                                                {getCompletionStats(onboardingSelectedPerson).percentage}% Complete
                                                            </div>
                                                            <div style={{ fontSize: '0.9rem', color: 'var(--text-secondary)' }}>
                                                                {getCompletionStats(onboardingSelectedPerson).completed} of {getCompletionStats(onboardingSelectedPerson).total} items completed
                                                            </div>
                                                        </div>

                                                        <h3 style={{ marginBottom: '1rem' }}>Onboarding Checklist</h3>
                                                        <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
                                                            {getRequiredItems(onboardingSelectedPerson.role).map(itemKey => {
                                                                const item = personData[itemKey] || { completed: false, dateCompleted: null, notes: '' };
                                                                return (
                                                                    <div key={itemKey} className="card" style={{ padding: '1rem', background: item.completed ? 'rgba(16, 185, 129, 0.1)' : 'var(--surface)' }}>
                                                                        <div style={{ display: 'flex', alignItems: 'flex-start', gap: '0.75rem' }}>
                                                                            <input type="checkbox" checked={item.completed} onChange={(e) => updatePersonItem(onboardingSelectedPerson.id, onboardingSelectedPerson.role, itemKey, 'completed', e.target.checked)} style={{ marginTop: '0.25rem', width: '20px', height: '20px', cursor: 'pointer' }} />
                                                                            <div style={{ flex: 1 }}>
                                                                                <div style={{ fontWeight: 'bold', marginBottom: '0.5rem', textDecoration: item.completed ? 'line-through' : 'none' }}>
                                                                                    {getItemLabel(itemKey)}
                                                                                </div>
                                                                                {item.completed && item.dateCompleted && (
                                                                                    <div style={{ fontSize: '0.85rem', color: '#10b981', marginBottom: '0.5rem' }}>
                                                                                        ✓ Completed on {new Date(item.dateCompleted).toLocaleDateString()}
                                                                                    </div>
                                                                                )}
                                                                                <input className="form-input" placeholder="Notes (optional)" value={item.notes} onChange={(e) => updatePersonItem(onboardingSelectedPerson.id, onboardingSelectedPerson.role, itemKey, 'notes', e.target.value)} style={{ fontSize: '0.9rem', marginTop: '0.5rem' }} />
                                                                            </div>
                                                                        </div>
                                                                    </div>
                                                                );
                                                            })}
                                                        </div>

                                                        <div style={{ marginTop: '1.5rem' }}>
                                                            <button className="btn-primary" onClick={() => setOnboardingSelectedPerson(null)} style={{ width: '100%' }}>Close</button>
                                                        </div>
                                                    </div>
                                                </div>
                                            );
                                        })()}
                                    </div>
                                )
                            }



                            {/* Unified Setup View with Phase Tabs */}
                            {(view === 'setup' || view === 'offense-setup' || view === 'defense-setup' || view === 'st-setup' || view === 'practice-setup') && (
                                <div style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                                    {/* Phase Tabs (Offense/Defense/Special Teams) */}
                                    <div style={{
                                        display: 'flex',
                                        gap: '4px',
                                        padding: '1rem 2rem 0 2rem',
                                        background: 'var(--bg-alt)',
                                        borderBottom: '1px solid var(--border)'
                                    }}>
                                        {[
                                            { key: 'OFFENSE', label: 'Offense', icon: 'Zap' },
                                            { key: 'DEFENSE', label: 'Defense', icon: 'Shield' },
                                            { key: 'SPECIAL_TEAMS', label: 'Special Teams', icon: 'Target' },
                                            { key: 'PRACTICE', label: 'Practice', icon: 'Clipboard' }
                                        ].map(tab => {
                                            const isActive = setupPhase === tab.key ||
                                                (view === 'offense-setup' && tab.key === 'OFFENSE') ||
                                                (view === 'defense-setup' && tab.key === 'DEFENSE') ||
                                                (view === 'st-setup' && tab.key === 'SPECIAL_TEAMS') ||
                                                (view === 'practice-setup' && tab.key === 'PRACTICE');
                                            return (
                                                <button
                                                    key={tab.key}
                                                    onClick={() => {
                                                        setSetupPhase(tab.key);
                                                        if (view !== 'setup') setView('setup');
                                                    }}
                                                    style={{
                                                        padding: '12px 24px',
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        gap: '8px',
                                                        background: isActive ? 'var(--bg-main)' : 'transparent',
                                                        border: isActive ? '1px solid var(--border)' : '1px solid transparent',
                                                        borderBottom: isActive ? '1px solid var(--bg-main)' : '1px solid transparent',
                                                        borderRadius: '8px 8px 0 0',
                                                        marginBottom: '-1px',
                                                        color: isActive ? 'var(--text-primary)' : 'var(--text-secondary)',
                                                        fontWeight: isActive ? '700' : '500',
                                                        fontSize: '0.9rem',
                                                        cursor: 'pointer',
                                                        transition: 'all 0.2s'
                                                    }}
                                                >
                                                    <Icon name={tab.icon} size={18} />
                                                    {tab.label}
                                                </button>
                                            );
                                        })}
                                    </div>

                                    {/* Setup Content */}
                                    <div style={{ flex: 1, overflow: 'auto' }}>
                                        {renderSetup(
                                            view === 'offense-setup' ? 'OFFENSE' :
                                            view === 'defense-setup' ? 'DEFENSE' :
                                            view === 'st-setup' ? 'SPECIAL_TEAMS' :
                                            view === 'practice-setup' ? 'PRACTICE' :
                                            setupPhase
                                        )}
                                    </div>
                                </div>
                            )}

                            {
                                view === 'new-play' && (
                                    <PlayInput
                                        onSave={handleSavePlay}
                                        onCancel={() => { setEditingPlay(null); setView('playbook'); }}
                                        onDelete={handleDeletePlay}
                                        initialData={editingPlay}
                                        wizLibrary={wizLibrary}
                                        setWizLibrary={setWizLibrary}
                                        positionNames={positionNames}
                                        positionColors={positionColors}
                                        formations={formations}
                                        playSyntax={playSyntax}
                                        termLibrary={termLibrary}
                                        playCategories={playCategories}
                                        playBuckets={playBuckets}
                                        onAddFormation={handleAddFormation}
                                        passProtections={passProtections}
                                        setPassProtections={setPassProtections}
                                        runBlocking={runBlocking}
                                        setRunBlocking={setRunBlocking}
                                        customTagCategories={customTagCategories}
                                        setCustomTagCategories={setCustomTagCategories}
                                    />
                                )
                            }

                            {view === 'install-manager' && <InstallManagerView plays={plays} week={currentWeek} weeks={weeks} currentWeekId={currentWeekId} onUpdateWeek={handleUpdateWeek} gamePlan={currentWeek.offensiveGamePlan} practicePlans={currentWeek.practicePlans} wbSettings={currentWeek.wristbands || wbSettings} onQuickAddPlay={handleQuickAddPlay} playSyntax={playSyntax} onUpdatePlay={handlePatchPlay} gamePlanLayouts={currentWeek.gamePlanLayouts || gamePlanLayouts} defaultWbSettings={getGlobalWbSettings()} defaultDepthChart={getGlobalDepthCharts()} defaultZonePhilosophies={getGlobalZonePhilosophies()} playCategories={playCategories} playBuckets={playBuckets} />}
                            {view === 'practice-report' && <PracticeReportView
                                weeks={weeks}
                                plays={plays}
                                playSyntax={playSyntax}
                                parsePlayName={parsePlayName}
                                currentWeek={currentWeek}
                                playCategories={playCategories}
                                playBuckets={playBuckets}
                                onUpdatePlans={(updated) => handleUpdateWeek(currentWeek.id, 'practicePlans', updated)}
                                onNavigate={setView}
                            />}
                            {view === 'game-plan' && <OffensiveGamePlan
                                plays={plays}
                                weekDate={currentWeek.date}
                                gamePlan={currentWeek.offensiveGamePlan}
                                practicePlans={currentWeek.practicePlans}
                                onUpdateGamePlan={(updated) => handleUpdateWeek(currentWeek.id, 'offensiveGamePlan', updated)}
                                onQuickAddPlay={handleQuickAddPlay}
                                onUpdatePlay={handlePatchPlay}
                                gamePlanLayouts={currentWeek.gamePlanLayouts || gamePlanLayouts}
                                weeks={weeks}
                                currentWeek={currentWeek}
                                onUpdateLayouts={(newLayouts) => {
                                    // Update WEEK specific layout
                                    handleUpdateWeek(currentWeek.id, 'gamePlanLayouts', newLayouts);
                                }}
                                isLocked={currentWeek.isLocked}
                                layoutVersions={layoutVersions}
                                onSaveLayoutVersion={saveLayoutVersion}
                                onDeleteLayoutVersion={deleteLayoutVersion}
                                onLoadLayoutVersion={loadLayoutVersion}
                                wbSettings={currentWeek.wristbands || wbSettings}
                                newInstallIds={currentWeek.newInstallIds}
                                onUpdateWeek={handleUpdateWeek}
                                playCategories={playCategories}
                                playBuckets={playBuckets}
                                setAppSidebarCollapsed={setSidebarCollapsed}
                                appSidebarCollapsed={sidebarCollapsed}
                                addToNextSlotRef={addToNextSlotRef}
                                teamLogo={teamLogo}
                                positionNames={positionNames}
                                customPositions={customPositions}
                                hiddenPositions={hiddenPositions}
                                suggestions={currentWeek.suggestions || {}}
                                onUpdateSuggestions={(newSuggestions) => handleUpdateWeek(currentWeek.id, 'suggestions', newSuggestions)}
                            />}

                            {
                                view === 'playbook' && (
                                    <div>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                            <h2>Master Playbook ({filteredPlaybook.length} / {plays.length})</h2>
                                            <div style={{ display: 'flex', gap: '1rem' }}>
                                                {selectedPlays.length > 0 && (
                                                    <button className="btn" style={{ backgroundColor: '#ef4444', color: 'white' }} onClick={handleDeleteSelected}>
                                                        <Icon name="Trash2" /> Delete Selected ({selectedPlays.length})
                                                    </button>
                                                )}
                                                <button className="btn" style={{ backgroundColor: '#10b981', color: 'white' }} onClick={() => setIsBatchImportOpen(true)}>
                                                    <Icon name="FileText" /> Batch Add Plays
                                                </button>
                                                <button className="btn btn-primary" onClick={() => { setEditingPlay(null); setView('new-play'); }}>
                                                    <Icon name="PlusCircle" /> New Play
                                                </button>
                                            </div>
                                        </div>

                                        <div style={{
                                            marginBottom: '2rem',
                                            padding: '1.5rem',
                                            background: 'var(--bg-panel)',
                                            border: '1px solid var(--border)',
                                            borderRadius: '12px'
                                        }}>
                                            <div style={{
                                                display: 'flex',
                                                justifyContent: 'space-between',
                                                alignItems: 'center',
                                                marginBottom: '1.25rem',
                                                paddingBottom: '0.75rem',
                                                borderBottom: '1px solid var(--border)'
                                            }}>
                                                <h4 style={{
                                                    margin: 0,
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    gap: '0.5rem',
                                                    fontSize: '0.85rem',
                                                    fontWeight: 'bold',
                                                    textTransform: 'uppercase',
                                                    letterSpacing: '0.05em',
                                                    color: 'var(--text-secondary)'
                                                }}>
                                                    <Icon name="Filter" size={14} style={{ color: 'var(--accent)' }} />
                                                    Search & Filter Playbook
                                                </h4>
                                                <div style={{ display: 'flex', gap: '0.75rem' }}>
                                                    {selectedPlays.length > 0 && (
                                                        <button
                                                            className="btn"
                                                            style={{
                                                                fontSize: '0.8rem',
                                                                padding: '0.4rem 0.8rem',
                                                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                                                color: '#ef4444',
                                                                border: '1px solid rgba(239, 68, 68, 0.2)'
                                                            }}
                                                            onClick={() => setSelectedPlays([])}
                                                        >
                                                            Clear Selection ({selectedPlays.length})
                                                        </button>
                                                    )}
                                                    <button
                                                        className="btn"
                                                        style={{
                                                            fontSize: '0.8rem',
                                                            padding: '0.4rem 0.8rem',
                                                            color: 'var(--accent)',
                                                            background: 'rgba(var(--accent-rgb), 0.1)',
                                                            border: '1px solid rgba(var(--accent-rgb), 0.2)'
                                                        }}
                                                        onClick={() => setPlaybookFilters({ formation: '', playCategory: '', bucketId: '', situation: '', tag: '' })}
                                                    >
                                                        <Icon name="FilterX" size={14} style={{ marginRight: '4px' }} />
                                                        Clear Filters
                                                    </button>
                                                </div>
                                            </div>

                                            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1.25rem' }}>
                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                                    <label style={{ fontSize: '0.75rem', fontWeight: 'bold', color: 'var(--text-secondary)', textTransform: 'uppercase' }}>Search Plays</label>
                                                    <div style={{ position: 'relative' }}>
                                                        <Icon name="Search" size={14} style={{ position: 'absolute', left: '0.75rem', top: '50%', transform: 'translateY(-50%)', color: 'var(--text-muted)', zIndex: 1 }} />
                                                        <input
                                                            className="form-input"
                                                            placeholder="Name or formation..."
                                                            value={searchTerm}
                                                            onChange={e => setSearchTerm(e.target.value)}
                                                            style={{ paddingLeft: '2.25rem', width: '100%' }}
                                                        />
                                                        {searchTerm && searchTerm.length >= 2 && (() => {
                                                            const search = searchTerm.toLowerCase();
                                                            const suggestions = plays
                                                                .filter(p => p.name.toLowerCase().includes(search) || (p.formation && p.formation.toLowerCase().includes(search)))
                                                                .slice(0, 8);
                                                            if (suggestions.length === 0) return null;
                                                            return (
                                                                <div style={{
                                                                    position: 'absolute',
                                                                    top: '100%',
                                                                    left: 0,
                                                                    right: 0,
                                                                    background: 'var(--bg-panel)',
                                                                    border: '1px solid var(--border)',
                                                                    borderRadius: '0 0 6px 6px',
                                                                    boxShadow: '0 4px 12px rgba(0,0,0,0.15)',
                                                                    zIndex: 100,
                                                                    maxHeight: '300px',
                                                                    overflowY: 'auto'
                                                                }}>
                                                                    {suggestions.map(play => (
                                                                        <div
                                                                            key={play.id}
                                                                            onClick={() => {
                                                                                setSearchTerm(play.name);
                                                                                // Scroll to the play card
                                                                                setTimeout(() => {
                                                                                    const card = document.querySelector(`[data-play-id="${play.id}"]`);
                                                                                    if (card) card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                                                                }, 100);
                                                                            }}
                                                                            style={{
                                                                                padding: '0.6rem 0.75rem',
                                                                                cursor: 'pointer',
                                                                                borderBottom: '1px solid var(--border)',
                                                                                display: 'flex',
                                                                                justifyContent: 'space-between',
                                                                                alignItems: 'center'
                                                                            }}
                                                                            onMouseEnter={e => e.currentTarget.style.background = 'var(--bg-hover)'}
                                                                            onMouseLeave={e => e.currentTarget.style.background = 'transparent'}
                                                                        >
                                                                            <span style={{ fontWeight: '500' }}>{play.name}</span>
                                                                            {play.formation && (
                                                                                <span style={{ fontSize: '0.75rem', color: 'var(--text-secondary)', marginLeft: '0.5rem' }}>{play.formation}</span>
                                                                            )}
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            );
                                                        })()}
                                                    </div>
                                                </div>

                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                                    <label style={{ fontSize: '0.75rem', fontWeight: 'bold', color: 'var(--text-secondary)', textTransform: 'uppercase' }}>Formation</label>
                                                    <select
                                                        className="form-input"
                                                        value={playbookFilters.formation}
                                                        onChange={e => setPlaybookFilters({ ...playbookFilters, formation: e.target.value })}
                                                    >
                                                        <option value="">All Formations</option>
                                                        {Array.from(new Set(plays.map(p => p.formation).filter(Boolean))).sort().map(f => (
                                                            <option key={f} value={f}>{f}</option>
                                                        ))}
                                                    </select>
                                                </div>

                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                                    <label style={{ fontSize: '0.75rem', fontWeight: 'bold', color: 'var(--text-secondary)', textTransform: 'uppercase' }}>Play Bucket</label>
                                                    <select
                                                        className="form-input"
                                                        value={playbookFilters.playCategory}
                                                        onChange={e => setPlaybookFilters({ ...playbookFilters, playCategory: e.target.value })}
                                                    >
                                                        <option value="">All Buckets</option>
                                                        {playCategories.map(cat => (
                                                            <option key={cat.id} value={cat.id}>{cat.label}</option>
                                                        ))}
                                                    </select>
                                                </div>

                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                                    <label style={{ fontSize: '0.75rem', fontWeight: 'bold', color: 'var(--text-secondary)', textTransform: 'uppercase' }}>Play Family</label>
                                                    <select
                                                        className="form-input"
                                                        value={playbookFilters.bucketId}
                                                        onChange={e => setPlaybookFilters({ ...playbookFilters, bucketId: e.target.value })}
                                                    >
                                                        <option value="">All Families</option>
                                                        {playBuckets
                                                            .filter(bucket => !playbookFilters.playCategory || bucket.categoryId === playbookFilters.playCategory)
                                                            .map(bucket => (
                                                                <option key={bucket.id} value={bucket.id}>{bucket.label}</option>
                                                            ))}
                                                    </select>
                                                </div>

                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                                    <label style={{ fontSize: '0.75rem', fontWeight: 'bold', color: 'var(--text-secondary)', textTransform: 'uppercase' }}>Situation</label>
                                                    <select
                                                        className="form-input"
                                                        value={playbookFilters.situation}
                                                        onChange={e => setPlaybookFilters({ ...playbookFilters, situation: e.target.value })}
                                                    >
                                                        <option value="">All Situations</option>
                                                        {Object.keys(TAG_CATEGORIES).filter(cat => ["Situation", "Field Position", "Down & Distance"].includes(cat)).map(cat => (
                                                            <optgroup key={cat} label={cat}>
                                                                {TAG_CATEGORIES[cat].map(tag => (
                                                                    <option key={tag} value={tag}>{tag}</option>
                                                                ))}
                                                            </optgroup>
                                                        ))}
                                                    </select>
                                                </div>

                                                <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
                                                    <label style={{ fontSize: '0.75rem', fontWeight: 'bold', color: 'var(--text-secondary)', textTransform: 'uppercase' }}>Tag</label>
                                                    <select
                                                        className="form-input"
                                                        value={playbookFilters.tag}
                                                        onChange={e => setPlaybookFilters({ ...playbookFilters, tag: e.target.value })}
                                                    >
                                                        <option value="">All Tags</option>
                                                        {allTags.map(t => (
                                                            <option key={t} value={t}>{t}</option>
                                                        ))}
                                                    </select>
                                                </div>
                                            </div>
                                        </div>

                                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(280px, 1fr))', gap: '1rem' }}>
                                            {filteredPlaybook.map(play => (
                                                <PlayCard
                                                    key={play.id}
                                                    play={play}
                                                    isSelected={selectedPlays.includes(play.id)}
                                                    onToggleSelect={(playId, e) => togglePlaySelection(playId, e?.shiftKey)}
                                                    onEdit={() => { setEditingPlay(play); setView('new-play'); }}
                                                    onQuickEdit={(play, x, y) => setQuickEditModalState({ playId: play.id, x, y })}
                                                />
                                            ))}
                                        </div>
                                        {quickEditModalState && (() => {
                                            const { playId, x, y } = quickEditModalState;
                                            const play = filteredPlaybook.find(p => p.id === playId);
                                            return (
                                                <PlayDetailsModal
                                                    play={play}
                                                    plays={plays}
                                                    gamePlanLayouts={gamePlanLayouts}
                                                    gamePlan={currentWeek?.offensiveGamePlan}
                                                    week={currentWeek}
                                                    onUpdatePlay={handleUpdatePlay}
                                                    onUpdateWeek={handleUpdateWeek}
                                                    onClose={() => setQuickEditModalState(null)}
                                                    position={{ x, y }}
                                                    playCategories={playCategories}
                                                />
                                            );
                                        })()}

                                    </div>
                                )
                            }




                            {view === 'roster' && <RosterManager roster={roster} onUpdateRoster={setRoster} depthChart={depthChart} />}

                            {view === 'staff-roster' && <StaffManager currentUser={currentUser} staff={staff} onUpdateStaff={setStaff} teamLogo={teamLogo} />}

                            {view === 'archive' && <ArchiveManager roster={roster} staff={staff} onUpdateRoster={setRoster} onUpdateStaff={setStaff} />}
                            {view === 'depth' && (
                                <div className="depth-view-container" style={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                                    {/* Hide top bar when printing all */}
                                    {!isViewingAll && (
                                        <div style={{
                                            display: 'flex',
                                            gap: '0.5rem',
                                            padding: '1rem',
                                            background: 'var(--surface)',
                                            borderBottom: '1px solid var(--border)',
                                            alignItems: 'center',
                                            overflowX: 'auto'
                                        }}>
                                            {DEPTH_CHART_TYPES.map(tab => (
                                                <button
                                                    key={tab.id}
                                                    onClick={() => setDepthChartType(tab.id)}
                                                    className={`btn ${depthChartType === tab.id ? 'btn-primary' : 'btn-secondary'}`}
                                                    style={{
                                                        display: 'flex',
                                                        alignItems: 'center',
                                                        justifyContent: 'center',
                                                        gap: '0.5rem',
                                                        whiteSpace: 'nowrap',
                                                        minWidth: '100px'
                                                    }}
                                                >
                                                    {tab.label}
                                                </button>
                                            ))}
                                            <div style={{ flex: 1 }} />
                                            <button
                                                className="btn btn-secondary"
                                                onClick={() => window.print()}
                                                style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', fontWeight: 'bold' }}
                                            >
                                                <Icon name="Printer" size={16} /> Print
                                            </button>
                                            <button
                                                className="btn btn-secondary"
                                                onClick={() => setIsViewingAll(true)}
                                                style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', fontWeight: 'bold' }}
                                            >
                                                <Icon name="Eye" size={16} /> See All
                                            </button>
                                        </div>
                                    )}

                                    <div className="depth-content-wrapper" style={{ flex: 1, overflow: isViewingAll ? 'visible' : 'auto' }}>
                                        {isViewingAll ? (
                                            // CONSOLIDATED VIEW WITH CHECKBOXES
                                            <div style={{ padding: '2rem' }}>
                                                {/* Header and Controls */}
                                                <div style={{ marginBottom: '2rem', borderBottom: '2px solid var(--border)', paddingBottom: '1rem' }}>
                                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
                                                        <h2 style={{ margin: 0 }}>Depth Charts - All Units</h2>
                                                        <div style={{ display: 'flex', gap: '1rem' }}>
                                                            <button
                                                                className="btn btn-secondary"
                                                                onClick={() => setIsViewingAll(false)}
                                                                style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}
                                                            >
                                                                <Icon name="ArrowLeft" size={16} /> Back
                                                            </button>
                                                            <button
                                                                className="btn btn-primary"
                                                                onClick={() => window.print()}
                                                                style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}
                                                            >
                                                                <Icon name="Printer" size={16} /> Print Selected
                                                            </button>
                                                        </div>
                                                    </div>

                                                    {/* Checkboxes */}
                                                    <div style={{ display: 'flex', flexWrap: 'wrap', gap: '1rem' }}>
                                                        {DEPTH_CHART_TYPES.map(chartTypeObj => (
                                                            <label key={chartTypeObj.id} style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', cursor: 'pointer' }}>
                                                                <input
                                                                    type="checkbox"
                                                                    checked={selectedCharts.includes(chartTypeObj.id)}
                                                                    onChange={(e) => {
                                                                        if (e.target.checked) {
                                                                            setSelectedCharts([...selectedCharts, chartTypeObj.id]);
                                                                        } else {
                                                                            setSelectedCharts(selectedCharts.filter(id => id !== chartTypeObj.id));
                                                                        }
                                                                    }}
                                                                    style={{ width: '18px', height: '18px', cursor: 'pointer' }}
                                                                />
                                                                <span style={{ fontWeight: '500' }}>{chartTypeObj.label}</span>
                                                            </label>
                                                        ))}
                                                    </div>
                                                </div>

                                                {/* Render Selected Charts */}
                                                <div>
                                                    {DEPTH_CHART_TYPES.filter(ct => selectedCharts.includes(ct.id)).map((chartTypeObj, index) => (
                                                        <div
                                                            key={chartTypeObj.id}
                                                            className="depth-chart-print-section"
                                                            style={{
                                                                pageBreakAfter: 'always',
                                                                marginBottom: '2rem',
                                                                display: selectedCharts.includes(chartTypeObj.id) ? 'block' : 'none'
                                                            }}
                                                        >
                                                            <DepthChart
                                                                roster={roster}
                                                                depthChart={(currentWeek.depthChart && currentWeek.depthChart[chartTypeObj.id]) || {}}
                                                                onUpdateDepthChart={(updated) => handleUpdateDepthChart(prev => ({ ...prev, [chartTypeObj.id]: updated }))}
                                                                chartType={chartTypeObj.id}
                                                                positionNames={positionNames}
                                                                customPositions={customPositions}
                                                                hiddenPositions={hiddenPositions}
                                                                personnelGroupings={personnelGroupings}
                                                                savedLayout={depthChartLayouts[chartTypeObj.id] || {}}
                                                                onUpdateLayout={(id, x, y) => handleUpdateDepthLayout(chartTypeObj.id, id, x, y)}
                                                                onResetLayout={() => handleResetDepthLayout(chartTypeObj.id)}
                                                                forcePrintView={true}
                                                                teamLogo={teamLogo}
                                                                currentWeek={currentWeek}
                                                            />
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        ) : (
                                            // RENDER SINGLE DEPTH CHART
                                            <DepthChart
                                                roster={roster}
                                                depthChart={(currentWeek.depthChart && currentWeek.depthChart[depthChartType]) || {}}
                                                onUpdateDepthChart={(updated) => handleUpdateDepthChart(prev => ({ ...prev, [depthChartType]: updated }))}
                                                chartType={depthChartType}
                                                positionNames={positionNames}
                                                customPositions={customPositions}
                                                hiddenPositions={hiddenPositions}
                                                personnelGroupings={personnelGroupings}
                                                savedLayout={depthChartLayouts[depthChartType] || {}}
                                                onUpdateLayout={(id, x, y) => handleUpdateDepthLayout(depthChartType, id, x, y)}
                                                onResetLayout={() => handleResetDepthLayout(depthChartType)}
                                                teamLogo={teamLogo}
                                                currentWeek={currentWeek}
                                            />
                                        )}
                                    </div>
                                </div>
                            )}
                            {view === 'wristband' && <WristbandBuilder plays={plays} weeks={weeks} currentWeek={currentWeek} gamePlan={currentWeek.offensiveGamePlan} onUpdatePlay={handlePatchPlay} onUpdateWeek={handleUpdateWeek} wbSettings={currentWeek.wristbands || {}} setWbSettings={handleUpdateWristbands} onNavigate={setView} installList={currentWeek?.installList || []} seasonOpponent={currentWeek.opponent} playCategories={playCategories} onQuickAddPlay={handleQuickAddPlay} formations={formations} onAddFormation={handleAddFormation} wizLibrary={wizLibrary} setWizLibrary={setWizLibrary} positionNames={positionNames} positionColors={positionColors} passProtections={passProtections} setPassProtections={setPassProtections} runBlocking={runBlocking} setRunBlocking={setRunBlocking} addToNextSlotRef={addToNextSlotRef} />}


                            {
                                view === 'settings' && (
                                    <Settings
                                        teamLogo={teamLogo}
                                        onUpdateLogo={setTeamLogo}
                                        accentColor={accentColor}
                                        onUpdateAccentColor={handleUpdateAccentColor}
                                        theme={theme}
                                        onUpdateTheme={setTheme}
                                        positionNames={positionNames}
                                        onUpdatePositionNames={setPositionNames}
                                        activeYear={activeYear}
                                        onUpdateActiveYear={setActiveYear}
                                        visibleFeatures={visibleFeatures}
                                        onUpdateVisibleFeatures={setVisibleFeatures}
                                        isAdmin={isSiteAdmin}
                                        siteAdmins={siteAdmins}
                                        schoolData={{ id: localStorage.getItem('hc_school_id') }}
                                        currentSchoolId={localStorage.getItem('hc_school_id')}
                                    />
                                )
                            }

                            {/* Site Admin Panel - only for site admins */}
                            {view === 'admin' && isSiteAdmin && <SiteAdminPanel />}

                            {/* REMOVED: pressbox view */}


                            {/* REMOVED: player-app and attendance-app views */}
                            {view === 'practice' && (
                                <PracticeScriptBuilder
                                    mode="plan"
                                    plays={plays}
                                    plans={currentWeek.practicePlans || {}}
                                    onUpdatePlans={(updated) => handleUpdateWeek(currentWeek.id, 'practicePlans', updated)}
                                    onUpdateGamePlan={(updated) => handleUpdateWeek(currentWeek.id, 'offensiveGamePlan', updated)}
                                    onUpdatePlay={handlePatchPlay}
                                    staff={staff}
                                    addCustomFocusItem={addCustomFocusItem}
                                    user={currentUser}
                                    isLocked={currentWeek.isLocked}
                                    isSiteAdmin={false}
                                    segmentTypes={getAllSegments()}
                                    focusItems={getAllFocusItems()}
                                    segmentTypesMap={practiceSegmentTypes}
                                    focusItemsMap={practiceFocusItems}
                                    segmentSettings={practiceSegmentSettings}
                                    scriptPresets={scriptPresets}
                                    gamePlan={currentWeek.offensiveGamePlan}
                                    gamePlanLayouts={(currentWeek.gamePlanLayouts && currentWeek.gamePlanLayouts.CALL_SHEET) ? currentWeek.gamePlanLayouts : GAME_PLAN_LAYOUTS}
                                    playBuckets={playBuckets}
                                    playCategories={playCategories}
                                    setAppSidebarCollapsed={setSidebarCollapsed}
                                    appSidebarCollapsed={sidebarCollapsed}
                                    closeSideMenuRef={closeSideMenuRef}
                                    roster={roster}
                                    teamLogo={teamLogo}
                                    currentWeek={currentWeek}
                                    onQuickAddPlay={handleQuickAddPlay}
                                    addToNextSlotRef={addToNextSlotRef}
                                    onNavigate={setView}
                                />
                            )}
                            {view === 'pregame' && (
                                <PregameTimeline
                                    plan={currentWeek.pregamePlan || { kickoffTime: '19:00', segments: [] }}
                                    onUpdatePlan={(updated) => handleUpdateWeek(currentWeek.id, 'pregamePlan', updated)}
                                    teamLogo={teamLogo}
                                    staff={staff}
                                    user={currentUser}
                                    isLocked={currentWeek.isLocked}
                                />
                            )}
                            {view === 'game-week-overview' && (
                                <GameWeekOverview
                                    week={currentWeek}
                                    onUpdateWeek={handleUpdateWeek}
                                    teamLogo={teamLogo}
                                    weeks={this.state.weeks}
                                    isLocked={currentWeek.isLocked}
                                />
                            )}
                            {view === 'practice-scripts' && (
                                <PracticeScriptBuilder
                                    mode="script"
                                    plays={plays}
                                    plans={currentWeek.practicePlans || {}}
                                    onUpdatePlans={(updated) => handleUpdateWeek(currentWeek.id, 'practicePlans', updated)}
                                    onUpdateGamePlan={(updated) => handleUpdateWeek(currentWeek.id, 'offensiveGamePlan', updated)}
                                    onUpdatePlay={handlePatchPlay}
                                    staff={staff}
                                    addCustomFocusItem={addCustomFocusItem}
                                    user={currentUser}
                                    isLocked={currentWeek.isLocked}
                                    isSiteAdmin={false}
                                    segmentTypes={getAllSegments()}
                                    focusItems={getAllFocusItems()}
                                    segmentSettings={practiceSegmentSettings}
                                    scriptPresets={scriptPresets}
                                    gamePlan={currentWeek.offensiveGamePlan}
                                    gamePlanLayouts={(currentWeek.gamePlanLayouts && currentWeek.gamePlanLayouts.CALL_SHEET) ? currentWeek.gamePlanLayouts : GAME_PLAN_LAYOUTS}
                                    onQuickAddPlay={handleQuickAddPlay}
                                    playBuckets={playBuckets}
                                    playCategories={playCategories}
                                    setAppSidebarCollapsed={setSidebarCollapsed}
                                    appSidebarCollapsed={sidebarCollapsed}
                                    closeSideMenuRef={closeSideMenuRef}
                                    roster={roster}
                                    teamLogo={teamLogo}
                                    currentWeek={currentWeek}
                                    addToNextSlotRef={addToNextSlotRef}
                                />
                            )}
                            {/* REMOVED: coach-app view */}

                            {/* REMOVED: smart-call-sheet view */}
                            {/* Legacy DumbCallSheet removed from here */}
                            {/* REMOVED: play-call-simulator view */}
                            {view === 'special-teams-setup' && renderSetup('SPECIAL_TEAMS')}
                            {view === 'opponent-scouting' && <OpponentScouting opponentData={currentWeek.opponentData || {}} onUpdateOpponentData={(data) => {
                                const updatedWeeks = weeks.map(w =>
                                    w.id === currentWeek.id ? { ...w, opponentData: data } : w
                                );
                                setWeeks(updatedWeeks);
                            }} />}

                            {/* Duplicate settings block removed */}

                            {view === 'help' && <UserGuide />}



                            {
                                showLogoutConfirm && (
                                    <div style={{
                                        position: 'fixed',
                                        top: 0,
                                        left: 0,
                                        right: 0,
                                        bottom: 0,
                                        background: 'rgba(0, 0, 0, 0.7)',
                                        display: 'flex',
                                        alignItems: 'center',
                                        justifyContent: 'center',
                                        zIndex: 10000
                                    }}>
                                        <div style={{
                                            background: 'white',
                                            padding: '2rem',
                                            borderRadius: '8px',
                                            maxWidth: '400px',
                                            width: '90%',
                                            boxShadow: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',
                                            border: '1px solid rgba(0,0,0,0.1)'
                                        }}>
                                            <h3 style={{ marginTop: 0, color: '#111827', marginBottom: '1rem', fontSize: '1.25rem' }}>Log Out?</h3>
                                            <p style={{ color: 'var(--text-secondary)', marginBottom: '1.5rem', lineHeight: '1.5' }}>
                                                Are you sure you want to sign out?
                                            </p>
                                            <div style={{ display: 'flex', justifyContent: 'flex-end', gap: '1rem' }}>
                                                <button
                                                    onClick={() => setShowLogoutConfirm(false)}
                                                    style={{
                                                        padding: '0.75rem 1.5rem',
                                                        borderRadius: '6px',
                                                        border: '1px solid #e2e8f0',
                                                        background: 'white',
                                                        color: 'var(--text-secondary)',
                                                        fontWeight: '600',
                                                        cursor: 'pointer'
                                                    }}
                                                >
                                                    Cancel
                                                </button>
                                                <button
                                                    onClick={() => {
                                                        setShowLogoutConfirm(false);
                                                        logout();
                                                    }}
                                                    style={{
                                                        padding: '0.75rem 1.5rem',
                                                        borderRadius: '6px',
                                                        border: 'none',
                                                        ound: '#ef4444',
                                                        color: 'white',
                                                        fontWeight: '600',
                                                        cursor: 'pointer',
                                                        boxShadow: '0 4px 6px -1px rgba(239, 68, 68, 0.4)'
                                                    }}
                                                >
                                                    Log Out
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                )
                            }

                            {/* Invite Acceptance Modal */}
                            {
                                inviteData && (
                                    <div style={{
                                        position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
                                        background: 'rgba(0,0,0,0.85)', zIndex: 10001,
                                        display: 'flex', justifyContent: 'center', alignItems: 'center'
                                    }}>
                                        <div className="card" style={{ maxWidth: '400px', width: '90%', textAlign: 'center', padding: '2rem', border: '1px solid var(--border)', background: 'var(--bg-panel)', borderRadius: 'var(--radius)' }}>
                                            <div style={{ fontSize: '3rem', marginBottom: '1rem' }}>
                                                {inviteData.type === 'domain_match' ? '🏫' : '📩'}
                                            </div>
                                            <h2 style={{ marginBottom: '0.5rem' }}>
                                                {inviteData.type === 'domain_match' ? 'Join Your Team?' : "You're Invited!"}
                                            </h2>
                                            <p style={{ color: 'var(--text-secondary)', marginBottom: '1.5rem' }}>
                                                {inviteData.type === 'domain_match'
                                                    ? <span>Your email matches <strong>{inviteData.schoolName}</strong>. Join as a <strong>{inviteData.role}</strong>?</span>
                                                    : <span>To join <strong>{inviteData.schoolName}</strong> as a <strong>{inviteData.role}</strong>.</span>
                                                }                          </p>
                                            <button
                                                className="btn btn-primary"
                                                style={{ width: '100%', padding: '', e: '1.1rem', marginBottom: '0.5rem' }}
                                                onClick={handleAcceptInvite}
                                            >
                                                Accept & Join Team
                                            </button>
                                            <button
                                                className="btn btn-secondary"
                                                yle={{ width: '100%', padding: '0.75rem', fontSize: '0.9rem', background: 'transparent', border: 'none', textDecoration: 'underline' }}
                                                onClick={() => {
                                                    if (confirm("Are you sure you want to ignore the existing team and create a new school instead?")) {
                                                        setInviteData(null);
                                                        setSchoolSetupData({ showWizard: true, schoolId: `SCH_${Date.now()}` });
                                                    }
                                                }}
                                            >
                                                No, Create New School
                                            </button>
                                        </div>
                                    </div>
                                )
                            }
                        </main >
                        {/* Global Modals */}
                        <ManageWeekModal
                            isOpen={showManageWeekModal}
                            onClose={() => setShowManageWeekModal(false)}
                            currentWeek={currentWeek}
                            weeks={weeks}
                            onUpdateWeek={handleUpdateWeek}
                        />

                        {/* Play Details Modal (Root-Level for PlayChip right-click) */}
                        {playDetailsModalState.isOpen && (
                            <PlayDetailsModal
                                playId={playDetailsModalState.playId}
                                plays={plays}
                                gamePlanLayouts={gamePlanLayouts}
                                onUpdatePlay={handleUpdatePlay}
                                playBuckets={playBuckets}
                                playCategories={playCategories}
                                currentWeek={currentWeek}
                                onClose={closePlayDetails}
                            />
                        )}

                        {/* Global Playbook Sidebar (Persistent across all views) */}
                        <div className="play-bank-sidebar" style={{
                            position: 'fixed',
                            right: 0,
                            top: 0,
                            bottom: 0,
                            zIndex: 100,
                            overflow: 'visible'
                        }}>
                            <GamePlannerSideMenu
                                isOpen={globalSidebarOpen}
                                onToggle={setGlobalSidebarOpen}
                                plays={plays}
                                practicePlans={currentWeek?.practicePlans || {}}
                                onQuickAddPlay={handleQuickAddPlay}
                                weekStats={(() => {
                                    // Calculate week stats for sidebar
                                    const gamePlan = currentWeek?.offensiveGamePlan || {};
                                    const allGamePlanPlayIds = new Set();
                                    Object.values(gamePlan?.sets || {}).forEach(set => {
                                        (set.playIds || []).forEach(item => {
                                            const id = typeof item === 'object' ? item.id : item;
                                            if (id) allGamePlanPlayIds.add(id);
                                        });
                                    });
                                    Object.values(gamePlan?.miniScripts || {}).forEach(script => {
                                        (script.playIds || []).forEach(item => {
                                            const id = typeof item === 'object' ? item.id : item;
                                            if (id) allGamePlanPlayIds.add(id);
                                        });
                                    });
                                    const uniquePlaysCount = allGamePlanPlayIds.size;

                                    // Total script slots
                                    let totalScriptSlots = 0;
                                    const plansList = Array.isArray(currentWeek?.practicePlans)
                                        ? currentWeek.practicePlans
                                        : Object.values(currentWeek?.practicePlans || {});
                                    plansList.forEach(plan => {
                                        (plan.segments || []).forEach(seg => {
                                            if (seg.hasScript && seg.script) {
                                                totalScriptSlots += seg.script.length;
                                            }
                                        });
                                    });

                                    return {
                                        uniquePlaysCount,
                                        newPlaysCount: 0, // Simplified for global view
                                        totalScriptSlots
                                    };
                                })()}
                                gamePlan={currentWeek?.offensiveGamePlan || {}}
                                gamePlanLayouts={gamePlanLayouts}
                                playBuckets={playBuckets}
                                playCategories={playCategories}
                                onAddSection={(playIdsOrSetId, section) => {
                                    // Handle various call patterns:
                                    // 1. onAddSection(playIds[]) - add array of plays to currently editing box
                                    // 2. onAddSection(setId) - add all plays from that set to currently editing box
                                    // 3. onAddSection(playId, section) - add single play to specific section

                                    if (!currentWeek) return;

                                    // If it's an array of play IDs, pass directly to addToNextSlotRef (supports batch)
                                    if (Array.isArray(playIdsOrSetId)) {
                                        if (addToNextSlotRef.current) {
                                            addToNextSlotRef.current(playIdsOrSetId);
                                        }
                                        return;
                                    }

                                    // If section is provided, add single play to that section
                                    if (section && section.setId) {
                                        const gamePlan = { ...(currentWeek?.offensiveGamePlan || {}) };
                                        const sets = { ...gamePlan.sets };
                                        if (!sets[section.setId]) {
                                            sets[section.setId] = { id: section.setId, playIds: [] };
                                        }
                                        if (!sets[section.setId].playIds.includes(playIdsOrSetId)) {
                                            sets[section.setId].playIds = [...sets[section.setId].playIds, playIdsOrSetId];
                                        }
                                        gamePlan.sets = sets;
                                        handleUpdateWeek(currentWeek.id, 'offensiveGamePlan', gamePlan);
                                        return;
                                    }

                                    // Treat as setId - get all plays from that set and add them to editing box
                                    const setId = playIdsOrSetId;
                                    const gamePlan = currentWeek?.offensiveGamePlan || {};
                                    let playIdsToAdd = [];

                                    // Look up plays from the set
                                    if (Array.isArray(gamePlan.sets)) {
                                        const set = gamePlan.sets.find(s => s.id === setId);
                                        if (set) playIdsToAdd = set.playIds || [];
                                    } else if (gamePlan.sets && gamePlan.sets[setId]) {
                                        playIdsToAdd = gamePlan.sets[setId].playIds || [];
                                    }

                                    // Also check miniScripts
                                    if (playIdsToAdd.length === 0 && setId?.startsWith('ms_')) {
                                        if (Array.isArray(gamePlan.miniScripts)) {
                                            const ms = gamePlan.miniScripts.find(s => s.id === setId);
                                            if (ms) playIdsToAdd = ms.playIds || [];
                                        } else if (gamePlan.miniScripts && gamePlan.miniScripts[setId]) {
                                            playIdsToAdd = gamePlan.miniScripts[setId].playIds || [];
                                        }
                                    }

                                    // Pass all plays to addToNextSlotRef for batch addition
                                    if (playIdsToAdd.length > 0 && addToNextSlotRef.current) {
                                        addToNextSlotRef.current(playIdsToAdd);
                                    }
                                }}
                                onUpdatePlay={handleUpdatePlay}
                                onUpdateGamePlan={(updated) => handleUpdateWeek(currentWeek?.id, 'offensiveGamePlan', updated)}
                                currentWeek={currentWeek}
                                onNavigate={setView}
                                onAddToNextSlot={(playId, play) => {
                                    // Call the registered handler from the current view
                                    if (addToNextSlotRef.current) {
                                        addToNextSlotRef.current(playId, play);
                                    }
                                }}
                                suggestions={currentWeek?.suggestions || {}}
                                onUpdateSuggestions={(newSuggestions) => handleUpdateWeek(currentWeek?.id, 'suggestions', newSuggestions)}
                            />
                        </div>
                    </div>
                </PlayDetailsModalContext.Provider>
            );
        };
        class ErrorBoundary extends React.Component {
            constructor(props) {
                super(props);
                this.state = { hasError: false, error: null, errorInfo: null };
            }
            static getDerivedStateFromError(error) {
                return { hasError: true };
            }

            componentDidCatch(error, errorInfo) {
                this.setState({ error, errorInfo });
                console.error("Caught error:", error, errorInfo);
            }


            render() {
                if (this.state.hasError) {
                    return (
                        <div style={{ padding: '2rem', color: '#ef4444', background: '#1e293b', height: '100vh' }}>
                            <h2>Something went wrong.</h2>
                            <details style={{ whiteSpace: 'pre-wrap' }}>
                                {this.state.error && this.state.error.toString()}
                                <br />
                                {this.state.errorInfo && this.state.errorInfo.componentStack}
                            </details>
                        </div>
                    );
                }
                return this.props.children;
            }
        }

        ReactDOM.render(
            <ErrorBoundary>
                <AuthProvider>
                    <App />
                </AuthProvider>
            </ErrorBoundary>,
            document.getElementById('root')
        );
    </script>
</body>

</html>